[
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\.dependency-cruiser.cjs",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\__tests__\\apiRequest.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\__tests__\\authValidation.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\__tests__\\clientSurface.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\__tests__\\expectedApiClientKeys.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\__tests__\\testUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\auth.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\auth\\authClientUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\auth\\authErrors.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\auth\\authOperations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\auth\\authStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\auth\\sessionValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\client.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher\\conflict.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher\\constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher\\errorCodes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher\\errors.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher\\requestExecutor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher\\requestUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher\\responseParser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher\\retry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher\\setup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\fetcher\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\resources\\assetsClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\resources\\chatAssetsClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\resources\\chatsClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\resources\\feedbackClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\resources\\lockinClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\resources\\notesClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\resources\\transcriptsClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\validation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\validationChats.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\validationFeedback.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\validationLockin.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\validationNotes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\validationTranscripts.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\api\\validationUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\app.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\assets.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\cors.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\env.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\index.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\llm.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\prompts.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\server.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\supabase.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\transcripts.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\units.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\config\\utils.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\constants\\httpStatus.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\constants\\numbers.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\__tests__\\assistantTitle.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 80.",
        "line": 25,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 25,
        "endColumn": 31
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 26,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 26,
        "endColumn": 42
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 80.",
        "line": 43,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 43,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 44,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 44,
        "endColumn": 44
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for assistant chat title generation and storage\n */\n\n// Test environment setup - use _DEV suffixed vars as per the environment config pattern\nprocess.env.NODE_ENV = 'development';\nprocess.env.SUPABASE_URL_DEV = process.env.SUPABASE_URL_DEV || 'https://example.supabase.test';\nprocess.env.SUPABASE_SERVICE_ROLE_KEY_DEV =\n  process.env.SUPABASE_SERVICE_ROLE_KEY_DEV || 'service-role-key';\nprocess.env.OPENAI_API_KEY = process.env.OPENAI_API_KEY || 'test-api-key';\n\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst {\n  buildInitialChatTitle,\n  extractFirstUserMessage,\n  coerceGeneratedTitle,\n} = require('../../utils/chatTitle');\nconst { updateChatTitle } = require('../../repositories/chatRepository');\n\ntest('buildInitialChatTitle creates fallback title from first user message', () => {\n  const title = buildInitialChatTitle('What is an array data structure?');\n  assert.ok(title.length > 0, 'Title should not be empty');\n  assert.ok(title.length <= 80, 'Title should be clamped to max length');\n  assert.equal(title.split(' ').length, 6, 'Title should be clamped to 6 words');\n});\n\ntest('extractFirstUserMessage extracts content from chat messages', () => {\n  const messages = [\n    { role: 'assistant', output_text: 'Hello!' },\n    { role: 'user', input_text: 'What is an array?' },\n    { role: 'user', input_text: 'Second question' },\n  ];\n\n  const first = extractFirstUserMessage(messages);\n  assert.equal(first, 'What is an array?', 'Should extract first user message');\n});\n\ntest('coerceGeneratedTitle validates and clamps generated titles', () => {\n  const longTitle = 'This is a very long title that exceeds the word limit';\n  const clamped = coerceGeneratedTitle(longTitle, 'Fallback');\n  assert.ok(clamped.length <= 80, 'Should clamp to max length');\n  assert.equal(clamped.split(' ').length, 6, 'Should clamp to 6 words');\n\n  const empty = coerceGeneratedTitle('', 'Custom fallback');\n  assert.equal(empty, 'Custom fallback', 'Should use fallback for empty title');\n});\n\ntest('updateChatTitle persists title to database', async (t) => {\n  const { supabase } = require('../../db/supabaseClient');\n  const calls = [];\n  const originalFrom = supabase.from;\n\n  t.after(() => {\n    supabase.from = originalFrom;\n  });\n\n  supabase.from = (table) => {\n    calls.push({ step: 'table', table });\n\n    return {\n      update(payload) {\n        calls.push({ step: 'update', payload });\n\n        const chain = {\n          eq(column, value) {\n            calls.push({ step: 'eq', column, value });\n            return chain;\n          },\n          select() {\n            calls.push({ step: 'select' });\n            return chain;\n          },\n          single() {\n            return Promise.resolve({\n              data: {\n                id: 'chat-123',\n                title: payload.title,\n                updated_at: payload.updated_at,\n                last_message_at: '2025-01-01T00:00:00.000Z',\n                created_at: '2025-01-01T00:00:00.000Z',\n              },\n              error: null,\n            });\n          },\n        };\n\n        return chain;\n      },\n    };\n  };\n\n  const result = await updateChatTitle('user-1', 'chat-123', 'Understanding arrays');\n\n  assert.equal(result.title, 'Understanding arrays', 'Should return updated title');\n  assert.ok(result.updated_at, 'Should update timestamp');\n\n  const updateCall = calls.find((entry) => entry.step === 'update');\n  assert.equal(updateCall?.payload?.title, 'Understanding arrays', 'Should store correct title');\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\assistant\\ai.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\assistant\\assets.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\assistant\\chat.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\assistant\\title.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\feedback\\index.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\health\\embeddings.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\notes\\assets.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\notes\\chat.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\notes\\crud.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\controllers\\transcripts\\index.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\db\\supabaseClient.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 45,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 45,
        "endColumn": 24
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 45,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 45,
        "endColumn": 41
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 503.",
        "line": 52,
        "column": 5,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 8
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { createClient } = require('@supabase/supabase-js');\nconst { AppError } = require('../errors');\nconst { CircuitBreaker } = require('../utils/circuitBreaker');\nconst config = require('../config');\n\n// Use environment-aware configuration from centralized config\nconst SUPABASE_URL = config.SUPABASE_URL;\nconst SUPABASE_SERVICE_ROLE_KEY = config.SUPABASE_SERVICE_ROLE_KEY;\n\n// Check if we're in a test environment (tests set these vars before requiring)\nconst IS_TEST = process.env.NODE_ENV === 'test' || process.argv.some((arg) => arg.includes('test'));\n\nif (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {\n  if (!IS_TEST) {\n    console.error(\n      `CRITICAL: Supabase credentials missing for ${config.NODE_ENV} environment.`,\n      'Backend will not function correctly.',\n      `Environment: ${config.SUPABASE_CONFIG.environment}`,\n    );\n  }\n}\n\nconst DEFAULT_CIRCUIT_BREAKER_OPTIONS = {\n  failureThreshold: 3,\n  openDurationMs: 30000,\n  halfOpenMaxAttempts: 1,\n};\n\nfunction isNetworkError(error) {\n  if (!error) return false;\n  const message = error instanceof Error ? error.message : String(error);\n  return (\n    message.includes('Failed to fetch') ||\n    message.includes('NetworkError') ||\n    message.includes('Network request failed') ||\n    message.includes('ERR_NETWORK') ||\n    message.includes('ECONNRESET') ||\n    message.includes('ETIMEDOUT') ||\n    message.includes('EAI_AGAIN')\n  );\n}\n\nfunction shouldRecordFailureFromStatus(status) {\n  if (typeof status !== 'number') return false;\n  return status === 429 || status >= 500;\n}\n\nfunction createCircuitOpenError(retryAfterMs) {\n  const error = new AppError(\n    'Supabase temporarily unavailable (circuit open)',\n    'SERVICE_UNAVAILABLE',\n    503,\n    { retryAfterMs },\n  );\n  error.name = 'CircuitOpenError';\n  return error;\n}\n\nfunction createSupabaseFetch(fetcher, circuitBreaker) {\n  return async (input, init) => {\n    const decision = circuitBreaker.canRequest('supabase');\n    if (!decision.allowed) {\n      throw createCircuitOpenError(decision.retryAfterMs);\n    }\n\n    try {\n      const response = await fetcher(input, init);\n      if (shouldRecordFailureFromStatus(response.status)) {\n        circuitBreaker.recordFailure('supabase');\n      } else {\n        circuitBreaker.recordSuccess('supabase');\n      }\n      return response;\n    } catch (error) {\n      if (isNetworkError(error)) {\n        circuitBreaker.recordFailure('supabase');\n      }\n      throw error;\n    }\n  };\n}\n\nfunction createSupabaseClient({\n  supabaseUrl,\n  supabaseKey,\n  fetcher = globalThis.fetch,\n  circuitBreaker = new CircuitBreaker(DEFAULT_CIRCUIT_BREAKER_OPTIONS),\n} = {}) {\n  if (typeof fetcher !== 'function') {\n    throw new Error('Fetch implementation is required for Supabase client.');\n  }\n\n  const fetchWithBreaker = createSupabaseFetch(fetcher, circuitBreaker);\n  const client = createClient(supabaseUrl, supabaseKey, {\n    auth: {\n      autoRefreshToken: false,\n      detectSessionInUrl: false,\n    },\n    global: {\n      fetch: fetchWithBreaker,\n    },\n  });\n\n  return { client, circuitBreaker };\n}\n\n// Create client only if we have valid credentials, otherwise create a dummy\n// that will fail gracefully when accessed (for test environments)\nlet supabase;\nlet supabaseCircuitBreaker = null;\nif (SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY) {\n  const { client, circuitBreaker } = createSupabaseClient({\n    supabaseUrl: SUPABASE_URL,\n    supabaseKey: SUPABASE_SERVICE_ROLE_KEY,\n  });\n  supabase = client;\n  supabaseCircuitBreaker = circuitBreaker;\n} else {\n  // Placeholder for tests - will be mocked by tests that need it\n  supabase = {\n    from: () => {\n      throw new Error(\n        'Supabase not configured. Set SUPABASE_URL_DEV and SUPABASE_SERVICE_ROLE_KEY_DEV.',\n      );\n    },\n  };\n}\n\nmodule.exports = {\n  supabase,\n  createSupabaseClient,\n  supabaseCircuitBreaker,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\errors\\index.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\eslint.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\index.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 30000.",
        "line": 127,
        "column": 6,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 127,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Lock-in Backend Server\n * Express API that handles AI-powered text processing for the Chrome extension.\n *\n * This file is now a thin bootstrap that wires configuration + the Express app\n * and starts the HTTP server. All request handling lives in the app/routes/\n * and controllers/ folders to keep things testable and maintainable.\n */\n\n// =============================================================================\n// CRITICAL: Load order matters!\n// 1. Environment variables\n// 2. Validation\n// 3. Application Insights (must be before other imports to instrument them)\n// 4. Sentry\n// 5. Everything else\n// =============================================================================\n\n// Load environment variables first\nrequire('dotenv').config();\n\n// Validate environment variables (fail fast if misconfigured)\nconst { validateEnvOrExit, LOCKIN_BACKEND_SCHEMA } = require('./utils/validateEnv');\nvalidateEnvOrExit(LOCKIN_BACKEND_SCHEMA);\n\n// Initialize Application Insights BEFORE other imports (instruments Node modules)\nconst { initApplicationInsights, disposeApplicationInsights, logger } = require('./observability');\ninitApplicationInsights();\n\n// Initialize Sentry after App Insights\nconst { initSentry } = require('./observability/sentry');\ninitSentry();\n\n// Now import everything else - both App Insights and Sentry will instrument these\nconst { createApp } = require('./app');\nconst { PORT, isAzureEnabled, isOpenAIEnabled, isOpenAIFallbackEnabled } = require('./config');\nconst {\n  startTranscriptJobReaper,\n  stopTranscriptJobReaper,\n} = require('./services/transcripts/transcriptsService');\n\n// =============================================================================\n// Application Startup\n// =============================================================================\nconst app = createApp();\n\n// Track server state for graceful shutdown\nlet isServerRunning = false;\n\nconst server = app.listen(PORT, () => {\n  isServerRunning = true;\n  logger.info(\n    { port: PORT, env: process.env.NODE_ENV },\n    `Lock-in backend server running on port ${PORT}`,\n  );\n  logger.info('Ready to help students learn!');\n\n  if (!isAzureEnabled() && !isOpenAIEnabled()) {\n    logger.warn('No LLM credentials found (Azure OpenAI or OpenAI).');\n  } else if (isAzureEnabled() && !isOpenAIFallbackEnabled()) {\n    logger.warn('Azure OpenAI enabled without OpenAI fallback credentials.');\n  }\n\n  startTranscriptJobReaper();\n});\n\n// Handle server startup errors (e.g., EADDRINUSE)\nserver.on('error', (err) => {\n  isServerRunning = false;\n  if (err.code === 'EADDRINUSE') {\n    logger.error(\n      { port: PORT, error: err.message },\n      `Port ${PORT} is already in use. Kill the existing process or use a different port.`,\n    );\n    logger.info('Hint: Run \"netstat -ano | findstr :3000\" to find the process using the port');\n  } else {\n    logger.error({ error: err.message, code: err.code }, 'Server startup error');\n  }\n  process.exit(1);\n});\n\n// =============================================================================\n// Graceful Shutdown Handlers\n// Ensures clean container termination in Azure Container Apps\n// =============================================================================\nlet isShuttingDown = false;\n\nconst gracefulShutdown = async (signal) => {\n  // Prevent multiple shutdown attempts\n  if (isShuttingDown) {\n    return;\n  }\n  isShuttingDown = true;\n\n  logger.info({ signal }, `${signal} received, starting graceful shutdown...`);\n\n  // If server never started, exit immediately\n  if (!isServerRunning) {\n    logger.info('Server was not running, exiting immediately');\n    process.exit(1);\n  }\n\n  // Stop accepting new connections\n  server.close(async (err) => {\n    if (err) {\n      logger.error({ error: err.message }, 'Error during server close');\n      process.exit(1);\n    }\n\n    logger.info('HTTP server closed');\n\n    // Stop background jobs\n    stopTranscriptJobReaper();\n    logger.info('Transcript job reaper stopped');\n\n    // Dispose Application Insights (flushes telemetry and cleans up OpenTelemetry)\n    await disposeApplicationInsights();\n\n    logger.info('Graceful shutdown complete');\n    process.exit(0);\n  });\n\n  // Force shutdown after 30 seconds if graceful shutdown fails\n  setTimeout(() => {\n    logger.error('Forced shutdown after timeout');\n    process.exit(1);\n  }, 30000);\n};\n\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n// Handle uncaught exceptions gracefully\nprocess.on('uncaughtException', (err) => {\n  logger.error({ error: err.message, stack: err.stack }, 'Uncaught exception');\n  gracefulShutdown('UNCAUGHT_EXCEPTION');\n});\n\nprocess.on('unhandledRejection', (reason, _promise) => {\n  logger.error({ reason: String(reason) }, 'Unhandled rejection');\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\middleware\\authMiddleware.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\middleware\\errorHandler.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\middleware\\uploadMiddleware.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\observability\\healthCheck.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\observability\\index.js",
    "messages": [
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (305). Maximum allowed is 300.",
        "line": 454,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 463,
        "endColumn": 1
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unified Observability Module for Lock-in Backend\n *\n * Provides:\n * - Application Insights (Azure-native APM)\n * - Structured logging with pino\n * - Correlation ID propagation\n * - LLM token usage tracking\n *\n * IMPORTANT: This module must be loaded FIRST in index.js, before any other imports.\n * Application Insights needs to instrument Node.js modules before they're loaded.\n */\n\nconst appInsights = process.env.APPLICATIONINSIGHTS_CONNECTION_STRING\n  ? require('applicationinsights')\n  : null;\nconst { FIVE, THOUSAND } = require('../constants/numbers');\n\nconst APP_INSIGHTS_FLUSH_TIMEOUT_MS = FIVE * THOUSAND;\n\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production';\nconst LOG_LEVEL = process.env.LOG_LEVEL || (IS_PRODUCTION ? 'info' : 'debug');\n\nlet pino = null;\ntry {\n  // Use Node resolution so workspaces/hoisting still locate the dependency.\n  pino = require('pino');\n} catch (error) {\n  if (!IS_PRODUCTION) {\n    console.warn(\n      '[Observability] Pino not available; using console logger fallback.',\n      error?.message,\n    );\n  }\n}\n\n// =============================================================================\n// Application Insights Setup\n// =============================================================================\n\nlet appInsightsClient = null;\nlet appInsightsInitialized = false;\nlet isShuttingDown = false;\n\n/**\n * Suppress OpenTelemetry MeterProvider warnings in development.\n * These warnings are harmless and occur during nodemon hot-reloads because\n * the OpenTelemetry SDK's shutdown is called multiple times.\n */\nfunction suppressOTelWarningsInDev() {\n  if (IS_PRODUCTION) return;\n\n  const originalConsoleLog = console.log;\n  const originalConsoleWarn = console.warn;\n  const originalConsoleError = console.error;\n\n  const shouldSuppress = (args) => {\n    const message = args[0];\n    if (typeof message !== 'string') return false;\n    return (\n      message.includes('shutdown may only be called once per MeterProvider') ||\n      message.includes('shutdown may only be called once per TracerProvider')\n    );\n  };\n\n  console.log = (...args) => {\n    if (!shouldSuppress(args)) originalConsoleLog.apply(console, args);\n  };\n  console.warn = (...args) => {\n    if (!shouldSuppress(args)) originalConsoleWarn.apply(console, args);\n  };\n  console.error = (...args) => {\n    if (!shouldSuppress(args)) originalConsoleError.apply(console, args);\n  };\n}\n\n// Apply suppression immediately on module load (before App Insights init)\nsuppressOTelWarningsInDev();\n\n/**\n * Initialize Application Insights for Azure-native APM.\n * Call this FIRST, before any other imports in index.js.\n *\n * Set APPLICATIONINSIGHTS_CONNECTION_STRING in your environment.\n * Get the connection string from Azure Portal -> Application Insights -> Overview -> Connection String\n *\n * @returns {boolean} Whether App Insights was initialized\n */\nfunction getAppInsightsConnectionString() {\n  if (appInsightsInitialized) {\n    console.log('[AppInsights] Already initialized, skipping');\n    return null;\n  }\n\n  if (!appInsights) {\n    if (!IS_PRODUCTION) {\n      console.log('[AppInsights] Module not loaded, skipping initialization');\n    }\n    appInsightsInitialized = true;\n    return null;\n  }\n\n  const connectionString = process.env.APPLICATIONINSIGHTS_CONNECTION_STRING;\n  if (!connectionString) {\n    if (!IS_PRODUCTION) {\n      console.log('[AppInsights] No connection string configured, skipping initialization');\n    }\n    appInsightsInitialized = true; // Mark as \"handled\" to prevent retry\n    return null;\n  }\n\n  return connectionString;\n}\n\nfunction startApplicationInsights(connectionString) {\n  try {\n    appInsights\n      .setup(connectionString)\n      .setAutoCollectRequests(true)\n      .setAutoCollectPerformance(true, false) // false = disable deprecated extended metrics\n      .setAutoCollectExceptions(true)\n      .setAutoCollectDependencies(true)\n      .setAutoCollectConsole(true, true) // Capture console.log as traces\n      .setAutoCollectPreAggregatedMetrics(true)\n      .setSendLiveMetrics(IS_PRODUCTION) // Live metrics stream in production\n      .setUseDiskRetryCaching(true)\n      .setInternalLogging(false, false); // Disable verbose internal logs\n\n    // Set cloud role for service map\n    appInsights.defaultClient.context.tags[appInsights.defaultClient.context.keys.cloudRole] =\n      'lockin-backend';\n\n    appInsights.start();\n    appInsightsClient = appInsights.defaultClient;\n    appInsightsInitialized = true;\n\n    console.log('[AppInsights] Initialized successfully');\n    return true;\n  } catch (error) {\n    // Application Insights v3 with OpenTelemetry can throw if already started\n    // This is expected during hot-reload scenarios\n    if (error.message?.includes('MeterProvider') || error.message?.includes('already')) {\n      console.log('[AppInsights] Skipping re-initialization (hot-reload detected)');\n      appInsightsInitialized = true;\n      return false;\n    }\n    console.error('[AppInsights] Failed to initialize:', error.message);\n    return false;\n  }\n}\n\nfunction initApplicationInsights() {\n  const connectionString = getAppInsightsConnectionString();\n  if (!connectionString) {\n    return Boolean(appInsightsClient);\n  }\n\n  return startApplicationInsights(connectionString);\n}\n\n/**\n * Gracefully dispose of Application Insights.\n * Call this during graceful shutdown to flush telemetry and clean up resources.\n * Uses a guard to prevent multiple shutdown calls (which cause MeterProvider warnings).\n *\n * @returns {Promise<void>}\n */\nasync function disposeApplicationInsights() {\n  // Guard against multiple shutdown calls\n  if (isShuttingDown || !appInsightsClient) {\n    return;\n  }\n\n  isShuttingDown = true;\n\n  try {\n    // Flush any pending telemetry before shutdown\n    await new Promise((resolve) => {\n      appInsightsClient.flush({\n        callback: () => {\n          console.log('[AppInsights] Telemetry flushed');\n          resolve();\n        },\n      });\n\n      // Timeout fallback in case flush hangs\n      setTimeout(resolve, APP_INSIGHTS_FLUSH_TIMEOUT_MS);\n    });\n\n    // Dispose the SDK (this internally calls OpenTelemetry shutdown)\n    appInsights.dispose();\n    console.log('[AppInsights] Disposed successfully');\n  } catch (error) {\n    // Swallow shutdown errors - these are expected during nodemon restarts\n    if (!error.message?.includes('MeterProvider')) {\n      console.error('[AppInsights] Error during dispose:', error.message);\n    }\n  }\n}\n\n/**\n * Get the Application Insights client for custom telemetry.\n * Returns null if App Insights is not configured.\n */\nfunction getAppInsightsClient() {\n  return appInsightsClient;\n}\n\n/**\n * Track a custom metric in Application Insights.\n * Use for business metrics like token usage, request counts, etc.\n *\n * @param {string} name - Metric name (e.g., 'llm.tokens.prompt')\n * @param {number} value - Metric value\n * @param {Object} properties - Additional dimensions/properties\n */\nfunction trackMetric(name, value, properties = {}) {\n  if (!appInsightsClient) return;\n\n  appInsightsClient.trackMetric({\n    name,\n    value,\n    properties,\n  });\n}\n\n/**\n * Track a custom event in Application Insights.\n * Use for significant business events like chat completion, note creation, etc.\n *\n * @param {string} name - Event name (e.g., 'chat.completion')\n * @param {Object} properties - Event properties\n * @param {Object} measurements - Numeric measurements\n */\nfunction trackEvent(name, properties = {}, measurements = {}) {\n  if (!appInsightsClient) return;\n\n  appInsightsClient.trackEvent({\n    name,\n    properties,\n    measurements,\n  });\n}\n\n// =============================================================================\n// Pino Structured Logger\n// =============================================================================\n\n/**\n * Create the base pino logger instance.\n * Configures JSON output for production, pretty output for development.\n */\nconst DEFAULT_PINO_LEVELS = {\n  fatal: 60,\n  error: 50,\n  warn: 40,\n  info: 30,\n  debug: 20,\n  trace: 10,\n};\n\nfunction createConsoleLogger() {\n  return {\n    level: LOG_LEVEL,\n    levels: { values: DEFAULT_PINO_LEVELS },\n    info: console.log.bind(console),\n    warn: console.warn.bind(console),\n    error: console.error.bind(console),\n    debug: console.debug.bind(console),\n    trace: console.debug.bind(console),\n    fatal: console.error.bind(console),\n    child: () => createConsoleLogger(),\n  };\n}\n\nconst logger = pino\n  ? pino({\n      level: LOG_LEVEL,\n      // Base fields included in every log entry\n      base: {\n        service: 'lockin-backend',\n        env: process.env.NODE_ENV || 'development',\n      },\n      // Timestamp configuration\n      timestamp: pino.stdTimeFunctions.isoTime,\n      // Format options\n      formatters: {\n        level: (label) => ({ level: label }),\n        bindings: (bindings) => ({\n          pid: bindings.pid,\n          host: bindings.hostname,\n        }),\n      },\n      // In development, use pretty printing\n      transport: IS_PRODUCTION\n        ? undefined\n        : {\n            target: 'pino/file',\n            options: { destination: 1 }, // stdout\n          },\n    })\n  : createConsoleLogger();\n\n/**\n * Create a child logger with additional context (e.g., request ID, user ID).\n *\n * @param {Object} bindings - Context to add to all log entries\n * @returns {pino.Logger} Child logger instance\n */\nfunction createChildLogger(bindings) {\n  return logger.child(bindings);\n}\n\n// =============================================================================\n// LLM Token Usage Tracking\n// =============================================================================\n\n/**\n * Track LLM API usage for cost monitoring and optimization.\n *\n * @param {Object} options\n * @param {string} options.provider - 'azure' or 'openai'\n * @param {string} options.operation - 'chat', 'embeddings', 'transcription'\n * @param {string} options.model - Model/deployment name\n * @param {number} options.promptTokens - Number of prompt tokens\n * @param {number} options.completionTokens - Number of completion tokens\n * @param {number} options.totalTokens - Total tokens used\n * @param {string} [options.userId] - User ID for per-user cost tracking\n * @param {string} [options.requestId] - Request correlation ID\n * @param {number} [options.latencyMs] - Request latency in milliseconds\n */\nfunction trackLlmUsage(options) {\n  const {\n    provider,\n    operation,\n    model,\n    promptTokens = 0,\n    completionTokens = 0,\n    totalTokens = 0,\n    userId,\n    requestId,\n    latencyMs,\n  } = options;\n\n  logLlmUsage({\n    provider,\n    operation,\n    model,\n    promptTokens,\n    completionTokens,\n    totalTokens,\n    userId,\n    requestId,\n    latencyMs,\n  });\n\n  recordLlmMetrics({\n    provider,\n    operation,\n    model,\n    promptTokens,\n    completionTokens,\n    totalTokens,\n    userId,\n    requestId,\n    latencyMs,\n  });\n}\n\nfunction logLlmUsage({\n  provider,\n  operation,\n  model,\n  promptTokens,\n  completionTokens,\n  totalTokens,\n  userId,\n  requestId,\n  latencyMs,\n}) {\n  logger.info(\n    {\n      type: 'llm_usage',\n      provider,\n      operation,\n      model,\n      tokens: {\n        prompt: promptTokens,\n        completion: completionTokens,\n        total: totalTokens,\n      },\n      userId,\n      requestId,\n      latencyMs,\n    },\n    `LLM ${operation}: ${totalTokens} tokens (${provider}/${model})`,\n  );\n}\n\nfunction recordLlmMetrics({\n  provider,\n  operation,\n  model,\n  promptTokens,\n  completionTokens,\n  totalTokens,\n  userId,\n  requestId,\n  latencyMs,\n}) {\n  if (!appInsightsClient) {\n    return;\n  }\n\n  trackMetric('llm.tokens.prompt', promptTokens, { provider, operation, model });\n  trackMetric('llm.tokens.completion', completionTokens, { provider, operation, model });\n  trackMetric('llm.tokens.total', totalTokens, { provider, operation, model });\n\n  if (latencyMs !== undefined) {\n    trackMetric('llm.latency.ms', latencyMs, { provider, operation, model });\n  }\n\n  trackEvent(\n    'llm.request',\n    {\n      provider,\n      operation,\n      model,\n      userId: userId || 'anonymous',\n      requestId,\n    },\n    {\n      promptTokens,\n      completionTokens,\n      totalTokens,\n      latencyMs: latencyMs || 0,\n    },\n  );\n}\n\n// =============================================================================\n// Exports\n// =============================================================================\n\nmodule.exports = {\n  // Application Insights\n  initApplicationInsights,\n  disposeApplicationInsights,\n  getAppInsightsClient,\n  trackMetric,\n  trackEvent,\n\n  // Pino logger\n  logger,\n  createChildLogger,\n\n  // LLM tracking\n  trackLlmUsage,\n\n  // Constants\n  LOG_LEVEL,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\observability\\requestLogger.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\observability\\sentry.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\__tests__\\transcriptionFactory.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\azureEmbeddingsClient.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\azureSpeechClient.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\embeddingsFactory.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\__tests__\\circuitBreaker.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (53). Maximum allowed is 50.",
        "line": 5,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 66,
        "endColumn": 2
      },
      {
        "ruleId": "prefer-const",
        "severity": 1,
        "message": "'now' is never reassigned. Use 'const' instead.",
        "line": 7,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "useConst",
        "endLine": 7,
        "endColumn": 12,
        "fix": { "range": [253, 268], "text": "const now = 1000;" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "const { test, describe } = require('node:test');\nconst assert = require('node:assert');\nconst { CircuitBreaker } = require('../circuitBreaker');\n\ndescribe('CircuitBreaker', () => {\n  test('opens after failure threshold and blocks requests', () => {\n    let now = 1000;\n    const breaker = new CircuitBreaker({\n      failureThreshold: 2,\n      openDurationMs: 30000,\n      now: () => now,\n    });\n\n    breaker.recordFailure('gemini');\n    let decision = breaker.canRequest('gemini');\n    assert.equal(decision.allowed, true);\n\n    breaker.recordFailure('gemini');\n    decision = breaker.canRequest('gemini');\n    assert.equal(decision.allowed, false);\n    assert.equal(decision.state, 'open');\n  });\n\n  test('transitions to half-open after open duration', () => {\n    let now = 0;\n    const breaker = new CircuitBreaker({\n      failureThreshold: 1,\n      openDurationMs: 1000,\n      halfOpenMaxAttempts: 1,\n      now: () => now,\n    });\n\n    breaker.recordFailure('openai');\n    let decision = breaker.canRequest('openai');\n    assert.equal(decision.allowed, false);\n\n    now += 1000;\n    decision = breaker.canRequest('openai');\n    assert.equal(decision.allowed, true);\n    assert.equal(decision.state, 'half_open');\n\n    decision = breaker.canRequest('openai');\n    assert.equal(decision.allowed, false);\n  });\n\n  test('closes on success after half-open', () => {\n    let now = 0;\n    const breaker = new CircuitBreaker({\n      failureThreshold: 1,\n      openDurationMs: 1000,\n      halfOpenMaxAttempts: 1,\n      now: () => now,\n    });\n\n    breaker.recordFailure('groq');\n    now += 1000;\n    let decision = breaker.canRequest('groq');\n    assert.equal(decision.allowed, true);\n    assert.equal(decision.state, 'half_open');\n\n    breaker.recordSuccess('groq');\n    decision = breaker.canRequest('groq');\n    assert.equal(decision.allowed, true);\n    assert.equal(decision.state, 'closed');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\__tests__\\contracts.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (84). Maximum allowed is 50.",
        "line": 15,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 113,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 125,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 125,
        "endColumn": 37
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 30.",
        "line": 167,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 167,
        "endColumn": 44
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 172,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 172,
        "endColumn": 44
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 30.",
        "line": 177,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 177,
        "endColumn": 44
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 15.",
        "line": 182,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 182,
        "endColumn": 44
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 120.",
        "line": 187,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 187,
        "endColumn": 45
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 45.",
        "line": 195,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 195,
        "endColumn": 44
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for LLM contracts\n */\n\nconst { test, describe } = require('node:test');\nconst assert = require('node:assert');\nconst {\n  shouldFallback,\n  createProviderError,\n  parseRetryAfter,\n  FALLBACK_ERROR_PATTERNS,\n  NO_FALLBACK_ERROR_PATTERNS,\n} = require('../contracts');\n\ndescribe('shouldFallback', () => {\n  describe('rate limiting errors', () => {\n    test('should fallback on 429 status', () => {\n      const error = new Error('Request failed');\n      error.status = 429;\n      assert.equal(shouldFallback(error), true);\n    });\n\n    test('should fallback on \"rate limit\" message', () => {\n      const error = new Error('Rate limit exceeded');\n      assert.equal(shouldFallback(error), true);\n    });\n\n    test('should fallback on \"quota\" message', () => {\n      const error = new Error('Quota exceeded for project');\n      assert.equal(shouldFallback(error), true);\n    });\n\n    test('should fallback on \"too many requests\" message', () => {\n      const error = new Error('Too many requests');\n      assert.equal(shouldFallback(error), true);\n    });\n  });\n\n  describe('server errors', () => {\n    test('should fallback on 500 status', () => {\n      const error = new Error('Internal server error');\n      error.status = 500;\n      assert.equal(shouldFallback(error), true);\n    });\n\n    test('should fallback on 503 status', () => {\n      const error = new Error('Service unavailable');\n      error.status = 503;\n      assert.equal(shouldFallback(error), true);\n    });\n  });\n\n  describe('network errors', () => {\n    test('should fallback on timeout', () => {\n      const error = new Error('Request timed out');\n      assert.equal(shouldFallback(error), true);\n    });\n\n    test('should fallback on connection reset', () => {\n      const error = new Error('ECONNRESET');\n      assert.equal(shouldFallback(error), true);\n    });\n\n    test('should fallback on socket hang up', () => {\n      const error = new Error('socket hang up');\n      assert.equal(shouldFallback(error), true);\n    });\n  });\n\n  describe('authentication errors (should NOT fallback)', () => {\n    test('should NOT fallback on invalid API key', () => {\n      const error = new Error('Invalid API key provided');\n      assert.equal(shouldFallback(error), false);\n    });\n\n    test('should NOT fallback on 401 status', () => {\n      const error = new Error('Unauthorized');\n      error.status = 401;\n      assert.equal(shouldFallback(error), false);\n    });\n\n    test('should NOT fallback on 403 status', () => {\n      const error = new Error('Forbidden');\n      error.status = 403;\n      assert.equal(shouldFallback(error), false);\n    });\n\n    test('should NOT fallback on authentication failed', () => {\n      const error = new Error('Authentication failed');\n      assert.equal(shouldFallback(error), false);\n    });\n  });\n\n  describe('bad request errors (should NOT fallback)', () => {\n    test('should NOT fallback on 400 status', () => {\n      const error = new Error('Bad request: invalid parameter');\n      error.status = 400;\n      assert.equal(shouldFallback(error), false);\n    });\n\n    test('should NOT fallback on content policy violation', () => {\n      const error = new Error('Content policy violation blocked');\n      assert.equal(shouldFallback(error), false);\n    });\n  });\n\n  describe('unknown errors', () => {\n    test('should NOT fallback on unknown errors by default', () => {\n      const error = new Error('Something unexpected happened');\n      assert.equal(shouldFallback(error), false);\n    });\n  });\n});\n\ndescribe('createProviderError', () => {\n  test('should create error with provider metadata', () => {\n    const original = new Error('API failed');\n    original.status = 500;\n\n    const wrapped = createProviderError('gemini', 'chatCompletion', original);\n\n    assert.equal(wrapped.provider, 'gemini');\n    assert.equal(wrapped.operation, 'chatCompletion');\n    assert.equal(wrapped.originalError, original);\n    assert.equal(wrapped.status, 500);\n    assert.ok(wrapped.message.includes('[gemini]'));\n    assert.ok(wrapped.message.includes('chatCompletion'));\n    assert.ok(wrapped.message.includes('API failed'));\n  });\n\n  test('should set shouldFallback property', () => {\n    const rateLimit = new Error('Rate limit exceeded');\n    const invalidRequest = new Error('Invalid request format');\n    invalidRequest.status = 400;\n\n    const rateLimitWrapped = createProviderError('openai', 'chat', rateLimit);\n    const invalidRequestWrapped = createProviderError('openai', 'chat', invalidRequest);\n\n    assert.equal(rateLimitWrapped.shouldFallback, true);\n    assert.equal(invalidRequestWrapped.shouldFallback, false);\n  });\n});\n\ndescribe('error pattern constants', () => {\n  test('FALLBACK_ERROR_PATTERNS should contain expected patterns', () => {\n    assert.ok(FALLBACK_ERROR_PATTERNS.includes('rate limit'));\n    assert.ok(FALLBACK_ERROR_PATTERNS.includes('quota'));\n    assert.ok(FALLBACK_ERROR_PATTERNS.includes('timeout'));\n    assert.ok(FALLBACK_ERROR_PATTERNS.includes('503'));\n  });\n\n  test('NO_FALLBACK_ERROR_PATTERNS should contain expected patterns', () => {\n    assert.ok(NO_FALLBACK_ERROR_PATTERNS.includes('invalid api key'));\n    assert.ok(NO_FALLBACK_ERROR_PATTERNS.includes('authentication failed'));\n  });\n});\n\ndescribe('parseRetryAfter', () => {\n  test('should return null for error without retry info', () => {\n    const error = new Error('Something went wrong');\n    assert.equal(parseRetryAfter(error), null);\n  });\n\n  test('should parse numeric header value', () => {\n    const error = new Error('Rate limited');\n    error.headers = { 'retry-after': '30' };\n    assert.equal(parseRetryAfter(error), 30);\n  });\n\n  test('should parse \"retry after X seconds\" pattern', () => {\n    const error = new Error('Please retry after 60 seconds');\n    assert.equal(parseRetryAfter(error), 60);\n  });\n\n  test('should parse \"retry in Xs\" pattern', () => {\n    const error = new Error('Rate limited. Retry in 30s');\n    assert.equal(parseRetryAfter(error), 30);\n  });\n\n  test('should parse \"wait X seconds\" pattern', () => {\n    const error = new Error('Too many requests. Wait 15 seconds.');\n    assert.equal(parseRetryAfter(error), 15);\n  });\n\n  test('should parse Gemini \"Retry after X\" pattern', () => {\n    const error = new Error('Resource exhausted. Retry after 120');\n    assert.equal(parseRetryAfter(error), 120);\n  });\n\n  test('should handle headers.get() method (fetch API style)', () => {\n    const error = new Error('Rate limited');\n    error.headers = {\n      get: (name) => (name.toLowerCase() === 'retry-after' ? '45' : null),\n    };\n    assert.equal(parseRetryAfter(error), 45);\n  });\n\n  test('should return null for invalid header value', () => {\n    const error = new Error('Rate limited');\n    error.headers = { 'retry-after': 'invalid' };\n    assert.equal(parseRetryAfter(error), null);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\__tests__\\integration.manual.js",
    "messages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'main' has too many statements (23). Maximum allowed is 20.",
        "line": 9,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 55,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Quick integration test for LLM provider chain\n * Run: node providers/llm/__tests__/integration.test.js\n */\n\nrequire('dotenv').config();\nconst { createChatProviderChain, getPrimaryProvider, getAvailableProviders } = require('../index');\n\nasync function main() {\n  console.log('=== LLM Provider Integration Test ===\\n');\n\n  // 1. Check configuration\n  console.log('Available providers:', getAvailableProviders());\n  console.log('Primary provider:', getPrimaryProvider());\n  console.log('');\n\n  // 2. Test chat completion\n  try {\n    const chain = createChatProviderChain();\n\n    console.log('Sending test request to primary provider...');\n    const startTime = Date.now();\n\n    const result = await chain.chatCompletion(\n      [\n        { role: 'system', content: 'You are a helpful assistant. Respond very briefly.' },\n        { role: 'user', content: 'Say \"Hello from Lock-in!\" in exactly 5 words.' },\n      ],\n      {\n        temperature: 0.7,\n        maxTokens: 20,\n        operation: 'integration-test',\n      },\n    );\n\n    const latency = Date.now() - startTime;\n\n    console.log('\\n SUCCESS');\n    console.log('Provider:', result.provider);\n    console.log('Model:', result.model);\n    console.log('Response:', result.content);\n    console.log('Usage:', result.usage);\n    console.log('Latency:', latency + 'ms');\n    console.log('Fallback used:', result.fallbackUsed || false);\n\n    process.exit(0);\n  } catch (error) {\n    console.error('\\n FAILED');\n    console.error('Error:', error.message);\n    if (error.errors) {\n      console.error('All errors:', error.errors);\n    }\n    process.exit(1);\n  }\n}\n\nmain();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\__tests__\\providerChain.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (232). Maximum allowed is 50.",
        "line": 65,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 347,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 88,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 88,
        "endColumn": 27
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 109,
        "column": 9,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 109,
        "endColumn": 63
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (170). Maximum allowed is 50.",
        "line": 135,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 333,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 80.",
        "line": 250,
        "column": 16,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 250,
        "endColumn": 18
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 301,
        "column": 37,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 301,
        "endColumn": 39
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for ProviderChain\n *\n * Uses dependency injection for:\n * - sleep: Eliminates real delays\n * - rateLimiter: Isolates each test from global singleton\n *\n * Tests run in milliseconds with full isolation.\n *\n * IMPORTANT: Each test creates its own RateLimiterManager instance\n * using TEST_LIMITS (no timers) for complete isolation.\n */\n\nconst { test, describe, beforeEach, afterEach, after } = require('node:test');\nconst assert = require('node:assert');\nconst { ProviderChain, immediateSleep } = require('../providerChain');\nconst { CircuitBreaker } = require('../circuitBreaker');\nconst {\n  RateLimiterManager,\n  TEST_LIMITS,\n  drainEventLoop,\n  forceResetRateLimiterManager,\n} = require('../rateLimiter');\n\n/** @type {RateLimiterManager|null} */\nlet testRateLimiter = null;\n\n/**\n * Create test options with immediate sleep and injected rate limiter\n * @returns {Object} Test options\n */\nfunction createTestOptions(overrides = {}) {\n  return {\n    sleep: immediateSleep,\n    retryDelayMs: 0,\n    maxRetries: 2,\n    rateLimiter: testRateLimiter,\n    ...overrides,\n  };\n}\n\n/**\n * Create a mock adapter for testing\n * @param {string} name - Provider name\n * @param {Object} options - Mock options\n * @returns {Object} Mock adapter\n */\nfunction createMockAdapter(name, options = {}) {\n  return {\n    getProviderName: () => name,\n    model: options.model || 'test-model',\n    isAvailable: () => options.available !== false,\n    chatCompletion:\n      options.chatCompletion ||\n      (async () => ({\n        content: `Response from ${name}`,\n        provider: name,\n        model: options.model || 'test-model',\n        usage: { prompt_tokens: 10, completion_tokens: 5, total_tokens: 15 },\n      })),\n    healthCheck: async () => ({ available: true, provider: name }),\n  };\n}\n\ndescribe('ProviderChain', () => {\n  beforeEach(() => {\n    // Ensure any global singleton is cleaned up before each test\n    forceResetRateLimiterManager();\n    // Create a fresh, isolated rate limiter for each test\n    // No singleton dependency - complete test isolation\n    testRateLimiter = new RateLimiterManager(TEST_LIMITS);\n  });\n\n  afterEach(async () => {\n    // Clean up the test-specific rate limiter\n    if (testRateLimiter) {\n      // Use forceCleanup for synchronous cleanup when possible\n      testRateLimiter.forceCleanup();\n      testRateLimiter = null;\n    }\n    // Also ensure global singleton is cleaned\n    forceResetRateLimiterManager();\n  });\n\n  // Final cleanup after all tests in this describe block complete\n  // This ensures any lingering Bottleneck internals are fully drained\n  after(async () => {\n    await drainEventLoop(5);\n  });\n\n  describe('constructor', () => {\n    test('should filter out unavailable adapters', () => {\n      const adapters = [\n        createMockAdapter('gemini', { available: true }),\n        createMockAdapter('openai', { available: false }),\n      ];\n\n      const chain = new ProviderChain(adapters, createTestOptions());\n      assert.deepEqual(chain.getAvailableProviders(), ['gemini']);\n    });\n\n    test('should throw when no adapters are available', () => {\n      const adapters = [\n        createMockAdapter('gemini', { available: false }),\n        createMockAdapter('openai', { available: false }),\n      ];\n\n      assert.throws(\n        () => new ProviderChain(adapters, createTestOptions()),\n        /No LLM providers available/,\n      );\n    });\n\n    test('should preserve adapter order', () => {\n      const adapters = [\n        createMockAdapter('gemini'),\n        createMockAdapter('openai'),\n        createMockAdapter('groq'),\n      ];\n\n      const chain = new ProviderChain(adapters, createTestOptions());\n      assert.deepEqual(chain.getAvailableProviders(), ['gemini', 'openai', 'groq']);\n    });\n  });\n\n  describe('getPrimaryProvider', () => {\n    test('should return first available provider', () => {\n      const adapters = [createMockAdapter('gemini'), createMockAdapter('openai')];\n\n      const chain = new ProviderChain(adapters, createTestOptions());\n      assert.equal(chain.getPrimaryProvider(), 'gemini');\n    });\n  });\n\n  describe('chatCompletion', () => {\n    test('should use primary provider when successful', async () => {\n      const adapters = [createMockAdapter('gemini'), createMockAdapter('openai')];\n\n      const chain = new ProviderChain(adapters, createTestOptions());\n      const result = await chain.chatCompletion([{ role: 'user', content: 'Hi' }]);\n\n      assert.equal(result.provider, 'gemini');\n      assert.equal(result.content, 'Response from gemini');\n      assert.equal(result.fallbackUsed, false);\n    });\n\n    test('should fallback when primary fails with rate limit', async () => {\n      const primaryError = new Error('Rate limit exceeded');\n      primaryError.shouldFallback = true;\n\n      const adapters = [\n        createMockAdapter('gemini', {\n          chatCompletion: async () => {\n            throw primaryError;\n          },\n        }),\n        createMockAdapter('openai'),\n      ];\n\n      const chain = new ProviderChain(adapters, createTestOptions());\n      const result = await chain.chatCompletion([{ role: 'user', content: 'Hi' }]);\n\n      assert.equal(result.fallbackUsed, true);\n      assert.deepEqual(result.attemptedProviders, ['gemini']);\n    });\n\n    test('should pass request through rate limiter', async () => {\n      // Spy on the injected rate limiter's schedule method\n      let scheduleCalled = false;\n      const originalSchedule = testRateLimiter.schedule.bind(testRateLimiter);\n\n      testRateLimiter.schedule = async (provider, fn) => {\n        scheduleCalled = true;\n        assert.equal(provider, 'gemini');\n        return originalSchedule(provider, fn);\n      };\n\n      const adapters = [createMockAdapter('gemini')];\n      const chain = new ProviderChain(adapters, createTestOptions());\n      await chain.chatCompletion([{ role: 'user', content: 'Hi' }]);\n\n      assert.equal(scheduleCalled, true, 'Should have called rate limiter schedule');\n    });\n\n    test('should NOT fallback on non-recoverable errors', async () => {\n      const badRequestError = new Error('Invalid request: bad request');\n      badRequestError.shouldFallback = false;\n\n      const adapters = [\n        createMockAdapter('gemini', {\n          chatCompletion: async () => {\n            throw badRequestError;\n          },\n        }),\n        createMockAdapter('openai'),\n      ];\n\n      const chain = new ProviderChain(adapters, createTestOptions());\n\n      await assert.rejects(\n        () => chain.chatCompletion([{ role: 'user', content: 'Hi' }]),\n        /Invalid request/,\n      );\n    });\n\n    test('should aggregate errors when all providers fail', async () => {\n      const error1 = new Error('Gemini quota exceeded');\n      error1.shouldFallback = true;\n      const error2 = new Error('OpenAI rate limited');\n      error2.shouldFallback = true;\n\n      const adapters = [\n        createMockAdapter('gemini', {\n          chatCompletion: async () => {\n            throw error1;\n          },\n        }),\n        createMockAdapter('openai', {\n          chatCompletion: async () => {\n            throw error2;\n          },\n        }),\n      ];\n\n      const chain = new ProviderChain(adapters, createTestOptions());\n\n      await assert.rejects(\n        () => chain.chatCompletion([{ role: 'user', content: 'Hi' }]),\n        (error) => {\n          assert.ok(error.message.includes('All LLM providers failed'));\n          assert.ok(error.message.includes('Gemini quota exceeded'));\n          assert.ok(error.message.includes('OpenAI rate limited'));\n          assert.equal(error.errors.length, 2);\n          return true;\n        },\n      );\n    });\n\n    test('should stop when overall timeout expires', async () => {\n      const slowAdapter = createMockAdapter('gemini', {\n        chatCompletion: async (_messages, options = {}) =>\n          new Promise((resolve, reject) => {\n            const timer = setTimeout(() => {\n              resolve({\n                content: 'Late response',\n                provider: 'gemini',\n                model: 'test-model',\n                usage: { prompt_tokens: 1, completion_tokens: 1, total_tokens: 2 },\n              });\n            }, 80);\n\n            if (options.signal) {\n              options.signal.addEventListener(\n                'abort',\n                () => {\n                  clearTimeout(timer);\n                  const error = new Error('Request aborted');\n                  error.name = 'AbortError';\n                  reject(error);\n                },\n                { once: true },\n              );\n            }\n          }),\n      });\n\n      const chain = new ProviderChain([slowAdapter], createTestOptions());\n\n      await assert.rejects(\n        () =>\n          chain.chatCompletion([{ role: 'user', content: 'Hi' }], {\n            overallTimeoutMs: 20,\n          }),\n        (error) => {\n          assert.ok(error.message.includes('deadline exceeded'));\n          return true;\n        },\n      );\n    });\n\n    test('should pass per-attempt timeout to adapter', async () => {\n      let observedTimeout = null;\n      const adapter = createMockAdapter('gemini', {\n        chatCompletion: async (_messages, options = {}) => {\n          observedTimeout = options.timeoutMs;\n          return {\n            content: 'ok',\n            provider: 'gemini',\n            model: 'test-model',\n            usage: { prompt_tokens: 1, completion_tokens: 1, total_tokens: 2 },\n          };\n        },\n      });\n\n      const chain = new ProviderChain([adapter], createTestOptions());\n      await chain.chatCompletion([{ role: 'user', content: 'Hi' }], {\n        overallTimeoutMs: 1000,\n        timeoutMs: 50,\n      });\n\n      assert.equal(observedTimeout, 50);\n    });\n\n    test('should skip provider when circuit is open', async () => {\n      let primaryCalls = 0;\n      const primary = createMockAdapter('gemini', {\n        chatCompletion: async () => {\n          primaryCalls += 1;\n          const error = new Error('Rate limit exceeded');\n          error.status = 429;\n          throw error;\n        },\n      });\n      const fallback = createMockAdapter('openai');\n      const breaker = new CircuitBreaker({\n        failureThreshold: 1,\n        openDurationMs: 60000,\n        now: () => Date.now(),\n      });\n\n      const chain = new ProviderChain(\n        [primary, fallback],\n        createTestOptions({ circuitBreaker: breaker, maxRetries: 1 }),\n      );\n      const first = await chain.chatCompletion([{ role: 'user', content: 'Hi' }]);\n      assert.equal(first.provider, 'openai');\n      assert.equal(primaryCalls, 1);\n\n      const second = await chain.chatCompletion([{ role: 'user', content: 'Hi again' }]);\n      assert.equal(second.provider, 'openai');\n      assert.equal(primaryCalls, 1, 'Primary should be skipped while circuit is open');\n    });\n  });\n\n  describe('healthCheck', () => {\n    test('should check health of all providers', async () => {\n      const adapters = [createMockAdapter('gemini'), createMockAdapter('openai')];\n\n      const chain = new ProviderChain(adapters, createTestOptions());\n      const results = await chain.healthCheck();\n\n      assert.equal(results.length, 2);\n      assert.deepEqual(results[0], { available: true, provider: 'gemini' });\n      assert.deepEqual(results[1], { available: true, provider: 'openai' });\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\__tests__\\rateLimiter.test.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'getRateLimiterManager' is assigned a value but never used.",
        "line": 15,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 15,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "removeVar",
            "data": { "varName": "getRateLimiterManager" },
            "fix": { "range": [474, 499], "text": "" },
            "desc": "Remove unused variable 'getRateLimiterManager'."
          }
        ]
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'resetRateLimiterManager' is assigned a value but never used.",
        "line": 17,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 17,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "removeVar",
            "data": { "varName": "resetRateLimiterManager" },
            "fix": { "range": [528, 555], "text": "" },
            "desc": "Remove unused variable 'resetRateLimiterManager'."
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (152). Maximum allowed is 50.",
        "line": 25,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 221,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 45,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 45,
        "endColumn": 27
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 74,
        "column": 40,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 77,
        "endColumn": 8
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 85,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 87,
        "endColumn": 8
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 97,
        "column": 50,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 100,
        "endColumn": 8
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 109,
        "column": 9,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 113,
        "endColumn": 10
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (5). Maximum allowed is 3.",
        "line": 110,
        "column": 44,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 112,
        "endColumn": 12
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 150.",
        "line": 131,
        "column": 39,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 131,
        "endColumn": 42
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 450.",
        "line": 150,
        "column": 39,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 150,
        "endColumn": 42
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 168,
        "column": 35,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 168,
        "endColumn": 65
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 169,
        "column": 35,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 169,
        "endColumn": 65
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 233,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 233,
        "endColumn": 27
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 263,
        "column": 50,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 263,
        "endColumn": 53
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 264,
        "column": 50,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 264,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 30.",
        "line": 265,
        "column": 48,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 265,
        "endColumn": 50
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 17,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for RateLimiterManager\n *\n * Uses TEST_LIMITS configuration for fast, deterministic tests.\n * Creates local instances for test isolation - avoids global singleton conflicts.\n *\n * IMPORTANT: Each test creates its own RateLimiterManager instance\n * and uses forceCleanup() for guaranteed resource release.\n */\n\nconst { test, describe, beforeEach, afterEach, after } = require('node:test');\nconst assert = require('node:assert');\nconst {\n  RateLimiterManager,\n  getRateLimiterManager,\n  getTestRateLimiterManager,\n  resetRateLimiterManager,\n  forceResetRateLimiterManager,\n  drainEventLoop,\n  DEFAULT_LIMITS,\n  TEST_LIMITS,\n  TOKEN_COSTS,\n} = require('../rateLimiter');\n\ndescribe('RateLimiterManager', () => {\n  let manager;\n\n  beforeEach(() => {\n    // Ensure any global singleton is cleaned up before each test\n    forceResetRateLimiterManager();\n  });\n\n  afterEach(async () => {\n    // Clean up local manager instance using force cleanup for reliability\n    if (manager) {\n      manager.forceCleanup();\n      manager = null;\n    }\n    // Also ensure global singleton is cleaned\n    forceResetRateLimiterManager();\n  });\n\n  // Final cleanup after all tests in this describe block complete\n  after(async () => {\n    await drainEventLoop(5);\n  });\n\n  describe('constructor', () => {\n    test('should initialize with default limits for all providers', () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n      const stats = manager.getQueueStats();\n\n      assert.ok(stats.gemini, 'Should have gemini limiter');\n      assert.ok(stats.groq, 'Should have groq limiter');\n      assert.ok(stats.openai, 'Should have openai limiter');\n    });\n\n    test('should accept custom limits', () => {\n      const customLimits = {\n        gemini: { ...TEST_LIMITS.gemini, reservoir: 100 },\n      };\n      manager = new RateLimiterManager(customLimits);\n      const stats = manager.getQueueStats();\n\n      assert.ok(stats.gemini);\n    });\n  });\n\n  describe('schedule', () => {\n    test('should execute function through rate limiter', async () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n      let executed = false;\n\n      await manager.schedule('gemini', async () => {\n        executed = true;\n        return { success: true };\n      });\n\n      assert.equal(executed, true);\n    });\n\n    test('should return result from scheduled function', async () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n\n      const result = await manager.schedule('gemini', async () => {\n        return { content: 'test response', provider: 'gemini' };\n      });\n\n      assert.equal(result.content, 'test response');\n      assert.equal(result.provider, 'gemini');\n    });\n\n    test('should execute directly for unknown provider', async () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n      let executed = false;\n\n      await manager.schedule('unknown-provider', async () => {\n        executed = true;\n        return { success: true };\n      });\n\n      assert.equal(executed, true);\n    });\n\n    test('should propagate errors from scheduled function', async () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n\n      await assert.rejects(\n        async () => {\n          await manager.schedule('gemini', async () => {\n            throw new Error('Test error');\n          });\n        },\n        { message: 'Test error' },\n      );\n    });\n  });\n\n  describe('recordUsage', () => {\n    test('should track usage statistics', () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n\n      manager.recordUsage('gemini', 'gemini-2.0-flash', {\n        prompt_tokens: 100,\n        completion_tokens: 50,\n        total_tokens: 150,\n      });\n\n      const stats = manager.getUsageStats();\n      assert.equal(stats.totalRequests, 1);\n      assert.equal(stats.totalTokens, 150);\n      assert.ok(stats.totalCostUsd > 0, 'Should calculate cost');\n    });\n\n    test('should accumulate usage across multiple requests', () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n\n      manager.recordUsage('gemini', 'gemini-2.0-flash', {\n        prompt_tokens: 100,\n        completion_tokens: 50,\n      });\n\n      manager.recordUsage('gemini', 'gemini-2.0-flash', {\n        prompt_tokens: 200,\n        completion_tokens: 100,\n      });\n\n      const stats = manager.getUsageStats();\n      assert.equal(stats.totalRequests, 2);\n      assert.equal(stats.totalTokens, 450);\n    });\n\n    test('should track usage per model', () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n\n      manager.recordUsage('gemini', 'gemini-2.0-flash', {\n        prompt_tokens: 100,\n        completion_tokens: 50,\n      });\n\n      manager.recordUsage('openai', 'gpt-4o-mini', {\n        prompt_tokens: 200,\n        completion_tokens: 100,\n      });\n\n      const stats = manager.getUsageStats();\n      assert.equal(stats.models.length, 2);\n      assert.ok(stats.models.some((m) => m.provider === 'gemini'));\n      assert.ok(stats.models.some((m) => m.provider === 'openai'));\n    });\n  });\n\n  describe('getQueueStats', () => {\n    test('should return queue stats for all providers', () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n      const stats = manager.getQueueStats();\n\n      assert.ok('gemini' in stats);\n      assert.ok('groq' in stats);\n      assert.ok('openai' in stats);\n\n      // Each provider should have running, queued, reservoir\n      for (const provider of ['gemini', 'groq', 'openai']) {\n        assert.ok('running' in stats[provider]);\n        assert.ok('queued' in stats[provider]);\n      }\n    });\n  });\n\n  describe('pauseProvider', () => {\n    test('should pause and resume provider', async () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n\n      // This should complete without error - timer is tracked and cleaned up by forceCleanup()\n      await manager.pauseProvider('gemini', 100);\n\n      // No need to wait - afterEach calls manager.forceCleanup() which cleans up the timer\n    });\n  });\n\n  describe('isStopped', () => {\n    test('should return false initially', () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n      assert.equal(manager.isStopped(), false);\n    });\n\n    test('should return true after stop', async () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n      await manager.stop();\n      assert.equal(manager.isStopped(), true);\n      manager = null; // Already stopped, don't cleanup again\n    });\n\n    test('should return true after forceCleanup', () => {\n      manager = new RateLimiterManager(TEST_LIMITS);\n      manager.forceCleanup();\n      assert.equal(manager.isStopped(), true);\n      manager = null; // Already stopped, don't cleanup again\n    });\n  });\n});\n\ndescribe('getRateLimiterManager', () => {\n  beforeEach(() => {\n    forceResetRateLimiterManager();\n  });\n\n  afterEach(() => {\n    forceResetRateLimiterManager();\n  });\n\n  after(async () => {\n    await drainEventLoop(5);\n  });\n\n  test('should return singleton instance', () => {\n    const manager1 = getTestRateLimiterManager();\n    const manager2 = getTestRateLimiterManager();\n\n    assert.strictEqual(manager1, manager2);\n  });\n\n  test('should create new instance after reset', async () => {\n    const manager1 = getTestRateLimiterManager();\n    forceResetRateLimiterManager();\n    const manager2 = getTestRateLimiterManager();\n\n    assert.notStrictEqual(manager1, manager2);\n  });\n});\n\ndescribe('DEFAULT_LIMITS', () => {\n  test('should have correct structure for each provider', () => {\n    for (const provider of ['gemini', 'groq', 'openai']) {\n      const limits = DEFAULT_LIMITS[provider];\n      assert.ok(limits.reservoir > 0, `${provider} should have reservoir`);\n      assert.ok(limits.maxConcurrent > 0, `${provider} should have maxConcurrent`);\n      assert.ok(limits.highWater > 0, `${provider} should have highWater`);\n    }\n  });\n\n  test('should have conservative limits for paid providers', () => {\n    assert.ok(DEFAULT_LIMITS.gemini.reservoir <= 200, 'Gemini should be conservative');\n    assert.ok(DEFAULT_LIMITS.openai.reservoir <= 50, 'OpenAI should be conservative');\n    assert.ok(DEFAULT_LIMITS.groq.reservoir <= 30, 'Groq should match free tier');\n  });\n});\n\ndescribe('TEST_LIMITS', () => {\n  test('should have no minTime delays for fast tests', () => {\n    for (const provider of ['gemini', 'groq', 'openai']) {\n      const limits = TEST_LIMITS[provider];\n      assert.equal(limits.minTime, 0, `${provider} should have zero minTime`);\n      assert.ok(limits.maxConcurrent >= 100, `${provider} should have high concurrency`);\n    }\n  });\n});\n\ndescribe('TOKEN_COSTS', () => {\n  test('should have cost definitions for all providers', () => {\n    assert.ok(TOKEN_COSTS.gemini, 'Should have gemini costs');\n    assert.ok(TOKEN_COSTS.groq, 'Should have groq costs');\n    assert.ok(TOKEN_COSTS.openai, 'Should have openai costs');\n  });\n\n  test('should have default costs for each provider', () => {\n    for (const provider of ['gemini', 'groq', 'openai']) {\n      const costs = TOKEN_COSTS[provider];\n      assert.ok(costs.default, `${provider} should have default costs`);\n      assert.ok(costs.default.input >= 0, `${provider} should have input cost`);\n      assert.ok(costs.default.output >= 0, `${provider} should have output cost`);\n    }\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\__tests__\\responseSchemas.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\__tests__\\testGroq.js",
    "messages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'main' has too many statements (26). Maximum allowed is 20.",
        "line": 9,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 60,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Quick test to verify Groq API specifically\n * Run: node providers/llm/__tests__/testGroq.js\n */\n\nrequire('dotenv').config();\nconst { GroqAdapter } = require('../adapters/groqAdapter');\n\nasync function main() {\n  console.log('=== Groq API Direct Test ===\\n');\n\n  const apiKey = process.env.GROQ_API_KEY;\n  if (!apiKey) {\n    console.error(' GROQ_API_KEY not set');\n    process.exit(1);\n  }\n\n  const adapter = new GroqAdapter({\n    apiKey,\n    model: process.env.GROQ_MODEL || 'llama-3.1-8b-instant',\n    fallbackModel: process.env.GROQ_FALLBACK_MODEL || 'llama-3.3-70b-versatile',\n  });\n\n  console.log('Provider:', adapter.getProviderName());\n  console.log('Model:', adapter.model);\n  console.log('Fallback Model:', adapter.fallbackModel);\n  console.log('Available:', adapter.isAvailable());\n  console.log('');\n\n  try {\n    console.log('Sending test request...');\n    const startTime = Date.now();\n\n    const result = await adapter.chatCompletion(\n      [\n        { role: 'system', content: 'You are a helpful assistant. Respond very briefly.' },\n        { role: 'user', content: 'Say \"Hello from Groq!\" in exactly 5 words.' },\n      ],\n      {\n        temperature: 0.7,\n        maxTokens: 20,\n      },\n    );\n\n    const latency = Date.now() - startTime;\n\n    console.log('\\n SUCCESS');\n    console.log('Provider:', result.provider);\n    console.log('Model:', result.model);\n    console.log('Response:', result.content);\n    console.log('Usage:', result.usage);\n    console.log('Latency:', latency + 'ms');\n\n    process.exit(0);\n  } catch (error) {\n    console.error('\\n FAILED');\n    console.error('Error:', error.message);\n    process.exit(1);\n  }\n}\n\nmain();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\adapters\\__tests__\\geminiAdapter.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (133). Maximum allowed is 50.",
        "line": 9,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 163,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (59). Maximum allowed is 50.",
        "line": 96,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 162,
        "endColumn": 4
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 106,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 124,
        "endColumn": 11
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 109,
        "column": 17,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 123,
        "endColumn": 15
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 155,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 155,
        "endColumn": 41
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for GeminiAdapter\n */\n\nconst { test, describe, beforeEach, mock } = require('node:test');\nconst assert = require('node:assert');\nconst { GeminiAdapter } = require('../geminiAdapter');\n\ndescribe('GeminiAdapter', () => {\n  describe('constructor', () => {\n    test('should set provider name to gemini', () => {\n      const adapter = new GeminiAdapter({ apiKey: 'test-key' });\n      assert.equal(adapter.getProviderName(), 'gemini');\n    });\n\n    test('should use default model when not specified', () => {\n      const adapter = new GeminiAdapter({ apiKey: 'test-key' });\n      assert.equal(adapter.model, 'gemini-2.0-flash');\n    });\n\n    test('should use custom model when specified', () => {\n      const adapter = new GeminiAdapter({ apiKey: 'test-key', model: 'gemini-pro' });\n      assert.equal(adapter.model, 'gemini-pro');\n    });\n  });\n\n  describe('isAvailable', () => {\n    test('should return true when API key is set', () => {\n      const adapter = new GeminiAdapter({ apiKey: 'test-key' });\n      assert.equal(adapter.isAvailable(), true);\n    });\n\n    test('should return false when API key is missing', () => {\n      const adapter = new GeminiAdapter({});\n      assert.equal(adapter.isAvailable(), false);\n    });\n  });\n\n  describe('_convertMessages', () => {\n    test('should convert system message to systemInstruction', () => {\n      const adapter = new GeminiAdapter({ apiKey: 'test-key' });\n      const messages = [\n        { role: 'system', content: 'You are helpful' },\n        { role: 'user', content: 'Hello' },\n      ];\n\n      const result = adapter._convertMessages(messages);\n\n      assert.deepEqual(result.systemInstruction, {\n        parts: [{ text: 'You are helpful' }],\n      });\n      assert.equal(result.contents.length, 1);\n      assert.equal(result.contents[0].role, 'user');\n    });\n\n    test('should map assistant role to model', () => {\n      const adapter = new GeminiAdapter({ apiKey: 'test-key' });\n      const messages = [\n        { role: 'user', content: 'Hi' },\n        { role: 'assistant', content: 'Hello!' },\n      ];\n\n      const result = adapter._convertMessages(messages);\n\n      assert.equal(result.contents[1].role, 'model');\n    });\n\n    test('should convert multimodal content with images', () => {\n      const adapter = new GeminiAdapter({ apiKey: 'test-key' });\n      const messages = [\n        {\n          role: 'user',\n          content: [\n            { type: 'text', text: 'Describe this image' },\n            {\n              type: 'image_url',\n              image_url: { url: 'data:image/png;base64,iVBORw0KGgo=' },\n            },\n          ],\n        },\n      ];\n\n      const result = adapter._convertMessages(messages);\n\n      assert.equal(result.contents[0].parts.length, 2);\n      assert.equal(result.contents[0].parts[0].text, 'Describe this image');\n      assert.deepEqual(result.contents[0].parts[1], {\n        inline_data: {\n          mime_type: 'image/png',\n          data: 'iVBORw0KGgo=',\n        },\n      });\n    });\n  });\n\n  describe('chatCompletion', () => {\n    let adapter;\n    let originalFetch;\n\n    beforeEach(() => {\n      adapter = new GeminiAdapter({ apiKey: 'test-key' });\n      originalFetch = globalThis.fetch;\n    });\n\n    test('should return properly formatted result on success', async () => {\n      globalThis.fetch = mock.fn(() =>\n        Promise.resolve({\n          ok: true,\n          json: () =>\n            Promise.resolve({\n              candidates: [\n                {\n                  content: {\n                    parts: [{ text: 'Hello from Gemini!' }],\n                  },\n                },\n              ],\n              usageMetadata: {\n                promptTokenCount: 10,\n                candidatesTokenCount: 5,\n                totalTokenCount: 15,\n              },\n            }),\n        }),\n      );\n\n      const result = await adapter.chatCompletion([{ role: 'user', content: 'Hi' }]);\n\n      assert.equal(result.content, 'Hello from Gemini!');\n      assert.equal(result.provider, 'gemini');\n      assert.equal(result.model, 'gemini-2.0-flash');\n      assert.deepEqual(result.usage, {\n        prompt_tokens: 10,\n        completion_tokens: 5,\n        total_tokens: 15,\n      });\n\n      globalThis.fetch = originalFetch;\n    });\n\n    test('should throw wrapped error on API failure', async () => {\n      globalThis.fetch = mock.fn(() =>\n        Promise.resolve({\n          ok: false,\n          status: 429,\n          text: () => Promise.resolve('Rate limited'),\n        }),\n      );\n\n      await assert.rejects(\n        () => adapter.chatCompletion([{ role: 'user', content: 'Hi' }]),\n        (error) => {\n          assert.equal(error.provider, 'gemini');\n          assert.equal(error.operation, 'chatCompletion');\n          assert.equal(error.status, 429);\n          return true;\n        },\n      );\n\n      globalThis.fetch = originalFetch;\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\adapters\\__tests__\\groqAdapter.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (104). Maximum allowed is 50.",
        "line": 9,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 140,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3500.",
        "line": 74,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 74,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for GroqAdapter\n */\n\nconst { test, describe, beforeEach } = require('node:test');\nconst assert = require('node:assert');\nconst { GroqAdapter } = require('../groqAdapter');\n\ndescribe('GroqAdapter', () => {\n  describe('constructor', () => {\n    test('should initialize with default models', () => {\n      const adapter = new GroqAdapter({ apiKey: 'test-key' });\n\n      assert.equal(adapter.getProviderName(), 'groq');\n      assert.equal(adapter.model, 'llama-3.1-8b-instant');\n      assert.equal(adapter.fallbackModel, 'llama-3.3-70b-versatile');\n    });\n\n    test('should accept custom models', () => {\n      const adapter = new GroqAdapter({\n        apiKey: 'test-key',\n        model: 'custom-model',\n        fallbackModel: 'custom-fallback',\n      });\n\n      assert.equal(adapter.model, 'custom-model');\n      assert.equal(adapter.fallbackModel, 'custom-fallback');\n    });\n\n    test('should be available when API key is provided', () => {\n      const adapter = new GroqAdapter({ apiKey: 'test-key' });\n      assert.equal(adapter.isAvailable(), true);\n    });\n\n    test('should not be available when API key is missing', () => {\n      const adapter = new GroqAdapter({});\n      assert.equal(adapter.isAvailable(), false);\n    });\n  });\n\n  describe('_selectModel', () => {\n    let adapter;\n\n    beforeEach(() => {\n      adapter = new GroqAdapter({\n        apiKey: 'test-key',\n        model: 'fast-model',\n        fallbackModel: 'quality-model',\n      });\n    });\n\n    test('should use default model for simple queries', () => {\n      const messages = [{ role: 'user', content: 'What is 2+2?' }];\n      const model = adapter._selectModel(messages, {});\n\n      assert.equal(model, 'fast-model');\n    });\n\n    test('should use fallback model when explicitly requested', () => {\n      const messages = [{ role: 'user', content: 'Simple question' }];\n      const model = adapter._selectModel(messages, { useHigherQualityModel: true });\n\n      assert.equal(model, 'quality-model');\n    });\n\n    test('should auto-upgrade for step-by-step requests', () => {\n      const messages = [{ role: 'user', content: 'Explain step-by-step how to solve this' }];\n      const model = adapter._selectModel(messages, {});\n\n      assert.equal(model, 'quality-model');\n    });\n\n    test('should auto-upgrade for long inputs', () => {\n      const longContent = 'a'.repeat(3500);\n      const messages = [{ role: 'user', content: longContent }];\n      const model = adapter._selectModel(messages, {});\n\n      assert.equal(model, 'quality-model');\n    });\n\n    test('should auto-upgrade for JSON output requests', () => {\n      const messages = [{ role: 'user', content: 'Give me data' }];\n      const model = adapter._selectModel(messages, { responseFormat: { type: 'json_object' } });\n\n      assert.equal(model, 'quality-model');\n    });\n  });\n\n  describe('_formatMessages', () => {\n    let adapter;\n\n    beforeEach(() => {\n      adapter = new GroqAdapter({ apiKey: 'test-key' });\n    });\n\n    test('should format simple text messages', () => {\n      const messages = [\n        { role: 'system', content: 'You are helpful' },\n        { role: 'user', content: 'Hello' },\n      ];\n\n      const formatted = adapter._formatMessages(messages);\n\n      assert.equal(formatted.length, 2);\n      assert.equal(formatted[0].role, 'system');\n      assert.equal(formatted[0].content, 'You are helpful');\n    });\n\n    test('should handle multimodal content', () => {\n      const messages = [\n        {\n          role: 'user',\n          content: [\n            { type: 'text', text: 'Describe this' },\n            { type: 'image_url', image_url: { url: 'https://example.com/img.png' } },\n          ],\n        },\n      ];\n\n      const formatted = adapter._formatMessages(messages);\n\n      assert.equal(formatted[0].content.length, 2);\n      assert.equal(formatted[0].content[0].type, 'text');\n      assert.equal(formatted[0].content[1].type, 'image_url');\n    });\n  });\n\n  describe('error handling', () => {\n    test('should wrap errors with provider context', () => {\n      const adapter = new GroqAdapter({ apiKey: 'test-key' });\n      const originalError = new Error('Something went wrong');\n\n      const wrappedError = adapter.wrapError('chatCompletion', originalError);\n\n      assert.ok(wrappedError.message.includes('[groq]'));\n      assert.ok(wrappedError.message.includes('chatCompletion'));\n      assert.equal(wrappedError.provider, 'groq');\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\adapters\\__tests__\\openaiAdapter.test.js",
    "messages": [
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 49,
        "column": 9,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 49,
        "endColumn": 72
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 50,
        "column": 9,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 54,
        "endColumn": 10
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for OpenAIAdapter\n */\n\nconst { test, describe } = require('node:test');\nconst assert = require('node:assert');\nconst { OpenAIAdapter } = require('../openaiAdapter');\n\ndescribe('OpenAIAdapter', () => {\n  describe('constructor', () => {\n    test('should set provider name to openai', () => {\n      const adapter = new OpenAIAdapter({ apiKey: 'test-key' });\n      assert.equal(adapter.getProviderName(), 'openai');\n    });\n\n    test('should use default model when not specified', () => {\n      const adapter = new OpenAIAdapter({ apiKey: 'test-key' });\n      assert.equal(adapter.model, 'gpt-4o-mini');\n    });\n\n    test('should use custom model when specified', () => {\n      const adapter = new OpenAIAdapter({ apiKey: 'test-key', model: 'gpt-4' });\n      assert.equal(adapter.model, 'gpt-4');\n    });\n  });\n\n  describe('isAvailable', () => {\n    test('should return true when API key is set', () => {\n      const adapter = new OpenAIAdapter({ apiKey: 'test-key' });\n      assert.equal(adapter.isAvailable(), true);\n    });\n\n    test('should return false when API key is missing', () => {\n      const adapter = new OpenAIAdapter({});\n      assert.equal(adapter.isAvailable(), false);\n    });\n\n    test('should return false when API key is null', () => {\n      const adapter = new OpenAIAdapter({ apiKey: null });\n      assert.equal(adapter.isAvailable(), false);\n    });\n  });\n\n  describe('chatCompletion', () => {\n    test('should throw error when client not initialized', async () => {\n      const adapter = new OpenAIAdapter({});\n\n      await assert.rejects(\n        () => adapter.chatCompletion([{ role: 'user', content: 'Hi' }]),\n        (error) => {\n          assert.equal(error.provider, 'openai');\n          assert.ok(error.message.includes('not initialized'));\n          return true;\n        },\n      );\n    });\n\n    // Note: Full integration tests would require mocking the OpenAI SDK\n    // which is complex due to its internal structure. For now, we test\n    // the adapter's error handling and configuration.\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\adapters\\baseAdapter.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\adapters\\geminiAdapter.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3000.",
        "line": 149,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 149,
        "endColumn": 50
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.7.",
        "line": 182,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 182,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 183,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 183,
        "endColumn": 51
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 202,
        "column": 62,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 202,
        "endColumn": 65
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 204,
        "column": 37,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 204,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Gemini Adapter\n *\n * Adapter for Google's Gemini API using REST (no SDK dependency).\n * Primary provider for chat completions.\n *\n * Model Routing:\n * - Default: gemini-2.0-flash (fast, cheap)\n * - Upgraded: gemini-2.5-flash (better for complex/long inputs)\n * - Premium: gemini-2.5-pro (critical correctness)\n *\n * @module providers/llm/adapters/geminiAdapter\n */\n\nconst { BaseAdapter } = require('./baseAdapter');\nconst { fetchWithRetry } = require('../../../utils/networkRetry');\nconst { parseGeminiResponse } = require('../responseSchemas');\nconst { resolveTimeoutMs } = require('../requestBudget');\n\nconst DEFAULT_MODEL = 'gemini-2.0-flash';\nconst UPGRADED_MODEL = 'gemini-2.5-flash';\nconst PREMIUM_MODEL = 'gemini-2.5-pro';\nconst BASE_URL = 'https://generativelanguage.googleapis.com/v1beta';\nconst REQUEST_TIMEOUT_MS = 60000;\n\n/**\n * Gemini API adapter\n * @extends BaseAdapter\n */\nclass GeminiAdapter extends BaseAdapter {\n  /**\n   * @param {Object} config\n   * @param {string} config.apiKey - Gemini API key\n   * @param {string} [config.model] - Default model (default: gemini-2.0-flash)\n   * @param {string} [config.upgradedModel] - Model for complex tasks\n   * @param {string} [config.premiumModel] - Model for critical correctness\n   */\n  constructor(config) {\n    super(config);\n    this._name = 'gemini';\n    this.model = config.model || DEFAULT_MODEL;\n    this.upgradedModel = config.upgradedModel || UPGRADED_MODEL;\n    this.premiumModel = config.premiumModel || PREMIUM_MODEL;\n    this.baseUrl = BASE_URL;\n  }\n\n  /**\n   * Convert OpenAI-style messages to Gemini format\n   * @private\n   * @param {import('../contracts').ChatMessage[]} messages\n   * @returns {{ systemInstruction: Object|null, contents: Array }}\n   */\n  _convertMessages(messages) {\n    let systemInstruction = null;\n    const contents = [];\n\n    for (const msg of messages) {\n      if (msg.role === 'system') {\n        // Gemini uses systemInstruction separately\n        systemInstruction = {\n          parts: [{ text: msg.content }],\n        };\n        continue;\n      }\n\n      // Map roles: user  user, assistant  model\n      const role = msg.role === 'assistant' ? 'model' : 'user';\n\n      // Handle multimodal content\n      let parts;\n      if (typeof msg.content === 'string') {\n        parts = [{ text: msg.content }];\n      } else if (Array.isArray(msg.content)) {\n        parts = msg.content.map((part) => {\n          if (part.type === 'text') {\n            return { text: part.text };\n          }\n          if (part.type === 'image_url' && part.image_url?.url) {\n            // Convert data URL to inline_data\n            const match = part.image_url.url.match(/^data:([^;]+);base64,(.+)$/);\n            if (match) {\n              return {\n                inline_data: {\n                  mime_type: match[1],\n                  data: match[2],\n                },\n              };\n            }\n          }\n          return { text: '[unsupported content]' };\n        });\n      } else {\n        parts = [{ text: String(msg.content) }];\n      }\n\n      contents.push({ role, parts });\n    }\n\n    return { systemInstruction, contents };\n  }\n\n  /**\n   * Select appropriate model based on task complexity\n   * @private\n   * @param {import('../contracts').ChatMessage[]} messages\n   * @param {import('../contracts').ChatCompletionOptions} options\n   * @returns {string} Selected model name\n   */\n  _selectModel(messages, options) {\n    // Use premium model if explicitly requested for critical correctness\n    if (options.usePremiumModel) {\n      return this.premiumModel;\n    }\n\n    // Use upgraded model if explicitly requested\n    if (options.useUpgradedModel) {\n      return this.upgradedModel;\n    }\n\n    // Auto-detect need for upgraded model\n    const lastUserMessage = this._getLastUserMessageContent(messages);\n\n    if (this._needsUpgradedModel(lastUserMessage, options)) {\n      return this.upgradedModel;\n    }\n\n    return this.model;\n  }\n\n  /**\n   * Check if task requires upgraded model\n   * @private\n   */\n  _needsUpgradedModel(userMessage, options) {\n    if (!userMessage) return false;\n\n    const lowerMessage = userMessage.toLowerCase();\n\n    // Upgrade indicators (per user requirements)\n    const upgradePatterns = [\n      'step-by-step',\n      'step by step',\n      'detailed',\n      'explain in depth',\n      'comprehensive',\n    ];\n\n    // Long input threshold (big lecture chunk)\n    const isLongInput = userMessage.length > 3000;\n\n    // Needs structured output (JSON/table)\n    const needsStructuredOutput =\n      options.responseFormat?.type === 'json_object' ||\n      lowerMessage.includes('table') ||\n      lowerMessage.includes('json');\n\n    return (\n      isLongInput ||\n      needsStructuredOutput ||\n      upgradePatterns.some((pattern) => lowerMessage.includes(pattern))\n    );\n  }\n\n  /**\n   * Get the last user message content\n   * @private\n   */\n  _getLastUserMessageContent(messages) {\n    for (let i = messages.length - 1; i >= 0; i--) {\n      if (messages[i].role === 'user') {\n        const content = messages[i].content;\n        return typeof content === 'string' ? content : content?.[0]?.text || '';\n      }\n    }\n    return '';\n  }\n\n  _buildRequestBody(systemInstruction, contents, options) {\n    const requestBody = {\n      contents,\n      generationConfig: {\n        temperature: options.temperature ?? 0.7,\n        maxOutputTokens: options.maxTokens ?? 1024,\n      },\n    };\n\n    if (systemInstruction) {\n      requestBody.systemInstruction = systemInstruction;\n    }\n\n    if (options.responseFormat?.type === 'json_object') {\n      requestBody.generationConfig.responseMimeType = 'application/json';\n    }\n\n    return requestBody;\n  }\n\n  _parseErrorDetails(errorBody) {\n    if (!errorBody) return '';\n    try {\n      const parsed = JSON.parse(errorBody);\n      return parsed.error?.message || errorBody.substring(0, 200);\n    } catch {\n      return errorBody.substring(0, 200);\n    }\n  }\n\n  async _buildHttpError(response) {\n    const errorBody = await response.text();\n    const errorDetails = this._parseErrorDetails(errorBody);\n    const error = new Error(`Gemini API error: ${response.status} - ${errorDetails}`);\n    error.status = response.status;\n    return this.wrapError('chatCompletion', error);\n  }\n\n  async _executeRequest(url, requestBody, requestOptions = {}) {\n    const timeoutMs = resolveTimeoutMs(requestOptions.timeoutMs, REQUEST_TIMEOUT_MS);\n    const response = await fetchWithRetry(\n      url,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-goog-api-key': this.config.apiKey,\n        },\n        body: JSON.stringify(requestBody),\n        signal: requestOptions.signal,\n      },\n      {\n        maxRetries: 0,\n        timeoutMs,\n        context: 'gemini chatCompletion',\n      },\n    );\n\n    if (!response.ok) {\n      throw await this._buildHttpError(response);\n    }\n\n    return await response.json();\n  }\n\n  _extractContent(data) {\n    const candidate = data.candidates?.[0];\n    if (!candidate?.content?.parts?.[0]?.text) {\n      throw this.wrapError('chatCompletion', new Error('No content in Gemini response'));\n    }\n    return candidate.content.parts[0].text;\n  }\n\n  _extractUsage(data) {\n    if (!data.usageMetadata) {\n      return null;\n    }\n    return {\n      prompt_tokens: data.usageMetadata.promptTokenCount || 0,\n      completion_tokens: data.usageMetadata.candidatesTokenCount || 0,\n      total_tokens: data.usageMetadata.totalTokenCount || 0,\n    };\n  }\n\n  _wrapChatCompletionError(error) {\n    if (error.provider === this.getProviderName()) {\n      return error;\n    }\n    return this.wrapError('chatCompletion', error);\n  }\n\n  /**\n   * Execute chat completion via Gemini REST API\n   * @param {import('../contracts').ChatMessage[]} messages\n   * @param {import('../contracts').ChatCompletionOptions} [options]\n   * @returns {Promise<import('../contracts').ChatCompletionResult>}\n   */\n  async chatCompletion(messages, options = {}) {\n    const { systemInstruction, contents } = this._convertMessages(messages);\n    const selectedModel = this._selectModel(messages, options);\n    const requestBody = this._buildRequestBody(systemInstruction, contents, options);\n    const url = `${this.baseUrl}/models/${selectedModel}:generateContent`;\n\n    try {\n      const data = await this._executeRequest(url, requestBody, {\n        timeoutMs: options.timeoutMs,\n        signal: options.signal,\n      });\n      const parsed = parseGeminiResponse(data);\n      const content = this._extractContent(parsed);\n      const usage = this._extractUsage(parsed);\n\n      return {\n        content,\n        provider: this.getProviderName(),\n        model: selectedModel,\n        usage,\n      };\n    } catch (error) {\n      throw this._wrapChatCompletionError(error);\n    }\n  }\n}\n\nmodule.exports = { GeminiAdapter };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\adapters\\groqAdapter.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.7.",
        "line": 47,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 47,
        "endColumn": 46
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 48,
        "column": 40,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 48,
        "endColumn": 44
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 62,
        "column": 62,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 62,
        "endColumn": 65
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 64,
        "column": 37,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 64,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3000.",
        "line": 204,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 204,
        "endColumn": 50
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Groq Adapter\n *\n * Adapter for Groq's OpenAI-compatible API.\n * Secondary fallback provider with fast inference.\n *\n * Model Routing:\n * - Default: llama-3.1-8b-instant (fast, high capacity)\n * - Fallback: llama-3.3-70b-versatile (higher quality)\n *\n * @module providers/llm/adapters/groqAdapter\n */\n\nconst { BaseAdapter } = require('./baseAdapter');\nconst { fetchWithRetry } = require('../../../utils/networkRetry');\nconst { parseGroqResponse } = require('../responseSchemas');\nconst { resolveTimeoutMs } = require('../requestBudget');\n\nconst DEFAULT_MODEL = 'llama-3.1-8b-instant';\nconst FALLBACK_MODEL = 'llama-3.3-70b-versatile';\nconst BASE_URL = 'https://api.groq.com/openai/v1';\nconst REQUEST_TIMEOUT_MS = 60000;\n\n/**\n * Groq API adapter (OpenAI-compatible)\n * @extends BaseAdapter\n */\nclass GroqAdapter extends BaseAdapter {\n  /**\n   * @param {Object} config\n   * @param {string} config.apiKey - Groq API key\n   * @param {string} [config.model] - Primary model (default: llama-3.1-8b-instant)\n   * @param {string} [config.fallbackModel] - Fallback model for complex tasks\n   */\n  constructor(config) {\n    super(config);\n    this._name = 'groq';\n    this.model = config.model || DEFAULT_MODEL;\n    this.fallbackModel = config.fallbackModel || FALLBACK_MODEL;\n    this.baseUrl = BASE_URL;\n  }\n\n  _buildRequestBody(model, messages, options) {\n    const requestBody = {\n      model,\n      messages: this._formatMessages(messages),\n      temperature: options.temperature ?? 0.7,\n      max_tokens: options.maxTokens ?? 1024,\n    };\n\n    if (options.responseFormat?.type === 'json_object') {\n      requestBody.response_format = { type: 'json_object' };\n    }\n\n    return requestBody;\n  }\n\n  _parseErrorDetails(errorBody) {\n    if (!errorBody) return '';\n    try {\n      const parsed = JSON.parse(errorBody);\n      return parsed.error?.message || errorBody.substring(0, 200);\n    } catch {\n      return errorBody.substring(0, 200);\n    }\n  }\n\n  async _buildHttpError(response) {\n    const errorBody = await response.text();\n    const errorDetails = this._parseErrorDetails(errorBody);\n    const error = new Error(`Groq API error: ${response.status} - ${errorDetails}`);\n    error.status = response.status;\n    return this.wrapError('chatCompletion', error);\n  }\n\n  async _executeRequest(url, requestBody, requestOptions = {}) {\n    const timeoutMs = resolveTimeoutMs(requestOptions.timeoutMs, REQUEST_TIMEOUT_MS);\n    const response = await fetchWithRetry(\n      url,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this.config.apiKey}`,\n        },\n        body: JSON.stringify(requestBody),\n        signal: requestOptions.signal,\n      },\n      {\n        maxRetries: 0,\n        timeoutMs,\n        context: 'groq chatCompletion',\n      },\n    );\n\n    if (!response.ok) {\n      throw await this._buildHttpError(response);\n    }\n\n    return await response.json();\n  }\n\n  _extractContent(data) {\n    const choice = data.choices?.[0];\n    if (!choice?.message?.content) {\n      throw this.wrapError('chatCompletion', new Error('No content in Groq response'));\n    }\n    return choice.message.content;\n  }\n\n  _extractUsage(data) {\n    if (!data.usage) {\n      return null;\n    }\n    return {\n      prompt_tokens: data.usage.prompt_tokens || 0,\n      completion_tokens: data.usage.completion_tokens || 0,\n      total_tokens: data.usage.total_tokens || 0,\n    };\n  }\n\n  _wrapChatCompletionError(error) {\n    if (error.provider === this.getProviderName()) {\n      return error;\n    }\n    return this.wrapError('chatCompletion', error);\n  }\n\n  /**\n   * Execute chat completion via Groq's OpenAI-compatible API\n   * @param {import('../contracts').ChatMessage[]} messages\n   * @param {import('../contracts').ChatCompletionOptions} [options]\n   * @returns {Promise<import('../contracts').ChatCompletionResult>}\n   */\n  async chatCompletion(messages, options = {}) {\n    const model = this._selectModel(messages, options);\n    const requestBody = this._buildRequestBody(model, messages, options);\n    const url = `${this.baseUrl}/chat/completions`;\n\n    try {\n      const data = await this._executeRequest(url, requestBody, {\n        timeoutMs: options.timeoutMs,\n        signal: options.signal,\n      });\n      const parsed = parseGroqResponse(data);\n      const content = this._extractContent(parsed);\n      const usage = this._extractUsage(parsed);\n\n      return {\n        content,\n        provider: this.getProviderName(),\n        model: parsed.model || model,\n        usage,\n      };\n    } catch (error) {\n      throw this._wrapChatCompletionError(error);\n    }\n  }\n\n  /**\n   * Select appropriate model based on task complexity\n   * @private\n   * @param {import('../contracts').ChatMessage[]} messages\n   * @param {import('../contracts').ChatCompletionOptions} options\n   * @returns {string} Selected model name\n   */\n  _selectModel(messages, options) {\n    // Use fallback model if explicitly requested\n    if (options.useHigherQualityModel) {\n      return this.fallbackModel;\n    }\n\n    // Check for complex task indicators\n    const lastUserMessage = this._getLastUserMessageContent(messages);\n\n    if (this._isComplexTask(lastUserMessage, options)) {\n      return this.fallbackModel;\n    }\n\n    return this.model;\n  }\n\n  /**\n   * Check if task requires higher quality model\n   * @private\n   */\n  _isComplexTask(userMessage, options) {\n    if (!userMessage) return false;\n\n    const lowerMessage = userMessage.toLowerCase();\n\n    // Complexity indicators\n    const complexPatterns = [\n      'step-by-step',\n      'step by step',\n      'detailed',\n      'explain in depth',\n      'comprehensive',\n      'analyze',\n      'compare and contrast',\n    ];\n\n    // Long input threshold (likely lecture chunk)\n    const isLongInput = userMessage.length > 3000;\n\n    // Check for structured output requirements\n    const needsStructuredOutput =\n      options.responseFormat?.type === 'json_object' || lowerMessage.includes('table');\n\n    return (\n      isLongInput ||\n      needsStructuredOutput ||\n      complexPatterns.some((pattern) => lowerMessage.includes(pattern))\n    );\n  }\n\n  /**\n   * Get the last user message content\n   * @private\n   */\n  _getLastUserMessageContent(messages) {\n    for (let i = messages.length - 1; i >= 0; i--) {\n      if (messages[i].role === 'user') {\n        const content = messages[i].content;\n        return typeof content === 'string' ? content : content?.[0]?.text || '';\n      }\n    }\n    return '';\n  }\n\n  /**\n   * Format messages for Groq API (OpenAI-compatible)\n   * @private\n   * @param {import('../contracts').ChatMessage[]} messages\n   * @returns {Array} Formatted messages\n   */\n  _formatMessages(messages) {\n    return messages.map((msg) => {\n      // Handle multimodal content (Groq supports images via URL)\n      if (Array.isArray(msg.content)) {\n        return {\n          role: msg.role,\n          content: msg.content.map((part) => {\n            if (part.type === 'text') {\n              return { type: 'text', text: part.text };\n            }\n            if (part.type === 'image_url') {\n              return { type: 'image_url', image_url: part.image_url };\n            }\n            return { type: 'text', text: '[unsupported content]' };\n          }),\n        };\n      }\n\n      return {\n        role: msg.role,\n        content: msg.content,\n      };\n    });\n  }\n}\n\nmodule.exports = { GroqAdapter };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\adapters\\index.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\adapters\\openaiAdapter.js",
    "messages": [
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async method 'chatCompletion' has a complexity of 19. Maximum allowed is 15.",
        "line": 56,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "complex",
        "endLine": 56,
        "endColumn": 23
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async method 'chatCompletion' has too many statements (21). Maximum allowed is 20.",
        "line": 56,
        "column": 23,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 112,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.7.",
        "line": 68,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 68,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 69,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 69,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * OpenAI Adapter\n *\n * Adapter for OpenAI's Chat Completions API.\n * Fallback provider when primary (Gemini) fails.\n *\n * @module providers/llm/adapters/openaiAdapter\n */\n\nconst OpenAI = require('openai');\nconst { BaseAdapter } = require('./baseAdapter');\nconst { parseOpenAiResponse } = require('../responseSchemas');\nconst { resolveTimeoutMs } = require('../requestBudget');\n\nconst DEFAULT_MODEL = 'gpt-4o-mini';\nconst REQUEST_TIMEOUT_MS = 60000;\n\n/**\n * OpenAI API adapter\n * @extends BaseAdapter\n */\nclass OpenAIAdapter extends BaseAdapter {\n  /**\n   * @param {Object} config\n   * @param {string} config.apiKey - OpenAI API key\n   * @param {string} [config.model] - Model name (default: gpt-4o-mini)\n   */\n  constructor(config) {\n    super(config);\n    this._name = 'openai';\n    this.model = config.model || DEFAULT_MODEL;\n\n    if (this.isAvailable()) {\n      this.client = new OpenAI({\n        apiKey: config.apiKey,\n        timeout: REQUEST_TIMEOUT_MS,\n        maxRetries: 0,\n      });\n    }\n  }\n\n  /**\n   * Check if provider is available\n   * @returns {boolean}\n   */\n  isAvailable() {\n    return Boolean(this.config?.apiKey);\n  }\n\n  /**\n   * Execute chat completion via OpenAI SDK\n   * @param {import('../contracts').ChatMessage[]} messages\n   * @param {import('../contracts').ChatCompletionOptions} [options]\n   * @returns {Promise<import('../contracts').ChatCompletionResult>}\n   */\n  async chatCompletion(messages, options = {}) {\n    if (!this.client) {\n      throw this.wrapError(\n        'chatCompletion',\n        new Error('OpenAI client not initialized - missing API key'),\n      );\n    }\n\n    try {\n      const requestParams = {\n        model: this.model,\n        messages,\n        temperature: options.temperature ?? 0.7,\n        max_tokens: options.maxTokens ?? 1024,\n      };\n\n      // Add JSON mode if requested\n      if (options.responseFormat) {\n        requestParams.response_format = options.responseFormat;\n      }\n\n      const requestOptions = {};\n      const timeoutMs = resolveTimeoutMs(options.timeoutMs, REQUEST_TIMEOUT_MS);\n      if (Number.isFinite(timeoutMs)) {\n        requestOptions.timeout = timeoutMs;\n      }\n      if (options.signal) {\n        requestOptions.signal = options.signal;\n      }\n\n      const response = await this.client.chat.completions.create(requestParams, requestOptions);\n      const parsed = parseOpenAiResponse(response);\n\n      const choice = parsed.choices?.[0];\n      if (!choice?.message?.content) {\n        throw this.wrapError('chatCompletion', new Error('No content in OpenAI response'));\n      }\n\n      return {\n        content: choice.message.content,\n        provider: this.getProviderName(),\n        model: parsed.model || this.model,\n        usage: parsed.usage\n          ? {\n              prompt_tokens: parsed.usage.prompt_tokens || 0,\n              completion_tokens: parsed.usage.completion_tokens || 0,\n              total_tokens: parsed.usage.total_tokens || 0,\n            }\n          : null,\n      };\n    } catch (error) {\n      if (error.provider === this.getProviderName()) {\n        throw error; // Already wrapped\n      }\n      throw this.wrapError('chatCompletion', error);\n    }\n  }\n}\n\nmodule.exports = { OpenAIAdapter };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\circuitBreaker.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\contracts.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 113,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 113,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 113,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 113,
        "endColumn": 39
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 113,
        "column": 54,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 113,
        "endColumn": 57
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 118,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 118,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 118,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 118,
        "endColumn": 38
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 142,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 142,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 143,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 143,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 144,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 144,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 144,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 144,
        "endColumn": 39
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 145,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 145,
        "endColumn": 50
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'parseRetryAfter' has too many statements (23). Maximum allowed is 20.",
        "line": 193,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 240,
        "endColumn": 2
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Function 'parseRetryAfter' has a complexity of 24. Maximum allowed is 15.",
        "line": 193,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 193,
        "endColumn": 25
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * LLM Provider Contracts\n *\n * Unified interface definitions for all LLM providers (Gemini, OpenAI, Groq, etc.)\n * These contracts ensure provider adapters are interchangeable.\n *\n * @module providers/llm/contracts\n */\n\n/**\n * Standard chat message format (OpenAI-compatible)\n * @typedef {Object} ChatMessage\n * @property {'system'|'user'|'assistant'} role\n * @property {string|Array<{type: string, text?: string, image_url?: Object}>} content\n */\n\n/**\n * Options for chat completion requests\n * @typedef {Object} ChatCompletionOptions\n * @property {number} [temperature=0.7] - Sampling temperature (0-2)\n * @property {number} [maxTokens=1024] - Maximum tokens to generate\n * @property {Object} [responseFormat] - Response format (e.g., { type: 'json_object' })\n * @property {number} [timeoutMs] - Per-provider attempt timeout (ms)\n * @property {number} [overallTimeoutMs] - Overall provider chain timeout (ms)\n * @property {number} [queueTimeoutMs] - Max time to wait in rate limiter queue (ms)\n * @property {AbortSignal} [signal] - Abort signal for cancellation\n * @property {string} [operation] - Operation name for logging\n */\n\n/**\n * Standardized chat completion result\n * @typedef {Object} ChatCompletionResult\n * @property {string} content - Generated text content\n * @property {string} provider - Provider name (e.g., 'gemini', 'openai')\n * @property {string} model - Model used\n * @property {Object} [usage] - Token usage statistics\n * @property {number} [usage.prompt_tokens] - Input tokens\n * @property {number} [usage.completion_tokens] - Output tokens\n * @property {number} [usage.total_tokens] - Total tokens\n */\n\n/**\n * Provider health status\n * @typedef {Object} ProviderHealth\n * @property {boolean} available - Whether provider is configured and reachable\n * @property {string} provider - Provider name\n * @property {string} [error] - Error message if unhealthy\n */\n\n/**\n * Error types that indicate fallback should be attempted\n */\nconst FALLBACK_ERROR_PATTERNS = [\n  'rate limit',\n  'rate_limit',\n  'ratelimit',\n  'quota',\n  '429',\n  'too many requests',\n  'resource exhausted',\n  'resource_exhausted',\n  'capacity',\n  'overloaded',\n  'timeout',\n  'timed out',\n  'econnreset',\n  'econnrefused',\n  'socket hang up',\n  'network error',\n  'service unavailable',\n  '503',\n  '502',\n  '500',\n];\n\n/**\n * Error types that should NOT trigger fallback (bad request, etc.)\n */\nconst NO_FALLBACK_ERROR_PATTERNS = [\n  'invalid api key',\n  'invalid_api_key',\n  'authentication failed',\n  'content policy',\n  'safety',\n  'blocked',\n  'invalid request',\n  // Note: Removed '400', '401', '403' from patterns - check status codes directly\n];\n\nconst { AppError } = require('../../errors');\n\nfunction getErrorStatus(error) {\n  return (\n    error?.status ??\n    error?.statusCode ??\n    error?.response?.status ??\n    error?.originalError?.status ??\n    error?.originalError?.statusCode ??\n    null\n  );\n}\n\n/**\n * Determine if an error should trigger fallback to next provider\n * @param {Error} error - The error to evaluate\n * @returns {boolean} - True if fallback should be attempted\n */\nfunction shouldFallback(error) {\n  const message = (error?.message || String(error)).toLowerCase();\n  const status = getErrorStatus(error);\n\n  // First check HTTP status codes - these are definitive\n  if (status === 400 || status === 401 || status === 403) {\n    // Bad request, auth errors - don't fallback\n    return false;\n  }\n\n  if (status === 429 || status >= 500) {\n    // Rate limit or server error - always fallback\n    return true;\n  }\n\n  // Check if it's explicitly a non-fallback error pattern\n  for (const pattern of NO_FALLBACK_ERROR_PATTERNS) {\n    if (message.includes(pattern)) {\n      return false;\n    }\n  }\n\n  // Check if it matches fallback patterns\n  for (const pattern of FALLBACK_ERROR_PATTERNS) {\n    if (message.includes(pattern)) {\n      return true;\n    }\n  }\n\n  // Default: don't fallback for unknown errors (might be invalid request)\n  return false;\n}\n\nfunction resolveErrorCode(status) {\n  if (status === 429) return 'RATE_LIMIT';\n  if (status === 400) return 'INVALID_INPUT';\n  if (status === 401 || status === 403) return 'AUTH_REQUIRED';\n  if (typeof status === 'number' && status >= 500) return 'BAD_GATEWAY';\n  return 'INTERNAL_ERROR';\n}\n\n/**\n * Create a standardized provider error\n * @param {string} provider - Provider name\n * @param {string} operation - Operation that failed\n * @param {Error} originalError - Original error\n * @returns {Error} - Standardized error with metadata\n */\nfunction createProviderError(provider, operation, originalError) {\n  const status = getErrorStatus(originalError);\n  const message = `[${provider}] ${operation} failed: ${originalError?.message || 'Unknown error'}`;\n  const baseDetails = { provider, operation };\n  const code = originalError instanceof AppError ? originalError.code : resolveErrorCode(status);\n  const statusCode =\n    originalError instanceof AppError\n      ? (originalError.statusCode ?? status)\n      : typeof status === 'number'\n        ? status\n        : null;\n  const details =\n    originalError instanceof AppError ? { ...baseDetails, ...originalError.details } : baseDetails;\n\n  const error = new AppError(message, code, statusCode, details);\n  error.provider = provider;\n  error.operation = operation;\n  error.originalError = originalError;\n  error.status = status ?? error.statusCode;\n  error.shouldFallback = shouldFallback(originalError);\n  if (originalError?.headers) {\n    error.headers = originalError.headers;\n  }\n  if (originalError?.response) {\n    error.response = originalError.response;\n  }\n  return error;\n}\n\n/**\n * Parse Retry-After from error response\n * Supports HTTP header formats: seconds (integer) or HTTP-date\n * Also parses common error message patterns\n *\n * @param {Error} error - Error with headers or message\n * @returns {number|null} - Seconds to wait, or null if not found\n */\nfunction parseRetryAfter(error) {\n  if (Number.isFinite(error?.retryAfter) && error.retryAfter > 0) {\n    return Math.floor(error.retryAfter);\n  }\n  if (Number.isFinite(error?.retryAfterSeconds) && error.retryAfterSeconds > 0) {\n    return Math.floor(error.retryAfterSeconds);\n  }\n  // Check Retry-After header (HTTP standard)\n  const header =\n    error.headers?.get?.('Retry-After') ||\n    error.headers?.['retry-after'] ||\n    error.response?.headers?.['retry-after'];\n\n  if (header) {\n    const seconds = parseInt(header, 10);\n    if (!isNaN(seconds) && seconds > 0) return seconds;\n\n    // Handle HTTP-date format (RFC 7231)\n    const date = Date.parse(header);\n    if (!isNaN(date)) {\n      const waitSeconds = Math.ceil((date - Date.now()) / 1000);\n      return waitSeconds > 0 ? waitSeconds : null;\n    }\n  }\n\n  // Check error message for common patterns\n  const message = error?.message || '';\n\n  // Pattern: \"retry after 30 seconds\" or \"retry in 30s\"\n  const retryMatch = message.match(/retry\\s+(?:after\\s+|in\\s+)?(\\d+)\\s*s(?:econds?)?/i);\n  if (retryMatch) {\n    return parseInt(retryMatch[1], 10);\n  }\n\n  // Pattern: \"wait 30 seconds\" or \"wait 30s\"\n  const waitMatch = message.match(/wait\\s+(\\d+)\\s*s(?:econds?)?/i);\n  if (waitMatch) {\n    return parseInt(waitMatch[1], 10);\n  }\n\n  // Gemini pattern: \"Retry after X\"\n  const geminiMatch = message.match(/Retry after (\\d+)/i);\n  if (geminiMatch) {\n    return parseInt(geminiMatch[1], 10);\n  }\n\n  return null;\n}\n\nmodule.exports = {\n  FALLBACK_ERROR_PATTERNS,\n  NO_FALLBACK_ERROR_PATTERNS,\n  shouldFallback,\n  createProviderError,\n  parseRetryAfter,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\factory.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\index.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\providerChain.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 503.",
        "line": 39,
        "column": 5,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 39,
        "endColumn": 8
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 30000.",
        "line": 72,
        "column": 53,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 72,
        "endColumn": 58
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 503.",
        "line": 81,
        "column": 9,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 81,
        "endColumn": 12
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async method 'chatCompletion' has too many lines (129). Maximum allowed is 50.",
        "line": 122,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "exceed",
        "endLine": 270,
        "endColumn": 4
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async method 'chatCompletion' has a complexity of 25. Maximum allowed is 15.",
        "line": 122,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "complex",
        "endLine": 122,
        "endColumn": 23
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async method 'chatCompletion' has too many statements (45). Maximum allowed is 20.",
        "line": 122,
        "column": 23,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 270,
        "endColumn": 4
      },
      {
        "ruleId": "max-depth",
        "severity": 1,
        "message": "Blocks are nested too deeply (5). Maximum allowed is 4.",
        "line": 218,
        "column": 13,
        "nodeType": "IfStatement",
        "messageId": "tooDeeply",
        "endLine": 225,
        "endColumn": 14
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 503.",
        "line": 258,
        "column": 15,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 258,
        "endColumn": 18
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 503.",
        "line": 269,
        "column": 77,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 269,
        "endColumn": 80
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async method '_executeWithRetry' has too many lines (104). Maximum allowed is 50.",
        "line": 276,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "exceed",
        "endLine": 405,
        "endColumn": 4
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Async method '_executeWithRetry' has too many parameters (5). Maximum allowed is 4.",
        "line": 276,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 276,
        "endColumn": 26
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async method '_executeWithRetry' has a complexity of 26. Maximum allowed is 15.",
        "line": 276,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "complex",
        "endLine": 276,
        "endColumn": 26
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async method '_executeWithRetry' has too many statements (43). Maximum allowed is 20.",
        "line": 276,
        "column": 26,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 405,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.5.",
        "line": 392,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 392,
        "endColumn": 39
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.5.",
        "line": 392,
        "column": 58,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 392,
        "endColumn": 61
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (313). Maximum allowed is 300.",
        "line": 401,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 422,
        "endColumn": 1
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Provider Chain\n *\n * Priority-based LLM provider chain with automatic fallback.\n * Tries providers in order until one succeeds or all fail.\n *\n * @module providers/llm/providerChain\n */\n\nconst { shouldFallback, parseRetryAfter } = require('./contracts');\nconst { AppError } = require('../../errors');\nconst { logger } = require('../../observability');\nconst { CircuitBreaker } = require('./circuitBreaker');\nconst { getRateLimiterManager } = require('./rateLimiter');\nconst {\n  createDeadlineExceededError,\n  createRequestBudget,\n  isAbortError,\n  isDeadlineExceededError,\n} = require('./requestBudget');\nconst {\n  MIN_REMAINING_MS,\n  attachChainContext,\n  buildDeadlineError,\n  categorizeError,\n  getErrorStatus,\n  resolveAttemptTimeoutMs,\n  resolveQueueTimeoutMs,\n} = require('./providerChainUtils');\n\nconst defaultSleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst immediateSleep = () => Promise.resolve();\n\nfunction createCircuitOpenError(providerName, decision) {\n  const error = new AppError(\n    `LLM provider ${providerName} temporarily unavailable (circuit open)`,\n    'SERVICE_UNAVAILABLE',\n    503,\n    {\n      provider: providerName,\n      retryAfterMs: decision.retryAfterMs,\n      circuitState: decision.state,\n    },\n  );\n  error.name = 'CircuitOpenError';\n  error.shouldFallback = true;\n  return error;\n}\n\n/**\n * Provider chain for LLM requests with fallback support\n */\nclass ProviderChain {\n  /**\n   * @param {import('./adapters/baseAdapter').BaseAdapter[]} adapters - Ordered list of adapters (first = highest priority)\n   * @param {Object} [options]\n   * @param {number} [options.maxRetries=2] - Max retries per provider before fallback\n   * @param {number} [options.retryDelayMs=1000] - Base delay between retries\n   * @param {Function} [options.sleep] - Custom sleep function for testing (default: real setTimeout)\n   * @param {import('./rateLimiter').RateLimiterManager} [options.rateLimiter] - Injected rate limiter (default: singleton)\n   */\n  constructor(adapters, options = {}) {\n    this.adapters = adapters.filter((a) => a.isAvailable());\n    this.maxRetries = options.maxRetries ?? 2;\n    this.retryDelayMs = options.retryDelayMs ?? 1000;\n    this._sleep = options.sleep ?? defaultSleep;\n    // Support dependency injection for testing isolation\n    this._rateLimiter = options.rateLimiter ?? null;\n    this.overallTimeoutMs = options.overallTimeoutMs;\n    this.attemptTimeoutMs = options.attemptTimeoutMs;\n    this.queueTimeoutMs = options.queueTimeoutMs ?? 30000;\n    this.minRemainingMs = options.minRemainingMs ?? MIN_REMAINING_MS;\n    this._circuitBreaker =\n      options.circuitBreaker ?? new CircuitBreaker(options.circuitBreakerOptions);\n\n    if (this.adapters.length === 0) {\n      throw new AppError(\n        'No LLM providers available. Check API key configuration.',\n        'SERVICE_UNAVAILABLE',\n        503,\n      );\n    }\n\n    logger.info('ProviderChain initialized', {\n      providers: this.adapters.map((a) => a.getProviderName()),\n      primaryProvider: this.adapters[0]?.getProviderName(),\n    });\n  }\n\n  /**\n   * Get the rate limiter (injected or global singleton)\n   * @private\n   * @returns {import('./rateLimiter').RateLimiterManager}\n   */\n  _getRateLimiter() {\n    return this._rateLimiter ?? getRateLimiterManager();\n  }\n\n  /**\n   * Get list of available providers\n   * @returns {string[]}\n   */\n  getAvailableProviders() {\n    return this.adapters.map((a) => a.getProviderName());\n  }\n\n  /**\n   * Get primary (first) provider name\n   * @returns {string}\n   */\n  getPrimaryProvider() {\n    return this.adapters[0]?.getProviderName() || 'none';\n  }\n\n  /**\n   * Execute chat completion with automatic fallback\n   * @param {import('./contracts').ChatMessage[]} messages\n   * @param {import('./contracts').ChatCompletionOptions} [options]\n   * @returns {Promise<import('./contracts').ChatCompletionResult>}\n   */\n  async chatCompletion(messages, options = {}) {\n    const errors = [];\n    const startTime = Date.now();\n    const budget = createRequestBudget({\n      timeoutMs: options.overallTimeoutMs ?? this.overallTimeoutMs,\n      signal: options.signal,\n    });\n\n    try {\n      for (let i = 0; i < this.adapters.length; i++) {\n        const adapter = this.adapters[i];\n        const providerName = adapter.getProviderName();\n        const isLastProvider = i === this.adapters.length - 1;\n        const remainingProviders = this.adapters.length - i;\n        const remainingMs = budget.remainingMs();\n\n        if (budget.isExpired() || remainingMs <= this.minRemainingMs) {\n          throw buildDeadlineError(budget, errors, startTime);\n        }\n\n        const circuitDecision = this._circuitBreaker.canRequest(providerName);\n        if (!circuitDecision.allowed) {\n          const circuitError = createCircuitOpenError(providerName, circuitDecision);\n          errors.push({\n            provider: providerName,\n            error: circuitError.message,\n            shouldFallback: true,\n            abortLike: false,\n            circuitOpen: true,\n          });\n\n          logger.warn('LLM provider skipped due to open circuit', {\n            provider: providerName,\n            providerIndex: i + 1,\n            totalProviders: this.adapters.length,\n            retryAfterMs: circuitDecision.retryAfterMs,\n            remainingBudgetMs: remainingMs,\n          });\n\n          if (isLastProvider) {\n            throw attachChainContext(circuitError, errors, startTime);\n          }\n          continue;\n        }\n\n        try {\n          const result = await this._executeWithRetry(\n            adapter,\n            messages,\n            options,\n            budget,\n            remainingProviders,\n          );\n\n          this._circuitBreaker.recordSuccess(providerName);\n\n          // Log success with comprehensive details\n          logger.info(`LLM request succeeded [${providerName}/${result.model}]`, {\n            provider: providerName,\n            model: result.model,\n            operation: options.operation || 'chatCompletion',\n            latencyMs: Date.now() - startTime,\n            providerIndex: i + 1,\n            totalProviders: this.adapters.length,\n            fallbackUsed: i > 0,\n            attemptedProviders: errors.map((e) => e.provider),\n            usage: result.usage,\n          });\n\n          return {\n            ...result,\n            fallbackUsed: i > 0,\n            attemptedProviders: errors.map((e) => e.provider),\n          };\n        } catch (error) {\n          const abortLike =\n            isAbortError(error) || isDeadlineExceededError(error) || budget.isExpired();\n          const errorCategory = categorizeError(error);\n          const errorStatus = getErrorStatus(error);\n          const fallbackEligible = abortLike\n            ? false\n            : (error.shouldFallback ?? shouldFallback(error));\n          const shouldRecordFailure =\n            !abortLike &&\n            (fallbackEligible ||\n              ['rate_limit', 'server_error', 'network_error', 'timeout'].includes(errorCategory));\n\n          errors.push({\n            provider: providerName,\n            error: error.message,\n            shouldFallback: fallbackEligible,\n            abortLike,\n          });\n\n          if (shouldRecordFailure) {\n            const breakerState = this._circuitBreaker.recordFailure(providerName);\n            if (breakerState.opened) {\n              logger.warn('LLM provider circuit opened', {\n                provider: providerName,\n                failures: breakerState.failures,\n                failureThreshold: this._circuitBreaker.failureThreshold,\n                openDurationMs: this._circuitBreaker.openDurationMs,\n              });\n            }\n          }\n\n          logger.warn('LLM provider failed, attempting fallback', {\n            provider: providerName,\n            model: adapter.model,\n            providerIndex: i + 1,\n            totalProviders: this.adapters.length,\n            nextProvider: !isLastProvider ? this.adapters[i + 1]?.getProviderName() : null,\n            error: error.message,\n            errorCode: errorStatus || 'UNKNOWN',\n            errorCategory,\n            shouldFallback: fallbackEligible,\n            isLastProvider,\n            operation: options.operation || 'chatCompletion',\n            latencyMs: Date.now() - startTime,\n            remainingBudgetMs: remainingMs,\n          });\n\n          if (abortLike) {\n            throw attachChainContext(error, errors, startTime);\n          }\n\n          // Only fallback if error is fallback-eligible\n          if (!fallbackEligible) {\n            throw attachChainContext(error, errors, startTime);\n          }\n\n          // If this is the last provider, throw aggregated error\n          if (isLastProvider) {\n            const aggregatedError = new AppError(\n              `All LLM providers failed: ${errors.map((e) => `${e.provider}: ${e.error}`).join('; ')}`,\n              'SERVICE_UNAVAILABLE',\n              503,\n            );\n            throw attachChainContext(aggregatedError, errors, startTime);\n          }\n        }\n      }\n    } finally {\n      budget.dispose();\n    }\n\n    // Should never reach here, but just in case\n    throw new AppError('No LLM providers available', 'SERVICE_UNAVAILABLE', 503);\n  }\n\n  /**\n   * Execute with retry logic for a single provider\n   * @private\n   */\n  async _executeWithRetry(adapter, messages, options, budget, remainingProviders) {\n    let lastError;\n    const providerName = adapter.getProviderName();\n    const model = adapter.model;\n    const rateLimiter = this._getRateLimiter();\n\n    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\n      if (budget.isExpired()) {\n        throw createDeadlineExceededError(budget.timeoutMs, budget.signal?.reason);\n      }\n\n      const remainingMs = budget.remainingMs();\n      if (Number.isFinite(remainingMs) && remainingMs <= this.minRemainingMs) {\n        throw createDeadlineExceededError(budget.timeoutMs, budget.signal?.reason);\n      }\n\n      const attemptTimeoutMs = resolveAttemptTimeoutMs({\n        remainingMs,\n        remainingProviders,\n        optionsTimeoutMs: options.timeoutMs,\n        attemptTimeoutMs: this.attemptTimeoutMs,\n        minRemainingMs: this.minRemainingMs,\n      });\n      const queueTimeoutMs = resolveQueueTimeoutMs({\n        remainingMs,\n        remainingProviders,\n        optionsQueueTimeoutMs: options.queueTimeoutMs,\n        queueTimeoutMs: this.queueTimeoutMs,\n        minRemainingMs: this.minRemainingMs,\n      });\n\n      try {\n        // Log attempt start for diagnostics\n        logger.info(\n          `LLM attempt [${providerName}/${model}] attempt=${attempt}/${this.maxRetries}`,\n          {\n            provider: providerName,\n            model,\n            attempt,\n            maxRetries: this.maxRetries,\n            operation: options.operation || 'chatCompletion',\n            attemptTimeoutMs,\n            queueTimeoutMs,\n          },\n        );\n\n        // Execute through rate limiter\n        const requestOptions = { ...options, signal: budget.signal };\n        if (Number.isFinite(attemptTimeoutMs)) {\n          requestOptions.timeoutMs = attemptTimeoutMs;\n        }\n\n        const scheduleOptions = Number.isFinite(queueTimeoutMs)\n          ? { timeout: queueTimeoutMs }\n          : undefined;\n\n        const result = await rateLimiter.schedule(\n          providerName,\n          async () => adapter.chatCompletion(messages, requestOptions),\n          scheduleOptions,\n        );\n\n        // Record usage for tracking\n        if (result.usage) {\n          rateLimiter.recordUsage(providerName, result.model, result.usage);\n        }\n\n        return result;\n      } catch (error) {\n        lastError = error;\n\n        if (isAbortError(error) || isDeadlineExceededError(error)) {\n          error.shouldFallback = false;\n          throw error;\n        }\n\n        const willRetry = shouldFallback(error) && attempt < this.maxRetries;\n        const errorStatus = getErrorStatus(error);\n\n        // Log detailed failure info with provider/model/attempt\n        logger.warn(\n          `LLM attempt FAILED [${providerName}/${model}] attempt=${attempt}/${this.maxRetries} status=${errorStatus || 'UNKNOWN'}`,\n          {\n            provider: providerName,\n            model,\n            attempt,\n            maxRetries: this.maxRetries,\n            errorMessage: error.message,\n            errorStatus: errorStatus || 'UNKNOWN',\n            willRetry,\n            operation: options.operation || 'chatCompletion',\n            remainingBudgetMs: budget.remainingMs(),\n          },\n        );\n\n        // Don't retry on non-retryable errors\n        if (!shouldFallback(error)) {\n          throw error;\n        }\n\n        // Don't retry on last attempt\n        if (attempt === this.maxRetries) {\n          break;\n        }\n\n        // Check for Retry-After and pause provider if needed\n        const retryAfter = parseRetryAfter(error);\n        if (retryAfter && retryAfter > 0) {\n          // Pause this provider's rate limiter\n          await rateLimiter.pauseProvider(providerName, retryAfter * 1000);\n        }\n\n        // Exponential backoff with jitter (respect Retry-After if present)\n        const baseDelay = retryAfter\n          ? retryAfter * 1000\n          : this.retryDelayMs * Math.pow(2, attempt - 1);\n        const delay = baseDelay * (0.5 + Math.random() * 0.5);\n        const remainingMsAfterDelay = budget.remainingMs() - delay;\n        if (\n          Number.isFinite(remainingMsAfterDelay) &&\n          remainingMsAfterDelay <= this.minRemainingMs\n        ) {\n          throw createDeadlineExceededError(budget.timeoutMs, budget.signal?.reason);\n        }\n        await this._sleep(delay);\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Health check all providers\n   * @returns {Promise<import('./contracts').ProviderHealth[]>}\n   */\n  async healthCheck() {\n    return Promise.all(this.adapters.map((adapter) => adapter.healthCheck()));\n  }\n}\n\nmodule.exports = {\n  ProviderChain,\n  // Export sleep functions for testing\n  defaultSleep,\n  immediateSleep,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\providerChainUtils.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 20,
        "column": 48,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 20,
        "endColumn": 51
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 21,
        "column": 48,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 21,
        "endColumn": 51
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 21,
        "column": 53,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 21,
        "endColumn": 56
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 22,
        "column": 49,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 22,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 77,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 50
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const {\n  createDeadlineExceededError,\n  MIN_REMAINING_MS,\n  resolveTimeoutMs,\n} = require('./requestBudget');\n\nfunction getErrorStatus(error) {\n  if (!error) return null;\n  return (\n    error.status ??\n    error.statusCode ??\n    error.response?.status ??\n    error.originalError?.status ??\n    error.originalError?.statusCode ??\n    null\n  );\n}\n\nconst STATUS_CATEGORY_RULES = [\n  { category: 'rate_limit', statuses: new Set([429]) },\n  { category: 'auth_error', statuses: new Set([401, 403]) },\n  { category: 'bad_request', statuses: new Set([400]) },\n];\n\nconst MESSAGE_CATEGORY_RULES = [\n  { category: 'rate_limit', patterns: ['rate limit', 'quota'] },\n  { category: 'auth_error', patterns: ['auth', 'invalid api key'] },\n  { category: 'server_error', patterns: ['server error', 'internal'] },\n  { category: 'timeout', patterns: ['timeout', 'timed out'] },\n  { category: 'network_error', patterns: ['network', 'econnreset', 'socket'] },\n  { category: 'bad_request', patterns: ['bad request', 'invalid'] },\n];\n\nfunction normalizeErrorMessage(error) {\n  return (error?.message || '').toLowerCase();\n}\n\nfunction attachChainContext(error, errors, startTime) {\n  if (!error || typeof error !== 'object') return error;\n  error.errors = errors;\n  error.latencyMs = Date.now() - startTime;\n  error.attemptedProviders = errors.map((e) => e.provider);\n  return error;\n}\n\nfunction matchStatusCategory(status) {\n  if (typeof status !== 'number') return null;\n  for (const rule of STATUS_CATEGORY_RULES) {\n    if (rule.statuses.has(status)) {\n      return rule.category;\n    }\n  }\n  return null;\n}\n\nfunction matchMessageCategory(message, errorName) {\n  if (errorName === 'AbortError') {\n    return 'timeout';\n  }\n  for (const rule of MESSAGE_CATEGORY_RULES) {\n    if (rule.patterns.some((pattern) => message.includes(pattern))) {\n      return rule.category;\n    }\n  }\n  return null;\n}\n\nfunction categorizeError(error) {\n  const status = getErrorStatus(error);\n  const message = normalizeErrorMessage(error);\n\n  const statusCategory = matchStatusCategory(status);\n  if (statusCategory) {\n    return statusCategory;\n  }\n\n  if (typeof status === 'number' && status >= 500) {\n    return 'server_error';\n  }\n\n  const messageCategory = matchMessageCategory(message, error?.name);\n  return messageCategory || 'unknown';\n}\n\nfunction resolveProviderBudgetMs(\n  remainingMs,\n  remainingProviders,\n  minRemainingMs = MIN_REMAINING_MS,\n) {\n  if (!Number.isFinite(remainingMs)) return null;\n  if (remainingProviders <= 1) return remainingMs;\n  return Math.max(minRemainingMs, Math.floor(remainingMs / remainingProviders));\n}\n\nfunction resolveAttemptTimeoutMs({\n  remainingMs,\n  remainingProviders,\n  optionsTimeoutMs,\n  attemptTimeoutMs,\n  minRemainingMs = MIN_REMAINING_MS,\n}) {\n  const providerBudgetMs = resolveProviderBudgetMs(remainingMs, remainingProviders, minRemainingMs);\n  const baseTimeoutMs = resolveTimeoutMs(optionsTimeoutMs, attemptTimeoutMs);\n  if (!Number.isFinite(remainingMs)) return baseTimeoutMs;\n  const candidate = Number.isFinite(baseTimeoutMs)\n    ? baseTimeoutMs\n    : (providerBudgetMs ?? remainingMs);\n  const ceiling = providerBudgetMs ?? remainingMs;\n  return Math.min(candidate, ceiling, remainingMs);\n}\n\nfunction resolveQueueTimeoutMs({\n  remainingMs,\n  remainingProviders,\n  optionsQueueTimeoutMs,\n  queueTimeoutMs,\n  minRemainingMs = MIN_REMAINING_MS,\n}) {\n  const providerBudgetMs = resolveProviderBudgetMs(remainingMs, remainingProviders, minRemainingMs);\n  const baseQueueTimeoutMs = resolveTimeoutMs(optionsQueueTimeoutMs, queueTimeoutMs);\n  if (!Number.isFinite(remainingMs)) return baseQueueTimeoutMs;\n  const candidate = Number.isFinite(baseQueueTimeoutMs)\n    ? baseQueueTimeoutMs\n    : (providerBudgetMs ?? remainingMs);\n  const ceiling = providerBudgetMs ?? remainingMs;\n  return Math.min(candidate, ceiling, remainingMs);\n}\n\nfunction buildDeadlineError(budget, errors, startTime) {\n  const error = createDeadlineExceededError(budget?.timeoutMs, budget?.signal?.reason);\n  return attachChainContext(error, errors, startTime);\n}\n\nmodule.exports = {\n  MIN_REMAINING_MS,\n  attachChainContext,\n  buildDeadlineError,\n  categorizeError,\n  getErrorStatus,\n  resolveAttemptTimeoutMs,\n  resolveQueueTimeoutMs,\n  resolveProviderBudgetMs,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\rateLimiter.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1000000.",
        "line": 173,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 173,
        "endColumn": 51
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1000000.",
        "line": 173,
        "column": 55,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 173,
        "endColumn": 62
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1000000.",
        "line": 176,
        "column": 53,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 176,
        "endColumn": 60
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1000000.",
        "line": 176,
        "column": 64,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 176,
        "endColumn": 71
      },
      {
        "ruleId": "eqeqeq",
        "severity": 1,
        "message": "Expected '!==' and instead saw '!='.",
        "line": 225,
        "column": 49,
        "nodeType": "BinaryExpression",
        "messageId": "unexpected",
        "endLine": 225,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "replaceOperator",
            "data": { "expectedOperator": "!==", "actualOperator": "!=" },
            "fix": { "range": [6767, 6769], "text": "!==" },
            "desc": "Use '!==' instead of '!='."
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 254,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 254,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 287,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 287,
        "endColumn": 27
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 287,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 287,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60000.",
        "line": 292,
        "column": 54,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 292,
        "endColumn": 59
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async method 'schedule' has too many statements (23). Maximum allowed is 20.",
        "line": 316,
        "column": 17,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 373,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 325,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 325,
        "endColumn": 43
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 30000.",
        "line": 326,
        "column": 40,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 326,
        "endColumn": 45
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 336,
        "column": 11,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 336,
        "endColumn": 12
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 356,
        "column": 11,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 356,
        "endColumn": 12
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 365,
        "column": 11,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 365,
        "endColumn": 13
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (370). Maximum allowed is 300.",
        "line": 476,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 594,
        "endColumn": 1
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 574,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 574,
        "endColumn": 45
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'setImmediate' is not defined.",
        "line": 577,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 577,
        "endColumn": 48,
        "suppressions": [
          { "kind": "directive", "justification": "setImmediate is a Node.js global" }
        ]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 17,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Rate Limiter Module\n *\n * Token-bucket rate limiting for LLM providers using bottleneck.\n * Provides per-provider rate limits, queue smoothing, and usage tracking.\n *\n * Features:\n * - Per-provider rate limits with reservoir auto-refill\n * - Concurrency limits to prevent overwhelming APIs\n * - Queue overflow protection (rejects when queue is full)\n * - Usage tracking (requests, tokens, cost estimates)\n * - Retry-After header integration\n *\n * @module providers/llm/rateLimiter\n */\n\nconst Bottleneck = require('bottleneck');\nconst { RateLimitError } = require('../../errors');\nconst { logger } = require('../../observability');\n\n/**\n * Per-provider rate limit configurations\n * Conservative limits for reliability\n */\nconst DEFAULT_LIMITS = {\n  gemini: {\n    reservoir: 200, // Requests per minute (paid tier, conservative)\n    reservoirRefreshAmount: 200,\n    reservoirRefreshInterval: 60000, // 60 seconds\n    maxConcurrent: 10, // Max concurrent requests\n    minTime: 50, // Minimum 50ms between requests\n    highWater: 30, // Max queued jobs before rejecting\n    strategy: Bottleneck.strategy.OVERFLOW,\n  },\n  groq: {\n    reservoir: 30, // Free tier: 30 RPM\n    reservoirRefreshAmount: 30,\n    reservoirRefreshInterval: 60000,\n    maxConcurrent: 3,\n    minTime: 200,\n    highWater: 10,\n    strategy: Bottleneck.strategy.OVERFLOW,\n  },\n  openai: {\n    reservoir: 50, // Conservative (last resort fallback)\n    reservoirRefreshAmount: 50,\n    reservoirRefreshInterval: 60000,\n    maxConcurrent: 5,\n    minTime: 150,\n    highWater: 15,\n    strategy: Bottleneck.strategy.OVERFLOW,\n  },\n};\n\n/**\n * Test-friendly rate limit configurations\n * No delays, high concurrency, NO timers for fast unit tests\n *\n * CRITICAL: reservoirRefreshInterval MUST be null to prevent\n * Bottleneck from creating internal timers that keep the event loop alive.\n */\nconst TEST_LIMITS = {\n  gemini: {\n    reservoir: 1000,\n    reservoirRefreshAmount: null, // No auto-refresh in tests\n    reservoirRefreshInterval: null, // CRITICAL: Prevents timer creation\n    maxConcurrent: 100,\n    minTime: 0, // No delay between requests\n    highWater: 100,\n    strategy: Bottleneck.strategy.OVERFLOW,\n  },\n  groq: {\n    reservoir: 1000,\n    reservoirRefreshAmount: null,\n    reservoirRefreshInterval: null, // CRITICAL: Prevents timer creation\n    maxConcurrent: 100,\n    minTime: 0,\n    highWater: 100,\n    strategy: Bottleneck.strategy.OVERFLOW,\n  },\n  openai: {\n    reservoir: 1000,\n    reservoirRefreshAmount: null,\n    reservoirRefreshInterval: null, // CRITICAL: Prevents timer creation\n    maxConcurrent: 100,\n    minTime: 0,\n    highWater: 100,\n    strategy: Bottleneck.strategy.OVERFLOW,\n  },\n};\n\n/**\n * Approximate per-token costs (USD) for cost estimation\n * Updated: 2026-01\n */\nconst TOKEN_COSTS = {\n  gemini: {\n    'gemini-2.0-flash': { input: 0.0000001, output: 0.0000004 },\n    'gemini-2.5-flash': { input: 0.00000015, output: 0.0000006 },\n    'gemini-2.5-pro': { input: 0.00000125, output: 0.000005 },\n    default: { input: 0.0000001, output: 0.0000004 },\n  },\n  groq: {\n    'llama-3.3-70b-versatile': { input: 0.00000059, output: 0.00000079 },\n    'llama-3.1-8b-instant': { input: 0.00000005, output: 0.00000008 },\n    default: { input: 0.00000059, output: 0.00000079 },\n  },\n  openai: {\n    'gpt-4o-mini': { input: 0.00000015, output: 0.0000006 },\n    'gpt-4o': { input: 0.0000025, output: 0.00001 },\n    default: { input: 0.00000015, output: 0.0000006 },\n  },\n};\n\n/**\n * Usage statistics tracker\n */\nclass UsageTracker {\n  constructor() {\n    this.stats = new Map(); // Map<provider:model, { requests, inputTokens, outputTokens, estimatedCost }>\n    this.startTime = Date.now();\n  }\n\n  /**\n   * Record usage for a request\n   * @param {string} provider - Provider name\n   * @param {string} model - Model name\n   * @param {Object} usage - Token usage from response\n   */\n  record(provider, model, usage) {\n    const key = `${provider}:${model}`;\n    const current = this.stats.get(key) || {\n      provider,\n      model,\n      requests: 0,\n      inputTokens: 0,\n      outputTokens: 0,\n      estimatedCost: 0,\n    };\n\n    current.requests++;\n\n    if (usage) {\n      const inputTokens = usage.prompt_tokens || 0;\n      const outputTokens = usage.completion_tokens || 0;\n\n      current.inputTokens += inputTokens;\n      current.outputTokens += outputTokens;\n\n      // Calculate cost estimate\n      const costs = TOKEN_COSTS[provider]?.[model] ||\n        TOKEN_COSTS[provider]?.default || { input: 0, output: 0 };\n      current.estimatedCost += inputTokens * costs.input + outputTokens * costs.output;\n    }\n\n    this.stats.set(key, current);\n  }\n\n  /**\n   * Get all usage statistics\n   * @returns {Object}\n   */\n  getStats() {\n    const models = Array.from(this.stats.values());\n    const totalRequests = models.reduce((sum, m) => sum + m.requests, 0);\n    const totalTokens = models.reduce((sum, m) => sum + m.inputTokens + m.outputTokens, 0);\n    const totalCost = models.reduce((sum, m) => sum + m.estimatedCost, 0);\n\n    return {\n      uptimeMs: Date.now() - this.startTime,\n      totalRequests,\n      totalTokens,\n      totalCostUsd: Math.round(totalCost * 1000000) / 1000000, // Round to 6 decimals\n      models: models.map((m) => ({\n        ...m,\n        estimatedCost: Math.round(m.estimatedCost * 1000000) / 1000000,\n      })),\n    };\n  }\n\n  /**\n   * Reset statistics\n   */\n  reset() {\n    this.stats.clear();\n    this.startTime = Date.now();\n  }\n}\n\n/**\n * Rate Limiter Manager\n *\n * Manages per-provider bottleneck instances and usage tracking.\n *\n * Lifecycle:\n * - Create instance with `new RateLimiterManager(limits)`\n * - Use via `schedule()`, `recordUsage()`, etc.\n * - Call `stop()` for graceful shutdown\n *\n * For testing:\n * - Use TEST_LIMITS which disable internal timers\n * - Always call `stop()` in afterEach hooks\n * - Use `forceCleanup()` for guaranteed resource release\n */\nclass RateLimiterManager {\n  /** @type {boolean} Whether the manager has been stopped */\n  #stopped = false;\n\n  constructor(customLimits = {}) {\n    this.limiters = new Map();\n    this.limits = { ...DEFAULT_LIMITS, ...customLimits };\n    this.usageTracker = new UsageTracker();\n    this._loggingInterval = null;\n    this._pauseTimers = new Map(); // Track pause timers for cleanup\n    this.#stopped = false;\n\n    // Initialize limiters for each provider\n    for (const [provider, config] of Object.entries(this.limits)) {\n      this.limiters.set(provider, this._createLimiter(provider, config));\n    }\n\n    // Only start logging interval if we have refresh intervals (production mode)\n    // TEST_LIMITS have null refreshInterval, so no timers are created for tests\n    const hasProductionLimits = Object.values(this.limits).some(\n      (limit) => limit.reservoirRefreshInterval != null,\n    );\n    if (hasProductionLimits) {\n      this._startUsageLogging();\n    }\n\n    logger.info('RateLimiterManager initialized', {\n      providers: Object.keys(this.limits),\n    });\n  }\n\n  /**\n   * Check if manager has been stopped\n   * @returns {boolean}\n   */\n  isStopped() {\n    return this.#stopped;\n  }\n\n  /**\n   * Create a bottleneck limiter with event handlers\n   * @private\n   */\n  _createLimiter(provider, config) {\n    const limiter = new Bottleneck(config);\n\n    // Log when requests are queued\n    limiter.on('queued', () => {\n      const counts = limiter.counts();\n      if (counts.QUEUED > 5) {\n        logger.warn(`Rate limiter queue growing for ${provider}`, {\n          provider,\n          queued: counts.QUEUED,\n          running: counts.RUNNING,\n        });\n      }\n    });\n\n    // Log when requests are dropped (queue overflow)\n    limiter.on('dropped', (dropped) => {\n      logger.error(`Rate limiter dropped request for ${provider}`, {\n        provider,\n        dropped: dropped?.options?.id || 'unknown',\n      });\n    });\n\n    // Handle errors to prevent unhandled events\n    limiter.on('error', (error) => {\n      logger.error(`Rate limiter error for ${provider}`, {\n        provider,\n        error: error.message,\n      });\n    });\n\n    return limiter;\n  }\n\n  /**\n   * Start periodic usage logging\n   * @private\n   */\n  _startUsageLogging() {\n    const FIVE_MINUTES = 5 * 60 * 1000;\n    this._loggingInterval = setInterval(() => {\n      const stats = this.usageTracker.getStats();\n      if (stats.totalRequests > 0) {\n        logger.info('LLM usage stats', {\n          uptimeMinutes: Math.round(stats.uptimeMs / 60000),\n          totalRequests: stats.totalRequests,\n          totalTokens: stats.totalTokens,\n          totalCostUsd: stats.totalCostUsd,\n          models: stats.models,\n        });\n      }\n    }, FIVE_MINUTES);\n\n    // Don't prevent process exit\n    if (this._loggingInterval.unref) {\n      this._loggingInterval.unref();\n    }\n  }\n\n  /**\n   * Schedule a request through the rate limiter\n   * @param {string} provider - Provider name\n   * @param {Function} fn - Async function to execute\n   * @param {Object} [options] - Options\n   * @param {number} [options.priority=5] - Job priority (0-9, lower = higher priority)\n   * @param {number} [options.timeout=30000] - Max time to wait in queue (ms)\n   * @returns {Promise<any>} - Result from fn\n   */\n  async schedule(provider, fn, options = {}) {\n    const limiter = this.limiters.get(provider);\n\n    if (!limiter) {\n      // No limiter for this provider - execute directly\n      logger.warn(`No rate limiter configured for ${provider}, executing directly`);\n      return fn();\n    }\n\n    const priority = options.priority ?? 5;\n    const timeout = options.timeout ?? 30000;\n\n    try {\n      // Check if queue is already at capacity\n      const counts = limiter.counts();\n      const config = this.limits[provider];\n\n      if (counts.QUEUED >= config.highWater) {\n        const error = new RateLimitError(\n          `Rate limit queue full for ${provider}. Try again in a few seconds.`,\n          5,\n        );\n        error.shouldFallback = true;\n        throw error;\n      }\n\n      // Schedule through bottleneck\n      return await limiter.schedule(\n        {\n          priority,\n          expiration: timeout,\n          id: `${provider}-${Date.now()}`,\n        },\n        fn,\n      );\n    } catch (error) {\n      // Handle bottleneck-specific errors\n      if (error.message?.includes('This job has been dropped')) {\n        const queueError = new RateLimitError(\n          `Rate limit queue full for ${provider}. Try again in a few seconds.`,\n          5,\n        );\n        queueError.shouldFallback = true;\n        throw queueError;\n      }\n\n      if (error.message?.includes('This job timed out')) {\n        const timeoutError = new RateLimitError(\n          `Request queued too long for ${provider}. Try again later.`,\n          10,\n        );\n        timeoutError.shouldFallback = true;\n        throw timeoutError;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Record usage after successful request\n   * @param {string} provider - Provider name\n   * @param {string} model - Model name\n   * @param {Object} usage - Token usage\n   */\n  recordUsage(provider, model, usage) {\n    this.usageTracker.record(provider, model, usage);\n  }\n\n  /**\n   * Get current queue statistics for all providers\n   * @returns {Object}\n   */\n  getQueueStats() {\n    const stats = {};\n    for (const [provider, limiter] of this.limiters) {\n      const counts = limiter.counts();\n      stats[provider] = {\n        running: counts.RUNNING,\n        queued: counts.QUEUED,\n        reservoir: counts.RESERVOIR ?? 'unlimited',\n      };\n    }\n    return stats;\n  }\n\n  /**\n   * Get usage statistics\n   * @returns {Object}\n   */\n  getUsageStats() {\n    return this.usageTracker.getStats();\n  }\n\n  /**\n   * Pause requests for a provider (e.g., when receiving Retry-After)\n   * @param {string} provider - Provider name\n   * @param {number} durationMs - Duration to pause (ms)\n   */\n  async pauseProvider(provider, durationMs) {\n    const limiter = this.limiters.get(provider);\n    if (!limiter) return;\n\n    logger.info(`Pausing ${provider} for ${durationMs}ms due to rate limit`, {\n      provider,\n      durationMs,\n    });\n\n    // Temporarily set reservoir to 0\n    await limiter.updateSettings({ reservoir: 0 });\n\n    // Clear any existing pause timer for this provider\n    if (this._pauseTimers.has(provider)) {\n      clearTimeout(this._pauseTimers.get(provider));\n    }\n\n    // Restore after duration (track timer for cleanup)\n    const timer = setTimeout(async () => {\n      const config = this.limits[provider];\n      await limiter.updateSettings({ reservoir: config.reservoir });\n      logger.info(`Resumed ${provider} after rate limit pause`, { provider });\n      this._pauseTimers.delete(provider);\n    }, durationMs);\n\n    // Unref so it doesn't prevent process exit\n    if (timer.unref) {\n      timer.unref();\n    }\n\n    this._pauseTimers.set(provider, timer);\n  }\n\n  /**\n   * Stop the rate limiter manager\n   * @returns {Promise<void>}\n   */\n  async stop() {\n    if (this._loggingInterval) {\n      clearInterval(this._loggingInterval);\n      this._loggingInterval = null;\n    }\n\n    // Clear all pause timers\n    for (const timer of this._pauseTimers.values()) {\n      clearTimeout(timer);\n    }\n    this._pauseTimers.clear();\n\n    // Stop all Bottleneck limiters and await their cleanup\n    // Bottleneck.stop() returns a Promise that resolves when all jobs are complete\n    const stopPromises = [];\n    for (const limiter of this.limiters.values()) {\n      stopPromises.push(limiter.stop({ dropWaitingJobs: true }));\n    }\n    await Promise.all(stopPromises);\n\n    // Disconnect to release any internal resources after stop completes\n    for (const limiter of this.limiters.values()) {\n      if (limiter.disconnect) {\n        limiter.disconnect();\n      }\n    }\n    this.limiters.clear();\n    this.#stopped = true;\n\n    logger.info('RateLimiterManager stopped');\n  }\n\n  /**\n   * Force cleanup all resources synchronously\n   * Use only in test teardown when async cleanup isn't sufficient\n   * @returns {void}\n   */\n  forceCleanup() {\n    // Clear interval\n    if (this._loggingInterval) {\n      clearInterval(this._loggingInterval);\n      this._loggingInterval = null;\n    }\n\n    // Clear all pause timers\n    for (const timer of this._pauseTimers.values()) {\n      clearTimeout(timer);\n    }\n    this._pauseTimers.clear();\n\n    // Force disconnect all limiters without waiting\n    for (const limiter of this.limiters.values()) {\n      try {\n        // Stop with dropWaitingJobs but don't await\n        limiter.stop({ dropWaitingJobs: true }).catch(() => {});\n        if (limiter.disconnect) {\n          limiter.disconnect();\n        }\n      } catch {\n        // Ignore errors during force cleanup\n      }\n    }\n    this.limiters.clear();\n    this.#stopped = true;\n  }\n}\n\n// Singleton instance\nlet instance = null;\n\n/**\n * Get or create the singleton RateLimiterManager\n * @param {Object} [customLimits] - Custom limit overrides (only used on first call)\n * @returns {RateLimiterManager}\n */\nfunction getRateLimiterManager(customLimits) {\n  if (!instance) {\n    instance = new RateLimiterManager(customLimits);\n  }\n  return instance;\n}\n\n/**\n * Get or create a test-friendly RateLimiterManager singleton\n * Uses TEST_LIMITS which have no delays for fast unit tests\n * @returns {RateLimiterManager}\n */\nfunction getTestRateLimiterManager() {\n  if (!instance) {\n    instance = new RateLimiterManager(TEST_LIMITS);\n  }\n  return instance;\n}\n\n/**\n * Reset the singleton (for testing)\n * @returns {Promise<void>}\n */\nasync function resetRateLimiterManager() {\n  if (instance) {\n    await instance.stop();\n    instance = null;\n  }\n}\n\n/**\n * Force reset the singleton synchronously (for test teardown)\n * Use when async reset isn't completing properly\n */\nfunction forceResetRateLimiterManager() {\n  if (instance) {\n    instance.forceCleanup();\n    instance = null;\n  }\n}\n\n/**\n * Drain the event loop to allow Bottleneck internal cleanup\n * Call this after tests to ensure all async work completes\n * @param {number} [iterations=5] - Number of event loop iterations\n * @returns {Promise<void>}\n */\nasync function drainEventLoop(iterations = 5) {\n  for (let i = 0; i < iterations; i++) {\n    // eslint-disable-next-line no-undef -- setImmediate is a Node.js global\n    await new Promise((resolve) => setImmediate(resolve));\n  }\n  // Additional microtask flush\n  await Promise.resolve();\n}\n\nmodule.exports = {\n  RateLimiterManager,\n  getRateLimiterManager,\n  getTestRateLimiterManager,\n  resetRateLimiterManager,\n  forceResetRateLimiterManager,\n  drainEventLoop,\n  DEFAULT_LIMITS,\n  TEST_LIMITS,\n  TOKEN_COSTS,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\requestBudget.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createRequestBudget' has too many lines (51). Maximum allowed is 50.",
        "line": 36,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 93,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const DEFAULT_CHAIN_TIMEOUT_MS = 60000;\nconst MIN_REMAINING_MS = 200;\nconst { DeadlineExceededError } = require('../../errors');\n\nfunction resolveTimeoutMs(value, fallback) {\n  const parsed = Number(value);\n  if (Number.isFinite(parsed) && parsed > 0) return parsed;\n  const fallbackParsed = Number(fallback);\n  if (Number.isFinite(fallbackParsed) && fallbackParsed > 0) return fallbackParsed;\n  return null;\n}\n\nfunction createDeadlineExceededError(timeoutMs, reason) {\n  const suffix = Number.isFinite(timeoutMs) ? ` after ${timeoutMs}ms` : '';\n  const error = new DeadlineExceededError(`LLM request deadline exceeded${suffix}`, {\n    timeoutMs: Number.isFinite(timeoutMs) ? timeoutMs : null,\n    reason: reason ?? null,\n  });\n  error.shouldFallback = false;\n  return error;\n}\n\nfunction isAbortError(error) {\n  return (\n    error?.name === 'AbortError' ||\n    error?.code === 'ABORTED' ||\n    error?.code === 'ABORT_ERR' ||\n    error?.code === 'ERR_ABORTED'\n  );\n}\n\nfunction isDeadlineExceededError(error) {\n  return error?.code === 'DEADLINE_EXCEEDED' || error?.name === 'DeadlineExceededError';\n}\n\nfunction createRequestBudget({\n  timeoutMs,\n  signal,\n  defaultTimeoutMs = DEFAULT_CHAIN_TIMEOUT_MS,\n} = {}) {\n  const resolvedTimeoutMs = resolveTimeoutMs(timeoutMs, defaultTimeoutMs);\n  const startTime = Date.now();\n  const controller = new AbortController();\n  let timeoutId;\n\n  const onAbort = () => {\n    if (!controller.signal.aborted) {\n      controller.abort(signal?.reason);\n    }\n  };\n\n  if (signal) {\n    if (signal.aborted) {\n      onAbort();\n    } else {\n      signal.addEventListener('abort', onAbort, { once: true });\n    }\n  }\n\n  if (Number.isFinite(resolvedTimeoutMs) && resolvedTimeoutMs > 0) {\n    timeoutId = setTimeout(() => {\n      controller.abort(createDeadlineExceededError(resolvedTimeoutMs));\n    }, resolvedTimeoutMs);\n    if (timeoutId.unref) {\n      timeoutId.unref();\n    }\n  }\n\n  const remainingMs = () => {\n    if (!Number.isFinite(resolvedTimeoutMs)) return Number.POSITIVE_INFINITY;\n    return Math.max(0, resolvedTimeoutMs - (Date.now() - startTime));\n  };\n\n  const isExpired = () => controller.signal.aborted || remainingMs() <= 0;\n\n  const dispose = () => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    if (signal) {\n      signal.removeEventListener('abort', onAbort);\n    }\n  };\n\n  return {\n    timeoutMs: resolvedTimeoutMs,\n    startTime,\n    signal: controller.signal,\n    remainingMs,\n    isExpired,\n    dispose,\n  };\n}\n\nmodule.exports = {\n  DEFAULT_CHAIN_TIMEOUT_MS,\n  MIN_REMAINING_MS,\n  resolveTimeoutMs,\n  createDeadlineExceededError,\n  createRequestBudget,\n  isAbortError,\n  isDeadlineExceededError,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\llm\\responseSchemas.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 502.",
        "line": 59,
        "column": 74,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 59,
        "endColumn": 77
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { z } = require('zod');\nconst { AppError } = require('../../errors');\n\nconst UsageSchema = z\n  .object({\n    prompt_tokens: z.number().int().nonnegative().optional(),\n    completion_tokens: z.number().int().nonnegative().optional(),\n    total_tokens: z.number().int().nonnegative().optional(),\n  })\n  .partial();\n\nconst OpenAiLikeResponseSchema = z\n  .object({\n    choices: z\n      .array(\n        z\n          .object({\n            message: z.object({ content: z.string().min(1) }).passthrough(),\n          })\n          .passthrough(),\n      )\n      .min(1),\n    model: z.string().optional(),\n    usage: UsageSchema.optional(),\n  })\n  .passthrough();\n\nconst GeminiResponseSchema = z\n  .object({\n    candidates: z\n      .array(\n        z\n          .object({\n            content: z\n              .object({\n                parts: z.array(z.object({ text: z.string().min(1) }).passthrough()).min(1),\n              })\n              .passthrough(),\n          })\n          .passthrough(),\n      )\n      .min(1),\n    usageMetadata: z\n      .object({\n        promptTokenCount: z.number().int().nonnegative().optional(),\n        candidatesTokenCount: z.number().int().nonnegative().optional(),\n        totalTokenCount: z.number().int().nonnegative().optional(),\n      })\n      .partial()\n      .optional(),\n  })\n  .passthrough();\n\nfunction parseWithSchema(schema, value, label) {\n  const result = schema.safeParse(value);\n  if (result.success) {\n    return result.data;\n  }\n  const error = new AppError(`Invalid ${label} response`, 'PARSE_ERROR', 502, {\n    provider: label,\n    issues: result.error.issues,\n  });\n  error.name = 'ParseError';\n  throw error;\n}\n\nfunction parseOpenAiResponse(value) {\n  return parseWithSchema(OpenAiLikeResponseSchema, value, 'OpenAI');\n}\n\nfunction parseGroqResponse(value) {\n  return parseWithSchema(OpenAiLikeResponseSchema, value, 'Groq');\n}\n\nfunction parseGeminiResponse(value) {\n  return parseWithSchema(GeminiResponseSchema, value, 'Gemini');\n}\n\nmodule.exports = {\n  parseOpenAiResponse,\n  parseGroqResponse,\n  parseGeminiResponse,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\providers\\transcriptionFactory.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\repositories\\__tests__\\chatRepository.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\repositories\\chatAssetsRepository.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\repositories\\chatRepository.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\repositories\\feedbackRepository.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 48,
        "column": 52,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 48,
        "endColumn": 54
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/repositories/feedbackRepository.js\n\nconst { supabase } = require('../db/supabaseClient');\n\n/**\n * Repository for feedback CRUD operations.\n * Handles user-submitted bug reports, feature requests, and questions.\n */\n\n/**\n * Create a new feedback entry.\n *\n * @param {Object} params - Feedback parameters\n * @param {string} params.userId - User ID (from JWT)\n * @param {string} params.type - Feedback type: 'bug', 'feature', 'question', 'other'\n * @param {string} params.message - Feedback message\n * @param {Object} [params.context] - Auto-captured context (url, courseCode, etc.)\n * @returns {Promise<Object>} Created feedback record\n */\nasync function createFeedback({ userId, type, message, context }) {\n  const insertData = {\n    user_id: userId,\n    type,\n    message,\n    context: context || null,\n    status: 'open',\n  };\n\n  const { data, error } = await supabase.from('feedback').insert(insertData).select().single();\n\n  if (error) {\n    console.error('Error creating feedback:', error);\n    throw error;\n  }\n\n  return data;\n}\n\n/**\n * Get all feedback for a specific user.\n * (For future \"My Feedback\" feature)\n *\n * @param {string} userId - User ID\n * @param {Object} [options] - Query options\n * @param {number} [options.limit=50] - Maximum records to return\n * @returns {Promise<Object[]>} Array of feedback records\n */\nasync function getFeedbackByUser(userId, { limit = 50 } = {}) {\n  const { data, error } = await supabase\n    .from('feedback')\n    .select('*')\n    .eq('user_id', userId)\n    .order('created_at', { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error('Error fetching user feedback:', error);\n    throw error;\n  }\n\n  return data;\n}\n\n/**\n * Get a single feedback entry by ID.\n * Only returns if the user owns the feedback (RLS enforced).\n *\n * @param {string} feedbackId - Feedback ID\n * @param {string} userId - User ID (for ownership check)\n * @returns {Promise<Object|null>} Feedback record or null if not found\n */\nasync function getFeedbackById(feedbackId, userId) {\n  const { data, error } = await supabase\n    .from('feedback')\n    .select('*')\n    .eq('id', feedbackId)\n    .eq('user_id', userId)\n    .single();\n\n  if (error) {\n    // PGRST116 = no rows found\n    if (error.code === 'PGRST116') return null;\n    console.error('Error fetching feedback:', error);\n    throw error;\n  }\n\n  return data;\n}\n\nmodule.exports = {\n  createFeedback,\n  getFeedbackByUser,\n  getFeedbackById,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\repositories\\noteAssetsRepository.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\repositories\\notesRepository.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'createNote' has too many lines (60). Maximum allowed is 50.",
        "line": 26,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 87,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 89,
        "column": 67,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 89,
        "endColumn": 69
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'updateNote' has too many lines (65). Maximum allowed is 50.",
        "line": 115,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 186,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'updateNote' has too many statements (22). Maximum allowed is 20.",
        "line": 115,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 186,
        "endColumn": 2
      },
      {
        "ruleId": "max-depth",
        "severity": 1,
        "message": "Blocks are nested too deeply (5). Maximum allowed is 4.",
        "line": 165,
        "column": 11,
        "nodeType": "IfStatement",
        "messageId": "tooDeeply",
        "endLine": 169,
        "endColumn": 12
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 194,
        "column": 78,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 194,
        "endColumn": 80
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/repositories/notesRepository.js\n\nconst { supabase } = require('../db/supabaseClient');\n\n/**\n * Repository for notes CRUD operations.\n *\n * Scalability features:\n * - Optimistic locking via updated_at for conflict detection\n * - Proper indexing recommendations in docs/reference/DATABASE.md\n * - Efficient queries with proper filtering\n */\n\n/**\n * Custom error for concurrent modification conflicts\n */\nclass ConflictError extends Error {\n  constructor(message, currentUpdatedAt) {\n    super(message);\n    this.name = 'ConflictError';\n    this.status = 409;\n    this.updatedAt = currentUpdatedAt;\n  }\n}\n\nasync function createNote({\n  userId,\n  clientNoteId,\n  title,\n  contentJson,\n  editorVersion,\n  contentPlain,\n  legacyContent,\n  sourceSelection,\n  sourceUrl,\n  courseCode,\n  noteType,\n  tags,\n  embedding,\n}) {\n  const insertData = {\n    ...(clientNoteId ? { id: clientNoteId } : {}),\n    user_id: userId,\n    title,\n    content_json: contentJson || {}, // Ensure we always provide content_json (defaults to {} in DB but safer to be explicit)\n    editor_version: editorVersion || 'lexical_v1',\n    content_plain: contentPlain || legacyContent || null, // Plain text content for search/display\n    source_selection: sourceSelection,\n    source_url: sourceUrl,\n    course_code: courseCode,\n    note_type: noteType,\n    tags,\n    embedding,\n  };\n\n  const { data, error } = await supabase.from('notes').insert(insertData).select().single();\n\n  if (error) {\n    if (clientNoteId && error.code === '23505') {\n      const existing = await getNoteForUser({\n        userId,\n        noteId: clientNoteId,\n      });\n      if (existing) {\n        return updateNote({\n          userId,\n          noteId: clientNoteId,\n          title,\n          contentJson,\n          editorVersion,\n          contentPlain,\n          legacyContent,\n          sourceSelection,\n          sourceUrl,\n          courseCode,\n          noteType,\n          tags,\n          embedding,\n          ifUnmodifiedSince: null,\n        });\n      }\n    }\n    console.error('Error creating note:', error);\n    throw error;\n  }\n  return data;\n}\n\nasync function listNotes({ userId, sourceUrl, courseCode, limit = 50 }) {\n  let query = supabase\n    .from('notes')\n    .select('*')\n    .eq('user_id', userId)\n    .order('created_at', { ascending: false })\n    .limit(limit);\n\n  if (sourceUrl) query = query.eq('source_url', sourceUrl);\n  if (courseCode) query = query.eq('course_code', courseCode);\n\n  const { data, error } = await query;\n  if (error) throw error;\n  return data;\n}\n\n/**\n * Update a note with optimistic locking support.\n *\n * @param {Object} params - Update parameters\n * @param {string} params.userId - User ID\n * @param {string} params.noteId - Note ID\n * @param {string} [params.ifUnmodifiedSince] - ISO timestamp for optimistic locking\n * @returns {Promise<Object>} Updated note\n * @throws {ConflictError} If note was modified since ifUnmodifiedSince\n */\nasync function updateNote({\n  userId,\n  noteId,\n  title,\n  contentJson,\n  editorVersion,\n  contentPlain,\n  legacyContent,\n  sourceSelection,\n  sourceUrl,\n  courseCode,\n  noteType,\n  tags,\n  embedding,\n  ifUnmodifiedSince,\n}) {\n  const updateData = {\n    title,\n    content_json: contentJson || {}, // Ensure we always provide content_json\n    editor_version: editorVersion || 'lexical_v1',\n    content_plain: contentPlain || legacyContent || null, // Plain text content for search/display\n    source_selection: sourceSelection,\n    source_url: sourceUrl,\n    course_code: courseCode,\n    note_type: noteType,\n    tags,\n    embedding,\n    updated_at: new Date().toISOString(), // Explicitly set updated_at for optimistic locking\n  };\n\n  let query = supabase.from('notes').update(updateData).eq('id', noteId).eq('user_id', userId);\n\n  if (ifUnmodifiedSince) {\n    query = query.eq('updated_at', ifUnmodifiedSince);\n  }\n\n  const { data, error } = await query.select().single();\n\n  if (error) {\n    console.error('Error updating note:', error);\n    if (error.code === 'PGRST116') {\n      if (ifUnmodifiedSince) {\n        const { data: currentNote, error: fetchError } = await supabase\n          .from('notes')\n          .select('updated_at')\n          .eq('id', noteId)\n          .eq('user_id', userId)\n          .single();\n\n        if (fetchError) {\n          if (fetchError.code === 'PGRST116') {\n            const notFoundError = new Error('Note not found');\n            notFoundError.status = 404;\n            throw notFoundError;\n          }\n          throw fetchError;\n        }\n\n        throw new ConflictError(\n          'Note was modified by another session. Please refresh and try again.',\n          currentNote.updated_at,\n        );\n      }\n\n      const notFoundError = new Error('Note not found');\n      notFoundError.status = 404;\n      throw notFoundError;\n    }\n    throw error;\n  }\n  return data;\n}\n\nasync function deleteNote({ userId, noteId }) {\n  const { error } = await supabase.from('notes').delete().eq('id', noteId).eq('user_id', userId);\n\n  if (error) throw error;\n}\n\nasync function searchNotesByEmbedding({ userId, queryEmbedding, matchCount = 10 }) {\n  const { data, error } = await supabase.rpc('match_notes', {\n    query_embedding: queryEmbedding,\n    match_count: matchCount,\n    in_user_id: userId,\n  });\n\n  if (error) throw error;\n  return data;\n}\n\nasync function getNoteForUser({ userId, noteId }) {\n  const { data, error } = await supabase\n    .from('notes')\n    .select('*')\n    .eq('id', noteId)\n    .eq('user_id', userId)\n    .single();\n\n  if (error) {\n    // PGRST116 = no rows found\n    if (error.code === 'PGRST116') return null;\n    throw error;\n  }\n  return data;\n}\n\n/**\n * Toggle the starred status of a note.\n * Returns the updated note with the new is_starred value.\n */\nasync function toggleStarred({ userId, noteId }) {\n  // First, get the current starred status\n  const { data: currentNote, error: fetchError } = await supabase\n    .from('notes')\n    .select('is_starred')\n    .eq('id', noteId)\n    .eq('user_id', userId)\n    .single();\n\n  if (fetchError) {\n    if (fetchError.code === 'PGRST116') {\n      const error = new Error('Note not found');\n      error.status = 404;\n      throw error;\n    }\n    throw fetchError;\n  }\n\n  // Toggle the value\n  const newValue = !currentNote.is_starred;\n\n  const { data, error } = await supabase\n    .from('notes')\n    .update({ is_starred: newValue, updated_at: new Date().toISOString() })\n    .eq('id', noteId)\n    .eq('user_id', userId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error('Error toggling starred:', error);\n    throw error;\n  }\n\n  return data;\n}\n\n/**\n * Set the starred status of a note to a specific value.\n */\nasync function setStarred({ userId, noteId, isStarred }) {\n  const { data, error } = await supabase\n    .from('notes')\n    .update({ is_starred: isStarred, updated_at: new Date().toISOString() })\n    .eq('id', noteId)\n    .eq('user_id', userId)\n    .select()\n    .single();\n\n  if (error) {\n    if (error.code === 'PGRST116') {\n      const notFoundError = new Error('Note not found');\n      notFoundError.status = 404;\n      throw notFoundError;\n    }\n    console.error('Error setting starred:', error);\n    throw error;\n  }\n\n  return data;\n}\n\nmodule.exports = {\n  createNote,\n  listNotes,\n  updateNote,\n  deleteNote,\n  searchNotesByEmbedding,\n  getNoteForUser,\n  toggleStarred,\n  setStarred,\n  ConflictError,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\repositories\\rateLimitRepository.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\repositories\\storageRepository.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\repositories\\transcriptsRepository.js",
    "messages": [
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (331). Maximum allowed is 300.",
        "line": 355,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 389,
        "endColumn": 1
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { supabase } = require('../db/supabaseClient');\n\nasync function getTranscriptByFingerprint({ fingerprint, userId }) {\n  if (!fingerprint || !userId) return null;\n  const { data, error } = await supabase\n    .from('transcripts')\n    .select('*')\n    .eq('fingerprint', fingerprint)\n    .eq('user_id', userId)\n    .single();\n\n  if (error) {\n    if (error.code === 'PGRST116') {\n      return null;\n    }\n    throw error;\n  }\n  return data;\n}\n\nasync function upsertTranscriptCache({\n  userId,\n  fingerprint,\n  provider,\n  mediaUrlRedacted,\n  mediaUrlNormalized,\n  etag,\n  lastModified,\n  durationMs,\n  transcriptJson,\n}) {\n  const payload = {\n    user_id: userId,\n    fingerprint,\n    provider,\n    media_url: mediaUrlRedacted,\n    media_url_normalized: mediaUrlNormalized,\n    etag,\n    last_modified: lastModified,\n    duration_ms: durationMs,\n    transcript_json: transcriptJson,\n    created_at: new Date().toISOString(),\n  };\n\n  const { data, error } = await supabase\n    .from('transcripts')\n    .upsert(payload, { onConflict: 'user_id,fingerprint' })\n    .select()\n    .single();\n\n  if (error) {\n    throw error;\n  }\n  return data;\n}\n\nasync function createTranscriptJob({\n  userId,\n  fingerprint,\n  mediaUrl,\n  mediaUrlNormalized,\n  durationMs,\n  provider,\n  expectedTotalChunks,\n}) {\n  const payload = {\n    user_id: userId,\n    fingerprint,\n    media_url: mediaUrl,\n    media_url_normalized: mediaUrlNormalized,\n    duration_ms: durationMs,\n    provider,\n    status: 'created',\n    expected_total_chunks: expectedTotalChunks ?? null,\n    bytes_received: 0,\n  };\n\n  const { data, error } = await supabase.from('transcript_jobs').insert(payload).select().single();\n\n  if (error) {\n    throw error;\n  }\n  return data;\n}\n\nasync function getTranscriptJob({ jobId, userId }) {\n  let query = supabase.from('transcript_jobs').select('*').eq('id', jobId);\n  if (userId) {\n    query = query.eq('user_id', userId);\n  }\n\n  const { data, error } = await query.single();\n  if (error) {\n    if (error.code === 'PGRST116') {\n      return null;\n    }\n    throw error;\n  }\n  return data;\n}\n\nasync function updateTranscriptJob({ jobId, userId, updates }) {\n  const payload = {\n    ...updates,\n    updated_at: new Date().toISOString(),\n  };\n\n  let query = supabase.from('transcript_jobs').update(payload).eq('id', jobId);\n  if (userId) {\n    query = query.eq('user_id', userId);\n  }\n\n  const { data, error } = await query.select().single();\n  if (error) {\n    throw error;\n  }\n  return data;\n}\n\nasync function countTranscriptJobsSince({ userId, since }) {\n  if (!userId || !since) return 0;\n  const { error, count } = await supabase\n    .from('transcript_jobs')\n    .select('*', { count: 'exact', head: true })\n    .eq('user_id', userId)\n    .gte('created_at', since);\n\n  if (error) {\n    throw error;\n  }\n  return typeof count === 'number' ? count : 0;\n}\n\nasync function countActiveTranscriptJobs({ userId }) {\n  if (!userId) return 0;\n  const { error, count } = await supabase\n    .from('transcript_jobs')\n    .select('*', { count: 'exact', head: true })\n    .eq('user_id', userId)\n    .in('status', ['created', 'uploading', 'uploaded', 'processing']);\n\n  if (error) {\n    throw error;\n  }\n  return typeof count === 'number' ? count : 0;\n}\n\nasync function insertTranscriptJobChunk({ jobId, chunkIndex, byteSize }) {\n  const { data, error } = await supabase\n    .from('transcript_job_chunks')\n    .insert({\n      job_id: jobId,\n      chunk_index: chunkIndex,\n      byte_size: byteSize,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    if (error.code === '23505') {\n      return { inserted: false };\n    }\n    throw error;\n  }\n\n  return { inserted: true, data };\n}\n\nasync function deleteTranscriptJobChunk({ jobId, chunkIndex }) {\n  const { error } = await supabase\n    .from('transcript_job_chunks')\n    .delete()\n    .eq('job_id', jobId)\n    .eq('chunk_index', chunkIndex);\n\n  if (error) {\n    throw error;\n  }\n}\n\nasync function deleteTranscriptJobChunks(jobId) {\n  if (!jobId) return;\n  const { error } = await supabase.from('transcript_job_chunks').delete().eq('job_id', jobId);\n  if (error) {\n    throw error;\n  }\n}\n\nasync function listTranscriptJobChunkIndices(jobId) {\n  if (!jobId) return [];\n  const { data, error } = await supabase\n    .from('transcript_job_chunks')\n    .select('chunk_index')\n    .eq('job_id', jobId)\n    .order('chunk_index', { ascending: true });\n\n  if (error) {\n    throw error;\n  }\n\n  return (data || []).map((row) => row.chunk_index);\n}\n\nasync function getTranscriptJobChunkStats(jobId) {\n  if (!jobId) {\n    return { count: 0, minIndex: null, maxIndex: null };\n  }\n\n  const { count, error: countError } = await supabase\n    .from('transcript_job_chunks')\n    .select('chunk_index', { count: 'exact', head: true })\n    .eq('job_id', jobId);\n\n  if (countError) {\n    throw countError;\n  }\n\n  const { data: minRows, error: minError } = await supabase\n    .from('transcript_job_chunks')\n    .select('chunk_index')\n    .eq('job_id', jobId)\n    .order('chunk_index', { ascending: true })\n    .limit(1);\n\n  if (minError) {\n    throw minError;\n  }\n\n  const { data: maxRows, error: maxError } = await supabase\n    .from('transcript_job_chunks')\n    .select('chunk_index')\n    .eq('job_id', jobId)\n    .order('chunk_index', { ascending: false })\n    .limit(1);\n\n  if (maxError) {\n    throw maxError;\n  }\n\n  const minIndex = Array.isArray(minRows) && minRows.length > 0 ? minRows[0].chunk_index : null;\n  const maxIndex = Array.isArray(maxRows) && maxRows.length > 0 ? maxRows[0].chunk_index : null;\n\n  return {\n    count: typeof count === 'number' ? count : 0,\n    minIndex,\n    maxIndex,\n  };\n}\n\nasync function listActiveTranscriptJobs({ userId }) {\n  if (!userId) return [];\n  const { data, error } = await supabase\n    .from('transcript_jobs')\n    .select('id, status, fingerprint, media_url, created_at, updated_at')\n    .eq('user_id', userId)\n    .in('status', ['created', 'uploading', 'uploaded', 'processing'])\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    throw error;\n  }\n  return data || [];\n}\n\nasync function listTranscriptJobsByHeartbeatBefore({ statuses, heartbeatBefore }) {\n  if (!Array.isArray(statuses) || statuses.length === 0) return [];\n  if (!heartbeatBefore) return [];\n\n  const { data, error } = await supabase\n    .from('transcript_jobs')\n    .select('*')\n    .in('status', statuses)\n    .or(`processing_heartbeat_at.is.null,processing_heartbeat_at.lt.${heartbeatBefore}`);\n\n  if (error) {\n    throw error;\n  }\n\n  return data || [];\n}\n\nasync function listTranscriptJobsByStatusBefore({ statuses, updatedBefore }) {\n  if (!Array.isArray(statuses) || statuses.length === 0) return [];\n  if (!updatedBefore) return [];\n\n  const { data, error } = await supabase\n    .from('transcript_jobs')\n    .select('*')\n    .in('status', statuses)\n    .lt('updated_at', updatedBefore);\n\n  if (error) {\n    throw error;\n  }\n\n  return data || [];\n}\n\nasync function listTranscriptJobsCreatedBefore({ createdBefore }) {\n  if (!createdBefore) return [];\n  const { data, error } = await supabase\n    .from('transcript_jobs')\n    .select('*')\n    .lt('created_at', createdBefore)\n    .gt('bytes_received', 0);\n\n  if (error) {\n    throw error;\n  }\n\n  return data || [];\n}\n\nasync function claimTranscriptJobForProcessing({ jobId, workerId, staleBefore }) {\n  if (!jobId || !workerId) return null;\n  const now = new Date().toISOString();\n  let query = supabase\n    .from('transcript_jobs')\n    .update({\n      status: 'processing',\n      error: null,\n      processing_worker_id: workerId,\n      processing_started_at: now,\n      processing_heartbeat_at: now,\n      updated_at: now,\n    })\n    .eq('id', jobId)\n    .in('status', ['uploaded', 'processing']);\n\n  const staleFilter = staleBefore\n    ? `processing_worker_id.is.null,processing_heartbeat_at.is.null,processing_heartbeat_at.lt.${staleBefore}`\n    : 'processing_worker_id.is.null';\n  query = query.or(staleFilter);\n\n  const { data, error } = await query.select().single();\n  if (error) {\n    if (error.code === 'PGRST116') {\n      return null;\n    }\n    throw error;\n  }\n\n  return data;\n}\n\nasync function consumeTranscriptUploadBytes({ userId, bytes, limit }) {\n  if (!userId || !Number.isFinite(bytes)) {\n    return { allowed: true, remaining: Infinity, retryAfterSeconds: 0 };\n  }\n\n  const { data, error } = await supabase.rpc('consume_transcript_upload_bytes', {\n    p_user_id: userId,\n    p_bytes: bytes,\n    p_limit: limit,\n  });\n\n  if (error) {\n    throw error;\n  }\n\n  const result = Array.isArray(data) ? data[0] : data;\n  return {\n    allowed: Boolean(result?.allowed),\n    remaining: result?.remaining ?? null,\n    retryAfterSeconds: result?.retry_after_seconds ?? 0,\n  };\n}\n\nmodule.exports = {\n  getTranscriptByFingerprint,\n  upsertTranscriptCache,\n  createTranscriptJob,\n  getTranscriptJob,\n  updateTranscriptJob,\n  countTranscriptJobsSince,\n  countActiveTranscriptJobs,\n  insertTranscriptJobChunk,\n  deleteTranscriptJobChunk,\n  deleteTranscriptJobChunks,\n  listTranscriptJobChunkIndices,\n  getTranscriptJobChunkStats,\n  listActiveTranscriptJobs,\n  listTranscriptJobsByHeartbeatBefore,\n  listTranscriptJobsByStatusBefore,\n  listTranscriptJobsCreatedBefore,\n  claimTranscriptJobForProcessing,\n  consumeTranscriptUploadBytes,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\routes\\assistantRoutes.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\routes\\feedbackRoutes.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\routes\\healthRoutes.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\routes\\noteRoutes.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\routes\\transcriptsRoutes.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\scripts\\check-syntax.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\scripts\\verify-azure-embeddings.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 11,
        "column": 24,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 11,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 18,
        "column": 86,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 18,
        "endColumn": 88
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (23). Maximum allowed is 20.",
        "line": 34,
        "column": 4,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 63,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 48,
        "column": 59,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 48,
        "endColumn": 60
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 50,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 50,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Detailed Azure Embeddings Diagnostic\n */\n\nrequire('dotenv').config();\n\nconst { createAzureEmbeddingsClient } = require('../providers/azureEmbeddingsClient');\nconst config = require('../config');\n\nconsole.log('\\n Detailed Azure Embeddings Diagnostic\\n');\nconsole.log(''.repeat(60));\n\nconsole.log('\\n Configuration:');\nconsole.log(`  Endpoint: ${config.AZURE_OPENAI_ENDPOINT}`);\nconsole.log(`  Deployment: ${config.AZURE_OPENAI_EMBEDDINGS_DEPLOYMENT}`);\nconsole.log(`  API Version: ${config.AZURE_OPENAI_API_VERSION}`);\nconsole.log(`  Has API Key: ${Boolean(config.AZURE_OPENAI_API_KEY)}`);\nconsole.log(`  API Key (first 10 chars): ${config.AZURE_OPENAI_API_KEY?.substring(0, 10)}...`);\n\nconsole.log('\\n Creating Azure embeddings client directly...');\n\ntry {\n  const client = createAzureEmbeddingsClient(\n    config.AZURE_OPENAI_API_KEY,\n    config.AZURE_OPENAI_ENDPOINT,\n    config.AZURE_OPENAI_API_VERSION,\n    config.AZURE_OPENAI_EMBEDDINGS_DEPLOYMENT,\n  );\n\n  console.log(' Client created successfully!');\n\n  console.log('\\n Running direct embedding test...');\n\n  (async () => {\n    try {\n      const testText = 'Test';\n      const result = await client.createEmbeddings(testText);\n\n      console.log(`\\n Direct Azure embedding successful!`);\n      console.log(`  Dimensions: ${result.embeddings[0].length}`);\n      console.log(`  Model: ${result.model}`);\n      console.log(`  Tokens Used: ${result.usage.total_tokens}`);\n\n      const stats = client.getStats();\n      console.log('\\n Stats:');\n      console.log(`  Requests: ${stats.totalRequests}`);\n      console.log(`  Tokens: ${stats.totalTokens}`);\n      console.log(`  Cost: $${stats.estimatedCost.toFixed(6)}`);\n\n      console.log('\\n'.repeat(60));\n      console.log(' Azure is configured correctly!\\n');\n      process.exit(0);\n    } catch (error) {\n      console.error('\\n Direct Azure embedding failed:');\n      console.error(`  Error: ${error.message}`);\n      console.error(`  Name: ${error.name}`);\n      console.error(`  Code: ${error.code || 'none'}`);\n      console.error(`  Status: ${error.status || 'none'}`);\n      console.error('\\n Stack trace:');\n      console.error(error.stack);\n      process.exit(1);\n    }\n  })();\n} catch (error) {\n  console.error('\\n Failed to create Azure client:');\n  console.error(`  ${error.message}\\n`);\n  process.exit(1);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\scripts\\verify-embeddings.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 14,
        "column": 24,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 14,
        "endColumn": 26
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (35). Maximum allowed is 20.",
        "line": 39,
        "column": 4,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 88,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 53,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 53,
        "endColumn": 22
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 54,
        "column": 33,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 54,
        "endColumn": 34
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 68,
        "column": 71,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 68,
        "endColumn": 72
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 72,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 72,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Test Azure Embeddings Setup\n *\n * Run this to verify your Azure OpenAI embeddings configuration is working correctly.\n */\n\n// Load environment variables\nrequire('dotenv').config();\n\nconst { createEmbeddingsClient } = require('../providers/embeddingsFactory');\nconst config = require('../config');\n\nconsole.log('\\n Azure Embeddings Configuration Test\\n');\nconsole.log(''.repeat(60));\n\nconsole.log('\\n Configuration:');\nconsole.log(`  Endpoint: ${config.AZURE_OPENAI_ENDPOINT}`);\nconsole.log(`  Deployment: ${config.AZURE_OPENAI_EMBEDDINGS_DEPLOYMENT}`);\nconsole.log(`  API Version: ${config.AZURE_OPENAI_API_VERSION}`);\nconsole.log(`  Has API Key: ${Boolean(config.AZURE_OPENAI_API_KEY)}`);\nconsole.log(`  OpenAI Fallback: ${config.OPENAI_FALLBACK_ENABLED ? 'Enabled' : 'Disabled'}`);\n\nconsole.log('\\n Creating embeddings client...');\n\ntry {\n  const client = createEmbeddingsClient({\n    azureApiKey: config.AZURE_OPENAI_API_KEY,\n    azureEndpoint: config.AZURE_OPENAI_ENDPOINT,\n    azureApiVersion: config.AZURE_OPENAI_API_VERSION,\n    azureDeployment: config.AZURE_OPENAI_EMBEDDINGS_DEPLOYMENT,\n    openaiApiKey: config.OPENAI_API_KEY,\n    openaiModel: config.OPENAI_EMBEDDINGS_MODEL,\n  });\n\n  console.log(' Client created successfully!');\n\n  console.log('\\n Running embedding test...');\n\n  (async () => {\n    try {\n      const testText = 'This is a test of the Azure OpenAI embeddings service.';\n      console.log(`  Input: \"${testText}\"`);\n\n      const start = Date.now();\n      const result = await client.createEmbeddings(testText);\n      const duration = Date.now() - start;\n\n      console.log(`\\n Embedding generated successfully!`);\n      console.log(`  Dimensions: ${result.embeddings[0].length}`);\n      console.log(`  Duration: ${duration}ms`);\n      console.log(\n        `  Sample (first 5 values): [${result.embeddings[0]\n          .slice(0, 5)\n          .map((v) => v.toFixed(6))\n          .join(', ')}...]`,\n      );\n      console.log(`  Model: ${result.model}`);\n      console.log(`  Provider: ${result.provider}`);\n      console.log(`  Tokens Used: ${result.usage.total_tokens}`);\n\n      // Get usage stats if available\n      if (client.primaryClient && typeof client.primaryClient.getStats === 'function') {\n        const stats = client.primaryClient.getStats();\n        console.log('\\n Usage Statistics:');\n        console.log(`  Total Requests: ${stats.totalRequests}`);\n        console.log(`  Total Tokens: ${stats.totalTokens}`);\n        console.log(`  Total Embeddings: ${stats.totalEmbeddings}`);\n        console.log(`  Estimated Cost: $${stats.estimatedCost.toFixed(6)}`);\n        console.log(`  Errors: ${stats.errors}`);\n      }\n\n      console.log('\\n'.repeat(60));\n      console.log(' All tests passed! Your Azure embeddings are configured correctly.\\n');\n      process.exit(0);\n    } catch (error) {\n      console.error('\\n Embedding test failed:');\n      console.error(`  ${error.message}`);\n      console.error('\\n Troubleshooting steps:');\n      console.error('  1. Verify your Azure OpenAI endpoint is correct');\n      console.error('  2. Check that your API key is valid and not expired');\n      console.error('  3. Ensure the deployment name matches exactly');\n      console.error('  4. Confirm you have quota available');\n      console.error('  5. Check your network/firewall settings\\n');\n      console.error('Full error:');\n      console.error(error);\n      process.exit(1);\n    }\n  })();\n} catch (error) {\n  console.error('\\n Failed to create embeddings client:');\n  console.error(`  ${error.message}\\n`);\n  process.exit(1);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\__tests__\\transcriptCacheService.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 2222.",
        "line": 120,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 120,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const test = require('node:test');\nconst assert = require('node:assert/strict');\nconst Module = require('node:module');\n\nfunction loadService(repo) {\n  const repoPath = require.resolve('../../repositories/transcriptsRepository');\n  const servicePath = require.resolve('../../services/transcripts/transcriptCacheService');\n\n  const originalRepo = require.cache[repoPath];\n  const originalService = require.cache[servicePath];\n\n  const repoModule = new Module(repoPath, module);\n  repoModule.filename = repoPath;\n  repoModule.exports = repo;\n  repoModule.loaded = true;\n\n  require.cache[repoPath] = repoModule;\n  delete require.cache[servicePath];\n\n  const service = require('../../services/transcripts/transcriptCacheService');\n\n  return {\n    service,\n    restore() {\n      if (originalRepo) {\n        require.cache[repoPath] = originalRepo;\n      } else {\n        delete require.cache[repoPath];\n      }\n      if (originalService) {\n        require.cache[servicePath] = originalService;\n      } else {\n        delete require.cache[servicePath];\n      }\n    },\n  };\n}\n\ntest('cacheExternalTranscript requires fingerprint and transcript', async () => {\n  const repo = {\n    async upsertTranscriptCache() {\n      return null;\n    },\n  };\n  const { service, restore } = loadService(repo);\n\n  try {\n    await assert.rejects(\n      () =>\n        service.cacheExternalTranscript({\n          userId: 'user-1',\n          provider: 'html5',\n          transcript: { plainText: 'Hello', segments: [] },\n        }),\n      (err) => {\n        assert.equal(err.code, 'VALIDATION_ERROR');\n        assert.match(err.message, /Fingerprint/);\n        return true;\n      },\n    );\n\n    await assert.rejects(\n      () =>\n        service.cacheExternalTranscript({\n          userId: 'user-1',\n          fingerprint: 'fp-1',\n          provider: 'html5',\n        }),\n      (err) => {\n        assert.equal(err.code, 'VALIDATION_ERROR');\n        assert.match(err.message, /Transcript/);\n        return true;\n      },\n    );\n  } finally {\n    restore();\n  }\n});\n\ntest('cacheExternalTranscript normalizes transcript payload and URLs', async () => {\n  const calls = [];\n  const repo = {\n    async upsertTranscriptCache(payload) {\n      calls.push(payload);\n      return {\n        fingerprint: payload.fingerprint,\n        created_at: '2026-01-25T00:00:00.000Z',\n      };\n    },\n  };\n  const { service, restore } = loadService(repo);\n\n  try {\n    const result = await service.cacheExternalTranscript({\n      userId: 'user-1',\n      fingerprint: '  fp-1  ',\n      provider: 'html5',\n      transcript: {\n        plainText: '  Hello world  ',\n        segments: [\n          { startMs: 0, endMs: 1000, text: 'Hello world' },\n          { startMs: 'oops', text: 'skip' },\n          { startMs: 2000, text: '   ' },\n        ],\n        durationMs: 1111,\n      },\n      meta: {\n        mediaUrl:\n          'https://example.com/media/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa?token=secret#frag',\n        durationMs: 2222,\n      },\n    });\n\n    assert.equal(result.fingerprint, 'fp-1');\n    assert.equal(calls.length, 1);\n    const payload = calls[0];\n\n    assert.equal(payload.fingerprint, 'fp-1');\n    assert.equal(payload.provider, 'html5');\n    assert.equal(payload.durationMs, 2222);\n    assert.equal(payload.mediaUrlRedacted, 'https://example.com/media/[redacted]');\n    assert.equal(payload.mediaUrlNormalized, 'https://example.com/media/[redacted]');\n    assert.equal(payload.transcriptJson.plainText, 'Hello world');\n    assert.equal(payload.transcriptJson.segments.length, 1);\n  } finally {\n    restore();\n  }\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\assistant\\assistantService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createAssistantService' has too many lines (139). Maximum allowed is 50.",
        "line": 38,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 201,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'handleLockinRequest' has too many lines (125). Maximum allowed is 50.",
        "line": 49,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 196,
        "endColumn": 4
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'handleLockinRequest' has a complexity of 20. Maximum allowed is 15.",
        "line": 49,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 49,
        "endColumn": 37
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 83,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 83,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 89,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 89,
        "endColumn": 35
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async arrow function has too many lines (88). Maximum allowed is 50.",
        "line": 92,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 189,
        "endColumn": 6
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (23). Maximum allowed is 20.",
        "line": 92,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 189,
        "endColumn": 6
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async arrow function has a complexity of 16. Maximum allowed is 15.",
        "line": 92,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 92,
        "endColumn": 38
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 97,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 97,
        "endColumn": 39
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 137,
        "column": 11,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 137,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Assistant Service\n *\n * Business logic for the Lock-in AI assistant.\n * Assumes request is ALREADY VALIDATED by Zod middleware in routes.\n *\n * IMPORTANT: Do NOT add duplicate validation here.\n * All input validation is handled by Zod schemas in /backend/validators/assistantValidators.js\n */\n\nconst { logger: baseLogger } = require('../../observability');\nconst { DAILY_REQUEST_LIMIT } = require('../../config');\nconst { createIdempotencyStore } = require('../../utils/idempotency');\nconst {\n  buildInitialChatTitle,\n  extractFirstUserMessage,\n  FALLBACK_TITLE,\n} = require('../../utils/chatTitle');\nconst chatRepository = require('../../repositories/chatRepository');\nconst { generateStructuredStudyResponse } = require('../llmClient');\nconst { checkDailyLimit } = require('../rateLimitService');\nconst { chatAssetsService: defaultChatAssetsService } = require('./chatAssetsService');\nconst { chatTitleService: defaultChatTitleService } = require('./chatTitleService');\n\nconst ATTACHMENT_ONLY_TITLE_SEED = 'Attachment-based question';\nconst defaultIdempotencyStore = createIdempotencyStore();\n\nfunction createRequestError(status, message) {\n  const error = new Error(message);\n  error.status = status;\n  error.payload = {\n    success: false,\n    error: { message },\n  };\n  return error;\n}\n\nfunction createAssistantService(deps = {}) {\n  const services = {\n    logger: deps.logger ?? baseLogger,\n    chatRepository: deps.chatRepository ?? chatRepository,\n    llmClient: deps.llmClient ?? { generateStructuredStudyResponse },\n    rateLimitService: deps.rateLimitService ?? { checkDailyLimit },\n    chatAssetsService: deps.chatAssetsService ?? defaultChatAssetsService,\n    chatTitleService: deps.chatTitleService ?? defaultChatTitleService,\n    idempotencyStore: deps.idempotencyStore ?? defaultIdempotencyStore,\n  };\n\n  async function handleLockinRequest({ userId, payload, idempotencyKey } = {}) {\n    // Payload is ALREADY validated by Zod middleware - no duplicate validation needed\n    const {\n      selection = '',\n      mode,\n      chatHistory = [],\n      newUserMessage,\n      chatId: incomingChatId,\n      pageContext,\n      pageUrl,\n      courseCode,\n      language = 'en',\n      attachments = [],\n    } = payload || {};\n\n    // Determine request type based on chat history\n    const isInitialRequest = chatHistory.length === 0;\n    const effectiveMode = isInitialRequest ? mode : 'general';\n\n    // Prepare text values\n    const trimmedSelection = typeof selection === 'string' ? selection.trim() : '';\n    const trimmedUserMessage = newUserMessage ? newUserMessage.trim() : '';\n    const hasAttachmentIds = Array.isArray(attachments) && attachments.length > 0;\n\n    // Build title seed\n    const userInputText =\n      trimmedUserMessage ||\n      trimmedSelection ||\n      (hasAttachmentIds ? ATTACHMENT_ONLY_TITLE_SEED : '');\n    const initialTitle = buildInitialChatTitle(userInputText || '');\n    const firstUserMessage = extractFirstUserMessage(chatHistory);\n    const initialTitleFromHistory = buildInitialChatTitle(firstUserMessage || userInputText || '');\n\n    if (!userId) {\n      throw createRequestError(500, 'User context missing for authenticated request.');\n    }\n\n    const limitCheck = await services.rateLimitService.checkDailyLimit(userId, DAILY_REQUEST_LIMIT);\n\n    if (!limitCheck.allowed) {\n      throw createRequestError(429, 'Daily limit reached');\n    }\n\n    const runLockinFlow = async () => {\n      let chatRecord;\n      if (incomingChatId) {\n        chatRecord = await services.chatRepository.getChatById(userId, incomingChatId);\n        if (!chatRecord) {\n          throw createRequestError(404, 'The requested chat does not exist for this user.');\n        }\n      } else {\n        chatRecord = await services.chatRepository.createChat(userId, initialTitle);\n      }\n\n      const chatId = chatRecord.id;\n\n      const userMessage = await services.chatRepository.insertChatMessage({\n        chat_id: chatId,\n        user_id: userId,\n        role: 'user',\n        mode: effectiveMode,\n        source: 'highlight',\n        input_text: userInputText,\n        output_text: null,\n      });\n\n      const { processedAttachments, linkedAssetIds } =\n        await services.chatAssetsService.resolveAttachmentsForMessage({\n          userId,\n          assetIds: attachments,\n        });\n\n      let structuredResponse;\n      try {\n        structuredResponse = await services.llmClient.generateStructuredStudyResponse({\n          mode: effectiveMode,\n          selection: trimmedSelection,\n          pageContext,\n          pageUrl,\n          courseCode,\n          language,\n          chatHistory,\n          newUserMessage: trimmedUserMessage || undefined,\n          attachments: processedAttachments.length > 0 ? processedAttachments : undefined,\n        });\n      } catch (error) {\n        services.logger.error({ err: error }, 'Error generating structured study response');\n        throw createRequestError(\n          500,\n          error.message || 'Failed to generate study response. Please try again.',\n        );\n      }\n\n      if (linkedAssetIds.length > 0 && userMessage?.id) {\n        await services.chatAssetsService.linkAssetsToMessage(\n          linkedAssetIds,\n          userMessage.id,\n          userId,\n        );\n      }\n\n      await services.chatRepository.insertChatMessage({\n        chat_id: chatId,\n        user_id: userId,\n        role: 'assistant',\n        mode: effectiveMode,\n        source: 'highlight',\n        input_text: null,\n        output_text: structuredResponse.explanation,\n      });\n\n      await services.chatRepository.touchChat(chatId);\n\n      const existingTitle = typeof chatRecord.title === 'string' ? chatRecord.title.trim() : '';\n      const shouldGenerateTitle =\n        !existingTitle ||\n        existingTitle === FALLBACK_TITLE ||\n        existingTitle === initialTitleFromHistory;\n\n      if (shouldGenerateTitle) {\n        services.chatTitleService\n          .generateChatTitleAsync(userId, chatId, firstUserMessage || userInputText)\n          .catch((error) => {\n            services.logger.warn({ err: error }, 'Failed to auto-generate chat title');\n          });\n      }\n\n      return {\n        success: true,\n        data: {\n          mode: structuredResponse.mode,\n          explanation: structuredResponse.explanation,\n          notes: structuredResponse.notes,\n          todos: structuredResponse.todos,\n          tags: structuredResponse.tags,\n          difficulty: structuredResponse.difficulty,\n        },\n        chatId,\n        chatTitle: existingTitle || initialTitle,\n      };\n    };\n\n    if (idempotencyKey) {\n      return services.idempotencyStore.run(idempotencyKey, userId, runLockinFlow);\n    }\n\n    return runLockinFlow();\n  }\n\n  return {\n    handleLockinRequest,\n  };\n}\n\nconst assistantService = createAssistantService();\n\nmodule.exports = {\n  createAssistantService,\n  assistantService,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\assistant\\chatAssetContentService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createChatAssetContentService' has too many lines (55). Maximum allowed is 50.",
        "line": 3,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 66,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const pdfParse = require('pdf-parse');\n\nfunction createChatAssetContentService({ chatAssetsRepository, storageRepository, logger }) {\n  async function getAssetForVision(assetId, userId) {\n    const asset = await chatAssetsRepository.getAssetById(assetId, userId);\n    if (!asset) return null;\n\n    const { data, error } = await storageRepository.download(asset.storage_path);\n    if (error) {\n      logger.error({ err: error }, 'Failed to download asset for vision');\n      return null;\n    }\n\n    const buffer = await data.arrayBuffer();\n    const base64 = Buffer.from(buffer).toString('base64');\n\n    return {\n      id: asset.id,\n      type: asset.type,\n      mimeType: asset.mime_type,\n      base64,\n      fileName: asset.file_name,\n    };\n  }\n\n  async function getAssetTextContent(assetId, userId) {\n    const asset = await chatAssetsRepository.getAssetById(assetId, userId);\n    if (!asset) return null;\n\n    const { data, error } = await storageRepository.download(asset.storage_path);\n    if (error) {\n      logger.error({ err: error }, 'Failed to download asset for text extraction');\n      return null;\n    }\n\n    const buffer = await data.arrayBuffer();\n    let textContent = '';\n\n    if (asset.mime_type === 'application/pdf') {\n      try {\n        const parsed = await pdfParse(Buffer.from(buffer));\n        textContent = parsed.text?.trim() || '';\n        if (!textContent) {\n          textContent = '[PDF text extraction returned empty]';\n        }\n      } catch (error) {\n        logger.error({ err: error }, 'Failed to extract PDF content');\n        textContent = '[PDF text extraction failed]';\n      }\n    } else if (asset.mime_type.startsWith('text/') || asset.mime_type === 'application/json') {\n      textContent = Buffer.from(buffer).toString('utf-8');\n    } else {\n      textContent = '[Binary file - content not extractable]';\n    }\n\n    return {\n      id: asset.id,\n      type: asset.type,\n      mimeType: asset.mime_type,\n      textContent,\n      fileName: asset.file_name,\n    };\n  }\n\n  return { getAssetForVision, getAssetTextContent };\n}\n\nmodule.exports = {\n  createChatAssetContentService,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\assistant\\chatAssetsService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createChatAssetsService' has too many lines (181). Maximum allowed is 50.",
        "line": 26,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 239,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 66,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 66,
        "endColumn": 35
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'uploadChatAsset' has too many lines (54). Maximum allowed is 50.",
        "line": 71,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 134,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 73,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 73,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 76,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 76,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 83,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 83,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 92,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 92,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 109,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 109,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 138,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 138,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 141,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 141,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 164,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 164,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 167,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 167,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 172,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 172,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 178,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 178,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 192,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 192,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 15,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { randomUUID } = require('crypto');\nconst { logger: baseLogger } = require('../../observability');\nconst {\n  CHAT_ASSETS_BUCKET,\n  CHAT_ASSET_DAILY_UPLOAD_LIMIT,\n  CHAT_ASSET_DAILY_UPLOAD_BYTES_LIMIT,\n  CHAT_ASSET_SIGNED_URL_TTL_SECONDS,\n} = require('../../config');\nconst { createStorageRepository } = require('../../repositories/storageRepository');\nconst chatAssetsRepository = require('../../repositories/chatAssetsRepository');\nconst chatRepository = require('../../repositories/chatRepository');\nconst {\n  validateChatAssetFile,\n  isVisionCompatibleImage,\n} = require('../../utils/chatAssetValidation');\nconst { checkChatAssetDailyLimits } = require('../rateLimitService');\nconst { createChatAssetContentService } = require('./chatAssetContentService');\n\nfunction createRequestError(status, message) {\n  const error = new Error(message);\n  error.status = status;\n  error.payload = { error: message };\n  return error;\n}\n\nfunction createChatAssetsService(deps = {}) {\n  const bucket = deps.bucket ?? CHAT_ASSETS_BUCKET;\n  const storageRepository =\n    deps.storageRepository ??\n    createStorageRepository({\n      bucket,\n      supabaseClient: deps.supabase,\n    });\n\n  const services = {\n    chatRepository: deps.chatRepository ?? chatRepository,\n    chatAssetsRepository: deps.chatAssetsRepository ?? chatAssetsRepository,\n    rateLimitService: deps.rateLimitService ?? { checkChatAssetDailyLimits },\n    storageRepository,\n    logger: deps.logger ?? baseLogger,\n    bucket,\n    dailyUploadLimit: deps.dailyUploadLimit ?? CHAT_ASSET_DAILY_UPLOAD_LIMIT,\n    dailyUploadBytesLimit: deps.dailyUploadBytesLimit ?? CHAT_ASSET_DAILY_UPLOAD_BYTES_LIMIT,\n    signedUrlTtl: deps.signedUrlTtl ?? CHAT_ASSET_SIGNED_URL_TTL_SECONDS,\n  };\n\n  const { getAssetForVision, getAssetTextContent } = createChatAssetContentService(services);\n\n  async function createSignedAssetUrl(storagePath) {\n    const { data, error } = await services.storageRepository.createSignedUrl(\n      storagePath,\n      services.signedUrlTtl,\n    );\n\n    if (error) {\n      services.logger.warn({ err: error }, 'Failed to create signed asset URL');\n      return null;\n    }\n\n    return data?.signedUrl || null;\n  }\n\n  async function ensureChatExists(userId, chatId) {\n    const chat = await services.chatRepository.getChatById(userId, chatId);\n    if (!chat) {\n      throw createRequestError(404, 'Chat not found');\n    }\n    return chat;\n  }\n\n  async function uploadChatAsset({ userId, chatId, file } = {}) {\n    if (!userId) {\n      throw createRequestError(500, 'User context missing.');\n    }\n    if (!chatId) {\n      throw createRequestError(400, 'Chat ID is required');\n    }\n\n    await ensureChatExists(userId, chatId);\n\n    const validation = await validateChatAssetFile(file);\n    if (!validation.valid) {\n      throw createRequestError(400, validation.reason || 'Invalid file');\n    }\n\n    const usage = await services.rateLimitService.checkChatAssetDailyLimits(userId, {\n      maxUploadsPerDay: services.dailyUploadLimit,\n      maxBytesPerDay: services.dailyUploadBytesLimit,\n    });\n\n    if (!usage.allowed || usage.remainingUploads < 1 || usage.remainingBytes < file.size) {\n      throw createRequestError(429, 'Daily upload limit reached');\n    }\n\n    const assetId = randomUUID();\n    const storagePath = `${userId}/${chatId}/${assetId}.${validation.extension}`;\n\n    const { error: uploadError } = await services.storageRepository.upload(\n      storagePath,\n      file.buffer,\n      {\n        contentType: validation.mimeType,\n        upsert: false,\n      },\n    );\n\n    if (uploadError) {\n      services.logger.error({ err: uploadError }, 'Failed to upload chat asset to storage');\n      throw createRequestError(500, 'Failed to upload file');\n    }\n\n    const asset = await services.chatAssetsRepository.createAsset({\n      id: assetId,\n      messageId: null,\n      userId,\n      type: validation.type,\n      mimeType: validation.mimeType,\n      storagePath,\n      fileName: file.originalname || null,\n      fileSize: file.size || null,\n    });\n\n    const url = await createSignedAssetUrl(storagePath);\n\n    return {\n      id: asset.id,\n      type: asset.type,\n      mimeType: asset.mime_type,\n      fileName: asset.file_name,\n      fileSize: asset.file_size,\n      url,\n      createdAt: asset.created_at,\n    };\n  }\n\n  async function listChatAssets({ userId, chatId } = {}) {\n    if (!userId) {\n      throw createRequestError(500, 'User context missing.');\n    }\n    if (!chatId) {\n      throw createRequestError(400, 'Chat ID is required');\n    }\n\n    await ensureChatExists(userId, chatId);\n\n    const assets = await services.chatAssetsRepository.listAssetsForChat(chatId, userId);\n\n    return Promise.all(\n      assets.map(async (asset) => ({\n        id: asset.id,\n        messageId: asset.message_id,\n        type: asset.type,\n        mimeType: asset.mime_type,\n        fileName: asset.file_name,\n        fileSize: asset.file_size,\n        url: await createSignedAssetUrl(asset.storage_path),\n        createdAt: asset.created_at,\n      })),\n    );\n  }\n\n  async function deleteChatAsset({ userId, assetId } = {}) {\n    if (!userId) {\n      throw createRequestError(500, 'User context missing.');\n    }\n    if (!assetId) {\n      throw createRequestError(400, 'Asset ID is required');\n    }\n\n    const asset = await services.chatAssetsRepository.getAssetById(assetId, userId);\n    if (!asset) {\n      throw createRequestError(404, 'Asset not found');\n    }\n\n    const { error: storageError } = await services.storageRepository.remove([asset.storage_path]);\n    if (storageError) {\n      services.logger.error({ err: storageError }, 'Failed to delete chat asset from storage');\n      throw createRequestError(500, 'Failed to delete asset');\n    }\n\n    await services.chatAssetsRepository.deleteAsset(assetId, userId);\n  }\n\n  async function resolveAttachmentsForMessage({ userId, assetIds } = {}) {\n    const processedAttachments = [];\n    const linkedAssetIds = [];\n\n    if (!Array.isArray(assetIds) || assetIds.length === 0) {\n      return { processedAttachments, linkedAssetIds };\n    }\n\n    for (const assetId of assetIds.slice(0, 5)) {\n      const asset = await services.chatAssetsRepository.getAssetById(assetId, userId);\n      if (!asset) continue;\n      linkedAssetIds.push(asset.id);\n\n      if (isVisionCompatibleImage(asset.mime_type)) {\n        const visionData = await getAssetForVision(assetId, userId);\n        if (visionData) {\n          processedAttachments.push({\n            type: 'image',\n            mimeType: visionData.mimeType,\n            base64: visionData.base64,\n            fileName: visionData.fileName,\n          });\n        }\n        continue;\n      }\n\n      const textData = await getAssetTextContent(assetId, userId);\n      if (textData && textData.textContent) {\n        processedAttachments.push({\n          type: asset.type,\n          mimeType: textData.mimeType,\n          textContent: textData.textContent,\n          fileName: textData.fileName,\n        });\n      }\n    }\n\n    return { processedAttachments, linkedAssetIds };\n  }\n\n  async function linkAssetsToMessage(assetIds, messageId, userId) {\n    if (!assetIds || assetIds.length === 0) return;\n    await services.chatAssetsRepository.linkAssetsToMessage(assetIds, messageId, userId);\n  }\n\n  return {\n    createSignedAssetUrl,\n    uploadChatAsset,\n    listChatAssets,\n    deleteChatAsset,\n    getAssetForVision,\n    getAssetTextContent,\n    resolveAttachmentsForMessage,\n    linkAssetsToMessage,\n  };\n}\n\nconst chatAssetsService = createChatAssetsService();\n\nmodule.exports = {\n  createChatAssetsService,\n  chatAssetsService,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\assistant\\chatService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createChatService' has too many lines (71). Maximum allowed is 50.",
        "line": 5,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 91,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const chatRepository = require('../../repositories/chatRepository');\nconst { buildInitialChatTitle } = require('../../utils/chatTitle');\nconst { chatAssetsService: defaultChatAssetsService } = require('./chatAssetsService');\n\nfunction createChatService(deps = {}) {\n  const services = {\n    chatRepository: deps.chatRepository ?? chatRepository,\n    chatAssetsService: deps.chatAssetsService ?? defaultChatAssetsService,\n  };\n\n  async function listChats({ userId, limit, cursor } = {}) {\n    if (!userId) {\n      throw new Error('User context missing.');\n    }\n\n    return services.chatRepository.getRecentChats(userId, { limit, cursor });\n  }\n\n  async function getChatById({ userId, chatId } = {}) {\n    if (!userId || !chatId) {\n      throw new Error('getChatById requires userId and chatId');\n    }\n    return services.chatRepository.getChatById(userId, chatId);\n  }\n\n  async function createChatSession({ userId, titleSeed } = {}) {\n    if (!userId) {\n      throw new Error('User context missing.');\n    }\n\n    const chatTitle = buildInitialChatTitle(titleSeed || '');\n    return services.chatRepository.createChat(userId, chatTitle);\n  }\n\n  async function deleteChat({ userId, chatId } = {}) {\n    if (!userId || !chatId) {\n      throw new Error('deleteChat requires userId and chatId');\n    }\n\n    const chat = await services.chatRepository.getChatById(userId, chatId);\n    if (!chat) {\n      return { notFound: true };\n    }\n\n    await services.chatRepository.deleteChatMessages({ userId, chatId });\n    await services.chatRepository.deleteChat({ userId, chatId });\n\n    return { deleted: true };\n  }\n\n  async function listChatMessages({ userId, chatId } = {}) {\n    if (!userId || !chatId) {\n      throw new Error('listChatMessages requires userId and chatId');\n    }\n\n    const chat = await services.chatRepository.getChatById(userId, chatId);\n    if (!chat) {\n      return { notFound: true };\n    }\n\n    const messages = await services.chatRepository.getChatMessages(userId, chatId);\n    const assets = await services.chatAssetsService.listChatAssets({ userId, chatId });\n    const assetsByMessage = new Map();\n\n    for (const asset of assets) {\n      if (!asset.messageId) continue;\n      if (!assetsByMessage.has(asset.messageId)) {\n        assetsByMessage.set(asset.messageId, []);\n      }\n      assetsByMessage.get(asset.messageId).push(asset);\n    }\n\n    const response = messages.map((message) => {\n      const attachments = assetsByMessage.get(message.id);\n      if (!attachments || attachments.length === 0) {\n        return message;\n      }\n      return { ...message, attachments };\n    });\n\n    return { messages: response };\n  }\n\n  return {\n    listChats,\n    getChatById,\n    createChatSession,\n    deleteChat,\n    listChatMessages,\n  };\n}\n\nconst chatService = createChatService();\n\nmodule.exports = {\n  createChatService,\n  chatService,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\assistant\\chatTitleService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createChatTitleService' has too many lines (61). Maximum allowed is 50.",
        "line": 29,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 102,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { logger: baseLogger } = require('../../observability');\nconst chatRepository = require('../../repositories/chatRepository');\nconst { generateChatTitleFromHistory } = require('../llmClient');\nconst {\n  buildInitialChatTitle,\n  extractFirstUserMessage,\n  FALLBACK_TITLE,\n} = require('../../utils/chatTitle');\n\nfunction normalizeHistory(messages) {\n  return (messages || [])\n    .map((message) => {\n      const content =\n        (typeof message.content === 'string' && message.content.trim()) ||\n        (typeof message.input_text === 'string' && message.input_text.trim()) ||\n        (typeof message.output_text === 'string' && message.output_text.trim()) ||\n        '';\n\n      if (!content) return null;\n\n      return {\n        role: message.role === 'assistant' ? 'assistant' : 'user',\n        content: content.trim(),\n      };\n    })\n    .filter(Boolean);\n}\n\nfunction createChatTitleService(deps = {}) {\n  const services = {\n    chatRepository: deps.chatRepository ?? chatRepository,\n    llmClient: deps.llmClient ?? { generateChatTitleFromHistory },\n    logger: deps.logger ?? baseLogger,\n  };\n\n  async function generateChatTitleAsync(userId, chatId, fallbackText = '') {\n    try {\n      const messages = await services.chatRepository.getChatMessages(userId, chatId);\n      const normalizedHistory = normalizeHistory(messages);\n\n      const hasUser = normalizedHistory.some((message) => message.role === 'user');\n      const hasAssistant = normalizedHistory.some((message) => message.role === 'assistant');\n      if (normalizedHistory.length < 2 || !hasUser || !hasAssistant) {\n        return;\n      }\n\n      const fallbackTitle = buildInitialChatTitle(\n        extractFirstUserMessage(messages) || fallbackText || '',\n      );\n\n      const generatedTitle = await services.llmClient.generateChatTitleFromHistory({\n        history: normalizedHistory,\n        fallbackTitle,\n      });\n\n      await services.chatRepository.updateChatTitle(userId, chatId, generatedTitle);\n    } catch (error) {\n      services.logger.warn({ err: error }, 'Error in async title generation');\n    }\n  }\n\n  async function generateChatTitle({ userId, chatId, fallbackText = '' } = {}) {\n    const messages = await services.chatRepository.getChatMessages(userId, chatId);\n    const normalizedHistory = normalizeHistory(messages);\n\n    const fallbackTitle = buildInitialChatTitle(\n      extractFirstUserMessage(messages) || fallbackText || '',\n    );\n\n    const generatedTitle = await services.llmClient.generateChatTitleFromHistory({\n      history: normalizedHistory,\n      fallbackTitle,\n    });\n\n    const stored = await services.chatRepository.updateChatTitle(userId, chatId, generatedTitle);\n\n    return {\n      title: stored?.title || generatedTitle,\n      fallbackTitle,\n    };\n  }\n\n  async function buildFallbackTitle({ userId, chatId, fallbackText = '' } = {}) {\n    const messages = await services.chatRepository.getChatMessages(userId, chatId);\n    return buildInitialChatTitle(extractFirstUserMessage(messages) || fallbackText || '');\n  }\n\n  async function persistChatTitle({ userId, chatId, title } = {}) {\n    if (!userId || !chatId) {\n      throw new Error('persistChatTitle requires userId and chatId');\n    }\n    return services.chatRepository.updateChatTitle(userId, chatId, title);\n  }\n\n  return {\n    generateChatTitleAsync,\n    generateChatTitle,\n    buildFallbackTitle,\n    persistChatTitle,\n    FALLBACK_TITLE,\n  };\n}\n\nconst chatTitleService = createChatTitleService();\n\nmodule.exports = {\n  createChatTitleService,\n  chatTitleService,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\auth\\__tests__\\jwksProvider.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (238). Maximum allowed is 50.",
        "line": 14,
        "column": 26,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 297,
        "endColumn": 2
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 38,
        "column": 21,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 38,
        "endColumn": 47
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 42,
        "column": 21,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 42,
        "endColumn": 60
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 58,
        "column": 40,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 58,
        "endColumn": 42
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 24.",
        "line": 64,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 64,
        "endColumn": 23
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 64,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 64,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 64,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 64,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 67,
        "column": 40,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 67,
        "endColumn": 42
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 67,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 67,
        "endColumn": 47
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (97). Maximum allowed is 50.",
        "line": 71,
        "column": 23,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 189,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 169,
        "column": 60,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 169,
        "endColumn": 62
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit Tests for JWKS Provider\n *\n * Tests the JSON Web Key Set fetching and caching functionality.\n * Uses a mock fetcher to avoid network calls.\n *\n * @module services/auth/__tests__/jwksProvider.test\n */\n\nconst { describe, it } = require('node:test');\nconst assert = require('node:assert');\nconst { JwksProvider } = require('../jwksProvider');\n\ndescribe('JwksProvider', () => {\n  // Sample JWKS for testing\n  const sampleJwks = {\n    keys: [\n      {\n        kid: 'key-1',\n        alg: 'ES256',\n        kty: 'EC',\n        crv: 'P-256',\n        x: 'test-x-coordinate',\n        y: 'test-y-coordinate',\n      },\n      {\n        kid: 'key-2',\n        alg: 'RS256',\n        kty: 'RSA',\n        n: 'test-modulus',\n        e: 'AQAB',\n      },\n    ],\n  };\n\n  describe('constructor', () => {\n    it('should throw if jwksUri is not provided', () => {\n      assert.throws(() => new JwksProvider({}), /requires a valid jwksUri/);\n    });\n\n    it('should throw if jwksUri is empty string', () => {\n      assert.throws(() => new JwksProvider({ jwksUri: '' }), /requires a valid jwksUri/);\n    });\n\n    it('should accept valid jwksUri', () => {\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n      });\n      assert.ok(provider);\n    });\n\n    it('should enforce minimum cache TTL', () => {\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        cacheTtlMs: 1000, // 1 second (below minimum)\n      });\n      const status = provider.getCacheStatus();\n      assert.strictEqual(status.ttlMs, 60 * 1000); // Should be clamped to minimum\n    });\n\n    it('should enforce maximum cache TTL', () => {\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        cacheTtlMs: 24 * 60 * 60 * 1000, // 24 hours (above maximum)\n      });\n      const status = provider.getCacheStatus();\n      assert.strictEqual(status.ttlMs, 60 * 60 * 1000); // Should be clamped to maximum\n    });\n  });\n\n  describe('getKeys', () => {\n    it('should fetch and return JWKS', async () => {\n      const mockFetcher = async () => sampleJwks;\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      const result = await provider.getKeys();\n      assert.deepStrictEqual(result, sampleJwks);\n    });\n\n    it('should cache results', async () => {\n      let fetchCount = 0;\n      const mockFetcher = async () => {\n        fetchCount++;\n        return sampleJwks;\n      };\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      await provider.getKeys();\n      await provider.getKeys();\n      await provider.getKeys();\n\n      assert.strictEqual(fetchCount, 1); // Should only fetch once\n    });\n\n    it('should force refresh when requested', async () => {\n      let fetchCount = 0;\n      const mockFetcher = async () => {\n        fetchCount++;\n        return sampleJwks;\n      };\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      await provider.getKeys();\n      await provider.getKeys(true); // Force refresh\n\n      assert.strictEqual(fetchCount, 2);\n    });\n\n    it('should throw on invalid JWKS format', async () => {\n      const mockFetcher = async () => ({ invalid: 'format' });\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      await assert.rejects(provider.getKeys(), /Invalid JWKS format/);\n    });\n\n    it('should use stale cache as fallback on fetch error', async () => {\n      let shouldFail = false;\n      const mockFetcher = async () => {\n        if (shouldFail) {\n          throw new Error('Network error');\n        }\n        return sampleJwks;\n      };\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      // First successful fetch\n      await provider.getKeys();\n\n      // Simulate cache expiry and network failure\n      shouldFail = true;\n      provider._cacheExpiry = 0; // Force expiry\n\n      // Should return stale cache\n      const result = await provider.getKeys();\n      assert.deepStrictEqual(result, sampleJwks);\n    });\n\n    it('should throw if no cache and fetch fails', async () => {\n      const mockFetcher = async () => {\n        throw new Error('Network error');\n      };\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      await assert.rejects(provider.getKeys(), /Network error/);\n    });\n\n    it('should prevent thundering herd with concurrent requests', async () => {\n      let fetchCount = 0;\n      const mockFetcher = async () => {\n        fetchCount++;\n        await new Promise((resolve) => setTimeout(resolve, 50));\n        return sampleJwks;\n      };\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      // Make concurrent requests\n      const results = await Promise.all([\n        provider.getKeys(),\n        provider.getKeys(),\n        provider.getKeys(),\n      ]);\n\n      assert.strictEqual(fetchCount, 1); // Should only fetch once\n      results.forEach((result) => {\n        assert.deepStrictEqual(result, sampleJwks);\n      });\n    });\n  });\n\n  describe('getKeyById', () => {\n    it('should return matching key', async () => {\n      const mockFetcher = async () => sampleJwks;\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      const key = await provider.getKeyById('key-1');\n      assert.strictEqual(key.kid, 'key-1');\n      assert.strictEqual(key.alg, 'ES256');\n    });\n\n    it('should return null for non-existent key', async () => {\n      const mockFetcher = async () => sampleJwks;\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      const key = await provider.getKeyById('non-existent');\n      assert.strictEqual(key, null);\n    });\n\n    it('should refresh cache and retry if key not found', async () => {\n      let fetchCount = 0;\n      const mockFetcher = async () => {\n        fetchCount++;\n        return sampleJwks;\n      };\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      await provider.getKeyById('non-existent');\n      assert.strictEqual(fetchCount, 2); // Initial fetch + refresh attempt\n    });\n  });\n\n  describe('getFirstKey', () => {\n    it('should return first key', async () => {\n      const mockFetcher = async () => sampleJwks;\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      const key = await provider.getFirstKey();\n      assert.strictEqual(key.kid, 'key-1');\n    });\n\n    it('should return null for empty keys array', async () => {\n      const mockFetcher = async () => ({ keys: [] });\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      const key = await provider.getFirstKey();\n      assert.strictEqual(key, null);\n    });\n  });\n\n  describe('clearCache', () => {\n    it('should clear cached keys', async () => {\n      let fetchCount = 0;\n      const mockFetcher = async () => {\n        fetchCount++;\n        return sampleJwks;\n      };\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      await provider.getKeys();\n      provider.clearCache();\n      await provider.getKeys();\n\n      assert.strictEqual(fetchCount, 2);\n    });\n  });\n\n  describe('getCacheStatus', () => {\n    it('should return cache status', async () => {\n      const mockFetcher = async () => sampleJwks;\n      const provider = new JwksProvider({\n        jwksUri: 'https://example.com/.well-known/jwks.json',\n        fetcher: mockFetcher,\n      });\n\n      let status = provider.getCacheStatus();\n      assert.strictEqual(status.hasCachedKeys, false);\n      assert.strictEqual(status.keyCount, 0);\n      assert.strictEqual(status.isExpired, true);\n\n      await provider.getKeys();\n\n      status = provider.getCacheStatus();\n      assert.strictEqual(status.hasCachedKeys, true);\n      assert.strictEqual(status.keyCount, 2);\n      assert.strictEqual(status.isExpired, false);\n      assert.ok(status.expiresIn > 0);\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\auth\\__tests__\\jwtVerificationService.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (189). Maximum allowed is 50.",
        "line": 14,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 230,
        "endColumn": 2
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 18,
        "column": 9,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 18,
        "endColumn": 61
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 25,
        "column": 9,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 25,
        "endColumn": 68
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (118). Maximum allowed is 50.",
        "line": 56,
        "column": 22,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 188,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit Tests for JWT Verification Service\n *\n * Tests the Strategy Pattern implementation for JWT verification.\n * Uses mock strategies to test orchestration logic in isolation.\n *\n * @module services/auth/__tests__/jwtVerificationService.test\n */\n\nconst { describe, it } = require('node:test');\nconst assert = require('node:assert');\nconst { JwtVerificationService } = require('../jwtVerificationService');\n\ndescribe('JwtVerificationService', () => {\n  describe('constructor', () => {\n    it('should throw if no strategies provided', () => {\n      assert.throws(\n        () => new JwtVerificationService({ strategies: [] }),\n        /requires at least one strategy/,\n      );\n    });\n\n    it('should throw if strategies is not an array', () => {\n      assert.throws(\n        () => new JwtVerificationService({ strategies: 'invalid' }),\n        /requires at least one strategy/,\n      );\n    });\n\n    it('should throw if strategy lacks name', () => {\n      const invalidStrategy = { verify: async () => ({ valid: true }) };\n      assert.throws(\n        () => new JwtVerificationService({ strategies: [invalidStrategy] }),\n        /must have a \"name\" property/,\n      );\n    });\n\n    it('should throw if strategy lacks verify method', () => {\n      const invalidStrategy = { name: 'test' };\n      assert.throws(\n        () => new JwtVerificationService({ strategies: [invalidStrategy] }),\n        /must have a \"verify\" method/,\n      );\n    });\n\n    it('should accept valid strategies', () => {\n      const validStrategy = {\n        name: 'test',\n        verify: async () => ({ valid: true }),\n      };\n      const service = new JwtVerificationService({ strategies: [validStrategy] });\n      assert.ok(service);\n    });\n  });\n\n  describe('verify', () => {\n    it('should return invalid for empty token', async () => {\n      const strategy = {\n        name: 'test',\n        verify: async () => ({ valid: true }),\n      };\n      const service = new JwtVerificationService({ strategies: [strategy] });\n\n      const result = await service.verify('');\n      assert.strictEqual(result.valid, false);\n      assert.ok(result.error.includes('non-empty string'));\n    });\n\n    it('should return invalid for null token', async () => {\n      const strategy = {\n        name: 'test',\n        verify: async () => ({ valid: true }),\n      };\n      const service = new JwtVerificationService({ strategies: [strategy] });\n\n      const result = await service.verify(null);\n      assert.strictEqual(result.valid, false);\n    });\n\n    it('should use first successful strategy', async () => {\n      const strategy1 = {\n        name: 'strategy1',\n        verify: async () => ({ valid: true, payload: { sub: 'user1' } }),\n      };\n      const strategy2 = {\n        name: 'strategy2',\n        verify: async () => ({ valid: true, payload: { sub: 'user2' } }),\n      };\n      const service = new JwtVerificationService({ strategies: [strategy1, strategy2] });\n\n      const result = await service.verify('test-token');\n      assert.strictEqual(result.valid, true);\n      assert.strictEqual(result.strategy, 'strategy1');\n      assert.strictEqual(result.payload.sub, 'user1');\n    });\n\n    it('should fallback to second strategy if first fails', async () => {\n      const strategy1 = {\n        name: 'strategy1',\n        verify: async () => ({ valid: false, error: 'First failed' }),\n      };\n      const strategy2 = {\n        name: 'strategy2',\n        verify: async () => ({ valid: true, payload: { sub: 'user2' } }),\n      };\n      const service = new JwtVerificationService({ strategies: [strategy1, strategy2] });\n\n      const result = await service.verify('test-token');\n      assert.strictEqual(result.valid, true);\n      assert.strictEqual(result.strategy, 'strategy2');\n    });\n\n    it('should skip unavailable strategies', async () => {\n      const strategy1 = {\n        name: 'unavailable',\n        isAvailable: () => false,\n        verify: async () => ({ valid: true, payload: { sub: 'user1' } }),\n      };\n      const strategy2 = {\n        name: 'available',\n        isAvailable: () => true,\n        verify: async () => ({ valid: true, payload: { sub: 'user2' } }),\n      };\n      const service = new JwtVerificationService({ strategies: [strategy1, strategy2] });\n\n      const result = await service.verify('test-token');\n      assert.strictEqual(result.valid, true);\n      assert.strictEqual(result.strategy, 'available');\n    });\n\n    it('should handle strategy that throws error', async () => {\n      const strategy1 = {\n        name: 'throwing',\n        verify: async () => {\n          throw new Error('Network error');\n        },\n      };\n      const strategy2 = {\n        name: 'working',\n        verify: async () => ({ valid: true, payload: { sub: 'user2' } }),\n      };\n      const service = new JwtVerificationService({ strategies: [strategy1, strategy2] });\n\n      const result = await service.verify('test-token');\n      assert.strictEqual(result.valid, true);\n      assert.strictEqual(result.strategy, 'working');\n    });\n\n    it('should return combined error when all strategies fail', async () => {\n      const strategy1 = {\n        name: 'first',\n        verify: async () => ({ valid: false, error: 'Error 1' }),\n      };\n      const strategy2 = {\n        name: 'second',\n        verify: async () => ({ valid: false, error: 'Error 2' }),\n      };\n      const service = new JwtVerificationService({ strategies: [strategy1, strategy2] });\n\n      const result = await service.verify('test-token');\n      assert.strictEqual(result.valid, false);\n      assert.ok(result.error.includes('first: Error 1'));\n      assert.ok(result.error.includes('second: Error 2'));\n    });\n\n    it('should fail fast when failFast is true', async () => {\n      let strategy2Called = false;\n      const strategy1 = {\n        name: 'first',\n        verify: async () => ({ valid: false, error: 'First error' }),\n      };\n      const strategy2 = {\n        name: 'second',\n        verify: async () => {\n          strategy2Called = true;\n          return { valid: true, payload: {} };\n        },\n      };\n      const service = new JwtVerificationService({\n        strategies: [strategy1, strategy2],\n        failFast: true,\n      });\n\n      const result = await service.verify('test-token');\n      assert.strictEqual(result.valid, false);\n      assert.strictEqual(strategy2Called, false);\n    });\n  });\n\n  describe('getAvailableStrategies', () => {\n    it('should return all strategies when none have isAvailable', () => {\n      const strategies = [\n        { name: 'a', verify: async () => ({ valid: true }) },\n        { name: 'b', verify: async () => ({ valid: true }) },\n      ];\n      const service = new JwtVerificationService({ strategies });\n\n      assert.deepStrictEqual(service.getAvailableStrategies(), ['a', 'b']);\n    });\n\n    it('should filter out unavailable strategies', () => {\n      const strategies = [\n        { name: 'a', isAvailable: () => true, verify: async () => ({ valid: true }) },\n        { name: 'b', isAvailable: () => false, verify: async () => ({ valid: true }) },\n        { name: 'c', isAvailable: () => true, verify: async () => ({ valid: true }) },\n      ];\n      const service = new JwtVerificationService({ strategies });\n\n      assert.deepStrictEqual(service.getAvailableStrategies(), ['a', 'c']);\n    });\n  });\n\n  describe('hasAvailableStrategy', () => {\n    it('should return true when strategies are available', () => {\n      const strategies = [{ name: 'a', verify: async () => ({ valid: true }) }];\n      const service = new JwtVerificationService({ strategies });\n\n      assert.strictEqual(service.hasAvailableStrategy(), true);\n    });\n\n    it('should return false when no strategies are available', () => {\n      const strategies = [\n        { name: 'a', isAvailable: () => false, verify: async () => ({ valid: true }) },\n      ];\n      const service = new JwtVerificationService({ strategies });\n\n      assert.strictEqual(service.hasAvailableStrategy(), false);\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\auth\\__tests__\\strategies.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (86). Maximum allowed is 50.",
        "line": 18,
        "column": 39,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 127,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (63). Maximum allowed is 50.",
        "line": 45,
        "column": 22,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 126,
        "endColumn": 4
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (67). Maximum allowed is 50.",
        "line": 129,
        "column": 41,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 204,
        "endColumn": 2
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 132,
        "column": 21,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 132,
        "endColumn": 62
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (51). Maximum allowed is 50.",
        "line": 146,
        "column": 22,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 203,
        "endColumn": 4
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (56). Maximum allowed is 50.",
        "line": 206,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 273,
        "endColumn": 2
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 209,
        "column": 21,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 209,
        "endColumn": 55
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit Tests for JWT Verifier Strategies\n *\n * Tests individual verification strategies in isolation.\n *\n * @module services/auth/__tests__/strategies.test\n */\n\nconst { describe, it } = require('node:test');\nconst assert = require('node:assert');\nconst jwt = require('jsonwebtoken');\nconst {\n  SymmetricVerifierStrategy,\n  SupabaseSdkVerifierStrategy,\n  JwksVerifierStrategy,\n} = require('../strategies');\n\ndescribe('SymmetricVerifierStrategy', () => {\n  const secret = 'super-secret-key-with-at-least-32-chars-for-hs256';\n\n  describe('constructor', () => {\n    it('should create strategy without secret', () => {\n      const strategy = new SymmetricVerifierStrategy({});\n      assert.strictEqual(strategy.name, 'symmetric');\n    });\n\n    it('should create strategy with secret', () => {\n      const strategy = new SymmetricVerifierStrategy({ secret });\n      assert.strictEqual(strategy.isAvailable(), true);\n    });\n  });\n\n  describe('isAvailable', () => {\n    it('should return false when no secret', () => {\n      const strategy = new SymmetricVerifierStrategy({});\n      assert.strictEqual(strategy.isAvailable(), false);\n    });\n\n    it('should return true when secret provided', () => {\n      const strategy = new SymmetricVerifierStrategy({ secret });\n      assert.strictEqual(strategy.isAvailable(), true);\n    });\n  });\n\n  describe('verify', () => {\n    it('should return invalid when no secret configured', async () => {\n      const strategy = new SymmetricVerifierStrategy({});\n      const result = await strategy.verify('any-token');\n      assert.strictEqual(result.valid, false);\n      assert.ok(result.error.includes('No symmetric secret configured'));\n    });\n\n    it('should verify valid HS256 token', async () => {\n      const strategy = new SymmetricVerifierStrategy({ secret });\n\n      const token = jwt.sign(\n        { sub: 'user-123', email: 'test@example.com', role: 'authenticated' },\n        secret,\n        { algorithm: 'HS256' },\n      );\n\n      const result = await strategy.verify(token);\n      assert.strictEqual(result.valid, true);\n      assert.strictEqual(result.payload.id, 'user-123');\n      assert.strictEqual(result.payload.email, 'test@example.com');\n    });\n\n    it('should reject token with wrong secret', async () => {\n      const strategy = new SymmetricVerifierStrategy({ secret });\n\n      const token = jwt.sign({ sub: 'user-123' }, 'wrong-secret', { algorithm: 'HS256' });\n\n      const result = await strategy.verify(token);\n      assert.strictEqual(result.valid, false);\n      assert.ok(result.error.includes('invalid signature'));\n    });\n\n    it('should reject expired token', async () => {\n      const strategy = new SymmetricVerifierStrategy({ secret });\n\n      const token = jwt.sign({ sub: 'user-123' }, secret, {\n        algorithm: 'HS256',\n        expiresIn: -10, // Already expired\n      });\n\n      const result = await strategy.verify(token);\n      assert.strictEqual(result.valid, false);\n      assert.ok(result.error.includes('expired'));\n    });\n\n    it('should reject malformed token', async () => {\n      const strategy = new SymmetricVerifierStrategy({ secret });\n\n      const result = await strategy.verify('not-a-valid-jwt');\n      assert.strictEqual(result.valid, false);\n    });\n\n    it('should verify issuer when specified', async () => {\n      const strategy = new SymmetricVerifierStrategy({\n        secret,\n        issuer: 'expected-issuer',\n      });\n\n      const validToken = jwt.sign({ sub: 'user-123', iss: 'expected-issuer' }, secret);\n      const invalidToken = jwt.sign({ sub: 'user-123', iss: 'wrong-issuer' }, secret);\n\n      const validResult = await strategy.verify(validToken);\n      assert.strictEqual(validResult.valid, true);\n\n      const invalidResult = await strategy.verify(invalidToken);\n      assert.strictEqual(invalidResult.valid, false);\n    });\n\n    it('should reject non-allowed algorithms', async () => {\n      const strategy = new SymmetricVerifierStrategy({\n        secret,\n        allowedAlgorithms: ['HS256'],\n      });\n\n      // Create HS384 token (not allowed)\n      const token = jwt.sign({ sub: 'user-123' }, secret, { algorithm: 'HS384' });\n\n      const result = await strategy.verify(token);\n      assert.strictEqual(result.valid, false);\n    });\n  });\n});\n\ndescribe('SupabaseSdkVerifierStrategy', () => {\n  describe('constructor', () => {\n    it('should throw if supabaseClient not provided', () => {\n      assert.throws(() => new SupabaseSdkVerifierStrategy({}), /requires a supabaseClient/);\n    });\n\n    it('should accept valid supabaseClient', () => {\n      const mockClient = {\n        auth: {\n          getUser: async () => ({ data: { user: {} }, error: null }),\n        },\n      };\n      const strategy = new SupabaseSdkVerifierStrategy({ supabaseClient: mockClient });\n      assert.strictEqual(strategy.name, 'supabase-sdk');\n    });\n  });\n\n  describe('verify', () => {\n    it('should return valid when SDK returns user', async () => {\n      const mockUser = { id: 'user-123', email: 'test@example.com' };\n      const mockClient = {\n        auth: {\n          getUser: async () => ({ data: { user: mockUser }, error: null }),\n        },\n      };\n      const strategy = new SupabaseSdkVerifierStrategy({ supabaseClient: mockClient });\n\n      const result = await strategy.verify('test-token');\n      assert.strictEqual(result.valid, true);\n      assert.strictEqual(result.payload.id, 'user-123');\n    });\n\n    it('should return invalid when SDK returns error', async () => {\n      const mockClient = {\n        auth: {\n          getUser: async () => ({\n            data: { user: null },\n            error: { message: 'Invalid token' },\n          }),\n        },\n      };\n      const strategy = new SupabaseSdkVerifierStrategy({ supabaseClient: mockClient });\n\n      const result = await strategy.verify('test-token');\n      assert.strictEqual(result.valid, false);\n      assert.ok(result.error.includes('Invalid token'));\n    });\n\n    it('should return invalid when SDK returns no user', async () => {\n      const mockClient = {\n        auth: {\n          getUser: async () => ({ data: { user: null }, error: null }),\n        },\n      };\n      const strategy = new SupabaseSdkVerifierStrategy({ supabaseClient: mockClient });\n\n      const result = await strategy.verify('test-token');\n      assert.strictEqual(result.valid, false);\n    });\n\n    it('should handle SDK throwing error', async () => {\n      const mockClient = {\n        auth: {\n          getUser: async () => {\n            throw new Error('Network error');\n          },\n        },\n      };\n      const strategy = new SupabaseSdkVerifierStrategy({ supabaseClient: mockClient });\n\n      const result = await strategy.verify('test-token');\n      assert.strictEqual(result.valid, false);\n      assert.ok(result.error.includes('Network error'));\n    });\n  });\n});\n\ndescribe('JwksVerifierStrategy', () => {\n  describe('constructor', () => {\n    it('should throw if jwksProvider not provided', () => {\n      assert.throws(() => new JwksVerifierStrategy({}), /requires a jwksProvider/);\n    });\n\n    it('should accept valid jwksProvider', () => {\n      const mockProvider = { getKeyById: async () => null, getFirstKey: async () => null };\n      const strategy = new JwksVerifierStrategy({ jwksProvider: mockProvider });\n      assert.strictEqual(strategy.name, 'jwks');\n    });\n  });\n\n  describe('isAvailable', () => {\n    it('should always return true', () => {\n      const mockProvider = { getKeyById: async () => null, getFirstKey: async () => null };\n      const strategy = new JwksVerifierStrategy({ jwksProvider: mockProvider });\n      assert.strictEqual(strategy.isAvailable(), true);\n    });\n  });\n\n  describe('verify', () => {\n    it('should return invalid for malformed JWT', async () => {\n      const mockProvider = { getKeyById: async () => null, getFirstKey: async () => null };\n      const strategy = new JwksVerifierStrategy({ jwksProvider: mockProvider });\n\n      const result = await strategy.verify('not-a-jwt');\n      assert.strictEqual(result.valid, false);\n      assert.ok(result.error.includes('Invalid JWT format'));\n    });\n\n    it('should reject unsupported algorithm', async () => {\n      const mockProvider = { getKeyById: async () => null, getFirstKey: async () => null };\n      const strategy = new JwksVerifierStrategy({\n        jwksProvider: mockProvider,\n        allowedAlgorithms: ['ES256'],\n      });\n\n      // Create an HS256 token (symmetric, but we're testing algorithm check)\n      const token = jwt.sign({ sub: 'user-123' }, 'secret', { algorithm: 'HS256' });\n\n      const result = await strategy.verify(token);\n      assert.strictEqual(result.valid, false);\n      assert.ok(result.error.includes('Unsupported algorithm'));\n    });\n\n    it('should return invalid when no matching key found', async () => {\n      const mockProvider = {\n        getKeyById: async () => null,\n        getFirstKey: async () => null,\n      };\n      const strategy = new JwksVerifierStrategy({\n        jwksProvider: mockProvider,\n        allowedAlgorithms: ['ES256', 'HS256'], // Allow HS256 to pass algorithm check\n      });\n\n      // Create a token that will pass algorithm check\n      const token = jwt.sign({ sub: 'user-123' }, 'secret', {\n        algorithm: 'HS256',\n        keyid: 'test-kid',\n      });\n\n      const result = await strategy.verify(token);\n      assert.strictEqual(result.valid, false);\n      assert.ok(result.error.includes('No matching key found'));\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\auth\\index.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\auth\\jwksProvider.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 27,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 27,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 27,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 27,
        "endColumn": 37
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 32,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 32,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 37,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 37,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 37,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 37,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10000.",
        "line": 58,
        "column": 24,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 58,
        "endColumn": 29
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 97,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 97,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 502.",
        "line": 97,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 97,
        "endColumn": 37
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 503.",
        "line": 97,
        "column": 39,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 97,
        "endColumn": 42
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 504.",
        "line": 97,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 97,
        "endColumn": 47
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * JWKS (JSON Web Key Set) Provider\n *\n * Fetches and caches public keys from a JWKS endpoint for JWT verification.\n * Supports automatic key rotation and cache invalidation.\n *\n * SOLID Principles Applied:\n * - Single Responsibility: Only responsible for fetching and caching JWKS\n * - Open/Closed: Cache strategy can be extended without modifying core logic\n * - Dependency Inversion: Depends on fetch abstraction, not concrete implementation\n *\n * Security Considerations:\n * - Keys are cached to reduce latency and prevent JWKS endpoint DoS\n * - Cache TTL is configurable to balance freshness vs performance\n * - Supports multiple key IDs (kid) for key rotation\n *\n * @module services/auth/jwksProvider\n */\n\nconst { logger } = require('../../observability');\nconst { fetchWithRetry } = require('../../utils/networkRetry');\n\n/**\n * Default cache TTL in milliseconds (10 minutes)\n * Supabase Edge caches JWKS for 10 minutes, so we match that\n */\nconst DEFAULT_CACHE_TTL_MS = 10 * 60 * 1000;\n\n/**\n * Minimum cache TTL (1 minute) - prevents excessive requests\n */\nconst MIN_CACHE_TTL_MS = 60 * 1000;\n\n/**\n * Maximum cache TTL (1 hour) - ensures keys stay relatively fresh\n */\nconst MAX_CACHE_TTL_MS = 60 * 60 * 1000;\n\n/**\n * JWKS Provider\n *\n * Manages fetching and caching of JSON Web Key Sets from remote endpoints.\n */\nclass JwksProvider {\n  /**\n   * Create a new JwksProvider\n   *\n   * @param {Object} options - Configuration options\n   * @param {string} options.jwksUri - The JWKS endpoint URL\n   * @param {number} [options.cacheTtlMs=600000] - Cache TTL in milliseconds\n   * @param {function} [options.fetcher] - Custom fetch function for testing\n   * @param {number} [options.requestTimeoutMs=10000] - Request timeout in ms\n   */\n  constructor({\n    jwksUri,\n    cacheTtlMs = DEFAULT_CACHE_TTL_MS,\n    fetcher = null,\n    requestTimeoutMs = 10000,\n  } = {}) {\n    if (!jwksUri || typeof jwksUri !== 'string') {\n      throw new Error('JwksProvider requires a valid jwksUri');\n    }\n\n    this._jwksUri = jwksUri;\n    this._cacheTtlMs = Math.max(MIN_CACHE_TTL_MS, Math.min(cacheTtlMs, MAX_CACHE_TTL_MS));\n    this._fetcher = fetcher || this._defaultFetcher.bind(this);\n    this._requestTimeoutMs = requestTimeoutMs;\n\n    // Cache state\n    this._cache = null;\n    this._cacheExpiry = 0;\n    this._fetchPromise = null; // Prevents thundering herd\n\n    logger.debug('[JwksProvider] Initialized', {\n      jwksUri: this._jwksUri,\n      cacheTtlMs: this._cacheTtlMs,\n    });\n  }\n\n  /**\n   * Default fetcher using global fetch\n   *\n   * @param {string} url - URL to fetch\n   * @returns {Promise<Object>} Parsed JSON response\n   */\n  async _defaultFetcher(url) {\n    const response = await fetchWithRetry(\n      url,\n      {\n        headers: {\n          Accept: 'application/json',\n        },\n      },\n      {\n        maxRetries: 2,\n        timeoutMs: this._requestTimeoutMs,\n        retryableStatuses: [429, 502, 503, 504],\n        retryOnServerError: true,\n        onRetry: (info) => {\n          logger.warn('[JwksProvider] Retry JWKS fetch', {\n            attempt: info.attempt,\n            delayMs: info.delayMs,\n            status: info.status,\n          });\n        },\n      },\n    );\n\n    if (!response.ok) {\n      throw new Error(`JWKS fetch failed: ${response.status} ${response.statusText}`);\n    }\n\n    return await response.json();\n  }\n\n  /**\n   * Get the JWKS, using cache if available\n   *\n   * @param {boolean} [forceRefresh=false] - Force a fresh fetch\n   * @returns {Promise<Object>} The JWKS object with keys array\n   */\n  async getKeys(forceRefresh = false) {\n    const now = Date.now();\n\n    // Return cached value if valid and not forcing refresh\n    if (!forceRefresh && this._cache && now < this._cacheExpiry) {\n      logger.debug('[JwksProvider] Returning cached JWKS');\n      return this._cache;\n    }\n\n    // Prevent thundering herd - if a fetch is in progress, wait for it\n    if (this._fetchPromise) {\n      logger.debug('[JwksProvider] Waiting for in-progress fetch');\n      return this._fetchPromise;\n    }\n\n    // Perform the fetch\n    this._fetchPromise = this._fetchKeys();\n\n    try {\n      const result = await this._fetchPromise;\n      return result;\n    } finally {\n      this._fetchPromise = null;\n    }\n  }\n\n  /**\n   * Fetch keys from the JWKS endpoint\n   *\n   * @returns {Promise<Object>} The JWKS object\n   */\n  async _fetchKeys() {\n    logger.debug('[JwksProvider] Fetching JWKS from', { uri: this._jwksUri });\n\n    try {\n      const jwks = await this._fetcher(this._jwksUri);\n\n      // Validate JWKS structure\n      if (!jwks || !Array.isArray(jwks.keys)) {\n        throw new Error('Invalid JWKS format: missing keys array');\n      }\n\n      // Update cache\n      this._cache = jwks;\n      this._cacheExpiry = Date.now() + this._cacheTtlMs;\n\n      logger.debug('[JwksProvider] JWKS fetched and cached', {\n        keyCount: jwks.keys.length,\n        keyIds: jwks.keys.map((k) => k.kid).filter(Boolean),\n      });\n\n      return jwks;\n    } catch (error) {\n      logger.error('[JwksProvider] Failed to fetch JWKS:', { error: error.message });\n\n      // If we have stale cache, use it as fallback\n      if (this._cache) {\n        logger.warn('[JwksProvider] Using stale cache as fallback');\n        return this._cache;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get a specific key by key ID (kid)\n   *\n   * @param {string} kid - The key ID to find\n   * @returns {Promise<Object|null>} The JWK or null if not found\n   */\n  async getKeyById(kid) {\n    const jwks = await this.getKeys();\n    const key = jwks.keys.find((k) => k.kid === kid);\n\n    if (!key) {\n      logger.debug('[JwksProvider] Key not found, refreshing cache', { kid });\n\n      // Key not found - try refreshing in case of key rotation\n      const refreshedJwks = await this.getKeys(true);\n      return refreshedJwks.keys.find((k) => k.kid === kid) || null;\n    }\n\n    return key;\n  }\n\n  /**\n   * Get the first available signing key\n   *\n   * Useful when tokens don't include a kid header\n   *\n   * @returns {Promise<Object|null>} The first JWK or null\n   */\n  async getFirstKey() {\n    const jwks = await this.getKeys();\n    return jwks.keys[0] || null;\n  }\n\n  /**\n   * Clear the cache, forcing a fresh fetch on next request\n   */\n  clearCache() {\n    this._cache = null;\n    this._cacheExpiry = 0;\n    logger.debug('[JwksProvider] Cache cleared');\n  }\n\n  /**\n   * Get cache status for monitoring/debugging\n   *\n   * @returns {Object} Cache status info\n   */\n  getCacheStatus() {\n    const now = Date.now();\n    return {\n      hasCachedKeys: Boolean(this._cache),\n      keyCount: this._cache?.keys?.length || 0,\n      isExpired: now >= this._cacheExpiry,\n      expiresIn: Math.max(0, this._cacheExpiry - now),\n      ttlMs: this._cacheTtlMs,\n    };\n  }\n}\n\nmodule.exports = { JwksProvider };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\auth\\jwtVerificationService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async method 'verify' has too many lines (51). Maximum allowed is 50.",
        "line": 95,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "exceed",
        "endLine": 160,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async method 'verify' has too many statements (22). Maximum allowed is 20.",
        "line": 95,
        "column": 15,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 160,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * JWT Verification Service\n *\n * Orchestrates JWT verification using the Strategy Pattern.\n * This service is the main entry point for token validation in the application.\n *\n * SOLID Principles Applied:\n * - Single Responsibility: Only responsible for orchestrating verification\n * - Open/Closed: New verification strategies can be added without modifying this class\n * - Liskov Substitution: All strategies implement the same interface\n * - Interface Segregation: Minimal interface for verifiers\n * - Dependency Inversion: Depends on abstractions (strategy interface), not concretions\n *\n * Design Patterns:\n * - Strategy Pattern: Pluggable verification algorithms\n * - Chain of Responsibility: Falls back through multiple strategies\n *\n * @module services/auth/jwtVerificationService\n */\n\nconst { logger } = require('../../observability');\n\n/**\n * @typedef {Object} VerificationResult\n * @property {boolean} valid - Whether the token is valid\n * @property {Object} [payload] - The decoded JWT payload if valid\n * @property {string} [error] - Error message if invalid\n * @property {string} [strategy] - Which strategy successfully verified the token\n */\n\n/**\n * @typedef {Object} JwtVerifierStrategy\n * @property {string} name - Strategy name for logging/debugging\n * @property {function(string): Promise<VerificationResult>} verify - Verify a JWT token\n * @property {function(): boolean} [isAvailable] - Check if strategy can be used\n */\n\n/**\n * JWT Verification Service\n *\n * Manages multiple verification strategies and provides a unified interface\n * for token validation with automatic fallback support.\n */\nclass JwtVerificationService {\n  /**\n   * Create a new JwtVerificationService\n   *\n   * @param {Object} options - Configuration options\n   * @param {JwtVerifierStrategy[]} options.strategies - Ordered list of verification strategies\n   * @param {boolean} [options.failFast=false] - If true, don't try fallback strategies\n   */\n  constructor({ strategies = [], failFast = false } = {}) {\n    if (!Array.isArray(strategies) || strategies.length === 0) {\n      throw new Error('JwtVerificationService requires at least one strategy');\n    }\n\n    this._strategies = strategies;\n    this._failFast = failFast;\n\n    // Validate all strategies implement required interface\n    for (const strategy of strategies) {\n      this._validateStrategy(strategy);\n    }\n\n    logger.debug('[JwtVerificationService] Initialized with strategies:', {\n      strategies: strategies.map((s) => s.name),\n      failFast,\n    });\n  }\n\n  /**\n   * Validate that a strategy implements the required interface\n   *\n   * @param {JwtVerifierStrategy} strategy\n   * @throws {Error} If strategy is invalid\n   */\n  _validateStrategy(strategy) {\n    if (!strategy.name || typeof strategy.name !== 'string') {\n      throw new Error('Strategy must have a \"name\" property');\n    }\n    if (typeof strategy.verify !== 'function') {\n      throw new Error(`Strategy \"${strategy.name}\" must have a \"verify\" method`);\n    }\n  }\n\n  /**\n   * Verify a JWT token using available strategies\n   *\n   * Tries each strategy in order until one succeeds.\n   * This provides resilience and supports migration between auth methods.\n   *\n   * @param {string} token - The JWT token to verify\n   * @returns {Promise<VerificationResult>} Verification result\n   */\n  async verify(token) {\n    if (!token || typeof token !== 'string') {\n      return {\n        valid: false,\n        error: 'Token must be a non-empty string',\n      };\n    }\n\n    const errors = [];\n\n    for (const strategy of this._strategies) {\n      // Check if strategy is available (e.g., has required config)\n      if (strategy.isAvailable && !strategy.isAvailable()) {\n        logger.debug(\n          `[JwtVerificationService] Strategy \"${strategy.name}\" not available, skipping`,\n        );\n        continue;\n      }\n\n      try {\n        const result = await strategy.verify(token);\n\n        if (result.valid) {\n          logger.debug(`[JwtVerificationService] Token verified by \"${strategy.name}\"`);\n          return {\n            ...result,\n            strategy: strategy.name,\n          };\n        }\n\n        // Strategy returned invalid but no error\n        errors.push({\n          strategy: strategy.name,\n          error: result.error || 'Verification failed',\n        });\n\n        // If failFast is enabled, don't try other strategies\n        if (this._failFast) {\n          break;\n        }\n      } catch (err) {\n        errors.push({\n          strategy: strategy.name,\n          error: err.message,\n        });\n\n        logger.debug(`[JwtVerificationService] Strategy \"${strategy.name}\" threw error:`, {\n          error: err.message,\n        });\n\n        // If failFast is enabled, propagate the error\n        if (this._failFast) {\n          break;\n        }\n      }\n    }\n\n    // All strategies failed\n    const errorSummary = errors.map((e) => `${e.strategy}: ${e.error}`).join('; ');\n    logger.warn('[JwtVerificationService] All strategies failed:', { errors });\n\n    return {\n      valid: false,\n      error: `Token verification failed: ${errorSummary}`,\n    };\n  }\n\n  /**\n   * Get list of available strategy names\n   *\n   * @returns {string[]} Array of available strategy names\n   */\n  getAvailableStrategies() {\n    return this._strategies.filter((s) => !s.isAvailable || s.isAvailable()).map((s) => s.name);\n  }\n\n  /**\n   * Check if the service has any available strategies\n   *\n   * @returns {boolean} True if at least one strategy is available\n   */\n  hasAvailableStrategy() {\n    return this.getAvailableStrategies().length > 0;\n  }\n}\n\nmodule.exports = { JwtVerificationService };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\auth\\jwtVerifierFactory.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createJwtVerifierForConfig' has too many lines (85). Maximum allowed is 50.",
        "line": 33,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 139,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'createJwtVerifierForConfig' has too many statements (41). Maximum allowed is 20.",
        "line": 33,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 139,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * JWT Verifier Factory\n *\n * Creates a properly configured JwtVerificationService based on environment\n * and configuration. This factory encapsulates the complexity of choosing\n * the right verification strategy for different deployment scenarios.\n *\n * Deployment Scenarios:\n * 1. Local Supabase (ES256): Uses JWKS endpoint for asymmetric key verification\n * 2. Local Supabase (Legacy HS256): Falls back to symmetric key verification\n * 3. Cloud Supabase: Uses Supabase SDK for most reliable verification\n *\n * @module services/auth/jwtVerifierFactory\n */\n\nconst { JwtVerificationService } = require('./jwtVerificationService');\nconst { JwksProvider } = require('./jwksProvider');\nconst {\n  JwksVerifierStrategy,\n  SymmetricVerifierStrategy,\n  SupabaseSdkVerifierStrategy,\n} = require('./strategies');\nconst { logger } = require('../../observability');\n\n/**\n * Create a JWT verifier service configured for the current environment\n *\n * @param {Object} options - Configuration options\n * @param {Object} options.config - Application configuration\n * @param {Object} [options.supabaseClient] - Supabase client for SDK verification\n * @returns {JwtVerificationService} Configured verification service\n */\nfunction createJwtVerifierForConfig({ config, supabaseClient = null }) {\n  const strategies = [];\n\n  const isLocal = config.SUPABASE_IS_LOCAL;\n  const supabaseUrl = config.SUPABASE_URL;\n  const jwtSecret = config.SUPABASE_JWT_SECRET;\n\n  logger.info('[JwtVerifierFactory] Creating verifier', {\n    isLocal,\n    hasJwtSecret: Boolean(jwtSecret),\n    hasSupabaseClient: Boolean(supabaseClient),\n  });\n\n  if (isLocal) {\n    // Local Supabase: Try JWKS first (ES256), then symmetric (HS256) as fallback\n\n    // Strategy 1: JWKS verification for ES256 tokens (Supabase CLI v1.x+)\n    const jwksUri = `${supabaseUrl}/auth/v1/.well-known/jwks.json`;\n\n    try {\n      const jwksProvider = new JwksProvider({ jwksUri });\n      // Local Supabase uses the auth endpoint as the issuer\n      const localIssuer = `${supabaseUrl}/auth/v1`;\n      const jwksStrategy = new JwksVerifierStrategy({\n        jwksProvider,\n        allowedAlgorithms: ['ES256', 'RS256'],\n        issuer: localIssuer,\n      });\n      strategies.push(jwksStrategy);\n      logger.debug('[JwtVerifierFactory] Added JWKS strategy for local Supabase', {\n        issuer: localIssuer,\n      });\n    } catch (error) {\n      logger.warn('[JwtVerifierFactory] Failed to create JWKS strategy:', { error: error.message });\n    }\n\n    // Strategy 2: Symmetric key verification (legacy HS256 tokens)\n    if (jwtSecret) {\n      const symmetricStrategy = new SymmetricVerifierStrategy({\n        secret: jwtSecret,\n        allowedAlgorithms: ['HS256', 'HS384', 'HS512'],\n      });\n      strategies.push(symmetricStrategy);\n      logger.debug('[JwtVerifierFactory] Added symmetric strategy for legacy tokens');\n    }\n\n    // Strategy 3: Supabase SDK as last resort for local (user tokens)\n    if (supabaseClient) {\n      const sdkStrategy = new SupabaseSdkVerifierStrategy({\n        supabaseClient,\n      });\n      strategies.push(sdkStrategy);\n      logger.debug('[JwtVerifierFactory] Added Supabase SDK strategy');\n    }\n  } else {\n    // Cloud Supabase: SDK first (most reliable), then JWKS, then symmetric\n\n    // Strategy 1: Supabase SDK (recommended for cloud)\n    if (supabaseClient) {\n      const sdkStrategy = new SupabaseSdkVerifierStrategy({\n        supabaseClient,\n      });\n      strategies.push(sdkStrategy);\n      logger.debug('[JwtVerifierFactory] Added Supabase SDK strategy for cloud');\n    }\n\n    // Strategy 2: JWKS verification (for third-party tokens or custom signing keys)\n    if (supabaseUrl) {\n      const jwksUri = `${supabaseUrl}/auth/v1/.well-known/jwks.json`;\n\n      try {\n        const jwksProvider = new JwksProvider({ jwksUri });\n        const jwksStrategy = new JwksVerifierStrategy({\n          jwksProvider,\n          allowedAlgorithms: ['ES256', 'RS256'],\n        });\n        strategies.push(jwksStrategy);\n        logger.debug('[JwtVerifierFactory] Added JWKS strategy for cloud');\n      } catch (error) {\n        logger.warn('[JwtVerifierFactory] Failed to create JWKS strategy:', {\n          error: error.message,\n        });\n      }\n    }\n\n    // Strategy 3: Symmetric key (legacy, discouraged)\n    if (jwtSecret) {\n      const symmetricStrategy = new SymmetricVerifierStrategy({\n        secret: jwtSecret,\n        allowedAlgorithms: ['HS256', 'HS384', 'HS512'],\n      });\n      strategies.push(symmetricStrategy);\n      logger.warn(\n        '[JwtVerifierFactory] Using symmetric key verification - consider migrating to asymmetric keys',\n      );\n    }\n  }\n\n  if (strategies.length === 0) {\n    throw new Error(\n      'No JWT verification strategies available. ' +\n        'Configure SUPABASE_JWT_SECRET or ensure Supabase client is available.',\n    );\n  }\n\n  return new JwtVerificationService({ strategies });\n}\n\nmodule.exports = { createJwtVerifierForConfig };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\auth\\strategies.js",
    "messages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async method 'verify' has too many statements (23). Maximum allowed is 20.",
        "line": 85,
        "column": 15,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 144,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * JWT Verifier Strategies\n *\n * Pluggable verification strategies for different JWT signing algorithms.\n * Each strategy implements a common interface for use with JwtVerificationService.\n *\n * Strategies Available:\n * - JwksVerifierStrategy: Verifies JWTs using asymmetric keys from JWKS endpoint\n * - SymmetricVerifierStrategy: Verifies JWTs using symmetric key (HS256/HS384/HS512)\n * - SupabaseSdkVerifierStrategy: Delegates to Supabase SDK's auth.getUser()\n *\n * SOLID Principles Applied:\n * - Single Responsibility: Each strategy handles one verification method\n * - Open/Closed: New strategies can be added without modifying existing ones\n * - Liskov Substitution: All strategies are interchangeable\n * - Dependency Inversion: Strategies depend on abstractions (JWT library interfaces)\n *\n * @module services/auth/strategies\n */\n\nconst jwt = require('jsonwebtoken');\nconst { createPublicKey } = require('crypto');\nconst { logger } = require('../../observability');\n\nfunction normalizeJwtPayload(payload) {\n  return {\n    id: payload.sub,\n    email: payload.email,\n    role: payload.role,\n    aud: payload.aud,\n    iss: payload.iss,\n    exp: payload.exp,\n    iat: payload.iat,\n    ...payload,\n  };\n}\n\n/**\n * Strategy that verifies JWTs using JWKS (asymmetric keys)\n *\n * Supports: ES256, ES384, ES512, RS256, RS384, RS512, PS256, PS384, PS512\n */\nclass JwksVerifierStrategy {\n  /**\n   * Create a new JwksVerifierStrategy\n   *\n   * @param {Object} options - Configuration options\n   * @param {JwksProvider} options.jwksProvider - Provider for fetching keys\n   * @param {string[]} [options.allowedAlgorithms] - Allowed signing algorithms\n   * @param {string} [options.issuer] - Expected token issuer\n   * @param {string} [options.audience] - Expected token audience\n   */\n  constructor({\n    jwksProvider,\n    allowedAlgorithms = ['ES256', 'RS256'],\n    issuer = null,\n    audience = null,\n  } = {}) {\n    if (!jwksProvider) {\n      throw new Error('JwksVerifierStrategy requires a jwksProvider');\n    }\n\n    this.name = 'jwks';\n    this._jwksProvider = jwksProvider;\n    this._allowedAlgorithms = allowedAlgorithms;\n    this._issuer = issuer;\n    this._audience = audience;\n  }\n\n  /**\n   * Check if this strategy is available\n   *\n   * @returns {boolean} Always true - JWKS strategy is always available\n   */\n  isAvailable() {\n    return true;\n  }\n\n  /**\n   * Verify a JWT token using JWKS\n   *\n   * @param {string} token - The JWT to verify\n   * @returns {Promise<Object>} Verification result\n   */\n  async verify(token) {\n    try {\n      // Decode header to get kid and alg\n      const decoded = jwt.decode(token, { complete: true });\n\n      if (!decoded || !decoded.header) {\n        return { valid: false, error: 'Invalid JWT format' };\n      }\n\n      const { kid, alg } = decoded.header;\n\n      // Validate algorithm\n      if (!this._allowedAlgorithms.includes(alg)) {\n        return {\n          valid: false,\n          error: `Unsupported algorithm: ${alg}. Allowed: ${this._allowedAlgorithms.join(', ')}`,\n        };\n      }\n\n      // Get the appropriate key\n      let jwk;\n      if (kid) {\n        jwk = await this._jwksProvider.getKeyById(kid);\n      } else {\n        // Fallback to first key if no kid in token\n        jwk = await this._jwksProvider.getFirstKey();\n      }\n\n      if (!jwk) {\n        return { valid: false, error: `No matching key found for kid: ${kid || '(none)'}` };\n      }\n\n      // Convert JWK to Node.js crypto key\n      const publicKey = createPublicKey({ key: jwk, format: 'jwk' });\n\n      // Build verification options\n      const verifyOptions = {\n        algorithms: [alg],\n      };\n\n      if (this._issuer) {\n        verifyOptions.issuer = this._issuer;\n      }\n\n      if (this._audience) {\n        verifyOptions.audience = this._audience;\n      }\n\n      // Verify the token\n      const payload = jwt.verify(token, publicKey, verifyOptions);\n\n      return {\n        valid: true,\n        payload: normalizeJwtPayload(payload),\n      };\n    } catch (error) {\n      logger.debug('[JwksVerifierStrategy] Verification failed:', { error: error.message });\n      return { valid: false, error: error.message };\n    }\n  }\n}\n\n/**\n * Strategy that verifies JWTs using symmetric keys (HMAC)\n *\n * Supports: HS256, HS384, HS512\n *\n * WARNING: Symmetric keys are less secure than asymmetric keys.\n * Only use for legacy compatibility or when asymmetric keys are not available.\n */\nclass SymmetricVerifierStrategy {\n  /**\n   * Create a new SymmetricVerifierStrategy\n   *\n   * @param {Object} options - Configuration options\n   * @param {string} options.secret - The symmetric secret key\n   * @param {string[]} [options.allowedAlgorithms] - Allowed signing algorithms\n   * @param {string} [options.issuer] - Expected token issuer\n   * @param {string} [options.audience] - Expected token audience\n   */\n  constructor({\n    secret,\n    allowedAlgorithms = ['HS256', 'HS384', 'HS512'],\n    issuer = null,\n    audience = null,\n  } = {}) {\n    this.name = 'symmetric';\n    this._secret = secret;\n    this._allowedAlgorithms = allowedAlgorithms;\n    this._issuer = issuer;\n    this._audience = audience;\n  }\n\n  /**\n   * Check if this strategy is available\n   *\n   * @returns {boolean} True if secret is configured\n   */\n  isAvailable() {\n    return Boolean(this._secret);\n  }\n\n  /**\n   * Verify a JWT token using symmetric key\n   *\n   * @param {string} token - The JWT to verify\n   * @returns {Promise<Object>} Verification result\n   */\n  async verify(token) {\n    if (!this._secret) {\n      return { valid: false, error: 'No symmetric secret configured' };\n    }\n\n    try {\n      // Build verification options\n      const verifyOptions = {\n        algorithms: this._allowedAlgorithms,\n      };\n\n      if (this._issuer) {\n        verifyOptions.issuer = this._issuer;\n      }\n\n      if (this._audience) {\n        verifyOptions.audience = this._audience;\n      }\n\n      // Verify the token\n      const payload = jwt.verify(token, this._secret, verifyOptions);\n\n      return {\n        valid: true,\n        payload: normalizeJwtPayload(payload),\n      };\n    } catch (error) {\n      logger.debug('[SymmetricVerifierStrategy] Verification failed:', { error: error.message });\n      return { valid: false, error: error.message };\n    }\n  }\n}\n\n/**\n * Strategy that delegates to Supabase SDK for verification\n *\n * This is the most reliable strategy for Supabase Cloud as it handles\n * all edge cases and key rotation automatically.\n */\nclass SupabaseSdkVerifierStrategy {\n  /**\n   * Create a new SupabaseSdkVerifierStrategy\n   *\n   * @param {Object} options - Configuration options\n   * @param {Object} options.supabaseClient - Initialized Supabase client\n   */\n  constructor({ supabaseClient } = {}) {\n    if (!supabaseClient) {\n      throw new Error('SupabaseSdkVerifierStrategy requires a supabaseClient');\n    }\n\n    this.name = 'supabase-sdk';\n    this._supabase = supabaseClient;\n  }\n\n  /**\n   * Check if this strategy is available\n   *\n   * @returns {boolean} Always true if client is provided\n   */\n  isAvailable() {\n    return Boolean(this._supabase);\n  }\n\n  /**\n   * Verify a JWT token using Supabase SDK\n   *\n   * @param {string} token - The JWT to verify\n   * @returns {Promise<Object>} Verification result\n   */\n  async verify(token) {\n    try {\n      const { data, error } = await this._supabase.auth.getUser(token);\n\n      if (error || !data?.user) {\n        const errorMessage = error?.message || error?.name || 'User not found';\n        return { valid: false, error: errorMessage };\n      }\n\n      return {\n        valid: true,\n        payload: data.user,\n      };\n    } catch (error) {\n      logger.debug('[SupabaseSdkVerifierStrategy] Verification failed:', { error: error.message });\n      return { valid: false, error: error.message };\n    }\n  }\n}\n\nmodule.exports = {\n  JwksVerifierStrategy,\n  SymmetricVerifierStrategy,\n  SupabaseSdkVerifierStrategy,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\embeddings.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\feedbackService.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 17,
        "column": 28,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 17,
        "endColumn": 31
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 28,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 28,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 38,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 38,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 2000.",
        "line": 51,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 51,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 52,
        "column": 50,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 53,
        "column": 62,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 53,
        "endColumn": 64
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 54,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 54,
        "endColumn": 47
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 55,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 55,
        "endColumn": 41
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 61,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 61,
        "endColumn": 45
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 67,
        "column": 68,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 67,
        "endColumn": 70
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 77,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 116,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 116,
        "endColumn": 35
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const feedbackRepo = require('../repositories/feedbackRepository');\n\nconst MAX_MESSAGE_LENGTH = 5000;\nconst VALID_TYPES = ['bug', 'feature', 'question', 'other'];\n\nfunction createRequestError(status, payload) {\n  const error = new Error(payload?.error?.message || 'Request error');\n  error.status = status;\n  error.payload = payload;\n  return error;\n}\n\nfunction ensureValidType(type) {\n  if (type && VALID_TYPES.includes(type)) {\n    return;\n  }\n  throw createRequestError(400, {\n    success: false,\n    error: {\n      code: 'INVALID_TYPE',\n      message: `type must be one of: ${VALID_TYPES.join(', ')}`,\n    },\n  });\n}\n\nfunction ensureValidMessage(message) {\n  if (!message || typeof message !== 'string' || message.trim().length === 0) {\n    throw createRequestError(400, {\n      success: false,\n      error: {\n        code: 'MISSING_MESSAGE',\n        message: 'message is required',\n      },\n    });\n  }\n\n  if (message.length > MAX_MESSAGE_LENGTH) {\n    throw createRequestError(400, {\n      success: false,\n      error: {\n        code: 'MESSAGE_TOO_LONG',\n        message: `message exceeds maximum length of ${MAX_MESSAGE_LENGTH} characters`,\n      },\n    });\n  }\n}\n\nfunction sanitizeContext(context, userAgent) {\n  const sanitizedContext = context\n    ? {\n        url: context.url?.slice(0, 2000) || null,\n        courseCode: context.courseCode?.slice(0, 50) || null,\n        extensionVersion: context.extensionVersion?.slice(0, 20) || null,\n        browser: context.browser?.slice(0, 200) || null,\n        page: context.page?.slice(0, 200) || null,\n      }\n    : null;\n\n  return {\n    ...sanitizedContext,\n    serverUserAgent: userAgent?.slice(0, 500) || null,\n    submittedAt: new Date().toISOString(),\n  };\n}\n\nfunction normalizeLimit(limit) {\n  return limit ? Math.min(Math.max(parseInt(limit, 10), 1), 100) : 50;\n}\n\nfunction isValidUUID(str) {\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n  return uuidRegex.test(str);\n}\n\nfunction ensureValidFeedbackId(feedbackId) {\n  if (!feedbackId || !isValidUUID(feedbackId)) {\n    throw createRequestError(400, {\n      success: false,\n      error: {\n        code: 'INVALID_FEEDBACK_ID',\n        message: 'feedbackId must be a valid UUID',\n      },\n    });\n  }\n}\n\nfunction createFeedbackService(deps = {}) {\n  const repo = deps.feedbackRepo ?? feedbackRepo;\n\n  async function createFeedback({ userId, payload, userAgent } = {}) {\n    const { type, message, context } = payload || {};\n\n    ensureValidType(type);\n    ensureValidMessage(message);\n    const finalContext = sanitizeContext(context, userAgent);\n\n    const feedback = await repo.createFeedback({\n      userId,\n      type,\n      message: message.trim(),\n      context: finalContext,\n    });\n\n    return feedback;\n  }\n\n  async function listUserFeedback({ userId, limit } = {}) {\n    return repo.getFeedbackByUser(userId, { limit: normalizeLimit(limit) });\n  }\n\n  async function getFeedback({ userId, feedbackId } = {}) {\n    ensureValidFeedbackId(feedbackId);\n\n    const feedback = await repo.getFeedbackById(feedbackId, userId);\n    if (!feedback) {\n      throw createRequestError(404, {\n        success: false,\n        error: {\n          code: 'NOT_FOUND',\n          message: 'Feedback not found',\n        },\n      });\n    }\n\n    return feedback;\n  }\n\n  return {\n    createFeedback,\n    listUserFeedback,\n    getFeedback,\n  };\n}\n\nconst feedbackService = createFeedbackService();\n\nmodule.exports = {\n  createFeedbackService,\n  feedbackService,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\llmClient.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\llm\\basicChat.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\llm\\chatTitle.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 220.",
        "line": 19,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 19,
        "endColumn": 44
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: -12.",
        "line": 21,
        "column": 12,
        "nodeType": "UnaryExpression",
        "messageId": "noMagic",
        "endLine": 21,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { logger: baseLogger } = require('../../observability');\nconst { buildInitialChatTitle, coerceGeneratedTitle } = require('../../utils/chatTitle');\nconst { createChatCompletion } = require('./providerChain');\nconst { sanitizeHistory } = require('./history');\n\n/**\n * Generate a concise chat title (5-6 words) from the chat history.\n * @param {Object} options\n * @param {Array<{role: string, content: string}>} options.history - Sanitized chat history\n * @param {string} [options.fallbackTitle] - Title to use if generation fails\n * @param {Object} [options.logger] - Optional logger override\n * @returns {Promise<string>}\n */\nasync function generateChatTitleFromHistory({ history = [], fallbackTitle = '', logger } = {}) {\n  const log = logger ?? baseLogger;\n  const sanitizedHistory = sanitizeHistory(history)\n    .map((message) => ({\n      ...message,\n      content: message.content.slice(0, 220),\n    }))\n    .slice(-12); // keep the last messages for context\n\n  const fallback = buildInitialChatTitle(fallbackTitle);\n\n  if (sanitizedHistory.length === 0) {\n    return fallback;\n  }\n\n  const conversation = sanitizedHistory\n    .map((message) => {\n      const speaker = message.role === 'assistant' ? 'Tutor' : 'Student';\n      return `${speaker}: ${message.content}`;\n    })\n    .join('\\n');\n\n  const messages = [\n    {\n      role: 'system',\n      content:\n        'You are summarizing a study conversation into a short, descriptive title. Reply with a single line of 5-6 words in sentence case. No quotes, no punctuation at the end.',\n    },\n    {\n      role: 'user',\n      content: `Conversation transcript:\\n${conversation}\\n\\nReturn only the short title.`,\n    },\n  ];\n\n  try {\n    const completion = await createChatCompletion({\n      messages,\n      temperature: 0.2,\n      maxTokens: 24,\n      operation: 'chat.completions.create',\n    });\n\n    const candidate = (completion.choices[0]?.message?.content || '').split('\\n')[0].trim();\n\n    return coerceGeneratedTitle(candidate, fallback);\n  } catch (error) {\n    log.warn({ err: error }, 'Failed to generate chat title');\n    return fallback;\n  }\n}\n\nmodule.exports = {\n  generateChatTitleFromHistory,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\llm\\constants.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\llm\\history.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\llm\\lockInResponse.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\llm\\providerChain.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\llm\\structuredMessages.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 13,
        "column": 50,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 13,
        "endColumn": 51
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 206,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 206,
        "endColumn": 48
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'buildStructuredStudyMessages' has too many lines (53). Maximum allowed is 50.",
        "line": 219,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 281,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const {\n  MAX_ATTACHMENT_CONTEXT_CHARS,\n  MIN_SELECTION_PRIMARY_CHARS,\n  ATTACHMENT_ONLY_SELECTION_PLACEHOLDER,\n} = require('./constants');\nconst { sanitizeHistory } = require('./history');\n\nfunction normalizeSelection(selection) {\n  if (typeof selection !== 'string') return '';\n  return selection.trim();\n}\n\nfunction extractHeadingLines(text, maxHeadings = 6) {\n  const headings = [];\n  const lines = text.split(/\\r?\\n/);\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed) continue;\n    if (/^#{1,6}\\s+\\S/.test(trimmed)) {\n      headings.push(trimmed);\n      if (headings.length >= maxHeadings) break;\n    }\n  }\n  return headings;\n}\n\nfunction buildHeadTailSnippet(text, maxChars) {\n  const trimmed = text.trim();\n  if (trimmed.length <= maxChars) return trimmed;\n\n  const marker = '\\n\\n... [content truncated] ...\\n\\n';\n  const available = Math.max(0, maxChars - marker.length);\n  const headLen = Math.max(0, Math.floor(available / 2));\n  const tailLen = Math.max(0, available - headLen);\n  const head = trimmed.slice(0, headLen);\n  const tail = trimmed.slice(-tailLen);\n\n  return `${head}${marker}${tail}`;\n}\n\nfunction buildAttachmentSnippet(text, maxChars = MAX_ATTACHMENT_CONTEXT_CHARS) {\n  const trimmed = text.trim();\n  if (trimmed.length <= maxChars) return trimmed;\n\n  const headings = extractHeadingLines(trimmed);\n  const headingBlock = headings.length ? `Headings:\\n${headings.join('\\n')}\\n\\n` : '';\n  const available = Math.max(0, maxChars - headingBlock.length);\n\n  return `${headingBlock}${buildHeadTailSnippet(trimmed, available)}`;\n}\n\nfunction resolveSelectionContext(selection, attachments) {\n  const selectionText = normalizeSelection(selection);\n  const hasSelection = selectionText.length > 0;\n  const hasAttachments = Array.isArray(attachments) && attachments.length > 0;\n  const selectionIsShort =\n    selectionText.length > 0 && selectionText.length < MIN_SELECTION_PRIMARY_CHARS;\n  const selectionForPrompt = hasSelection\n    ? selectionText\n    : hasAttachments\n      ? ATTACHMENT_ONLY_SELECTION_PLACEHOLDER\n      : '';\n\n  return {\n    selectionText,\n    hasSelection,\n    hasAttachments,\n    selectionIsShort,\n    selectionForPrompt,\n  };\n}\n\nfunction resolveUserQuestion(newUserMessage) {\n  const trimmed = typeof newUserMessage === 'string' ? newUserMessage.trim() : '';\n  return {\n    hasUserQuestion: trimmed.length > 0,\n    userQuestion: trimmed,\n  };\n}\n\nfunction buildModeInstruction(mode) {\n  switch (mode) {\n    case 'explain':\n      return \"Provide a detailed explanation in the 'explanation' field. Still create notes and todos if relevant to help the student study.\";\n    case 'general':\n      return \"Treat this as general Q&A about the selection/context. Provide a helpful explanation in the 'explanation' field.\";\n    default:\n      return \"Provide a clear explanation in the 'explanation' field. Create notes and todos if relevant.\";\n  }\n}\n\nfunction buildContextInfo({ pageContext, pageUrl, courseCode }) {\n  const contextParts = [];\n  if (pageContext) {\n    contextParts.push(`Page context: ${pageContext}`);\n  }\n  if (pageUrl) {\n    contextParts.push(`Page URL: ${pageUrl}`);\n  }\n  if (courseCode) {\n    contextParts.push(`Course code: ${courseCode}`);\n  }\n  return contextParts.length > 0 ? `\\n\\n${contextParts.join('\\n')}` : '';\n}\n\nfunction buildFocusInstruction({\n  hasUserQuestion,\n  hasAttachments,\n  hasSelection,\n  selectionIsShort,\n}) {\n  if (hasUserQuestion) {\n    return 'Treat the student question as the primary task. Use the selected text and any attachments as supporting evidence.';\n  }\n  if (hasAttachments && (!hasSelection || selectionIsShort)) {\n    return 'The attached files/images are the primary source of context. The selected text is minimal or missing; focus on the attachments first.';\n  }\n  return 'The selected text is the primary source of context. Use attachments as supporting evidence when available.';\n}\n\nfunction buildAttachmentNote(hasAttachments) {\n  return hasAttachments\n    ? '\\n\\nThe student may also attach images, documents, or code files. For images, describe what you see and how it relates to the topic.'\n    : '';\n}\n\nfunction buildSystemPrompt({\n  modeInstruction,\n  focusInstruction,\n  contextInfo,\n  attachmentNote,\n  selectionForPrompt,\n}) {\n  return `You are Lock-in, a helpful AI study assistant. Your task is to analyze the selected text and return a structured JSON response.\n\n${modeInstruction}\n${focusInstruction ? `\\n${focusInstruction}` : ''}\n\nUse the provided context (page context, course code, page URL) to improve the quality of tags and notes.${attachmentNote}\n\nIMPORTANT: You MUST return ONLY a valid JSON object with this exact structure:\n{\n  \"explanation\": \"string - the main answer/explanation for the user\",\n  \"notes\": [{\"title\": \"string\", \"content\": \"string\", \"type\": \"string\"}],\n  \"todos\": [{\"title\": \"string\", \"description\": \"string\"}],\n  \"tags\": [\"string\"],\n  \"difficulty\": \"easy\" | \"medium\" | \"hard\"\n}\n\nDo NOT include any markdown, code blocks, or extra text. Return ONLY the JSON object.\n\nGuidelines:\n- explanation: The main answer based on the mode (explain/general)\n- notes: Array of study notes that could be saved (title, content, type like \"definition\", \"formula\", \"concept\", etc.)\n- todos: Array of study tasks (title, description)\n- tags: Array of topic tags relevant to the content\n- difficulty: Estimate the difficulty level of the selected text\n\nSelected text:\n${selectionForPrompt}${contextInfo}`;\n}\n\nfunction buildAttachmentContext(attachments) {\n  const textAttachments = (attachments || []).filter((a) => a.type !== 'image' && a.textContent);\n  if (textAttachments.length === 0) {\n    return '';\n  }\n  const attachmentTexts = textAttachments.map((a) => {\n    const label = a.fileName || `${a.type} file`;\n    const content = buildAttachmentSnippet(a.textContent);\n    return `\\n--- ${label} ---\\n${content}`;\n  });\n  return `\\n\\nAttached files:${attachmentTexts.join('\\n')}`;\n}\n\nfunction buildUserTextContent({\n  hasUserQuestion,\n  userQuestion,\n  hasAttachments,\n  hasSelection,\n  selectionIsShort,\n  attachmentContext,\n}) {\n  if (hasUserQuestion) {\n    return `The student has asked a follow-up question about the selected text and previous explanation:\n\n\"${userQuestion}\"${attachmentContext}\n\nUsing the selected text, the previous conversation, any attached files/images, and the mode instructions, answer their question and return ONLY the structured JSON object described in the system message.`;\n  }\n\n  if (hasAttachments && (!hasSelection || selectionIsShort)) {\n    return `Analyze the attached files/images as the primary source of context. The selected text is minimal or missing, so treat it as optional background. Return ONLY the structured JSON response described in the system message.${attachmentContext}`;\n  }\n\n  return `Analyze the selected text${attachmentContext ? ' and the attached files/images' : ''} and return the structured JSON response described in the system message.${attachmentContext}`;\n}\n\nfunction buildUserMessage(userTextContent, attachments) {\n  const imageAttachments = (attachments || []).filter((a) => a.type === 'image' && a.base64);\n  if (imageAttachments.length === 0) {\n    return { role: 'user', content: userTextContent };\n  }\n\n  const contentParts = [{ type: 'text', text: userTextContent }];\n  for (const img of imageAttachments.slice(0, 4)) {\n    contentParts.push({\n      type: 'image_url',\n      image_url: {\n        url: `data:${img.mimeType};base64,${img.base64}`,\n        detail: 'auto',\n      },\n    });\n  }\n\n  return { role: 'user', content: contentParts };\n}\n\nfunction buildStructuredStudyMessages(options) {\n  const {\n    mode = 'explain',\n    selection,\n    pageContext,\n    pageUrl,\n    courseCode,\n    language = 'en',\n    chatHistory = [],\n    newUserMessage,\n    attachments = [],\n  } = options;\n\n  const selectionContext = resolveSelectionContext(selection, attachments);\n  const userQuestion = resolveUserQuestion(newUserMessage);\n\n  if (!selectionContext.hasSelection && !selectionContext.hasAttachments) {\n    throw new Error('Selection or attachments are required to generate a response');\n  }\n\n  const systemPrompt = buildSystemPrompt({\n    modeInstruction: buildModeInstruction(mode),\n    focusInstruction: buildFocusInstruction({\n      hasUserQuestion: userQuestion.hasUserQuestion,\n      hasAttachments: selectionContext.hasAttachments,\n      hasSelection: selectionContext.hasSelection,\n      selectionIsShort: selectionContext.selectionIsShort,\n    }),\n    contextInfo: buildContextInfo({ pageContext, pageUrl, courseCode }),\n    attachmentNote: buildAttachmentNote(selectionContext.hasAttachments),\n    selectionForPrompt: selectionContext.selectionForPrompt,\n  });\n\n  // Build messages array starting with system prompt\n  const messages = [{ role: 'system', content: systemPrompt }];\n\n  // Append sanitized chat history if available\n  if (Array.isArray(chatHistory) && chatHistory.length > 0) {\n    const safeHistory = sanitizeHistory(chatHistory);\n    messages.push(...safeHistory);\n  }\n\n  // Build attachment context for text-based attachments (documents, code)\n  const attachmentContext = buildAttachmentContext(attachments);\n  const userTextContent = buildUserTextContent({\n    hasUserQuestion: userQuestion.hasUserQuestion,\n    userQuestion: userQuestion.userQuestion,\n    hasAttachments: selectionContext.hasAttachments,\n    hasSelection: selectionContext.hasSelection,\n    selectionIsShort: selectionContext.selectionIsShort,\n    attachmentContext,\n  });\n  messages.push(buildUserMessage(userTextContent, attachments));\n\n  return {\n    messages,\n    selectionForPrompt: selectionContext.selectionForPrompt,\n    userTextContent,\n    hasAttachments: selectionContext.hasAttachments,\n    hasUserQuestion: userQuestion.hasUserQuestion,\n    language,\n  };\n}\n\nmodule.exports = {\n  buildStructuredStudyMessages,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\llm\\structuredResponse.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'generateStructuredStudyResponse' has too many lines (72). Maximum allowed is 50.",
        "line": 29,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 116,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'generateStructuredStudyResponse' has too many statements (29). Maximum allowed is 20.",
        "line": 29,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 116,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 58,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 58,
        "endColumn": 48
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { createChatCompletion } = require('./providerChain');\nconst { clampHistory } = require('./history');\nconst { buildStructuredStudyMessages } = require('./structuredMessages');\n\n/**\n * @typedef {Object} StudyResponse\n * @property {string} mode - The mode used (\"explain\" | \"general\")\n * @property {string} explanation - The main answer/explanation for the user\n * @property {Array<{title: string, content: string, type: string}>} notes - Array of possible notes to save\n * @property {Array<{title: string, description: string}>} todos - Array of possible tasks\n * @property {string[]} tags - Array of topic tags\n * @property {\"easy\" | \"medium\" | \"hard\"} difficulty - Estimated difficulty of the selected text\n */\n\n/**\n * Generate a structured study response with explanation, notes, todos, tags, and difficulty\n * @param {Object} options - Request options\n * @param {string} options.mode - Mode: \"explain\" | \"general\"\n * @param {string} [options.selection] - The highlighted text (required unless attachments provided)\n * @param {string} [options.pageContext] - Optional extra surrounding text or page summary\n * @param {string} [options.pageUrl] - Optional page URL\n * @param {string} [options.courseCode] - Optional course code (e.g. \"FIT2101\")\n * @param {string} [options.language] - UI language (e.g. \"en\")\n * @param {Array<{role: string, content: string}>} [options.chatHistory] - Previous messages\n * @param {string} [options.newUserMessage] - Follow-up question from the user\n * @param {Array<Object>} [options.attachments] - Processed attachments (images with base64, documents with textContent)\n * @returns {Promise<StudyResponse>}\n */\nasync function generateStructuredStudyResponse(options) {\n  const { mode = 'explain' } = options;\n  const { messages } = buildStructuredStudyMessages(options);\n\n  // Clamp history before sending to OpenAI\n  const finalMessages = clampHistory(messages);\n\n  try {\n    const completion = await createChatCompletion({\n      messages: finalMessages,\n      temperature: 0.4,\n      maxTokens: 1500,\n      responseFormat: { type: 'json_object' },\n      operation: 'chat.completions.create',\n    });\n\n    const content = completion.choices[0]?.message?.content;\n    if (!content) {\n      throw new Error('No response content from OpenAI');\n    }\n\n    // Parse JSON response\n    let parsed;\n    try {\n      parsed = JSON.parse(content);\n    } catch (parseError) {\n      throw new Error(\n        `Failed to parse JSON response: ${\n          parseError.message\n        }. Response: ${content.substring(0, 200)}`,\n      );\n    }\n\n    // Validate required fields\n    if (typeof parsed.explanation !== 'string') {\n      throw new Error(\"Response missing or invalid 'explanation' field\");\n    }\n    if (!Array.isArray(parsed.notes)) {\n      parsed.notes = [];\n    }\n    if (!Array.isArray(parsed.todos)) {\n      parsed.todos = [];\n    }\n    if (!Array.isArray(parsed.tags)) {\n      parsed.tags = [];\n    }\n    if (!['easy', 'medium', 'hard'].includes(parsed.difficulty)) {\n      parsed.difficulty = 'medium';\n    }\n\n    // Validate notes structure\n    parsed.notes = parsed.notes\n      .filter((note) => note && typeof note.title === 'string' && typeof note.content === 'string')\n      .map((note) => ({\n        title: note.title,\n        content: note.content,\n        type: typeof note.type === 'string' ? note.type : 'general',\n      }));\n\n    // Validate todos structure\n    parsed.todos = parsed.todos\n      .filter(\n        (todo) => todo && typeof todo.title === 'string' && typeof todo.description === 'string',\n      )\n      .map((todo) => ({\n        title: todo.title,\n        description: todo.description,\n      }));\n\n    // Validate tags\n    parsed.tags = parsed.tags.filter((tag) => typeof tag === 'string' && tag.trim().length > 0);\n\n    // Add mode to response\n    return {\n      mode,\n      explanation: parsed.explanation,\n      notes: parsed.notes,\n      todos: parsed.todos,\n      tags: parsed.tags,\n      difficulty: parsed.difficulty,\n    };\n  } catch (error) {\n    if (error.message && error.message.includes('JSON')) {\n      throw error;\n    }\n    throw new Error(`Failed to generate structured study response: ${error.message}`);\n  }\n}\n\nmodule.exports = {\n  generateStructuredStudyResponse,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\notes\\__tests__\\contentService.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 132,
        "column": 50,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 132,
        "endColumn": 51
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 133,
        "column": 51,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 133,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 25.",
        "line": 165,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 165,
        "endColumn": 24
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 166,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 166,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 168,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 168,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 600.",
        "line": 194,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 194,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 195,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 195,
        "endColumn": 46
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 197,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 197,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/services/notes/__tests__/contentService.test.js\n\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst {\n  processNoteContent,\n  validateNoteContentNotEmpty,\n  normalizeTags,\n  validateTitle,\n} = require('../contentService');\n\ntest('processNoteContent - process valid Lexical content', () => {\n  const input = {\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n    content_text: 'Sample text',\n  };\n\n  const result = processNoteContent(input);\n\n  assert.deepEqual(result.contentJson, { root: { children: [] } });\n  assert.equal(result.editorVersion, 'lexical_v1');\n  assert.equal(result.plainText, 'Sample text');\n  assert.equal(result.legacyContent, null);\n});\n\ntest('processNoteContent - process Lexical content with empty text', () => {\n  const input = {\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n    content_text: '',\n  };\n\n  const result = processNoteContent(input);\n\n  assert.equal(result.plainText, '');\n  assert.equal(result.legacyContent, null);\n});\n\ntest('processNoteContent - accept Lexical content with empty legacy fallback', () => {\n  const input = {\n    content: '', // Empty legacy content\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n    content_text: 'Text',\n  };\n\n  const result = processNoteContent(input);\n\n  assert.equal(result.plainText, 'Text');\n  assert.equal(result.legacyContent, null);\n});\n\ntest('processNoteContent - parse content_json from string', () => {\n  const input = {\n    content_json: '{\"root\":{\"children\":[]}}',\n    editor_version: 'lexical_v1',\n    content_text: 'Text',\n  };\n\n  const result = processNoteContent(input);\n\n  assert.deepEqual(result.contentJson, { root: { children: [] } });\n});\n\ntest('processNoteContent - throw on invalid JSON string', () => {\n  const input = {\n    content_json: 'not valid json',\n    editor_version: 'lexical_v1',\n  };\n\n  assert.throws(() => processNoteContent(input), /Invalid content_json: must be valid JSON/);\n});\n\ntest('processNoteContent - process plain text legacy content', () => {\n  const input = {\n    content: 'Plain text content',\n  };\n\n  const result = processNoteContent(input);\n\n  assert.equal(result.plainText, 'Plain text content');\n  assert.equal(result.legacyContent, 'Plain text content');\n});\n\ntest('processNoteContent - strip HTML from legacy content', () => {\n  const input = {\n    content: '<p>HTML <strong>content</strong></p>',\n  };\n\n  const result = processNoteContent(input);\n\n  assert.equal(result.plainText, 'HTML content');\n  assert.equal(result.legacyContent, '<p>HTML <strong>content</strong></p>');\n});\n\ntest('processNoteContent - throw when neither Lexical nor legacy content provided', () => {\n  const input = {};\n\n  assert.throws(() => processNoteContent(input), /Content format error/);\n});\n\ntest('processNoteContent - NOT throw for empty plainText when Lexical is present', () => {\n  const input = {\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n    content_text: '',\n  };\n\n  const result = processNoteContent(input); // Should not throw\n  assert.equal(result.plainText, '');\n});\n\ntest('validateNoteContentNotEmpty - return true for non-empty content', () => {\n  assert.equal(validateNoteContentNotEmpty('Some text'), true);\n});\n\ntest('validateNoteContentNotEmpty - return false for empty string', () => {\n  assert.equal(validateNoteContentNotEmpty(''), false);\n});\n\ntest('validateNoteContentNotEmpty - return false for whitespace only', () => {\n  assert.equal(validateNoteContentNotEmpty('   '), false);\n});\n\ntest('validateNoteContentNotEmpty - return false for null', () => {\n  assert.equal(validateNoteContentNotEmpty(null), false);\n});\n\ntest('validateNoteContentNotEmpty - respect custom minLength parameter', () => {\n  assert.equal(validateNoteContentNotEmpty('ab', 3), false);\n  assert.equal(validateNoteContentNotEmpty('abc', 3), true);\n});\n\ntest('normalizeTags - normalize array of tags', () => {\n  const tags = ['tag1', 'tag2', 'tag3'];\n  const result = normalizeTags(tags);\n\n  assert.deepEqual(result, ['tag1', 'tag2', 'tag3']);\n});\n\ntest('normalizeTags - parse comma-separated string', () => {\n  const tags = 'tag1, tag2, tag3';\n  const result = normalizeTags(tags);\n\n  assert.deepEqual(result, ['tag1', 'tag2', 'tag3']);\n});\n\ntest('normalizeTags - filter out empty strings', () => {\n  const tags = ['tag1', '', '  ', 'tag2'];\n  const result = normalizeTags(tags);\n\n  assert.deepEqual(result, ['tag1', 'tag2']);\n});\n\ntest('normalizeTags - trim whitespace from tags', () => {\n  const tags = ['  tag1  ', 'tag2  '];\n  const result = normalizeTags(tags);\n\n  assert.deepEqual(result, ['tag1', 'tag2']);\n});\n\ntest('normalizeTags - limit to max tags', () => {\n  const tags = Array(25).fill('tag');\n  const result = normalizeTags(tags, 20);\n\n  assert.equal(result.length, 20);\n});\n\ntest('normalizeTags - return empty array for null/undefined', () => {\n  assert.deepEqual(normalizeTags(null), []);\n  assert.deepEqual(normalizeTags(undefined), []);\n});\n\ntest('validateTitle - return trimmed title', () => {\n  assert.equal(validateTitle('  My Title  '), 'My Title');\n});\n\ntest('validateTitle - return \"Untitled Note\" for empty string', () => {\n  assert.equal(validateTitle(''), 'Untitled Note');\n});\n\ntest('validateTitle - return \"Untitled Note\" for whitespace only', () => {\n  assert.equal(validateTitle('   '), 'Untitled Note');\n});\n\ntest('validateTitle - return \"Untitled Note\" for null/undefined', () => {\n  assert.equal(validateTitle(null), 'Untitled Note');\n  assert.equal(validateTitle(undefined), 'Untitled Note');\n});\n\ntest('validateTitle - truncate long titles', () => {\n  const longTitle = 'a'.repeat(600);\n  const result = validateTitle(longTitle, 500);\n\n  assert.equal(result.length, 500);\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\notes\\__tests__\\noteAssetsService.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\notes\\__tests__\\notesService.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.1.",
        "line": 15,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 15,
        "endColumn": 47
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.2.",
        "line": 15,
        "column": 49,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 15,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.3.",
        "line": 15,
        "column": 54,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 15,
        "endColumn": 57
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst { createNotesService } = require('../notesService');\n\nfunction createMockContentService(overrides = {}) {\n  return {\n    processNoteContent: (payload) => ({\n      contentJson: { root: { children: [] } },\n      editorVersion: 'lexical_v1',\n      plainText: payload?.content_text || 'Sample',\n      legacyContent: null,\n    }),\n    validateNoteContentNotEmpty: () => true,\n    generateEmbeddingForNote: async () => [0.1, 0.2, 0.3],\n    normalizeTags: (tags) => (Array.isArray(tags) ? tags : []),\n    validateTitle: (title) =>\n      typeof title === 'string' && title.trim() ? title.trim() : 'Untitled',\n    ...overrides,\n  };\n}\n\ntest('createNote - normalizes nullable metadata and uses idempotency store', async () => {\n  let runCalled = false;\n  const notesRepo = {\n    createNote: async (data) => ({ id: 'note-1', ...data }),\n  };\n  const idempotencyStore = {\n    run: async (_key, _userId, task) => {\n      runCalled = true;\n      return task();\n    },\n  };\n  const contentService = createMockContentService();\n\n  const service = createNotesService({\n    notesRepo,\n    contentService,\n    idempotencyStore,\n    logger: { error: () => {} },\n  });\n\n  const result = await service.createNote({\n    userId: 'user-1',\n    idempotencyKey: 'key-1',\n    payload: {\n      title: null,\n      content_json: { root: { children: [] } },\n      editor_version: 'lexical_v1',\n      content_text: 'Hello',\n      sourceUrl: null,\n      sourceSelection: null,\n      courseCode: null,\n      tags: null,\n      clientNoteId: null,\n    },\n  });\n\n  assert.equal(runCalled, true);\n  assert.equal(result.id, 'note-1');\n  assert.equal(result.sourceUrl, null);\n  assert.equal(result.courseCode, null);\n  assert.deepEqual(result.tags, []);\n});\n\ntest('updateNote - wraps conflict errors with updatedAt', async () => {\n  const notesRepo = {\n    updateNote: async () => {\n      const error = new Error('Conflict');\n      error.name = 'ConflictError';\n      error.updatedAt = '2026-01-29T00:00:00.000Z';\n      throw error;\n    },\n  };\n  const contentService = createMockContentService();\n\n  const service = createNotesService({\n    notesRepo,\n    contentService,\n    idempotencyStore: { run: async () => {} },\n    logger: { error: () => {} },\n  });\n\n  try {\n    await service.updateNote({\n      userId: 'user-1',\n      noteId: 'note-1',\n      payload: {\n        title: 'Updated',\n        content_json: { root: { children: [] } },\n        editor_version: 'lexical_v1',\n        content_text: 'Hello',\n      },\n    });\n    assert.fail('Expected conflict error');\n  } catch (error) {\n    assert.equal(error.code, 'CONFLICT');\n    assert.equal(error.updatedAt, '2026-01-29T00:00:00.000Z');\n  }\n});\n\ntest('createNote - throws validation error when content processing fails', async () => {\n  const notesRepo = {\n    createNote: async () => ({ id: 'note-1' }),\n  };\n  const contentService = createMockContentService({\n    processNoteContent: () => {\n      throw new Error('Invalid content');\n    },\n  });\n\n  const service = createNotesService({\n    notesRepo,\n    contentService,\n    idempotencyStore: { run: async () => {} },\n    logger: { error: () => {} },\n  });\n\n  await assert.rejects(\n    () =>\n      service.createNote({\n        userId: 'user-1',\n        payload: { content: 'invalid' },\n      }),\n    (error) => error.code === 'VALIDATION_ERROR',\n  );\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\notes\\chatService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'chatWithNotes' has too many lines (52). Maximum allowed is 50.",
        "line": 26,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 91,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 8.",
        "line": 26,
        "column": 72,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 26,
        "endColumn": 73
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/services/notes/chatService.js\n\nconst notesRepo = require('../../repositories/notesRepository');\nconst { embedText } = require('../embeddings');\nconst { chatWithModel } = require('../llmClient');\nconst { extractPlainTextFromLexical } = require('../../utils/lexicalUtils');\nconst { CHAT_WITH_NOTES_SYSTEM_PROMPT } = require('../../config/prompts');\n\n/**\n * Chat with Notes Service\n *\n * Business logic for AI-powered chat using user's notes as context.\n * Separated from controller for testability and reusability.\n */\n\n/**\n * Chat with user's notes using AI\n *\n * @param {Object} params\n * @param {string} params.userId - User ID\n * @param {string} params.query - User's question\n * @param {string} [params.courseCode] - Optional course code filter\n * @param {number} [params.matchCount=8] - Number of notes to retrieve\n * @returns {Promise<{answer: string, usedNotes: Array}>}\n */\nasync function chatWithNotes({ userId, query, courseCode, matchCount = 8 }) {\n  // Generate embedding for search query\n  let queryEmbedding;\n  try {\n    queryEmbedding = await embedText(query.trim());\n  } catch (embedError) {\n    console.error('Failed to generate query embedding:', embedError);\n    throw new Error('Failed to process search query');\n  }\n\n  // Search notes by embedding similarity\n  let matches = await notesRepo.searchNotesByEmbedding({\n    userId,\n    queryEmbedding,\n    matchCount,\n  });\n\n  // Optional filter by course code\n  if (courseCode) {\n    matches = matches.filter((n) => n.course_code === courseCode);\n  }\n\n  // If no notes found, return early\n  if (matches.length === 0) {\n    return {\n      answer:\n        \"I couldn't find any relevant notes to answer your question. Try creating some notes first!\",\n      usedNotes: [],\n    };\n  }\n\n  // Build context from matched notes\n  const contextBlocks = matches.map((n, i) => {\n    const courseInfo = n.course_code ? ` (course: ${n.course_code})` : '';\n    // Use content_plain if available, otherwise extract from content_json\n    const noteText =\n      n.content_plain || (n.content_json ? extractPlainTextFromLexical(n.content_json) : '') || '';\n    return `Note ${i + 1}${courseInfo}:\\n${noteText}`;\n  });\n\n  const messages = [\n    { role: 'system', content: CHAT_WITH_NOTES_SYSTEM_PROMPT },\n    {\n      role: 'user',\n      content: `Here are my notes:\\n\\n${contextBlocks.join('\\n\\n')}\\n\\nMy question: ${query.trim()}`,\n    },\n  ];\n\n  // Generate answer using OpenAI chat\n  let answer;\n  try {\n    answer = await chatWithModel({ messages });\n  } catch (chatError) {\n    console.error('Failed to generate chat response:', chatError);\n    throw new Error('Failed to generate answer');\n  }\n\n  return {\n    answer,\n    usedNotes: matches.map((n) => ({\n      id: n.id,\n      title: n.title || 'Untitled Note',\n      courseCode: n.course_code || null,\n    })),\n  };\n}\n\nmodule.exports = {\n  chatWithNotes,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\notes\\contentService.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 130,
        "column": 40,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 130,
        "endColumn": 42
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 130,
        "column": 59,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 130,
        "endColumn": 61
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 156,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 156,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/services/notes/contentService.js\n\nconst { embedText } = require('../embeddings');\nconst { extractPlainTextFromLexical } = require('../../utils/lexicalUtils');\n\n/**\n * Note Content Service\n *\n * Handles content processing logic for notes:\n * - Legacy vs Lexical format detection\n * - Plain text extraction\n * - Embedding generation\n */\n\n/**\n * Process note content based on format (Lexical or Legacy)\n *\n * This function transforms content from various formats into a normalized structure.\n * It does NOT enforce business rules about empty content - that's the controller's job.\n *\n * @param {Object} params\n * @param {string} [params.content] - Legacy HTML/plaintext content\n * @param {Object|string} [params.content_json] - Lexical JSON state\n * @param {string} [params.editor_version] - Editor version (e.g., 'lexical_v1')\n * @param {string} [params.content_text] - Pre-extracted plain text from Lexical\n * @returns {Object} { contentJson, editorVersion, plainText, legacyContent }\n * @throws {Error} If content format is invalid (malformed JSON, wrong types, etc.)\n */\nfunction processNoteContent({ content, content_json, editor_version, content_text }) {\n  const hasLexicalContent = content_json && editor_version;\n  const hasLegacyContent = content && typeof content === 'string' && content.trim().length > 0;\n\n  // At least one format must be present (validated by Zod schema)\n  if (!hasLexicalContent && !hasLegacyContent) {\n    throw new Error(\n      'Content format error: content_json+editor_version or legacy content field is required',\n    );\n  }\n\n  let finalContentJson = {};\n  let finalEditorVersion = 'lexical_v1';\n  let plainText = '';\n\n  if (hasLexicalContent) {\n    // Parse and validate Lexical JSON structure\n    if (typeof content_json === 'string') {\n      try {\n        finalContentJson = JSON.parse(content_json);\n      } catch (err) {\n        throw new Error(`Invalid content_json: must be valid JSON. ${err.message}`);\n      }\n    } else if (typeof content_json === 'object' && content_json !== null) {\n      finalContentJson = content_json;\n    } else {\n      throw new Error('Invalid content_json: must be a JSON object or string');\n    }\n    finalEditorVersion = editor_version;\n\n    // Extract plain text from Lexical state\n    // If pre-extracted text is provided, use that for performance\n    plainText = content_text || extractPlainTextFromLexical(finalContentJson) || '';\n  } else {\n    // Legacy: use content field\n    plainText = content.trim();\n    // Basic HTML stripping for legacy content\n    plainText = plainText\n      .replace(/<[^>]*>/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  }\n\n  // Note: We intentionally do NOT throw an error for empty plainText here.\n  // This allows the system to:\n  // 1. Accept notes in draft state (user just opened editor)\n  // 2. Handle edge cases where Lexical state exists but text is empty\n  // 3. Let controllers enforce business rules about minimum content\n  //\n  // If empty content is unacceptable, the controller should validate\n  // plainText.length before proceeding with embedding/storage.\n\n  return {\n    contentJson: finalContentJson,\n    editorVersion: finalEditorVersion,\n    plainText,\n    legacyContent: hasLegacyContent ? content.trim() : null,\n  };\n}\n\n/**\n * Validate that note content is not empty\n *\n * This is a business rule validator that should be called by controllers\n * when they need to enforce minimum content requirements.\n *\n * @param {string} plainText - Plain text extracted from note content\n * @param {number} minLength - Minimum acceptable length (default: 1)\n * @returns {boolean} true if valid, false if empty\n */\nfunction validateNoteContentNotEmpty(plainText, minLength = 1) {\n  if (!plainText || typeof plainText !== 'string') {\n    return false;\n  }\n  return plainText.trim().length >= minLength;\n}\n\n/**\n * Generate embedding for note content\n *\n * @param {string} plainText - Plain text to embed\n * @returns {Promise<Array|null>} Embedding vector or null on failure\n */\nasync function generateEmbeddingForNote(plainText) {\n  try {\n    return await embedText(plainText);\n  } catch (embedError) {\n    // Log but don't fail - note can still be saved without embedding\n    console.error('Failed to generate embedding:', embedError);\n    return null;\n  }\n}\n\n/**\n * Normalize tags to ensure consistent array format\n *\n * @param {any} tags - Tags input (array, string, or null/undefined)\n * @param {number} maxTags - Maximum number of tags allowed\n * @param {number} maxTagLength - Maximum length per tag\n * @returns {string[]} Normalized array of tags\n */\nfunction normalizeTags(tags, maxTags = 20, maxTagLength = 50) {\n  if (!tags) return [];\n  if (Array.isArray(tags)) {\n    return tags\n      .filter((tag) => typeof tag === 'string' && tag.trim().length > 0)\n      .slice(0, maxTags)\n      .map((tag) => tag.trim().slice(0, maxTagLength));\n  }\n  if (typeof tags === 'string') {\n    return tags\n      .split(',')\n      .map((tag) => tag.trim())\n      .filter((tag) => tag.length > 0)\n      .slice(0, maxTags)\n      .map((tag) => tag.slice(0, maxTagLength));\n  }\n  return [];\n}\n\n/**\n * Validate and sanitize title\n *\n * @param {string} title - Note title\n * @param {number} maxLength - Maximum title length\n * @returns {string} Sanitized title\n */\nfunction validateTitle(title, maxLength = 500) {\n  if (!title || typeof title !== 'string') {\n    return 'Untitled Note';\n  }\n  return title.trim().slice(0, maxLength) || 'Untitled Note';\n}\n\nmodule.exports = {\n  processNoteContent,\n  validateNoteContentNotEmpty,\n  generateEmbeddingForNote,\n  normalizeTags,\n  validateTitle,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\notes\\noteAssetsService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createNoteAssetsService' has too many lines (110). Maximum allowed is 50.",
        "line": 10,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 140,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 63,
        "column": 69,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 63,
        "endColumn": 72
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 129,
        "column": 70,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 129,
        "endColumn": 73
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { randomUUID } = require('crypto');\nconst { AppError, NotFoundError, ValidationError } = require('../../errors');\nconst { logger: baseLogger } = require('../../observability');\nconst { NOTE_ASSETS_BUCKET } = require('../../config');\nconst noteAssetsRepository = require('../../repositories/noteAssetsRepository');\nconst notesRepository = require('../../repositories/notesRepository');\nconst { createStorageRepository } = require('../../repositories/storageRepository');\nconst { validateAssetFile } = require('../../utils/assetValidation');\n\nfunction createNoteAssetsService(deps = {}) {\n  const bucket = deps.bucket ?? NOTE_ASSETS_BUCKET;\n  const storageRepository =\n    deps.storageRepository ??\n    createStorageRepository({\n      bucket,\n      supabaseClient: deps.supabase,\n    });\n  const services = {\n    logger: deps.logger ?? baseLogger,\n    noteAssetsRepository: deps.noteAssetsRepository ?? noteAssetsRepository,\n    notesRepository: deps.notesRepository ?? notesRepository,\n    storageRepository,\n    bucket,\n  };\n\n  async function ensureNoteExists(userId, noteId) {\n    const note = await services.notesRepository.getNoteForUser({ userId, noteId });\n    if (!note) {\n      throw new NotFoundError('Note', noteId);\n    }\n    return note;\n  }\n\n  async function uploadNoteAsset({ userId, noteId, file } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n    if (!noteId) {\n      throw new ValidationError('Note ID is required', 'noteId');\n    }\n\n    await ensureNoteExists(userId, noteId);\n\n    const validation = validateAssetFile(file);\n    if (!validation.valid) {\n      throw new ValidationError(validation.reason || 'Invalid file', 'file');\n    }\n\n    const assetId = randomUUID();\n    const storagePath = `${userId}/${noteId}/${assetId}.${validation.extension}`;\n\n    const { error: uploadError } = await services.storageRepository.upload(\n      storagePath,\n      file.buffer,\n      {\n        contentType: validation.mimeType,\n        upsert: false,\n      },\n    );\n\n    if (uploadError) {\n      services.logger.error({ err: uploadError, noteId, userId }, 'Failed to upload note asset');\n      throw new AppError('Failed to upload file', 'INTERNAL_ERROR', 500);\n    }\n\n    const asset = await services.noteAssetsRepository.createAsset({\n      id: assetId,\n      noteId,\n      userId,\n      type: validation.type,\n      mimeType: validation.mimeType,\n      storagePath,\n    });\n\n    const { data: publicUrlData, error: publicUrlError } =\n      services.storageRepository.getPublicUrl(storagePath);\n\n    if (publicUrlError) {\n      services.logger.warn(\n        { err: publicUrlError, noteId, userId },\n        'Failed to generate public URL for note asset',\n      );\n    }\n\n    return {\n      ...asset,\n      url: publicUrlData?.publicUrl || null,\n    };\n  }\n\n  async function listNoteAssets({ userId, noteId } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n    if (!noteId) {\n      throw new ValidationError('Note ID is required', 'noteId');\n    }\n\n    await ensureNoteExists(userId, noteId);\n\n    const assets = await services.noteAssetsRepository.listAssetsForNote(noteId, userId);\n\n    return assets.map((asset) => {\n      const { data } = services.storageRepository.getPublicUrl(asset.storage_path);\n      return { ...asset, url: data?.publicUrl || null };\n    });\n  }\n\n  async function deleteNoteAsset({ userId, assetId } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n    if (!assetId) {\n      throw new ValidationError('Asset ID is required', 'assetId');\n    }\n\n    const asset = await services.noteAssetsRepository.getAssetById(assetId, userId);\n    if (!asset) {\n      throw new NotFoundError('Asset', assetId);\n    }\n\n    const { error: storageError } = await services.storageRepository.remove([asset.storage_path]);\n\n    if (storageError) {\n      services.logger.error(\n        { err: storageError, assetId, userId },\n        'Failed to delete note asset from storage',\n      );\n      throw new AppError('Failed to delete asset', 'INTERNAL_ERROR', 500);\n    }\n\n    await services.noteAssetsRepository.deleteAsset(assetId, userId);\n  }\n\n  return {\n    uploadNoteAsset,\n    listNoteAssets,\n    deleteNoteAsset,\n  };\n}\n\nconst noteAssetsService = createNoteAssetsService();\n\nmodule.exports = {\n  createNoteAssetsService,\n  noteAssetsService,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\notes\\notesService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createNotesService' has too many lines (186). Maximum allowed is 50.",
        "line": 18,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 234,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 69,
        "column": 69,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 69,
        "endColumn": 71
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 82,
        "column": 72,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 82,
        "endColumn": 74
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 94,
        "column": 78,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 94,
        "endColumn": 81
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 157,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 157,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 202,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 202,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 217,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 217,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { AppError, ConflictError, NotFoundError, ValidationError } = require('../../errors');\nconst { logger: baseLogger } = require('../../observability');\nconst notesRepo = require('../../repositories/notesRepository');\nconst noteAssetsRepository = require('../../repositories/noteAssetsRepository');\nconst contentService = require('./contentService');\nconst { createIdempotencyStore } = require('../../utils/idempotency');\nconst { NOTE_ASSETS_BUCKET } = require('../../config');\nconst { createStorageRepository } = require('../../repositories/storageRepository');\nconst {\n  normalizeOptionalString,\n  prepareContent,\n  buildCreateMetadata,\n  buildUpdateMetadata,\n} = require('./notesServiceHelpers');\n\nconst defaultIdempotencyStore = createIdempotencyStore();\n\nfunction createNotesService(deps = {}) {\n  const bucket = deps.bucket ?? NOTE_ASSETS_BUCKET;\n  const storageRepository =\n    deps.storageRepository ??\n    createStorageRepository({\n      bucket,\n      supabaseClient: deps.supabase,\n    });\n  const services = {\n    notesRepo: deps.notesRepo ?? notesRepo,\n    noteAssetsRepository: deps.noteAssetsRepository ?? noteAssetsRepository,\n    contentService: deps.contentService ?? contentService,\n    idempotencyStore: deps.idempotencyStore ?? defaultIdempotencyStore,\n    logger: deps.logger ?? baseLogger,\n    storageRepository,\n    bucket,\n  };\n\n  async function createNote({ userId, payload, idempotencyKey } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n\n    const { processed, embedding } = await prepareContent(payload, services);\n    const metadata = buildCreateMetadata(payload, services);\n\n    const noteData = {\n      userId,\n      clientNoteId: metadata.clientNoteId,\n      title: metadata.title,\n      contentJson: processed.contentJson,\n      editorVersion: processed.editorVersion,\n      contentPlain: processed.plainText,\n      legacyContent: processed.legacyContent,\n      sourceSelection: metadata.sourceSelection,\n      sourceUrl: metadata.sourceUrl,\n      courseCode: metadata.courseCode,\n      noteType: metadata.noteType,\n      tags: metadata.tags,\n      embedding,\n    };\n\n    const runCreate = () => services.notesRepo.createNote(noteData);\n\n    if (idempotencyKey) {\n      return services.idempotencyStore.run(idempotencyKey, userId, runCreate);\n    }\n\n    return runCreate();\n  }\n\n  async function listNotes({ userId, sourceUrl, courseCode, limit = 50 } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n\n    return services.notesRepo.listNotes({\n      userId,\n      sourceUrl: normalizeOptionalString(sourceUrl) || undefined,\n      courseCode: normalizeOptionalString(courseCode) || undefined,\n      limit,\n    });\n  }\n\n  async function searchNotes({ userId, query, courseCode, matchCount = 10 } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n\n    const trimmedQuery = typeof query === 'string' ? query.trim() : '';\n    if (!trimmedQuery) {\n      throw new ValidationError('Query parameter (q) is required');\n    }\n\n    const queryEmbedding = await services.contentService.generateEmbeddingForNote(trimmedQuery);\n    if (!queryEmbedding) {\n      throw new AppError('Failed to process search query', 'INTERNAL_ERROR', 500);\n    }\n\n    let matches = await services.notesRepo.searchNotesByEmbedding({\n      userId,\n      queryEmbedding,\n      matchCount,\n    });\n\n    const normalizedCourse = normalizeOptionalString(courseCode);\n    if (normalizedCourse) {\n      matches = matches.filter((note) => note.course_code === normalizedCourse);\n    }\n\n    return matches;\n  }\n\n  async function getNote({ userId, noteId } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n\n    const note = await services.notesRepo.getNoteForUser({ userId, noteId });\n    if (!note) {\n      throw new NotFoundError('Note', noteId);\n    }\n\n    return note;\n  }\n\n  async function updateNote({ userId, noteId, payload, ifUnmodifiedSince } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n\n    const { processed, embedding } = await prepareContent(payload, services);\n    const metadata = buildUpdateMetadata(payload, services);\n\n    try {\n      return await services.notesRepo.updateNote({\n        userId,\n        noteId,\n        title: metadata.title,\n        contentJson: processed.contentJson,\n        editorVersion: processed.editorVersion,\n        contentPlain: processed.plainText,\n        legacyContent: processed.legacyContent,\n        sourceSelection: metadata.sourceSelection,\n        sourceUrl: metadata.sourceUrl,\n        courseCode: metadata.courseCode,\n        noteType: metadata.noteType,\n        tags: metadata.tags,\n        embedding,\n        ifUnmodifiedSince: ifUnmodifiedSince || null,\n      });\n    } catch (error) {\n      if (error?.name === 'ConflictError') {\n        throw new ConflictError(\n          error.message || 'Note was modified by another session.',\n          error.updatedAt || null,\n        );\n      }\n\n      if (error?.status === 404) {\n        throw new NotFoundError('Note', noteId);\n      }\n\n      services.logger.error({ err: error, noteId, userId }, 'Failed to update note');\n      throw error;\n    }\n  }\n\n  async function deleteNote({ userId, noteId } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n\n    try {\n      const assets = await services.noteAssetsRepository.listAssetsForNote(noteId, userId);\n      if (assets && assets.length > 0) {\n        const storagePaths = assets.map((asset) => asset.storage_path);\n        const { error: storageError } = await services.storageRepository.remove(storagePaths);\n\n        if (storageError) {\n          services.logger.warn(\n            { err: storageError, noteId, userId },\n            'Failed to delete note asset files from storage',\n          );\n        }\n      }\n    } catch (error) {\n      services.logger.warn(\n        { err: error, noteId, userId },\n        'Failed to clean up note assets before deletion',\n      );\n    }\n\n    await services.notesRepo.deleteNote({ userId, noteId });\n  }\n\n  async function toggleStarred({ userId, noteId } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n\n    try {\n      return await services.notesRepo.toggleStarred({ userId, noteId });\n    } catch (error) {\n      if (error?.status === 404) {\n        throw new NotFoundError('Note', noteId);\n      }\n      throw error;\n    }\n  }\n\n  async function setStarred({ userId, noteId, isStarred } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n\n    try {\n      return await services.notesRepo.setStarred({ userId, noteId, isStarred });\n    } catch (error) {\n      if (error?.status === 404) {\n        throw new NotFoundError('Note', noteId);\n      }\n      throw error;\n    }\n  }\n\n  return {\n    createNote,\n    listNotes,\n    searchNotes,\n    getNote,\n    updateNote,\n    deleteNote,\n    toggleStarred,\n    setStarred,\n  };\n}\n\nconst notesService = createNotesService();\n\nmodule.exports = {\n  createNotesService,\n  notesService,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\notes\\notesServiceHelpers.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\rateLimitService.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\__tests__\\transcriptJobsService.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createStubRepo' has too many lines (64). Maximum allowed is 50.",
        "line": 17,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 80,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 251,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 251,
        "endColumn": 39
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 12.",
        "line": 252,
        "column": 52,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 252,
        "endColumn": 54
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 32.",
        "line": 263,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 263,
        "endColumn": 38
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 263,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 263,
        "endColumn": 45
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 263,
        "column": 48,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 263,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 413.",
        "line": 297,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 297,
        "endColumn": 39
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Transcript job lifecycle service tests.\n */\n\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\nconst { TRANSCRIPT_CHUNK_MAX_BYTES } = require('../../../config');\nconst { createTranscriptJobsService } = require('../transcriptJobsService');\n\nfunction createRepoState() {\n  return {\n    jobs: new Map(),\n    chunks: new Map(),\n  };\n}\n\nfunction createStubRepo(state) {\n  return {\n    async createTranscriptJob(payload) {\n      const job = {\n        id: payload.jobId || 'job-1',\n        user_id: payload.userId,\n        fingerprint: payload.fingerprint,\n        status: 'created',\n        error: null,\n        bytes_received: 0,\n        expected_total_chunks: payload.expectedTotalChunks ?? null,\n      };\n      state.jobs.set(job.id, job);\n      return job;\n    },\n    async getTranscriptJob({ jobId, userId }) {\n      const job = state.jobs.get(jobId);\n      if (!job || job.user_id !== userId) return null;\n      return { ...job };\n    },\n    async updateTranscriptJob({ jobId, userId, updates }) {\n      const job = state.jobs.get(jobId);\n      if (!job || job.user_id !== userId) return null;\n      const next = { ...job, ...updates };\n      state.jobs.set(jobId, next);\n      return next;\n    },\n    async getTranscriptByFingerprint() {\n      return null;\n    },\n    async countTranscriptJobsSince() {\n      return 0;\n    },\n    async countActiveTranscriptJobs() {\n      return 0;\n    },\n    async insertTranscriptJobChunk({ jobId, chunkIndex, byteSize }) {\n      const jobChunks = state.chunks.get(jobId) || new Map();\n      if (jobChunks.has(chunkIndex)) {\n        return { inserted: false };\n      }\n      jobChunks.set(chunkIndex, byteSize);\n      state.chunks.set(jobId, jobChunks);\n      return { inserted: true, data: { job_id: jobId, chunk_index: chunkIndex } };\n    },\n    async getTranscriptJobChunkStats(jobId) {\n      const jobChunks = state.chunks.get(jobId) || new Map();\n      const indices = Array.from(jobChunks.keys());\n      const count = indices.length;\n      const minIndex = count ? Math.min(...indices) : null;\n      const maxIndex = count ? Math.max(...indices) : null;\n      return { count, minIndex, maxIndex };\n    },\n    async deleteTranscriptJobChunk() {\n      return null;\n    },\n    async consumeTranscriptUploadBytes() {\n      return { allowed: true, remaining: 0, retryAfterSeconds: 0 };\n    },\n    async listActiveTranscriptJobs() {\n      return [];\n    },\n  };\n}\n\nfunction createStubService(flags) {\n  return {\n    async appendTranscriptChunk() {\n      return null;\n    },\n    startTranscriptProcessing() {\n      flags.started = true;\n    },\n  };\n}\n\ntest('accepts out-of-order chunks and marks job uploaded', async () => {\n  const state = createRepoState();\n  const flags = { started: false };\n  const repo = createStubRepo(state);\n  const processing = createStubService(flags);\n  const service = createTranscriptJobsService({\n    transcriptsRepository: repo,\n    transcriptsService: processing,\n  });\n\n  state.jobs.set('job-1', {\n    id: 'job-1',\n    user_id: 'user-1',\n    status: 'created',\n    expected_total_chunks: 2,\n    bytes_received: 0,\n  });\n\n  await service.uploadChunk({\n    userId: 'user-1',\n    jobId: 'job-1',\n    chunk: Buffer.from('a'),\n    headers: { 'x-chunk-index': '1', 'x-total-chunks': '2' },\n  });\n\n  assert.equal(state.jobs.get('job-1').status, 'uploading');\n\n  await service.uploadChunk({\n    userId: 'user-1',\n    jobId: 'job-1',\n    chunk: Buffer.from('b'),\n    headers: { 'x-chunk-index': '0', 'x-total-chunks': '2' },\n  });\n\n  assert.equal(state.jobs.get('job-1').status, 'uploaded');\n});\n\ntest('rejects finalize when chunks are missing', async () => {\n  const state = createRepoState();\n  const flags = { started: false };\n  const repo = createStubRepo(state);\n  const processing = createStubService(flags);\n  const service = createTranscriptJobsService({\n    transcriptsRepository: repo,\n    transcriptsService: processing,\n  });\n\n  state.jobs.set('job-2', {\n    id: 'job-2',\n    user_id: 'user-1',\n    status: 'uploading',\n    expected_total_chunks: 2,\n    bytes_received: 1,\n    fingerprint: 'fp-2',\n  });\n  state.chunks.set('job-2', new Map([[0, 1]]));\n\n  await assert.rejects(\n    () => service.finalizeJob({ userId: 'user-1', jobId: 'job-2', payload: {} }),\n    (err) => {\n      assert.equal(err.code, 'TRANSCRIPT_MISSING_CHUNKS');\n      return true;\n    },\n  );\n});\n\ntest('rejects chunk uploads after cancel', async () => {\n  const state = createRepoState();\n  const flags = { started: false };\n  const repo = createStubRepo(state);\n  const processing = createStubService(flags);\n  const service = createTranscriptJobsService({\n    transcriptsRepository: repo,\n    transcriptsService: processing,\n  });\n\n  state.jobs.set('job-3', {\n    id: 'job-3',\n    user_id: 'user-1',\n    status: 'uploading',\n    expected_total_chunks: 2,\n    bytes_received: 1,\n  });\n\n  await service.cancelJob({ userId: 'user-1', jobId: 'job-3' });\n  assert.equal(state.jobs.get('job-3').status, 'canceled');\n\n  await assert.rejects(\n    () =>\n      service.uploadChunk({\n        userId: 'user-1',\n        jobId: 'job-3',\n        chunk: Buffer.from('c'),\n        headers: { 'x-chunk-index': '1', 'x-total-chunks': '2' },\n      }),\n    (err) => {\n      assert.equal(err.code, 'TRANSCRIPT_CANCELED');\n      return true;\n    },\n  );\n});\n\ntest('cancel mid-processing stops job', async () => {\n  const state = createRepoState();\n  const flags = { started: false };\n  const repo = createStubRepo(state);\n  const processing = createStubService(flags);\n  const service = createTranscriptJobsService({\n    transcriptsRepository: repo,\n    transcriptsService: processing,\n  });\n\n  state.jobs.set('job-4', {\n    id: 'job-4',\n    user_id: 'user-1',\n    status: 'processing',\n    expected_total_chunks: 2,\n    bytes_received: 2,\n  });\n\n  await service.cancelJob({ userId: 'user-1', jobId: 'job-4' });\n\n  assert.equal(state.jobs.get('job-4').status, 'canceled');\n});\n\ntest('rate limits transcript chunk uploads', async () => {\n  const state = createRepoState();\n  const flags = { started: false };\n  const repo = {\n    ...createStubRepo(state),\n    async consumeTranscriptUploadBytes() {\n      return { allowed: false, remaining: 0, retryAfterSeconds: 12 };\n    },\n  };\n  const processing = createStubService(flags);\n  const service = createTranscriptJobsService({\n    transcriptsRepository: repo,\n    transcriptsService: processing,\n  });\n\n  state.jobs.set('job-5', {\n    id: 'job-5',\n    user_id: 'user-1',\n    status: 'created',\n    expected_total_chunks: 1,\n    bytes_received: 0,\n  });\n\n  await assert.rejects(\n    () =>\n      service.uploadChunk({\n        userId: 'user-1',\n        jobId: 'job-5',\n        chunk: Buffer.from('x'),\n        headers: { 'x-chunk-index': '0', 'x-total-chunks': '1' },\n      }),\n    (err) => {\n      assert.equal(err.code, 'TRANSCRIPT_RATE_LIMIT');\n      assert.equal(err.statusCode, 429);\n      assert.equal(err.details?.retryAfterSeconds, 12);\n      return true;\n    },\n  );\n});\n\ntest('rejects transcript chunks that exceed the max size', async (t) => {\n  if (!Number.isFinite(TRANSCRIPT_CHUNK_MAX_BYTES)) {\n    t.skip('TRANSCRIPT_CHUNK_MAX_BYTES is not configured');\n    return;\n  }\n  if (TRANSCRIPT_CHUNK_MAX_BYTES > 32 * 1024 * 1024) {\n    t.skip('TRANSCRIPT_CHUNK_MAX_BYTES is too large to allocate safely in unit tests');\n    return;\n  }\n\n  const state = createRepoState();\n  const flags = { started: false };\n  const repo = createStubRepo(state);\n  const processing = createStubService(flags);\n  const service = createTranscriptJobsService({\n    transcriptsRepository: repo,\n    transcriptsService: processing,\n  });\n\n  state.jobs.set('job-6', {\n    id: 'job-6',\n    user_id: 'user-1',\n    status: 'created',\n    expected_total_chunks: 1,\n    bytes_received: 0,\n  });\n\n  const oversizedChunk = Buffer.alloc(TRANSCRIPT_CHUNK_MAX_BYTES + 1, 0);\n\n  await assert.rejects(\n    () =>\n      service.uploadChunk({\n        userId: 'user-1',\n        jobId: 'job-6',\n        chunk: oversizedChunk,\n        headers: { 'x-chunk-index': '0', 'x-total-chunks': '1' },\n      }),\n    (err) => {\n      assert.equal(err.code, 'TRANSCRIPT_CHUNK_TOO_LARGE');\n      assert.equal(err.statusCode, 413);\n      return true;\n    },\n  );\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptCacheService.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 32.",
        "line": 17,
        "column": 28,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 17,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { ValidationError } = require('../../errors');\nconst { upsertTranscriptCache } = require('../../repositories/transcriptsRepository');\n\nfunction coerceNumber(value) {\n  const num = Number(value);\n  return Number.isFinite(num) ? num : null;\n}\n\nfunction sanitizeMediaUrlForStorage(mediaUrl) {\n  if (!mediaUrl) return '';\n  try {\n    const url = new URL(mediaUrl);\n    url.hash = '';\n    url.search = '';\n    const segments = url.pathname.split('/').map((segment) => {\n      if (!segment) return segment;\n      if (segment.length > 32) return '[redacted]';\n      return segment;\n    });\n    url.pathname = segments.join('/');\n    return url.toString();\n  } catch {\n    return '';\n  }\n}\n\nfunction normalizeMediaUrlForStorage(mediaUrl) {\n  return sanitizeMediaUrlForStorage(mediaUrl);\n}\n\nfunction normalizeSegment(segment) {\n  if (!segment || typeof segment !== 'object') return null;\n  const startMs = coerceNumber(segment.startMs);\n  if (startMs === null) return null;\n  const text = typeof segment.text === 'string' ? segment.text.trim() : '';\n  if (!text) return null;\n\n  const endMs = coerceNumber(segment.endMs);\n  const speaker = typeof segment.speaker === 'string' ? segment.speaker.trim() : '';\n  const confidence = coerceNumber(segment.confidence);\n\n  const normalized = {\n    startMs,\n    endMs: endMs === null ? null : endMs,\n    text,\n  };\n\n  if (speaker) {\n    normalized.speaker = speaker;\n  }\n  if (confidence !== null) {\n    normalized.confidence = confidence;\n  }\n\n  return normalized;\n}\n\nfunction normalizeTranscript(transcript) {\n  if (!transcript || typeof transcript !== 'object') {\n    throw new ValidationError('Transcript is required', 'transcript');\n  }\n\n  const plainText = typeof transcript.plainText === 'string' ? transcript.plainText.trim() : '';\n  if (!plainText) {\n    throw new ValidationError('Transcript text is required', 'transcript.plainText');\n  }\n\n  const segments = Array.isArray(transcript.segments) ? transcript.segments : [];\n  const normalizedSegments = segments.map((segment) => normalizeSegment(segment)).filter(Boolean);\n\n  const durationMs = coerceNumber(transcript.durationMs);\n  const normalized = {\n    plainText,\n    segments: normalizedSegments,\n  };\n\n  if (durationMs !== null) {\n    normalized.durationMs = durationMs;\n  }\n\n  return normalized;\n}\n\nasync function cacheExternalTranscript({ userId, fingerprint, provider, transcript, meta }) {\n  if (!userId) {\n    throw new ValidationError('User context missing');\n  }\n\n  if (!fingerprint || typeof fingerprint !== 'string') {\n    throw new ValidationError('Fingerprint is required', 'fingerprint');\n  }\n\n  const normalizedProvider = typeof provider === 'string' ? provider.trim() : '';\n  if (!normalizedProvider) {\n    throw new ValidationError('Provider is required', 'provider');\n  }\n\n  const normalizedTranscript = normalizeTranscript(transcript);\n  const metaValue = meta && typeof meta === 'object' ? meta : {};\n\n  const rawMediaUrl = typeof metaValue.mediaUrl === 'string' ? metaValue.mediaUrl : '';\n  const rawNormalizedUrl =\n    typeof metaValue.mediaUrlNormalized === 'string' ? metaValue.mediaUrlNormalized : rawMediaUrl;\n\n  const mediaUrlRedacted = sanitizeMediaUrlForStorage(rawMediaUrl);\n  const mediaUrlNormalized = normalizeMediaUrlForStorage(rawNormalizedUrl);\n  const etag = typeof metaValue.etag === 'string' ? metaValue.etag : null;\n  const lastModified = typeof metaValue.lastModified === 'string' ? metaValue.lastModified : null;\n  const durationMs = coerceNumber(metaValue.durationMs ?? normalizedTranscript.durationMs);\n\n  return upsertTranscriptCache({\n    userId,\n    fingerprint: fingerprint.trim(),\n    provider: normalizedProvider,\n    mediaUrlRedacted,\n    mediaUrlNormalized,\n    etag,\n    lastModified,\n    durationMs,\n    transcriptJson: normalizedTranscript,\n  });\n}\n\nmodule.exports = {\n  cacheExternalTranscript,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptFfmpeg.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptFs.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptJobConstants.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptJobRateLimit.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 17,
        "column": 7,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 17,
        "endColumn": 10
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { AppError } = require('../../errors');\nconst { TRANSCRIPT_UPLOAD_BYTES_PER_MINUTE } = require('../../config');\n\nasync function enforceUploadRateLimit(repo, userId, bytes) {\n  if (!userId || !Number.isFinite(TRANSCRIPT_UPLOAD_BYTES_PER_MINUTE)) return;\n  const limit =\n    Number.isFinite(TRANSCRIPT_UPLOAD_BYTES_PER_MINUTE) && TRANSCRIPT_UPLOAD_BYTES_PER_MINUTE > 0\n      ? TRANSCRIPT_UPLOAD_BYTES_PER_MINUTE\n      : null;\n  if (!limit) return;\n\n  const result = await repo.consumeTranscriptUploadBytes({ userId, bytes, limit });\n  if (!result.allowed) {\n    throw new AppError(\n      'Upload rate limit exceeded. Please wait before uploading more.',\n      'TRANSCRIPT_RATE_LIMIT',\n      429,\n      { retryAfterSeconds: result.retryAfterSeconds },\n    );\n  }\n}\n\nmodule.exports = {\n  enforceUploadRateLimit,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptJobState.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 43,
        "column": 69,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 43,
        "endColumn": 71
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 104,
        "column": 7,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 104,
        "endColumn": 10
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 114,
        "column": 91,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 114,
        "endColumn": 94
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { AppError } = require('../../errors');\nconst { TRANSCRIPT_PROCESSING_STALE_MINUTES } = require('../../config');\nconst { coerceNumber } = require('./transcriptJobUtils');\nconst { JOB_STATUS } = require('./transcriptJobConstants');\nconst { parseExpectedTotalChunks } = require('./transcriptJobValidation');\n\nasync function updateJobUploadState({\n  repo,\n  job,\n  jobId,\n  userId,\n  chunkLength,\n  expectedTotalChunks,\n}) {\n  const bytesReceived = Number(job.bytes_received || 0);\n  const updates = {\n    status: job.status === JOB_STATUS.CREATED ? JOB_STATUS.UPLOADING : job.status,\n    error: null,\n    bytes_received: bytesReceived + chunkLength,\n  };\n\n  if (!job.expected_total_chunks && expectedTotalChunks) {\n    updates.expected_total_chunks = expectedTotalChunks;\n  }\n\n  const expectedCount = Number(updates.expected_total_chunks ?? job.expected_total_chunks);\n  if (Number.isFinite(expectedCount) && expectedCount > 0) {\n    const stats = await repo.getTranscriptJobChunkStats(jobId);\n    if (\n      stats.count === expectedCount &&\n      stats.minIndex === 0 &&\n      stats.maxIndex === expectedCount - 1\n    ) {\n      updates.status = JOB_STATUS.UPLOADED;\n    }\n  }\n\n  await repo.updateTranscriptJob({ jobId, userId, updates });\n}\n\nfunction isProcessingStale(job) {\n  if (!TRANSCRIPT_PROCESSING_STALE_MINUTES || !job) return false;\n  const cutoff = Date.now() - TRANSCRIPT_PROCESSING_STALE_MINUTES * 60 * 1000;\n  const heartbeat = job.processing_heartbeat_at\n    ? new Date(job.processing_heartbeat_at).getTime()\n    : null;\n  const started = job.processing_started_at ? new Date(job.processing_started_at).getTime() : null;\n  const reference = heartbeat ?? started;\n  return reference !== null && Number.isFinite(reference) && reference < cutoff;\n}\n\nasync function resolveFinalizeResponse(repo, job, userId) {\n  if (job.status === JOB_STATUS.DONE) {\n    const cached = await repo.getTranscriptByFingerprint({\n      fingerprint: job.fingerprint,\n      userId,\n    });\n    return {\n      success: true,\n      job: {\n        id: job.id,\n        status: JOB_STATUS.DONE,\n        transcript: cached?.transcript_json || null,\n      },\n    };\n  }\n\n  if (job.status === JOB_STATUS.CANCELED) {\n    return {\n      success: true,\n      job: { id: job.id, status: JOB_STATUS.CANCELED },\n    };\n  }\n\n  if (job.status === JOB_STATUS.ERROR) {\n    return {\n      success: true,\n      job: { id: job.id, status: JOB_STATUS.ERROR, error: job.error || null },\n    };\n  }\n\n  if (job.status === JOB_STATUS.PROCESSING && !isProcessingStale(job)) {\n    return {\n      success: true,\n      job: { id: job.id, status: JOB_STATUS.PROCESSING },\n    };\n  }\n\n  return null;\n}\n\nfunction resolveExpectedChunks(job, expectedTotalChunks) {\n  return (\n    job.expected_total_chunks ??\n    (expectedTotalChunks ? parseExpectedTotalChunks(expectedTotalChunks) : null)\n  );\n}\n\nasync function ensureAllChunksPresent(repo, jobId, expectedChunks) {\n  if (!expectedChunks) {\n    throw new AppError(\n      'Expected total chunks not provided.',\n      'TRANSCRIPT_TOTAL_CHUNKS_REQUIRED',\n      400,\n    );\n  }\n\n  const stats = await repo.getTranscriptJobChunkStats(jobId);\n  if (\n    stats.count !== expectedChunks ||\n    stats.minIndex !== 0 ||\n    stats.maxIndex !== expectedChunks - 1\n  ) {\n    throw new AppError('Upload incomplete: missing chunks.', 'TRANSCRIPT_MISSING_CHUNKS', 400, {\n      expectedTotalChunks: expectedChunks,\n      receivedChunks: stats.count,\n    });\n  }\n}\n\nfunction buildProcessingUpdates(expectedChunks, languageHint, maxMinutes) {\n  return {\n    status: JOB_STATUS.PROCESSING,\n    error: null,\n    expected_total_chunks: expectedChunks,\n    language_hint: typeof languageHint === 'string' ? languageHint : null,\n    max_minutes: coerceNumber(maxMinutes),\n  };\n}\n\nmodule.exports = {\n  updateJobUploadState,\n  resolveFinalizeResponse,\n  resolveExpectedChunks,\n  ensureAllChunksPresent,\n  buildProcessingUpdates,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptJobUtils.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 32.",
        "line": 9,
        "column": 28,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 9,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "function sanitizeMediaUrlForStorage(mediaUrl) {\n  if (!mediaUrl) return '';\n  try {\n    const url = new URL(mediaUrl);\n    url.hash = '';\n    url.search = '';\n    const segments = url.pathname.split('/').map((segment) => {\n      if (!segment) return segment;\n      if (segment.length > 32) return '[redacted]';\n      return segment;\n    });\n    url.pathname = segments.join('/');\n    return url.toString();\n  } catch {\n    return '';\n  }\n}\n\nfunction normalizeMediaUrlForStorage(mediaUrl) {\n  return sanitizeMediaUrlForStorage(mediaUrl);\n}\n\nfunction coerceNumber(value) {\n  const num = Number(value);\n  return Number.isFinite(num) ? num : null;\n}\n\nfunction getStartOfTodayUTC() {\n  const now = new Date();\n  return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));\n}\n\nmodule.exports = {\n  sanitizeMediaUrlForStorage,\n  normalizeMediaUrlForStorage,\n  coerceNumber,\n  getStartOfTodayUTC,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptJobValidation.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 413.",
        "line": 36,
        "column": 93,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 36,
        "endColumn": 96
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 409.",
        "line": 48,
        "column": 92,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 48,
        "endColumn": 95
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 409.",
        "line": 51,
        "column": 90,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 51,
        "endColumn": 93
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 60,
        "column": 7,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 60,
        "endColumn": 10
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 409.",
        "line": 71,
        "column": 7,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 71,
        "endColumn": 10
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { AppError, ValidationError } = require('../../errors');\nconst { TRANSCRIPT_CHUNK_MAX_BYTES } = require('../../config');\nconst { coerceNumber } = require('./transcriptJobUtils');\nconst { JOB_STATUS, UPLOADABLE_STATUSES } = require('./transcriptJobConstants');\n\nfunction parseExpectedTotalChunks(rawValue) {\n  const value = coerceNumber(rawValue);\n  if (value === null) return null;\n  if (!Number.isInteger(value) || value <= 0) {\n    throw new ValidationError('Expected total chunks must be a positive integer', 'x-total-chunks');\n  }\n  return value;\n}\n\nfunction ensureValidChunkIndex(chunkIndex) {\n  if (!Number.isInteger(chunkIndex) || chunkIndex < 0) {\n    throw new ValidationError('Chunk index must be a non-negative integer', 'x-chunk-index');\n  }\n}\n\nfunction parseChunkHeaders(headers) {\n  return {\n    chunkIndex: coerceNumber(headers?.['x-chunk-index']),\n    expectedTotalChunks: parseExpectedTotalChunks(headers?.['x-total-chunks']),\n  };\n}\n\nfunction ensureValidUploadPayload(jobId, chunk, chunkIndex) {\n  if (!jobId) {\n    throw new ValidationError('Job ID is required', 'id');\n  }\n  if (!Buffer.isBuffer(chunk) || chunk.length === 0) {\n    throw new ValidationError('Chunk payload is required', 'chunk');\n  }\n  if (Number.isFinite(TRANSCRIPT_CHUNK_MAX_BYTES) && chunk.length > TRANSCRIPT_CHUNK_MAX_BYTES) {\n    throw new AppError('Chunk exceeds maximum allowed size.', 'TRANSCRIPT_CHUNK_TOO_LARGE', 413, {\n      maxBytes: TRANSCRIPT_CHUNK_MAX_BYTES,\n    });\n  }\n  if (chunkIndex === null) {\n    throw new ValidationError('Chunk index header is required', 'x-chunk-index');\n  }\n  ensureValidChunkIndex(chunkIndex);\n}\n\nfunction ensureJobUploadable(job) {\n  if (job.status === JOB_STATUS.CANCELED) {\n    throw new AppError('This transcription job has been canceled.', 'TRANSCRIPT_CANCELED', 409);\n  }\n  if (!UPLOADABLE_STATUSES.has(job.status)) {\n    throw new AppError('Job is no longer accepting chunks.', 'TRANSCRIPT_INVALID_STATE', 409);\n  }\n}\n\nfunction ensureChunkIndexInRange(job, chunkIndex, expectedTotalChunks) {\n  if (job.expected_total_chunks && chunkIndex >= Number(job.expected_total_chunks)) {\n    throw new AppError(\n      'Chunk index exceeds expected total chunks.',\n      'TRANSCRIPT_CHUNK_OUT_OF_RANGE',\n      400,\n    );\n  }\n  if (\n    expectedTotalChunks &&\n    job.expected_total_chunks &&\n    expectedTotalChunks !== Number(job.expected_total_chunks)\n  ) {\n    throw new AppError(\n      'Expected total chunks header does not match job configuration.',\n      'TRANSCRIPT_TOTAL_CHUNKS_MISMATCH',\n      409,\n    );\n  }\n}\n\nmodule.exports = {\n  parseExpectedTotalChunks,\n  ensureValidChunkIndex,\n  parseChunkHeaders,\n  ensureValidUploadPayload,\n  ensureJobUploadable,\n  ensureChunkIndexInRange,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptJobsQueryService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createTranscriptJobsQueryService' has too many lines (92). Maximum allowed is 50.",
        "line": 5,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 108,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { ValidationError, NotFoundError } = require('../../errors');\nconst { TRANSCRIPT_MAX_CONCURRENT_JOBS } = require('../../config');\nconst { JOB_STATUS } = require('./transcriptJobConstants');\n\nfunction createTranscriptJobsQueryService({ repo, cacheService, logger }) {\n  async function getJob({ userId, jobId } = {}) {\n    const job = await repo.getTranscriptJob({ jobId, userId });\n    if (!job) {\n      throw new NotFoundError('Transcript job', jobId);\n    }\n\n    let transcript = null;\n    if (job.status === JOB_STATUS.DONE) {\n      const cached = await repo.getTranscriptByFingerprint({\n        fingerprint: job.fingerprint,\n        userId,\n      });\n      transcript = cached?.transcript_json || null;\n    }\n\n    return {\n      success: true,\n      job: {\n        id: job.id,\n        status: job.status,\n        error: job.error || null,\n        transcript,\n      },\n    };\n  }\n\n  async function listActiveJobs({ userId } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n\n    const jobs = await repo.listActiveTranscriptJobs({ userId });\n    return {\n      success: true,\n      jobs: jobs.map((job) => ({\n        id: job.id,\n        status: job.status,\n        fingerprint: job.fingerprint,\n        mediaUrl: job.media_url,\n        createdAt: job.created_at,\n        updatedAt: job.updated_at,\n      })),\n      count: jobs.length,\n      limit: TRANSCRIPT_MAX_CONCURRENT_JOBS,\n    };\n  }\n\n  async function cancelAllActiveJobs({ userId } = {}) {\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n\n    const jobs = await repo.listActiveTranscriptJobs({ userId });\n    const canceled = [];\n\n    for (const job of jobs) {\n      try {\n        await repo.updateTranscriptJob({\n          jobId: job.id,\n          userId,\n          updates: {\n            status: JOB_STATUS.CANCELED,\n            error: 'Canceled by user (bulk)',\n          },\n        });\n        canceled.push(job.id);\n      } catch (error) {\n        logger.warn({ err: error, jobId: job.id }, '[Transcripts] Failed to cancel job');\n      }\n    }\n\n    return {\n      success: true,\n      canceledCount: canceled.length,\n      canceledIds: canceled,\n    };\n  }\n\n  async function cacheTranscript({ userId, payload } = {}) {\n    const { fingerprint, provider, transcript, meta } = payload || {};\n\n    const cached = await cacheService.cacheExternalTranscript({\n      userId,\n      fingerprint,\n      provider,\n      transcript,\n      meta,\n    });\n\n    return {\n      success: true,\n      fingerprint: cached?.fingerprint || fingerprint,\n      cachedAt: cached?.created_at || null,\n    };\n  }\n\n  return {\n    getJob,\n    listActiveJobs,\n    cancelAllActiveJobs,\n    cacheTranscript,\n  };\n}\n\nmodule.exports = {\n  createTranscriptJobsQueryService,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptJobsService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createTranscriptJobsService' has too many lines (175). Maximum allowed is 50.",
        "line": 36,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 241,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'createJob' has too many lines (68). Maximum allowed is 50.",
        "line": 43,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 118,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'createJob' has too many statements (26). Maximum allowed is 20.",
        "line": 43,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 118,
        "endColumn": 4
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'createJob' has a complexity of 17. Maximum allowed is 15.",
        "line": 43,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 43,
        "endColumn": 27
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 77,
        "column": 90,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 93
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 82,
        "column": 96,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 82,
        "endColumn": 99
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 87,
        "column": 55,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 87,
        "endColumn": 57
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 92,
        "column": 11,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 92,
        "endColumn": 14
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 413.",
        "line": 135,
        "column": 90,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 135,
        "endColumn": 93
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { ValidationError, NotFoundError, AppError } = require('../../errors');\nconst { logger: baseLogger } = require('../../observability');\nconst transcriptsRepository = require('../../repositories/transcriptsRepository');\nconst transcriptsService = require('./transcriptsService');\nconst { cacheExternalTranscript } = require('./transcriptCacheService');\nconst {\n  coerceNumber,\n  getStartOfTodayUTC,\n  normalizeMediaUrlForStorage,\n  sanitizeMediaUrlForStorage,\n} = require('./transcriptJobUtils');\nconst {\n  TRANSCRIPT_DAILY_JOB_LIMIT,\n  TRANSCRIPT_MAX_CONCURRENT_JOBS,\n  TRANSCRIPT_MAX_TOTAL_BYTES,\n  TRANSCRIPT_MAX_DURATION_MINUTES,\n} = require('../../config');\nconst { JOB_STATUS } = require('./transcriptJobConstants');\nconst { enforceUploadRateLimit } = require('./transcriptJobRateLimit');\nconst {\n  parseChunkHeaders,\n  ensureValidUploadPayload,\n  ensureJobUploadable,\n  ensureChunkIndexInRange,\n  parseExpectedTotalChunks,\n} = require('./transcriptJobValidation');\nconst {\n  updateJobUploadState,\n  resolveFinalizeResponse,\n  resolveExpectedChunks,\n  ensureAllChunksPresent,\n  buildProcessingUpdates,\n} = require('./transcriptJobState');\nconst { createTranscriptJobsQueryService } = require('./transcriptJobsQueryService');\n\nfunction createTranscriptJobsService(deps = {}) {\n  const repo = deps.transcriptsRepository ?? transcriptsRepository;\n  const processingService = deps.transcriptsService ?? transcriptsService;\n  const cacheService = deps.transcriptCacheService ?? { cacheExternalTranscript };\n  const logger = deps.logger ?? baseLogger;\n  const queryService = createTranscriptJobsQueryService({ repo, cacheService, logger });\n\n  async function createJob({ userId, payload } = {}) {\n    const { fingerprint, mediaUrl, mediaUrlNormalized, durationMs, provider, expectedTotalChunks } =\n      payload || {};\n\n    if (!userId) {\n      throw new ValidationError('User context missing');\n    }\n    if (!fingerprint || typeof fingerprint !== 'string') {\n      throw new ValidationError('Fingerprint is required', 'fingerprint');\n    }\n    if (!mediaUrl || typeof mediaUrl !== 'string') {\n      throw new ValidationError('mediaUrl is required', 'mediaUrl');\n    }\n\n    const normalized = normalizeMediaUrlForStorage(mediaUrlNormalized || mediaUrl);\n    const redactedUrl = sanitizeMediaUrlForStorage(mediaUrl);\n    const cached = await repo.getTranscriptByFingerprint({ fingerprint, userId });\n    if (cached?.transcript_json) {\n      return {\n        success: true,\n        job: {\n          id: null,\n          status: JOB_STATUS.DONE,\n          transcript: cached.transcript_json,\n          cached: true,\n        },\n      };\n    }\n\n    const dailyCount = await repo.countTranscriptJobsSince({\n      userId,\n      since: getStartOfTodayUTC().toISOString(),\n    });\n    if (dailyCount >= TRANSCRIPT_DAILY_JOB_LIMIT) {\n      throw new AppError('Daily transcription limit reached.', 'TRANSCRIPT_DAILY_LIMIT', 429);\n    }\n\n    const activeCount = await repo.countActiveTranscriptJobs({ userId });\n    if (activeCount >= TRANSCRIPT_MAX_CONCURRENT_JOBS) {\n      throw new AppError('Too many active transcription jobs.', 'TRANSCRIPT_CONCURRENT_LIMIT', 429);\n    }\n\n    const durationMsValue = coerceNumber(durationMs);\n    if (durationMsValue && TRANSCRIPT_MAX_DURATION_MINUTES) {\n      const maxMs = TRANSCRIPT_MAX_DURATION_MINUTES * 60 * 1000;\n      if (durationMsValue > maxMs) {\n        throw new AppError(\n          `Video exceeds ${TRANSCRIPT_MAX_DURATION_MINUTES} minute limit.`,\n          'TRANSCRIPT_DURATION_LIMIT',\n          400,\n        );\n      }\n    }\n\n    const expectedChunks = expectedTotalChunks\n      ? parseExpectedTotalChunks(expectedTotalChunks)\n      : null;\n\n    const job = await repo.createTranscriptJob({\n      userId,\n      fingerprint,\n      mediaUrl: redactedUrl,\n      mediaUrlNormalized: normalized,\n      durationMs: durationMsValue,\n      provider,\n      expectedTotalChunks: expectedChunks,\n    });\n\n    return {\n      success: true,\n      job: {\n        id: job.id,\n        status: job.status,\n      },\n    };\n  }\n\n  async function uploadChunk({ userId, jobId, chunk, headers } = {}) {\n    const { chunkIndex, expectedTotalChunks } = parseChunkHeaders(headers);\n\n    ensureValidUploadPayload(jobId, chunk, chunkIndex);\n\n    const job = await repo.getTranscriptJob({ jobId, userId });\n    if (!job) {\n      throw new NotFoundError('Transcript job', jobId);\n    }\n\n    ensureJobUploadable(job);\n    ensureChunkIndexInRange(job, chunkIndex, expectedTotalChunks);\n\n    const bytesReceived = Number(job.bytes_received || 0);\n    if (bytesReceived + chunk.length > TRANSCRIPT_MAX_TOTAL_BYTES) {\n      throw new AppError('Upload exceeds maximum allowed size.', 'TRANSCRIPT_MAX_BYTES', 413);\n    }\n\n    await enforceUploadRateLimit(repo, userId, chunk.length);\n\n    const insertResult = await repo.insertTranscriptJobChunk({\n      jobId,\n      chunkIndex,\n      byteSize: chunk.length,\n    });\n\n    if (!insertResult.inserted) {\n      return { success: true, duplicate: true };\n    }\n\n    try {\n      await processingService.appendTranscriptChunk({ jobId, userId, chunk, chunkIndex });\n    } catch (error) {\n      await repo.deleteTranscriptJobChunk({ jobId, chunkIndex });\n      throw error;\n    }\n    await updateJobUploadState({\n      repo,\n      job,\n      jobId,\n      userId,\n      chunkLength: chunk.length,\n      expectedTotalChunks,\n    });\n\n    return { success: true };\n  }\n\n  async function finalizeJob({ userId, jobId, payload } = {}) {\n    const { languageHint, maxMinutes, expectedTotalChunks } = payload || {};\n\n    const job = await repo.getTranscriptJob({ jobId, userId });\n    if (!job) {\n      throw new NotFoundError('Transcript job', jobId);\n    }\n\n    const earlyResponse = await resolveFinalizeResponse(repo, job, userId);\n    if (earlyResponse) {\n      return earlyResponse;\n    }\n\n    const expectedChunks = resolveExpectedChunks(job, expectedTotalChunks);\n    await ensureAllChunksPresent(repo, jobId, expectedChunks);\n\n    await repo.updateTranscriptJob({\n      jobId,\n      userId,\n      updates: buildProcessingUpdates(expectedChunks, languageHint, maxMinutes),\n    });\n\n    processingService.startTranscriptProcessing(\n      {\n        ...job,\n        expected_total_chunks: expectedChunks,\n        language_hint: typeof languageHint === 'string' ? languageHint : null,\n        max_minutes: coerceNumber(maxMinutes),\n      },\n      {\n        languageHint: typeof languageHint === 'string' ? languageHint : null,\n        maxMinutes: coerceNumber(maxMinutes),\n      },\n    );\n\n    return {\n      success: true,\n      job: { id: job.id, status: JOB_STATUS.PROCESSING },\n    };\n  }\n\n  async function cancelJob({ userId, jobId } = {}) {\n    const job = await repo.getTranscriptJob({ jobId, userId });\n    if (!job) {\n      throw new NotFoundError('Transcript job', jobId);\n    }\n\n    if (job.status === JOB_STATUS.DONE || job.status === JOB_STATUS.ERROR) {\n      return {\n        success: true,\n        job: { id: job.id, status: job.status, error: job.error || null },\n      };\n    }\n\n    await repo.updateTranscriptJob({\n      jobId,\n      userId,\n      updates: { status: JOB_STATUS.CANCELED, error: 'Canceled' },\n    });\n\n    return {\n      success: true,\n      job: { id: job.id, status: JOB_STATUS.CANCELED },\n    };\n  }\n\n  return {\n    createJob,\n    uploadChunk,\n    finalizeJob,\n    cancelJob,\n    ...queryService,\n  };\n}\n\nconst transcriptJobsService = createTranscriptJobsService();\n\nmodule.exports = {\n  createTranscriptJobsService,\n  transcriptJobsService,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptProcessing.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 37,
        "column": 60,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 37,
        "endColumn": 62
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { randomUUID } = require('crypto');\nconst {\n  claimTranscriptJobForProcessing,\n  getTranscriptJob,\n  updateTranscriptJob,\n} = require('../../repositories/transcriptsRepository');\nconst {\n  TRANSCRIPT_PROCESSING_HEARTBEAT_INTERVAL_SECONDS,\n  TRANSCRIPT_PROCESSING_STALE_MINUTES,\n} = require('../../config');\nconst { logger } = require('../../observability');\nconst { uploadTranscriptChunk } = require('./transcriptStorage');\nconst { cleanupJobFiles } = require('./transcriptFs');\nconst { createProcessingState } = require('./transcriptProcessingUtils');\nconst { createProcessingMonitor } = require('./transcriptProcessingMonitor');\nconst { processTranscriptJob } = require('./transcriptProcessingJob');\n\nconst WORKER_ID = randomUUID();\nconst startProcessingMonitor = createProcessingMonitor({\n  getTranscriptJob,\n  updateTranscriptJob,\n  logger,\n  heartbeatIntervalSeconds: TRANSCRIPT_PROCESSING_HEARTBEAT_INTERVAL_SECONDS,\n  workerId: WORKER_ID,\n});\n\nasync function appendTranscriptChunk({ jobId, userId, chunk, chunkIndex }) {\n  if (!userId) {\n    throw new Error('Transcript chunk upload requires userId');\n  }\n  await uploadTranscriptChunk({ userId, jobId, chunkIndex, chunk });\n  return { jobId, chunkIndex };\n}\n\nasync function startTranscriptProcessing(job, options) {\n  const staleMinutes = Math.max(1, TRANSCRIPT_PROCESSING_STALE_MINUTES);\n  const staleBefore = new Date(Date.now() - staleMinutes * 60 * 1000).toISOString();\n  const claimedJob = await claimTranscriptJobForProcessing({\n    jobId: job.id,\n    workerId: WORKER_ID,\n    staleBefore,\n  });\n\n  if (!claimedJob) {\n    logger.info({ jobId: job.id }, '[Transcripts] Job already claimed by another worker');\n    return;\n  }\n\n  const state = createProcessingState(claimedJob);\n  const stopMonitor = startProcessingMonitor(state);\n\n  processTranscriptJob(claimedJob, options, state)\n    .catch(async (error) => {\n      const message = error instanceof Error ? error.message : String(error);\n      const canceled = message === 'CANCELED' || state.cancelRequested;\n\n      await updateTranscriptJob({\n        jobId: claimedJob.id,\n        userId: claimedJob.user_id,\n        updates: {\n          status: canceled ? 'canceled' : 'error',\n          error: canceled ? 'Canceled' : message,\n        },\n      });\n\n      await cleanupJobFiles(claimedJob.id);\n    })\n    .finally(() => {\n      stopMonitor();\n    });\n}\n\nmodule.exports = {\n  appendTranscriptChunk,\n  startTranscriptProcessing,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptProcessingAssembly.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptProcessingAudio.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'splitAudioIfNeeded' has too many lines (51). Maximum allowed is 50.",
        "line": 37,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 92,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 41,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 41,
        "endColumn": 34
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 41,
        "column": 37,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 41,
        "endColumn": 41
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 41,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 41,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 44,
        "column": 48,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 44,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 44,
        "column": 55,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 44,
        "endColumn": 59
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 50,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 50,
        "endColumn": 50
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 50,
        "column": 53,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 50,
        "endColumn": 57
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 52,
        "column": 56,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 58
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const fs = require('fs');\nconst path = require('path');\nconst { logger } = require('../../observability');\nconst { runFfmpeg, SEGMENT_DURATION_SECONDS } = require('./transcriptFfmpeg');\nconst { ensureNotCanceled } = require('./transcriptProcessingUtils');\n\n/**\n * Convert input media to MP3 format optimized for Whisper API.\n * Uses 64kbps mono audio - ideal balance of quality and file size.\n */\nasync function convertToAudio(inputPath, outputPath, state) {\n  ensureNotCanceled(state);\n  await runFfmpeg(\n    [\n      '-y',\n      '-i',\n      inputPath,\n      '-vn',\n      '-ac',\n      '1',\n      '-ar',\n      '16000',\n      '-b:a',\n      '64k',\n      '-f',\n      'mp3',\n      outputPath,\n    ],\n    state,\n  );\n}\n\n/**\n * Split audio into segments for reliable transcription.\n * Uses time-based splitting (5 min segments) rather than size-based.\n */\nasync function splitAudioIfNeeded(audioPath, jobDir, state) {\n  ensureNotCanceled(state);\n  const stats = await fs.promises.stat(audioPath);\n\n  const SMALL_FILE_THRESHOLD = 20 * 1024 * 1024;\n  if (stats.size <= SMALL_FILE_THRESHOLD) {\n    logger.info(\n      `[Transcripts] File size ${(stats.size / 1024 / 1024).toFixed(1)}MB - no splitting needed`,\n    );\n    return [{ path: audioPath, startMs: 0 }];\n  }\n\n  logger.info(\n    `[Transcripts] File size ${(stats.size / 1024 / 1024).toFixed(\n      1,\n    )}MB - splitting into ${SEGMENT_DURATION_SECONDS / 60} minute segments`,\n  );\n  const segmentsDir = path.join(jobDir, 'segments');\n  await fs.promises.mkdir(segmentsDir, { recursive: true });\n  const outputPattern = path.join(segmentsDir, 'segment-%03d.mp3');\n\n  await runFfmpeg(\n    [\n      '-y',\n      '-i',\n      audioPath,\n      '-vn',\n      '-f',\n      'segment',\n      '-segment_time',\n      String(SEGMENT_DURATION_SECONDS),\n      '-reset_timestamps',\n      '1',\n      '-ac',\n      '1',\n      '-ar',\n      '16000',\n      '-b:a',\n      '64k',\n      outputPattern,\n    ],\n    state,\n  );\n\n  const files = await fs.promises.readdir(segmentsDir);\n  const segments = files\n    .filter((file) => file.startsWith('segment-') && file.endsWith('.mp3'))\n    .sort()\n    .map((file, index) => ({\n      path: path.join(segmentsDir, file),\n      startMs: index * SEGMENT_DURATION_SECONDS * 1000,\n    }));\n\n  logger.info(`[Transcripts] Created ${segments.length} segments for transcription`);\n  return segments;\n}\n\nmodule.exports = {\n  convertToAudio,\n  splitAudioIfNeeded,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptProcessingJob.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 16,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 16,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const path = require('path');\nconst {\n  upsertTranscriptCache,\n  updateTranscriptJob,\n} = require('../../repositories/transcriptsRepository');\nconst { ensureJobDir, cleanupJobFiles } = require('./transcriptFs');\nconst { assembleUploadFromChunks } = require('./transcriptProcessingAssembly');\nconst { convertToAudio, splitAudioIfNeeded } = require('./transcriptProcessingAudio');\nconst { transcribeSegments } = require('./transcriptProcessingTranscription');\nconst { ensureNotCanceled, normalizeProcessingOptions } = require('./transcriptProcessingUtils');\n\nfunction enforceDurationLimit(job, options) {\n  if (!options.maxMinutes || !job.duration_ms) {\n    return;\n  }\n  const maxMs = options.maxMinutes * 60 * 1000;\n  if (job.duration_ms > maxMs) {\n    throw new Error(`Video exceeds ${options.maxMinutes} minute limit`);\n  }\n}\n\nasync function cacheTranscriptResult(job, transcript) {\n  const mediaUrlRedacted = '[REDACTED_FOR_PRIVACY]';\n  await upsertTranscriptCache({\n    userId: job.user_id,\n    fingerprint: job.fingerprint,\n    provider: job.provider || 'openai',\n    mediaUrlRedacted,\n    mediaUrlNormalized: job.media_url_normalized,\n    etag: null,\n    lastModified: null,\n    durationMs: job.duration_ms,\n    transcriptJson: transcript,\n  });\n}\n\nasync function processTranscriptJob(job, options, state) {\n  const jobDir = await ensureJobDir(job.id);\n  const uploadPath = await assembleUploadFromChunks(job, jobDir, state);\n  const effectiveOptions = normalizeProcessingOptions(job, options);\n\n  enforceDurationLimit(job, effectiveOptions);\n\n  const audioPath = path.join(jobDir, 'audio.wav');\n  await convertToAudio(uploadPath, audioPath, state);\n\n  const segments = await splitAudioIfNeeded(audioPath, jobDir, state);\n  const transcript = await transcribeSegments(segments, effectiveOptions, state);\n  ensureNotCanceled(state);\n\n  await cacheTranscriptResult(job, transcript);\n\n  await updateTranscriptJob({\n    jobId: job.id,\n    userId: job.user_id,\n    updates: { status: 'done', error: null },\n  });\n\n  await cleanupJobFiles(job.id);\n}\n\nmodule.exports = {\n  processTranscriptJob,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptProcessingMonitor.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createProcessingMonitor' has too many lines (52). Maximum allowed is 50.",
        "line": 1,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 58,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "function createProcessingMonitor({\n  getTranscriptJob,\n  updateTranscriptJob,\n  logger,\n  heartbeatIntervalSeconds,\n  workerId,\n}) {\n  return function startProcessingMonitor(state) {\n    const intervalMs = Math.max(1, heartbeatIntervalSeconds) * 1000;\n    let running = false;\n\n    const tick = async () => {\n      if (running) return;\n      running = true;\n      try {\n        const job = await getTranscriptJob({ jobId: state.jobId, userId: state.userId });\n        if (!job) return;\n\n        if (job.status === 'canceled') {\n          state.cancelRequested = true;\n          if (state.currentProcess) {\n            try {\n              state.currentProcess.kill('SIGKILL');\n            } catch (error) {\n              logger.warn({ err: error }, '[Transcripts] Failed to kill ffmpeg process');\n            }\n          }\n          return;\n        }\n\n        await updateTranscriptJob({\n          jobId: state.jobId,\n          userId: state.userId,\n          updates: {\n            processing_heartbeat_at: new Date().toISOString(),\n            processing_worker_id: workerId,\n          },\n        });\n      } catch (error) {\n        logger.warn({ err: error }, '[Transcripts] Processing heartbeat failed');\n      } finally {\n        running = false;\n      }\n    };\n\n    tick().catch((error) => {\n      logger.warn({ err: error }, '[Transcripts] Initial processing heartbeat failed');\n    });\n\n    const timer = setInterval(() => {\n      tick().catch((error) => {\n        logger.warn({ err: error }, '[Transcripts] Processing heartbeat failed');\n      });\n    }, intervalMs);\n\n    return () => clearInterval(timer);\n  };\n}\n\nmodule.exports = {\n  createProcessingMonitor,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptProcessingTranscription.js",
    "messages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'transcribeSegments' has too many statements (22). Maximum allowed is 20.",
        "line": 4,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 50,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { transcribeAudioFile } = require('./transcriptionService');\nconst { ensureNotCanceled } = require('./transcriptProcessingUtils');\n\nasync function transcribeSegments(segments, options, state) {\n  const mergedSegments = [];\n  const textParts = [];\n\n  for (const segment of segments) {\n    ensureNotCanceled(state);\n    const response = await transcribeAudioFile({\n      filePath: segment.path,\n      language: options?.languageHint,\n    });\n\n    const responseSegments = Array.isArray(response?.segments) ? response.segments : [];\n\n    if (responseSegments.length === 0 && typeof response?.text === 'string') {\n      const fallbackText = response.text.trim();\n      if (fallbackText) {\n        mergedSegments.push({\n          startMs: segment.startMs,\n          endMs: segment.startMs,\n          text: fallbackText,\n        });\n        textParts.push(fallbackText);\n      }\n      continue;\n    }\n\n    for (const cue of responseSegments) {\n      const text = typeof cue.text === 'string' ? cue.text.trim() : '';\n      if (!text) continue;\n\n      const startMs = segment.startMs + Math.round((cue.start || 0) * 1000);\n      const endMs = segment.startMs + Math.round((cue.end || 0) * 1000);\n      mergedSegments.push({ startMs, endMs, text });\n      textParts.push(text);\n    }\n  }\n\n  const plainText = textParts.join('\\n');\n  const durationMs =\n    mergedSegments.length > 0 ? mergedSegments[mergedSegments.length - 1].endMs : undefined;\n\n  return {\n    plainText,\n    segments: mergedSegments,\n    durationMs,\n  };\n}\n\nmodule.exports = {\n  transcribeSegments,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptProcessingUtils.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptReaper.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 42,
        "column": 71,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 42,
        "endColumn": 73
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 42,
        "column": 76,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 42,
        "endColumn": 78
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 24.",
        "line": 61,
        "column": 63,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 61,
        "endColumn": 65
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 61,
        "column": 68,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 61,
        "endColumn": 70
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 61,
        "column": 73,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 61,
        "endColumn": 75
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 88,
        "column": 60,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 88,
        "endColumn": 62
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 107,
        "column": 59,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 107,
        "endColumn": 61
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 144,
        "column": 76,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 144,
        "endColumn": 78
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const {\n  deleteTranscriptJobChunks,\n  listTranscriptJobChunkIndices,\n  listTranscriptJobsByHeartbeatBefore,\n  listTranscriptJobsCreatedBefore,\n  listTranscriptJobsByStatusBefore,\n  updateTranscriptJob,\n} = require('../../repositories/transcriptsRepository');\nconst {\n  TRANSCRIPT_CHUNK_RETENTION_HOURS,\n  TRANSCRIPT_CHUNK_HARD_TTL_DAYS,\n  TRANSCRIPT_JOB_TTL_MINUTES,\n  TRANSCRIPT_JOB_REAPER_INTERVAL_MINUTES,\n  TRANSCRIPT_PROCESSING_STALE_MINUTES,\n} = require('../../config');\nconst { logger } = require('../../observability');\nconst { removeTranscriptChunks } = require('./transcriptStorage');\nconst { cleanupJobFiles } = require('./transcriptFs');\nconst { startTranscriptProcessing } = require('./transcriptProcessing');\n\nasync function cleanupTranscriptChunksForJob(job, reason) {\n  if (!job?.id || !job?.user_id) return { removed: 0 };\n  const chunkIndices = await listTranscriptJobChunkIndices(job.id);\n  if (chunkIndices.length === 0) return { removed: 0 };\n\n  const batchSize = 100;\n  let removed = 0;\n\n  for (let i = 0; i < chunkIndices.length; i += batchSize) {\n    const batch = chunkIndices.slice(i, i + batchSize);\n    await removeTranscriptChunks({ userId: job.user_id, jobId: job.id, chunkIndices: batch });\n    removed += batch.length;\n  }\n\n  await deleteTranscriptJobChunks(job.id);\n  logger.info({ jobId: job.id, removed, reason }, '[Transcripts] Cleaned up transcript job chunks');\n\n  return { removed };\n}\n\nasync function cleanupCompletedTranscriptChunks() {\n  const retentionMs = Math.max(1, TRANSCRIPT_CHUNK_RETENTION_HOURS) * 60 * 60 * 1000;\n  const cutoff = new Date(Date.now() - retentionMs).toISOString();\n  const jobs = await listTranscriptJobsByStatusBefore({\n    statuses: ['done', 'error', 'canceled'],\n    updatedBefore: cutoff,\n  });\n\n  for (const job of jobs) {\n    try {\n      await cleanupTranscriptChunksForJob(job, 'retention');\n    } catch (error) {\n      logger.warn({ err: error }, '[Transcripts] Failed to clean retained job chunks');\n    }\n  }\n\n  return jobs.length;\n}\n\nasync function cleanupExpiredTranscriptChunks() {\n  const ttlMs = Math.max(1, TRANSCRIPT_CHUNK_HARD_TTL_DAYS) * 24 * 60 * 60 * 1000;\n  const cutoff = new Date(Date.now() - ttlMs).toISOString();\n  const jobs = await listTranscriptJobsCreatedBefore({ createdBefore: cutoff });\n\n  for (const job of jobs) {\n    try {\n      const result = await cleanupTranscriptChunksForJob(job, 'hard-ttl');\n      if (\n        result.removed > 0 &&\n        ['created', 'uploading', 'uploaded', 'processing'].includes(job.status)\n      ) {\n        await updateTranscriptJob({\n          jobId: job.id,\n          userId: job.user_id,\n          updates: { status: 'error', error: 'Job exceeded retention TTL' },\n        });\n      }\n    } catch (error) {\n      logger.warn({ err: error }, '[Transcripts] Failed to clean expired job chunks');\n    }\n  }\n\n  return jobs.length;\n}\n\nasync function resumeStaleTranscriptJobs() {\n  const staleMinutes = Math.max(1, TRANSCRIPT_PROCESSING_STALE_MINUTES);\n  const staleBefore = new Date(Date.now() - staleMinutes * 60 * 1000).toISOString();\n  const staleJobs = await listTranscriptJobsByHeartbeatBefore({\n    statuses: ['processing'],\n    heartbeatBefore: staleBefore,\n  });\n\n  for (const job of staleJobs) {\n    try {\n      await startTranscriptProcessing(job);\n    } catch (error) {\n      logger.warn({ err: error }, '[Transcripts] Failed to resume stale job');\n    }\n  }\n\n  return staleJobs.length;\n}\n\nasync function reapStaleTranscriptJobs() {\n  const resumed = await resumeStaleTranscriptJobs();\n  const ttlMs = Math.max(1, TRANSCRIPT_JOB_TTL_MINUTES) * 60 * 1000;\n  const cutoff = new Date(Date.now() - ttlMs).toISOString();\n  const staleJobs = await listTranscriptJobsByStatusBefore({\n    statuses: ['created', 'uploading', 'uploaded', 'processing'],\n    updatedBefore: cutoff,\n  });\n\n  for (const job of staleJobs) {\n    try {\n      await updateTranscriptJob({\n        jobId: job.id,\n        userId: job.user_id,\n        updates: {\n          status: 'error',\n          error: 'Job expired before completion',\n        },\n      });\n      await cleanupJobFiles(job.id);\n    } catch (error) {\n      logger.warn({ err: error }, '[Transcripts] Failed to mark stale job');\n    }\n  }\n\n  const cleaned = await cleanupCompletedTranscriptChunks();\n  const hardCleaned = await cleanupExpiredTranscriptChunks();\n\n  return {\n    reaped: staleJobs.length,\n    resumed,\n    cleaned,\n    hardCleaned,\n  };\n}\n\nlet reaperInterval = null;\n\nfunction startTranscriptJobReaper() {\n  const intervalMs = Math.max(1, TRANSCRIPT_JOB_REAPER_INTERVAL_MINUTES) * 60 * 1000;\n\n  reapStaleTranscriptJobs().catch((error) => {\n    logger.warn({ err: error }, '[Transcripts] Initial job reaper run failed');\n  });\n\n  reaperInterval = setInterval(() => {\n    reapStaleTranscriptJobs().catch((error) => {\n      logger.warn({ err: error }, '[Transcripts] Job reaper run failed');\n    });\n  }, intervalMs);\n\n  return () => stopTranscriptJobReaper();\n}\n\nfunction stopTranscriptJobReaper() {\n  if (reaperInterval) {\n    clearInterval(reaperInterval);\n    reaperInterval = null;\n  }\n}\n\nmodule.exports = {\n  reapStaleTranscriptJobs,\n  startTranscriptJobReaper,\n  stopTranscriptJobReaper,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptStorage.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptionService.js",
    "messages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'transcribeAudioFile' has too many statements (30). Maximum allowed is 20.",
        "line": 50,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 115,
        "endColumn": 2
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'transcribeAudioFile' has a complexity of 16. Maximum allowed is 15.",
        "line": 50,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 50,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 50,
        "column": 84,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 50,
        "endColumn": 85
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 62,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 62,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 62,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 62,
        "endColumn": 47
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 25.",
        "line": 65,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 65,
        "endColumn": 22
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 65,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 65,
        "endColumn": 29
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 65,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 65,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Transcription Service Wrapper\n *\n * Provides unified interface for audio transcription with Azure Speech (primary)\n * and OpenAI Whisper (fallback). This wrapper maintains backward compatibility\n * with existing transcribeAudioFile interface.\n *\n * @module services/transcription\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { createTranscriptionClient } = require('../../providers/transcriptionFactory');\nconst {\n  AZURE_SPEECH_API_KEY,\n  AZURE_SPEECH_REGION,\n  AZURE_SPEECH_LANGUAGE,\n  OPENAI_API_KEY,\n} = require('../../config');\n\nlet transcriptionClientInstance = null;\n\n/**\n * Get or create transcription client singleton\n */\nfunction getTranscriptionClient() {\n  if (!transcriptionClientInstance) {\n    transcriptionClientInstance = createTranscriptionClient({\n      azureSpeechApiKey: AZURE_SPEECH_API_KEY,\n      azureSpeechRegion: AZURE_SPEECH_REGION,\n      openaiApiKey: OPENAI_API_KEY,\n      preferredLanguage: AZURE_SPEECH_LANGUAGE || 'en-US',\n    });\n  }\n  return transcriptionClientInstance;\n}\n\n/**\n * Transcribe audio file with automatic provider selection\n *\n * Maintains backward compatibility with existing interface while using\n * modular provider architecture underneath.\n *\n * @param {Object} options - Transcription options\n * @param {string} options.filePath - Path to audio file\n * @param {string} options.language - Language code (ISO 639-1)\n * @param {number} options.maxRetries - Max retries (default: 3)\n * @returns {Promise<Object>} Transcription response\n */\nasync function transcribeAudioFile({ filePath, language, maxRetries: _maxRetries = 3 }) {\n  if (!filePath) {\n    throw new Error('Audio file path is required');\n  }\n\n  // Check file exists\n  if (!fs.existsSync(filePath)) {\n    throw new Error(`Audio file not found: ${filePath}`);\n  }\n\n  // Check file size\n  const stats = fs.statSync(filePath);\n  const fileSizeMB = stats.size / (1024 * 1024);\n\n  // Both Azure Speech and Whisper have size limits (25MB for Whisper, 200MB for Azure Speech)\n  if (stats.size > 25 * 1024 * 1024) {\n    throw new Error(\n      `Audio file too large: ${fileSizeMB.toFixed(\n        1,\n      )}MB (max 25MB). File should be split into smaller segments.`,\n    );\n  }\n\n  const filename = path.basename(filePath);\n  const format = path.extname(filename).slice(1) || 'wav';\n\n  console.log(`[Transcription] Processing ${fileSizeMB.toFixed(1)}MB audio file: ${filename}`);\n\n  try {\n    const startTime = Date.now();\n    const client = getTranscriptionClient();\n\n    // Read audio file\n    const audioData = fs.readFileSync(filePath);\n\n    // Transcribe with automatic fallback\n    const result = await client.transcribe(audioData, {\n      language,\n      format,\n      filename,\n    });\n\n    const duration = ((Date.now() - startTime) / 1000).toFixed(1);\n    const provider = result.provider || 'unknown';\n    const fallbackNote = result.fallbackUsed ? ' (fallback used)' : '';\n\n    console.log(`[Transcription] Completed in ${duration}s using ${provider}${fallbackNote}`);\n\n    // Normalize response format to match existing interface\n    return normalizeTranscriptionResponse(result);\n  } catch (error) {\n    let message = 'Transcription failed';\n    if (error?.message) {\n      message = error.message;\n    }\n\n    if (error?.message?.includes('Connection error') || error?.code === 'ECONNREFUSED') {\n      message += '. This may be a temporary network issue - please try again.';\n    }\n\n    console.error('[Transcription] Failed:', message);\n    const wrappedError = new Error(message);\n    wrappedError.originalError = error;\n    throw wrappedError;\n  }\n}\n\n/**\n * Normalize transcription response to common format\n *\n * Ensures response matches the format expected by transcriptsService.js\n */\nfunction normalizeTranscriptionResponse(result) {\n  // Check if it's a Whisper response (has segments array)\n  if (Array.isArray(result.segments)) {\n    return result; // Already in correct format\n  }\n\n  // Azure Speech response - create compatible format\n  return {\n    text: result.text || '',\n    language: result.language || 'unknown',\n    duration: result.duration || 0,\n    segments: [], // Azure Speech doesn't provide segments by default\n  };\n}\n\nmodule.exports = {\n  transcribeAudioFile,\n  getTranscriptionClient,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\services\\transcripts\\transcriptsService.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\__tests__\\networkRetry.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 8,
        "column": 19,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 8,
        "endColumn": 22
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 300.",
        "line": 8,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 8,
        "endColumn": 38
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 10,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 10,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 300.",
        "line": 10,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 10,
        "endColumn": 46
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (61). Maximum allowed is 50.",
        "line": 17,
        "column": 41,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 85,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 30,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 30,
        "endColumn": 46
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 30,
        "column": 65,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 30,
        "endColumn": 68
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 51,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 51,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 64,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 64,
        "endColumn": 44
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { describe, it, afterEach } = require('node:test');\nconst assert = require('node:assert');\nconst { fetchWithRetry } = require('../networkRetry');\nconst originalFetch = global.fetch;\n\nfunction createResponse(status) {\n  return {\n    ok: status >= 200 && status < 300,\n    status,\n    statusText: status >= 200 && status < 300 ? 'OK' : 'Error',\n    headers: {\n      get: () => null,\n    },\n  };\n}\n\ndescribe('networkRetry.fetchWithRetry', () => {\n  afterEach(() => {\n    if (originalFetch) {\n      global.fetch = originalFetch;\n    } else {\n      delete global.fetch;\n    }\n  });\n\n  it('retries retryable responses and succeeds', async () => {\n    let calls = 0;\n    global.fetch = async () => {\n      calls += 1;\n      return calls === 1 ? createResponse(500) : createResponse(200);\n    };\n\n    const response = await fetchWithRetry(\n      'https://example.com',\n      {},\n      {\n        maxRetries: 1,\n        baseDelayMs: 0,\n        maxDelayMs: 0,\n      },\n    );\n\n    assert.strictEqual(response.ok, true);\n    assert.strictEqual(calls, 2);\n  });\n\n  it('does not retry non-retryable responses', async () => {\n    let calls = 0;\n    global.fetch = async () => {\n      calls += 1;\n      return createResponse(404);\n    };\n\n    const response = await fetchWithRetry(\n      'https://example.com',\n      {},\n      {\n        maxRetries: 3,\n        baseDelayMs: 0,\n        maxDelayMs: 0,\n      },\n    );\n\n    assert.strictEqual(response.status, 404);\n    assert.strictEqual(calls, 1);\n  });\n\n  it('throws timeout error when request exceeds timeout', async () => {\n    global.fetch = (_url, options) =>\n      new Promise((_, reject) => {\n        if (options?.signal) {\n          options.signal.addEventListener('abort', () => {\n            const error = new Error('Aborted');\n            error.name = 'AbortError';\n            reject(error);\n          });\n        }\n      });\n\n    await assert.rejects(\n      () => fetchWithRetry('https://example.com', {}, { maxRetries: 0, timeoutMs: 5 }),\n      (error) => error && error.code === 'TIMEOUT',\n    );\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\assetValidation.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\assetValidation.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\chatAssetValidation.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 77,
        "column": 55,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 59
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 77,
        "column": 62,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 66
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Chat Asset Validation\n *\n * Validation utilities for chat message attachments.\n * Supports images (for vision), documents, and code files.\n */\n\nconst {\n  CHAT_ASSETS_MAX_BYTES,\n  ALLOWED_CHAT_ASSET_MIME_TYPES,\n  CHAT_ASSET_MIME_GROUPS,\n  MIME_EXTENSION_MAP,\n} = require('../config');\n\n/**\n * Infer asset type from MIME type\n * @param {string} mimeType\n * @returns {'image'|'document'|'code'|'other'}\n */\nfunction inferChatAssetType(mimeType) {\n  const match = Object.entries(CHAT_ASSET_MIME_GROUPS).find(([, mimes]) =>\n    mimes.includes(mimeType),\n  );\n  return match ? match[0] : 'other';\n}\n\n/**\n * Get file extension for a MIME type\n * @param {string} mimeType\n * @returns {string}\n */\nfunction getExtensionForMime(mimeType) {\n  if (MIME_EXTENSION_MAP[mimeType]) {\n    return MIME_EXTENSION_MAP[mimeType];\n  }\n\n  const subtype = mimeType?.split('/')?.[1];\n  if (!subtype) return 'bin';\n\n  // Strip any parameters (e.g., \"text/plain; charset=utf-8\")\n  return subtype.split(';')[0];\n}\n\nconst TEXTUAL_MIME_TYPES = new Set(['application/json']);\nconst OFFICE_ZIP_MIME_TYPES = new Set([\n  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n]);\n\nfunction normalizeMimeType(mimeType) {\n  if (!mimeType || typeof mimeType !== 'string') return '';\n  return mimeType.split(';')[0].trim().toLowerCase();\n}\n\nfunction isTextualMime(mimeType) {\n  return mimeType.startsWith('text/') || TEXTUAL_MIME_TYPES.has(mimeType);\n}\n\nasync function detectMagicMimeType(file) {\n  if (!file?.buffer) return null;\n\n  const { fileTypeFromBuffer } = await import('file-type');\n  return fileTypeFromBuffer(file.buffer);\n}\n\n/**\n * Validate a file for chat attachment upload (includes magic bytes validation)\n * @param {Object} file - Multer file object\n * @returns {Promise<Object>} Validation result\n */\nasync function validateChatAssetFile(file) {\n  if (!file) {\n    return { valid: false, reason: 'File is required' };\n  }\n\n  if (file.size > CHAT_ASSETS_MAX_BYTES) {\n    const maxMB = Math.round(CHAT_ASSETS_MAX_BYTES / (1024 * 1024));\n    return {\n      valid: false,\n      reason: `File exceeds maximum size of ${maxMB}MB`,\n    };\n  }\n\n  const declaredMimeType = normalizeMimeType(file.mimetype);\n  if (!ALLOWED_CHAT_ASSET_MIME_TYPES.includes(declaredMimeType)) {\n    return { valid: false, reason: 'File type not allowed' };\n  }\n\n  const detected = await detectMagicMimeType(file);\n  if (detected) {\n    const detectedMime = normalizeMimeType(detected.mime);\n    const isOfficeZip =\n      detectedMime === 'application/zip' && OFFICE_ZIP_MIME_TYPES.has(declaredMimeType);\n\n    if (!isOfficeZip && detectedMime !== declaredMimeType) {\n      return { valid: false, reason: 'File content does not match declared type' };\n    }\n  } else if (!isTextualMime(declaredMimeType)) {\n    return { valid: false, reason: 'Unable to verify file content' };\n  }\n\n  const type = inferChatAssetType(declaredMimeType);\n  const extension = getExtensionForMime(declaredMimeType);\n\n  return {\n    valid: true,\n    mimeType: declaredMimeType,\n    type,\n    extension,\n  };\n}\n\n/**\n * Check if a MIME type is an image that supports vision analysis\n * @param {string} mimeType\n * @returns {boolean}\n */\nfunction isVisionCompatibleImage(mimeType) {\n  const visionMimes = ['image/png', 'image/jpeg', 'image/webp', 'image/gif'];\n  return visionMimes.includes(mimeType);\n}\n\nmodule.exports = {\n  validateChatAssetFile,\n  inferChatAssetType,\n  getExtensionForMime,\n  isVisionCompatibleImage,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\chatAssetValidation.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\chatTitle.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\chatTitle.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 80.",
        "line": 19,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 19,
        "endColumn": 31
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 20,
        "column": 40,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 20,
        "endColumn": 41
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst {\n  buildInitialChatTitle,\n  coerceGeneratedTitle,\n  extractFirstUserMessage,\n} = require('./chatTitle');\n\ntest('buildInitialChatTitle trims to six words and normalizes whitespace', () => {\n  const title = buildInitialChatTitle('Intro   to distributed   systems and concurrency basics');\n  assert.equal(title, 'Intro to distributed systems and concurrency');\n});\n\ntest('buildInitialChatTitle clamps to max length', () => {\n  const longWord = 'abcdefghijklmnopqrst';\n  const text = Array.from({ length: 6 }, () => longWord).join(' ');\n  const title = buildInitialChatTitle(text);\n  assert.ok(title.length <= 80, 'Title should be clamped to 80 characters');\n  assert.ok(title.split(' ').length <= 6, 'Title should be clamped to 6 words');\n});\n\ntest('buildInitialChatTitle falls back to default when empty', () => {\n  const title = buildInitialChatTitle('   ');\n  assert.equal(title, 'New chat');\n});\n\ntest('extractFirstUserMessage returns the first user-authored message content', () => {\n  const messages = [\n    { role: 'assistant', content: 'Hello!' },\n    { role: 'user', input_text: ' First question about arrays ' },\n    { role: 'user', input_text: 'Second question' },\n  ];\n\n  const first = extractFirstUserMessage(messages);\n  assert.equal(first, 'First question about arrays');\n});\n\ntest('coerceGeneratedTitle clamps long candidates and uses fallback when empty', () => {\n  const clamped = coerceGeneratedTitle(\n    'Arrays and linked lists overview in depth today',\n    'Placeholder title',\n  );\n  assert.equal(clamped, 'Arrays and linked lists overview in');\n\n  const fallback = coerceGeneratedTitle('', '  Custom fallback  ');\n  assert.equal(fallback, 'Custom fallback');\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\circuitBreaker.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 3,
        "column": 57,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 3,
        "endColumn": 58
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 30000.",
        "line": 4,
        "column": 53,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 4,
        "endColumn": 58
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "class CircuitBreaker {\n  constructor(options = {}) {\n    this.failureThreshold = options.failureThreshold ?? 3;\n    this.openDurationMs = options.openDurationMs ?? 30000;\n    this.halfOpenMaxAttempts = options.halfOpenMaxAttempts ?? 1;\n    this._now = options.now ?? (() => Date.now());\n    this._states = new Map();\n  }\n\n  _getState(provider) {\n    if (!this._states.has(provider)) {\n      this._states.set(provider, {\n        state: 'closed',\n        failures: 0,\n        openedAt: null,\n        halfOpenAttempts: 0,\n      });\n    }\n    return this._states.get(provider);\n  }\n\n  canRequest(provider) {\n    const state = this._getState(provider);\n    if (state.state === 'open') {\n      const elapsed = this._now() - state.openedAt;\n      if (elapsed >= this.openDurationMs) {\n        state.state = 'half_open';\n        state.halfOpenAttempts = 0;\n      } else {\n        return {\n          allowed: false,\n          state: 'open',\n          retryAfterMs: Math.max(0, this.openDurationMs - elapsed),\n        };\n      }\n    }\n\n    if (state.state === 'half_open') {\n      if (state.halfOpenAttempts >= this.halfOpenMaxAttempts) {\n        return { allowed: false, state: 'half_open', retryAfterMs: this.openDurationMs };\n      }\n      state.halfOpenAttempts += 1;\n      return { allowed: true, state: 'half_open', retryAfterMs: 0 };\n    }\n\n    return { allowed: true, state: 'closed', retryAfterMs: 0 };\n  }\n\n  recordSuccess(provider) {\n    const state = this._getState(provider);\n    state.state = 'closed';\n    state.failures = 0;\n    state.openedAt = null;\n    state.halfOpenAttempts = 0;\n    return { state: state.state, failures: state.failures };\n  }\n\n  recordFailure(provider) {\n    const state = this._getState(provider);\n    state.failures += 1;\n    if (state.failures >= this.failureThreshold) {\n      state.state = 'open';\n      state.openedAt = this._now();\n      state.halfOpenAttempts = 0;\n      return { state: state.state, failures: state.failures, opened: true };\n    }\n    return { state: state.state, failures: state.failures, opened: false };\n  }\n\n  getState(provider) {\n    const state = this._getState(provider);\n    return { ...state };\n  }\n\n  reset(provider) {\n    if (provider) {\n      this._states.delete(provider);\n      return;\n    }\n    this._states.clear();\n  }\n}\n\nmodule.exports = {\n  CircuitBreaker,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\idempotency.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 3,
        "column": 28,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 3,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 4,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 4,
        "endColumn": 26
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createIdempotencyStore' has too many lines (126). Maximum allowed is 50.",
        "line": 17,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 167,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'run' has too many statements (21). Maximum allowed is 20.",
        "line": 126,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 161,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { supabase } = require('../db/supabaseClient');\n\nconst DEFAULT_TTL_MS = 2 * 60 * 1000;\nconst DEFAULT_WAIT_MS = 5 * 1000;\nconst DEFAULT_POLL_INTERVAL_MS = 250;\n\nfunction createIdempotencyConflictError(message) {\n  const error = new Error(message);\n  error.status = 409;\n  error.payload = {\n    success: false,\n    error: { message },\n  };\n  return error;\n}\n\nfunction createIdempotencyStore(options = {}) {\n  const ttlMs = options.ttlMs ?? DEFAULT_TTL_MS;\n  const waitMs = options.waitMs ?? DEFAULT_WAIT_MS;\n  const pollIntervalMs = options.pollIntervalMs ?? DEFAULT_POLL_INTERVAL_MS;\n\n  async function cleanupExpired(userId, nowIso) {\n    if (!userId) return;\n    const { error } = await supabase\n      .from('idempotency_keys')\n      .delete()\n      .eq('user_id', userId)\n      .lt('expires_at', nowIso);\n    if (error) {\n      throw error;\n    }\n  }\n\n  async function getEntry(key, userId) {\n    if (!key || !userId) return null;\n    const { data, error } = await supabase\n      .from('idempotency_keys')\n      .select('*')\n      .eq('idempotency_key', key)\n      .eq('user_id', userId)\n      .limit(1);\n\n    if (error) {\n      throw error;\n    }\n\n    return Array.isArray(data) && data.length > 0 ? data[0] : null;\n  }\n\n  async function insertEntry(key, userId, nowIso, expiresAt) {\n    const payload = {\n      idempotency_key: key,\n      user_id: userId,\n      status: 'in_progress',\n      created_at: nowIso,\n      updated_at: nowIso,\n      expires_at: expiresAt,\n    };\n\n    const { data, error } = await supabase\n      .from('idempotency_keys')\n      .insert(payload)\n      .select()\n      .single();\n\n    if (error) {\n      if (error.code === '23505') {\n        return { inserted: false, entry: null };\n      }\n      throw error;\n    }\n\n    return { inserted: true, entry: data };\n  }\n\n  async function updateEntry(key, userId, updates) {\n    const payload = {\n      ...updates,\n      updated_at: new Date().toISOString(),\n    };\n\n    const { error } = await supabase\n      .from('idempotency_keys')\n      .update(payload)\n      .eq('idempotency_key', key)\n      .eq('user_id', userId);\n\n    if (error) {\n      throw error;\n    }\n  }\n\n  async function deleteEntry(key, userId) {\n    if (!key || !userId) return;\n    const { error } = await supabase\n      .from('idempotency_keys')\n      .delete()\n      .eq('idempotency_key', key)\n      .eq('user_id', userId);\n\n    if (error) {\n      throw error;\n    }\n  }\n\n  async function waitForCompletion(key, userId) {\n    const start = Date.now();\n    const deadline = start + waitMs;\n\n    while (Date.now() < deadline) {\n      const entry = await getEntry(key, userId);\n      if (!entry) return null;\n      if (entry.status === 'completed' && entry.response) {\n        return entry.response;\n      }\n      if (entry.expires_at && new Date(entry.expires_at).getTime() <= Date.now()) {\n        await deleteEntry(key, userId);\n        return null;\n      }\n      await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));\n    }\n\n    throw createIdempotencyConflictError('Request is already in progress. Please retry shortly.');\n  }\n\n  async function run(key, userId, task) {\n    if (!key || !userId) {\n      return task();\n    }\n\n    const now = new Date();\n    const nowIso = now.toISOString();\n    const expiresAt = new Date(now.getTime() + ttlMs).toISOString();\n\n    await cleanupExpired(userId, nowIso);\n\n    const insertResult = await insertEntry(key, userId, nowIso, expiresAt);\n\n    if (!insertResult.inserted) {\n      const existing = await getEntry(key, userId);\n      if (existing?.expires_at && new Date(existing.expires_at).getTime() <= Date.now()) {\n        await deleteEntry(key, userId);\n        return run(key, userId, task);\n      }\n\n      if (existing?.status === 'completed' && existing.response) {\n        return existing.response;\n      }\n\n      return waitForCompletion(key, userId);\n    }\n\n    try {\n      const response = await task();\n      await updateEntry(key, userId, { status: 'completed', response });\n      return response;\n    } catch (error) {\n      await deleteEntry(key, userId);\n      throw error;\n    }\n  }\n\n  return {\n    run,\n    getEntry,\n  };\n}\n\nmodule.exports = {\n  createIdempotencyStore,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\idempotencyKey.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\lexicalUtils.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\lexicalUtils.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\networkRetry.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 8,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 8,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.3.",
        "line": 29,
        "column": 49,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 29,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 52,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 52,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 39
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 52,
        "column": 54,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 57
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 54,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 54,
        "endColumn": 49
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has too many lines (81). Maximum allowed is 50.",
        "line": 98,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 193,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has too many statements (47). Maximum allowed is 20.",
        "line": 98,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 193,
        "endColumn": 2
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has a complexity of 36. Maximum allowed is 15.",
        "line": 98,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 98,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "const { TimeoutError, AbortError } = require('../errors');\n\nconst DEFAULT_RETRY_CONFIG = {\n  maxRetries: 3,\n  baseDelayMs: 500,\n  maxDelayMs: 5000,\n  timeoutMs: 30000,\n  retryableStatuses: [429],\n  retryOnServerError: true,\n  retryOnNetworkError: true,\n  retryOnTimeout: true,\n};\n\nfunction normalizeConfig(overrides) {\n  if (!overrides) return { ...DEFAULT_RETRY_CONFIG };\n  const retryableStatuses = Array.isArray(overrides.retryableStatuses)\n    ? overrides.retryableStatuses\n    : DEFAULT_RETRY_CONFIG.retryableStatuses;\n  return { ...DEFAULT_RETRY_CONFIG, ...overrides, retryableStatuses };\n}\n\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nfunction calculateRetryDelay(attempt, config) {\n  const exponentialDelay = config.baseDelayMs * Math.pow(2, attempt);\n  const cappedDelay = Math.min(exponentialDelay, config.maxDelayMs);\n  const jitter = cappedDelay * (Math.random() * 0.3);\n  return Math.floor(cappedDelay + jitter);\n}\n\nfunction parseRetryAfterMs(response) {\n  const value = response.headers?.get?.('retry-after');\n  if (!value) return undefined;\n\n  const seconds = Number(value);\n  if (!Number.isNaN(seconds)) {\n    return Math.max(0, seconds * 1000);\n  }\n\n  const dateMs = Date.parse(value);\n  if (!Number.isNaN(dateMs)) {\n    return Math.max(0, dateMs - Date.now());\n  }\n\n  return undefined;\n}\n\nfunction isRetryableStatus(status, config) {\n  if (status === 0) return false;\n  if (status === 401 || status === 403 || status === 404) return false;\n  if (config.retryableStatuses.includes(status)) return true;\n  if (config.retryOnServerError && status >= 500) return true;\n  return false;\n}\n\nfunction isNetworkError(error) {\n  if (!error) return false;\n  const message = error instanceof Error ? error.message : String(error);\n  return (\n    message.includes('Failed to fetch') ||\n    message.includes('NetworkError') ||\n    message.includes('Network request failed') ||\n    message.includes('ERR_NETWORK') ||\n    message.includes('ECONNRESET') ||\n    message.includes('ETIMEDOUT') ||\n    message.includes('EAI_AGAIN')\n  );\n}\n\nfunction createTimeoutError(timeoutMs, context) {\n  const label = context ? `${context} ` : '';\n  return new TimeoutError(`${label}timed out after ${timeoutMs}ms`, {\n    timeoutMs,\n    context: context ?? null,\n  });\n}\n\nfunction isAbortError(error) {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' ||\n      error.code === 'ABORTED' ||\n      error.code === 'ABORT_ERR' ||\n      error.code === 'ERR_ABORTED')\n  );\n}\n\nfunction shouldRetryError(error, config) {\n  if (!error) return false;\n  if (error.code === 'TIMEOUT') return config.retryOnTimeout;\n  if (error.code === 'ABORTED') return false;\n  if (isNetworkError(error)) return config.retryOnNetworkError;\n  return false;\n}\n\nasync function fetchWithRetry(url, options = {}, configOverrides = {}) {\n  const config = normalizeConfig(configOverrides);\n  const fetcher = config.fetcher || global.fetch;\n  if (typeof fetcher !== 'function') {\n    throw new Error('Fetch implementation is required.');\n  }\n\n  const maxAttempts = Math.max(0, config.maxRetries) + 1;\n  let lastError = null;\n  let lastResponse = null;\n\n  for (let attempt = 0; attempt < maxAttempts; attempt += 1) {\n    if (options.signal?.aborted) {\n      throw new AbortError('Request aborted');\n    }\n\n    let timeoutId;\n    let timedOut = false;\n    const controller = new AbortController();\n    const abortFromSignal = () => controller.abort();\n\n    if (options.signal) {\n      if (options.signal.aborted) {\n        controller.abort();\n      } else {\n        options.signal.addEventListener('abort', abortFromSignal, { once: true });\n      }\n    }\n\n    if (config.timeoutMs && config.timeoutMs > 0) {\n      timeoutId = setTimeout(() => {\n        timedOut = true;\n        controller.abort();\n      }, config.timeoutMs);\n    }\n\n    try {\n      const response = await fetcher(url, { ...options, signal: controller.signal });\n      lastResponse = response;\n\n      if (response.ok || !isRetryableStatus(response.status, config)) {\n        return response;\n      }\n\n      lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);\n    } catch (error) {\n      if (isAbortError(error) && timedOut) {\n        lastError = createTimeoutError(config.timeoutMs, config.context);\n      } else if (isAbortError(error)) {\n        lastError = new AbortError('Request aborted');\n      } else {\n        lastError = error instanceof Error ? error : new Error(String(error));\n      }\n\n      if (options.signal?.aborted && !timedOut) {\n        throw lastError;\n      }\n    } finally {\n      if (timeoutId) clearTimeout(timeoutId);\n      if (options.signal) {\n        options.signal.removeEventListener('abort', abortFromSignal);\n      }\n    }\n\n    const shouldRetry =\n      lastResponse && isRetryableStatus(lastResponse.status, config)\n        ? true\n        : shouldRetryError(lastError, config);\n\n    if (!shouldRetry || attempt >= maxAttempts - 1) {\n      if (lastResponse) {\n        return lastResponse;\n      }\n      throw lastError || new Error('Request failed');\n    }\n\n    const retryAfterMs = lastResponse ? parseRetryAfterMs(lastResponse) : undefined;\n    const delayMs =\n      typeof retryAfterMs === 'number' ? retryAfterMs : calculateRetryDelay(attempt, config);\n\n    if (typeof config.onRetry === 'function') {\n      config.onRetry({\n        attempt: attempt + 1,\n        maxRetries: config.maxRetries,\n        delayMs,\n        status: lastResponse?.status,\n        error: lastError,\n      });\n    }\n\n    await sleep(delayMs);\n  }\n\n  if (lastResponse) return lastResponse;\n  throw lastError || new Error('Request failed after retries');\n}\n\nmodule.exports = {\n  DEFAULT_RETRY_CONFIG,\n  fetchWithRetry,\n  parseRetryAfterMs,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\noteLimits.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\utils\\validateEnv.js",
    "messages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'validateEnv' has too many statements (27). Maximum allowed is 20.",
        "line": 39,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 98,
        "endColumn": 2
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Function 'validateEnv' has a complexity of 20. Maximum allowed is 15.",
        "line": 39,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 39,
        "endColumn": 21
      },
      {
        "ruleId": "no-eval",
        "severity": 1,
        "message": "eval can be harmful.",
        "line": 87,
        "column": 11,
        "nodeType": "CallExpression",
        "messageId": "unexpected",
        "endLine": 87,
        "endColumn": 15
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'validateEnvOrExit' has too many statements (21). Maximum allowed is 20.",
        "line": 107,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 142,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Environment Variable Validation Utility\n *\n * Provides fail-fast validation for required environment variables.\n * Prevents runtime errors by checking configuration at startup.\n *\n * Industry best practices:\n * - Fail fast: Validate on startup, not on first use\n * - Clear errors: Tell developers exactly what's missing\n * - Environment-aware: Different requirements for dev/prod\n * - Single source of truth: One place for all validation logic\n */\n\n// Simple console color helpers (no dependencies)\nconst colors = {\n  red: (text) => `\\x1b[31m${text}\\x1b[0m`,\n  yellow: (text) => `\\x1b[33m${text}\\x1b[0m`,\n  green: (text) => `\\x1b[32m${text}\\x1b[0m`,\n  reset: (text) => text,\n};\n\nclass ValidationError extends Error {\n  constructor(message, missing = []) {\n    super(message);\n    this.name = 'ValidationError';\n    this.missing = missing;\n  }\n}\n\n/**\n * Validates that required environment variables are set.\n *\n * @param {Object} schema - Validation schema\n * @param {Object} schema.required - Always required variables (all environments)\n * @param {Object} schema.requiredInProd - Required only in production\n * @param {Object} schema.atLeastOne - At least one from the list must be set\n * @returns {Object} Validation result { valid, errors, warnings }\n */\nfunction validateEnv(schema = {}) {\n  const env = process.env.NODE_ENV || 'development';\n  const isProd = env === 'production';\n  const isDev = env === 'development';\n\n  const errors = [];\n  const warnings = [];\n\n  // Check always-required variables\n  if (schema.required) {\n    for (const [key, description] of Object.entries(schema.required)) {\n      if (!process.env[key]) {\n        errors.push(`${key} (${description})`);\n      }\n    }\n  }\n\n  // Check production-only requirements\n  if (isProd && schema.requiredInProd) {\n    for (const [key, description] of Object.entries(schema.requiredInProd)) {\n      if (!process.env[key]) {\n        errors.push(`${key} (${description}) [PROD ONLY]`);\n      }\n    }\n  }\n\n  // Check development-only requirements\n  if (isDev && schema.requiredInDev) {\n    for (const [key, description] of Object.entries(schema.requiredInDev)) {\n      if (!process.env[key]) {\n        errors.push(`${key} (${description}) [DEV ONLY]`);\n      }\n    }\n  }\n\n  // Check \"at least one\" requirements\n  if (schema.atLeastOne) {\n    for (const [groupName, keys] of Object.entries(schema.atLeastOne)) {\n      const hasAtLeastOne = keys.some((key) => process.env[key]);\n      if (!hasAtLeastOne) {\n        errors.push(`${groupName}: At least one of [${keys.join(', ')}] must be set`);\n      }\n    }\n  }\n\n  // Check for common misconfigurations\n  if (schema.warnings) {\n    for (const [condition, message] of Object.entries(schema.warnings)) {\n      if (eval(condition)) {\n        warnings.push(message);\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n/**\n * Validates and fails fast if required variables are missing.\n * Prints colored output to help developers quickly identify issues.\n *\n * @param {Object} schema - Validation schema (same as validateEnv)\n * @throws {ValidationError} If validation fails\n */\nfunction validateEnvOrExit(schema) {\n  const env = process.env.NODE_ENV || 'development';\n  const result = validateEnv(schema);\n\n  if (result.warnings.length > 0) {\n    console.warn(colors.yellow('  Environment Configuration Warnings:'));\n    result.warnings.forEach((warning) => {\n      console.warn(colors.yellow(`   - ${warning}`));\n    });\n    console.warn('');\n  }\n\n  if (!result.valid) {\n    console.error(colors.red(' Environment Validation Failed'));\n    console.error(colors.red(`   Current environment: ${env}`));\n    console.error('');\n    console.error(colors.red('Missing required variables:'));\n    result.errors.forEach((error) => {\n      console.error(colors.red(`    ${error}`));\n    });\n    console.error('');\n    console.error(colors.yellow(' Fix:'));\n    console.error(colors.yellow('   1. Copy backend/.env.example to backend/.env'));\n    console.error(colors.yellow('   2. Fill in the required values'));\n    console.error(colors.yellow('   3. Restart the server'));\n    console.error('');\n\n    // Exit with error code\n    process.exit(1);\n  }\n\n  // Success message (only in verbose mode)\n  if (process.env.SHOW_ENV_VALIDATION_SUCCESS === 'true') {\n    console.log(colors.green(' Environment validation passed'));\n  }\n}\n\n/**\n * Lock-in Backend validation schema\n */\nconst LOCKIN_BACKEND_SCHEMA = {\n  required: {\n    NODE_ENV: 'Environment (development|staging|production)',\n  },\n\n  requiredInDev: {\n    SUPABASE_URL_DEV: 'Development Supabase URL',\n    SUPABASE_SERVICE_ROLE_KEY_DEV: 'Development Supabase service role key',\n  },\n\n  requiredInProd: {\n    SUPABASE_URL_PROD: 'Production Supabase URL',\n    SUPABASE_SERVICE_ROLE_KEY_PROD: 'Production Supabase service role key',\n  },\n\n  atLeastOne: {\n    'AI Provider': ['AZURE_OPENAI_API_KEY', 'OPENAI_API_KEY'],\n  },\n\n  warnings: {\n    'process.env.SUPABASE_URL && !process.env.SUPABASE_URL_DEV && !process.env.SUPABASE_URL_PROD':\n      'Found legacy SUPABASE_URL. Use SUPABASE_URL_DEV or SUPABASE_URL_PROD instead.',\n    'process.env.SUPABASE_SERVICE_ROLE_KEY && !process.env.SUPABASE_SERVICE_ROLE_KEY_DEV && !process.env.SUPABASE_SERVICE_ROLE_KEY_PROD':\n      'Found legacy SUPABASE_SERVICE_ROLE_KEY. Use environment-specific keys instead.',\n    'process.env.NODE_ENV === \"development\" && process.env.SUPABASE_URL_PROD':\n      'NODE_ENV=development but SUPABASE_URL_PROD is set. Risk of accidental prod writes!',\n    'process.env.NODE_ENV === \"production\" && process.env.SUPABASE_URL_DEV':\n      'NODE_ENV=production but SUPABASE_URL_DEV is set. Should only have prod vars.',\n  },\n};\n\nmodule.exports = {\n  validateEnv,\n  validateEnvOrExit,\n  ValidationError,\n  LOCKIN_BACKEND_SCHEMA,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\validators\\__tests__\\assistantValidators.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50001.",
        "line": 116,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 116,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 51.",
        "line": 127,
        "column": 24,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 127,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 11.",
        "line": 140,
        "column": 24,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 140,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 201.",
        "line": 270,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 270,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 285,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 285,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/validators/__tests__/assistantValidators.test.js\n\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst {\n  lockinRequestSchema,\n  chatIdParamSchema,\n  createChatSessionSchema,\n  listChatsQuerySchema,\n  assetIdParamSchema,\n} = require('../assistantValidators');\n\n// ============================================================================\n// lockinRequestSchema tests\n// ============================================================================\n\ntest('lockinRequestSchema - valid explain request with selection', () => {\n  const validData = {\n    mode: 'explain',\n    selection: 'What is React?',\n    chatHistory: [],\n  };\n\n  const result = lockinRequestSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.mode, 'explain');\n  assert.equal(result.data.selection, 'What is React?');\n});\n\ntest('lockinRequestSchema - valid explain request with pageContext', () => {\n  const validData = {\n    mode: 'explain',\n    selection: 'React hooks',\n    pageContext: 'This page is about React hooks and their usage in functional components.',\n    pageUrl: 'https://example.com/react-hooks',\n  };\n\n  const result = lockinRequestSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.pageContext, validData.pageContext);\n});\n\ntest('lockinRequestSchema - valid general request with chatHistory', () => {\n  const validData = {\n    mode: 'general',\n    selection: 'Some text',\n    chatHistory: [\n      { role: 'user', content: 'Hi there' },\n      { role: 'assistant', content: 'Hello! How can I help?' },\n    ],\n    newUserMessage: 'Can you explain more?',\n  };\n\n  const result = lockinRequestSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.chatHistory.length, 2);\n  assert.equal(result.data.newUserMessage, 'Can you explain more?');\n});\n\ntest('lockinRequestSchema - valid follow-up with empty selection', () => {\n  // Follow-up messages can have empty selection if chatHistory exists\n  const validData = {\n    mode: 'general',\n    selection: '',\n    chatHistory: [\n      { role: 'user', content: 'Initial question' },\n      { role: 'assistant', content: 'Initial answer' },\n    ],\n    newUserMessage: 'Tell me more',\n  };\n\n  const result = lockinRequestSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('lockinRequestSchema - valid initial request with attachments only', () => {\n  const validData = {\n    mode: 'explain',\n    selection: '',\n    chatHistory: [],\n    attachments: ['550e8400-e29b-41d4-a716-446655440000'],\n  };\n\n  const result = lockinRequestSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('lockinRequestSchema - reject initial request without selection or attachments', () => {\n  const invalidData = {\n    mode: 'explain',\n    selection: '',\n    chatHistory: [],\n  };\n\n  const result = lockinRequestSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n  // Should fail the refinement\n  assert.ok(result.error.errors.some((e) => e.message.includes('Initial requests require')));\n});\n\ntest('lockinRequestSchema - reject invalid mode', () => {\n  const invalidData = {\n    mode: 'invalid_mode',\n    selection: 'Hello',\n  };\n\n  const result = lockinRequestSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n  assert.ok(result.error.errors.some((e) => e.path.includes('mode')));\n});\n\ntest('lockinRequestSchema - reject selection exceeding max length', () => {\n  const invalidData = {\n    mode: 'explain',\n    selection: 'a'.repeat(50001),\n  };\n\n  const result = lockinRequestSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('lockinRequestSchema - reject chatHistory exceeding 50 messages', () => {\n  const invalidData = {\n    mode: 'general',\n    selection: 'Hello',\n    chatHistory: Array(51)\n      .fill(null)\n      .map(() => ({ role: 'user', content: 'message' })),\n  };\n\n  const result = lockinRequestSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('lockinRequestSchema - reject too many attachments', () => {\n  const invalidData = {\n    mode: 'explain',\n    selection: 'Hello',\n    attachments: Array(11)\n      .fill(null)\n      .map(() => '550e8400-e29b-41d4-a716-446655440000'),\n  };\n\n  const result = lockinRequestSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('lockinRequestSchema - reject invalid attachment UUID', () => {\n  const invalidData = {\n    mode: 'explain',\n    selection: 'Hello',\n    attachments: ['not-a-uuid'],\n  };\n\n  const result = lockinRequestSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('lockinRequestSchema - accept optional chatId as UUID', () => {\n  const validData = {\n    mode: 'explain',\n    selection: 'Hello',\n    chatId: '550e8400-e29b-41d4-a716-446655440000',\n  };\n\n  const result = lockinRequestSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('lockinRequestSchema - reject invalid chatId UUID', () => {\n  const invalidData = {\n    mode: 'explain',\n    selection: 'Hello',\n    chatId: 'not-a-uuid',\n  };\n\n  const result = lockinRequestSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('lockinRequestSchema - accept and lowercase language code', () => {\n  const validData = {\n    mode: 'explain',\n    selection: 'Hello',\n    language: 'EN',\n  };\n\n  const result = lockinRequestSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.language, 'en');\n});\n\ntest('lockinRequestSchema - accept courseCode', () => {\n  const validData = {\n    mode: 'explain',\n    selection: 'Hello',\n    courseCode: 'FIT2004',\n  };\n\n  const result = lockinRequestSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.courseCode, 'FIT2004');\n});\n\ntest('lockinRequestSchema - defaults for optional fields', () => {\n  const validData = {\n    mode: 'explain',\n    selection: 'Some text',\n  };\n\n  const result = lockinRequestSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.deepEqual(result.data.chatHistory, []);\n  assert.deepEqual(result.data.attachments, []);\n});\n\n// chatIdParamSchema tests\ntest('chatIdParamSchema - valid UUID', () => {\n  const validData = {\n    chatId: '550e8400-e29b-41d4-a716-446655440000',\n  };\n\n  const result = chatIdParamSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('chatIdParamSchema - reject invalid UUID', () => {\n  const invalidData = {\n    chatId: 'invalid-uuid',\n  };\n\n  const result = chatIdParamSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('chatIdParamSchema - reject missing chatId', () => {\n  const invalidData = {};\n\n  const result = chatIdParamSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\n// createChatSessionSchema tests\ntest('createChatSessionSchema - valid with title', () => {\n  const validData = {\n    title: 'My Chat Session',\n  };\n\n  const result = createChatSessionSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createChatSessionSchema - valid with initialMessage', () => {\n  const validData = {\n    initialMessage: 'Hello, I need help with React.',\n  };\n\n  const result = createChatSessionSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createChatSessionSchema - valid empty body', () => {\n  const result = createChatSessionSchema.safeParse({});\n  assert.equal(result.success, true);\n});\n\ntest('createChatSessionSchema - reject title exceeding max length', () => {\n  const invalidData = {\n    title: 'a'.repeat(201),\n  };\n\n  const result = createChatSessionSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\n// listChatsQuerySchema tests\ntest('listChatsQuerySchema - valid with limit', () => {\n  const validData = {\n    limit: '20',\n  };\n\n  const result = listChatsQuerySchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.limit, 20); // Coerced to number\n});\n\ntest('listChatsQuerySchema - valid with cursor', () => {\n  const validData = {\n    cursor: '2024-01-01T00:00:00Z',\n  };\n\n  const result = listChatsQuerySchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('listChatsQuerySchema - reject limit exceeding max', () => {\n  const invalidData = {\n    limit: '101',\n  };\n\n  const result = listChatsQuerySchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('listChatsQuerySchema - reject limit below min', () => {\n  const invalidData = {\n    limit: '0',\n  };\n\n  const result = listChatsQuerySchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\n// assetIdParamSchema tests\ntest('assetIdParamSchema - valid UUID', () => {\n  const validData = {\n    assetId: '550e8400-e29b-41d4-a716-446655440000',\n  };\n\n  const result = assetIdParamSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('assetIdParamSchema - reject invalid UUID', () => {\n  const invalidData = {\n    assetId: 'not-valid',\n  };\n\n  const result = assetIdParamSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\validators\\__tests__\\feedbackValidators.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5001.",
        "line": 142,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 142,
        "endColumn": 29
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 25.",
        "line": 173,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 173,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/validators/__tests__/feedbackValidators.test.js\n\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst {\n  createFeedbackSchema,\n  listFeedbackQuerySchema,\n  feedbackIdParamSchema,\n} = require('../feedbackValidators');\n\n// ============================================================================\n// createFeedbackSchema tests\n// ============================================================================\n\ntest('createFeedbackSchema - valid bug feedback', () => {\n  const validData = {\n    type: 'bug',\n    message: 'The save button is not working correctly.',\n  };\n\n  const result = createFeedbackSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createFeedbackSchema - valid feature request', () => {\n  const validData = {\n    type: 'feature',\n    message: 'Please add dark mode support.',\n  };\n\n  const result = createFeedbackSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createFeedbackSchema - valid question type', () => {\n  const validData = {\n    type: 'question',\n    message: 'How do I use the export feature?',\n  };\n\n  const result = createFeedbackSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createFeedbackSchema - valid other type', () => {\n  const validData = {\n    type: 'other',\n    message: 'General feedback about the app.',\n  };\n\n  const result = createFeedbackSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createFeedbackSchema - valid with context', () => {\n  const validData = {\n    type: 'bug',\n    message: 'UI glitch on this page.',\n    context: {\n      url: 'https://example.com/page',\n      courseCode: 'FIT2004',\n      extensionVersion: '1.2.3',\n      browser: 'Chrome 120',\n      page: 'Notes Editor',\n    },\n  };\n\n  const result = createFeedbackSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.context.url, 'https://example.com/page');\n  assert.equal(result.data.context.courseCode, 'FIT2004');\n});\n\ntest('createFeedbackSchema - valid with partial context', () => {\n  const validData = {\n    type: 'feature',\n    message: 'Add more themes.',\n    context: {\n      extensionVersion: '1.2.3',\n    },\n  };\n\n  const result = createFeedbackSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createFeedbackSchema - valid with null context', () => {\n  const validData = {\n    type: 'bug',\n    message: 'Something is broken.',\n    context: null,\n  };\n\n  const result = createFeedbackSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createFeedbackSchema - reject invalid type', () => {\n  const invalidData = {\n    type: 'invalid_type',\n    message: 'Some feedback',\n  };\n\n  const result = createFeedbackSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n  assert.ok(result.error.errors.some((e) => e.path.includes('type')));\n});\n\ntest('createFeedbackSchema - reject improvement type (not in valid types)', () => {\n  const invalidData = {\n    type: 'improvement',\n    message: 'UI could be better.',\n  };\n\n  const result = createFeedbackSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createFeedbackSchema - reject missing message', () => {\n  const invalidData = {\n    type: 'bug',\n  };\n\n  const result = createFeedbackSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createFeedbackSchema - reject empty message', () => {\n  const invalidData = {\n    type: 'bug',\n    message: '',\n  };\n\n  const result = createFeedbackSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createFeedbackSchema - reject message exceeding max length', () => {\n  const invalidData = {\n    type: 'bug',\n    message: 'a'.repeat(5001),\n  };\n\n  const result = createFeedbackSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createFeedbackSchema - reject invalid context url', () => {\n  const invalidData = {\n    type: 'bug',\n    message: 'Something is broken.',\n    context: {\n      url: 'not-a-valid-url',\n    },\n  };\n\n  const result = createFeedbackSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\n// ============================================================================\n// listFeedbackQuerySchema tests\n// ============================================================================\n\ntest('listFeedbackQuerySchema - valid with limit', () => {\n  const validData = {\n    limit: '25',\n  };\n\n  const result = listFeedbackQuerySchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.limit, 25);\n});\n\ntest('listFeedbackQuerySchema - valid empty query', () => {\n  const result = listFeedbackQuerySchema.safeParse({});\n  assert.equal(result.success, true);\n});\n\ntest('listFeedbackQuerySchema - reject limit exceeding max', () => {\n  const invalidData = {\n    limit: '101',\n  };\n\n  const result = listFeedbackQuerySchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\n// ============================================================================\n// feedbackIdParamSchema tests\n// ============================================================================\n\ntest('feedbackIdParamSchema - valid UUID', () => {\n  const validData = {\n    feedbackId: '550e8400-e29b-41d4-a716-446655440000',\n  };\n\n  const result = feedbackIdParamSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('feedbackIdParamSchema - reject invalid UUID', () => {\n  const invalidData = {\n    feedbackId: 'not-a-valid-uuid',\n  };\n\n  const result = feedbackIdParamSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('feedbackIdParamSchema - reject missing feedbackId', () => {\n  const invalidData = {};\n\n  const result = feedbackIdParamSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\validators\\__tests__\\noteValidators.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 501.",
        "line": 149,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 149,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 186,
        "column": 33,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 186,
        "endColumn": 35
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/validators/__tests__/noteValidators.test.js\n\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst {\n  createNoteSchema,\n  noteIdParamSchema,\n  searchNotesSchema,\n  setStarredSchema,\n} = require('../noteValidators');\n\ntest('createNoteSchema - valid Lexical content with empty legacy content', () => {\n  const validData = {\n    title: 'Test Note',\n    content: '', // Empty legacy content (used as fallback)\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n    content_text: 'Some text',\n  };\n\n  const result = createNoteSchema.safeParse(validData);\n  assert.equal(result.success, true, 'Should accept Lexical with empty legacy content');\n});\n\ntest('createNoteSchema - valid Lexical content without legacy content field', () => {\n  const validData = {\n    title: 'Test Note',\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n    content_text: 'Some text',\n  };\n\n  const result = createNoteSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createNoteSchema - valid legacy content without Lexical', () => {\n  const validData = {\n    title: 'Test Note',\n    content: '<p>Legacy HTML content</p>',\n  };\n\n  const result = createNoteSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createNoteSchema - reject when both Lexical and legacy content are missing', () => {\n  const invalidData = {\n    title: 'Test Note',\n  };\n\n  const result = createNoteSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createNoteSchema - reject when only empty legacy content is provided', () => {\n  const invalidData = {\n    title: 'Test Note',\n    content: '',\n  };\n\n  const result = createNoteSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createNoteSchema - reject when only whitespace legacy content provided', () => {\n  const invalidData = {\n    title: 'Test Note',\n    content: '   ',\n  };\n\n  const result = createNoteSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createNoteSchema - reject Lexical content without editor_version', () => {\n  const invalidData = {\n    title: 'Test Note',\n    content_json: { root: { children: [] } },\n  };\n\n  const result = createNoteSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createNoteSchema - accept all optional metadata fields', () => {\n  const validData = {\n    title: 'Test Note',\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n    clientNoteId: '123e4567-e89b-12d3-a456-426614174000',\n    sourceSelection: 'Selected text',\n    sourceUrl: 'https://example.com/page',\n    courseCode: 'CS101',\n    noteType: 'manual',\n    tags: ['tag1', 'tag2'],\n  };\n\n  const result = createNoteSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createNoteSchema - accept nullable optional fields', () => {\n  const validData = {\n    title: null,\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n    clientNoteId: null,\n    sourceSelection: null,\n    sourceUrl: null,\n    courseCode: null,\n    noteType: null,\n    tags: null,\n    content_text: null,\n    content: null,\n  };\n\n  const result = createNoteSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createNoteSchema - accept tags as comma-separated string', () => {\n  const validData = {\n    title: 'Test Note',\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n    tags: 'tag1,tag2,tag3',\n  };\n\n  const result = createNoteSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createNoteSchema - reject invalid UUID for clientNoteId', () => {\n  const invalidData = {\n    title: 'Test Note',\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n    clientNoteId: 'not-a-uuid',\n  };\n\n  const result = createNoteSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createNoteSchema - reject title longer than 500 characters', () => {\n  const invalidData = {\n    title: 'a'.repeat(501),\n    content_json: { root: { children: [] } },\n    editor_version: 'lexical_v1',\n  };\n\n  const result = createNoteSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('noteIdParamSchema - accept valid UUID', () => {\n  const validData = {\n    noteId: '123e4567-e89b-12d3-a456-426614174000',\n  };\n\n  const result = noteIdParamSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('noteIdParamSchema - reject invalid UUID', () => {\n  const invalidData = {\n    noteId: 'not-a-uuid',\n  };\n\n  const result = noteIdParamSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('searchNotesSchema - accept valid search query', () => {\n  const validData = {\n    q: 'search term',\n    courseCode: 'CS101',\n    k: '10',\n  };\n\n  const result = searchNotesSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  if (result.success) {\n    assert.equal(result.data.k, 10); // Coerced to number\n  }\n});\n\ntest('searchNotesSchema - reject empty query', () => {\n  const invalidData = {\n    q: '',\n  };\n\n  const result = searchNotesSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('setStarredSchema - accept boolean isStarred', () => {\n  const validData = {\n    isStarred: true,\n  };\n\n  const result = setStarredSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('setStarredSchema - reject non-boolean isStarred', () => {\n  const invalidData = {\n    isStarred: 'true',\n  };\n\n  const result = setStarredSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\validators\\__tests__\\transcriptValidators.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 144,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 144,
        "endColumn": 43
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/validators/__tests__/transcriptValidators.test.js\n\nconst test = require('node:test');\nconst assert = require('node:assert/strict');\n\nconst {\n  jobIdParamSchema,\n  createJobSchema,\n  finalizeJobSchema,\n  cacheTranscriptSchema,\n} = require('../transcriptValidators');\n\n// jobIdParamSchema tests\ntest('jobIdParamSchema - valid UUID', () => {\n  const validData = {\n    id: '550e8400-e29b-41d4-a716-446655440000',\n  };\n\n  const result = jobIdParamSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('jobIdParamSchema - reject invalid UUID', () => {\n  const invalidData = {\n    id: 'invalid-uuid',\n  };\n\n  const result = jobIdParamSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('jobIdParamSchema - reject missing id', () => {\n  const invalidData = {};\n\n  const result = jobIdParamSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\n// createJobSchema tests\ntest('createJobSchema - valid minimal job', () => {\n  const validData = {\n    videoId: 'abc123',\n    videoUrl: 'https://example.com/video/abc123',\n  };\n\n  const result = createJobSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.provider, 'custom'); // Default value\n});\n\ntest('createJobSchema - valid with provider', () => {\n  const validData = {\n    videoId: 'abc123',\n    videoUrl: 'https://panopto.example.com/video/abc123',\n    provider: 'panopto',\n  };\n\n  const result = createJobSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.provider, 'panopto');\n});\n\ntest('createJobSchema - valid with metadata', () => {\n  const validData = {\n    videoId: 'abc123',\n    videoUrl: 'https://example.com/video/abc123',\n    metadata: {\n      title: 'Lecture 1: Introduction',\n      duration: 3600,\n    },\n  };\n\n  const result = createJobSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('createJobSchema - reject missing videoId', () => {\n  const invalidData = {\n    videoUrl: 'https://example.com/video/abc123',\n  };\n\n  const result = createJobSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createJobSchema - reject empty videoId', () => {\n  const invalidData = {\n    videoId: '',\n    videoUrl: 'https://example.com/video/abc123',\n  };\n\n  const result = createJobSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createJobSchema - reject invalid videoUrl', () => {\n  const invalidData = {\n    videoId: 'abc123',\n    videoUrl: 'not-a-valid-url',\n  };\n\n  const result = createJobSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('createJobSchema - reject invalid provider', () => {\n  const invalidData = {\n    videoId: 'abc123',\n    videoUrl: 'https://example.com/video/abc123',\n    provider: 'invalid_provider',\n  };\n\n  const result = createJobSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\n// finalizeJobSchema tests\ntest('finalizeJobSchema - valid with totalChunks', () => {\n  const validData = {\n    totalChunks: 5,\n  };\n\n  const result = finalizeJobSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('finalizeJobSchema - valid with checksum', () => {\n  const validData = {\n    totalChunks: 3,\n    checksum: 'abc123def456',\n  };\n\n  const result = finalizeJobSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('finalizeJobSchema - coerce string totalChunks', () => {\n  const validData = {\n    totalChunks: '10',\n  };\n\n  const result = finalizeJobSchema.safeParse(validData);\n  assert.equal(result.success, true);\n  assert.equal(result.data.totalChunks, 10);\n});\n\ntest('finalizeJobSchema - reject zero totalChunks', () => {\n  const invalidData = {\n    totalChunks: 0,\n  };\n\n  const result = finalizeJobSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('finalizeJobSchema - reject negative totalChunks', () => {\n  const invalidData = {\n    totalChunks: -1,\n  };\n\n  const result = finalizeJobSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\n// cacheTranscriptSchema tests\ntest('cacheTranscriptSchema - valid transcript', () => {\n  const validData = {\n    videoId: 'abc123',\n    videoUrl: 'https://example.com/video/abc123',\n    transcript: {\n      segments: [\n        { start: 0, end: 5, text: 'Hello world' },\n        { start: 5, end: 10, text: 'This is a test' },\n      ],\n    },\n  };\n\n  const result = cacheTranscriptSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('cacheTranscriptSchema - valid with optional fields', () => {\n  const validData = {\n    videoId: 'abc123',\n    videoUrl: 'https://example.com/video/abc123',\n    transcript: {\n      segments: [{ start: 0, end: 5, text: 'Hello' }],\n      language: 'en',\n      source: 'manual',\n    },\n    provider: 'youtube',\n  };\n\n  const result = cacheTranscriptSchema.safeParse(validData);\n  assert.equal(result.success, true);\n});\n\ntest('cacheTranscriptSchema - reject empty segments', () => {\n  const invalidData = {\n    videoId: 'abc123',\n    videoUrl: 'https://example.com/video/abc123',\n    transcript: {\n      segments: [],\n    },\n  };\n\n  const result = cacheTranscriptSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('cacheTranscriptSchema - reject missing transcript', () => {\n  const invalidData = {\n    videoId: 'abc123',\n    videoUrl: 'https://example.com/video/abc123',\n  };\n\n  const result = cacheTranscriptSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('cacheTranscriptSchema - reject segment with negative start time', () => {\n  const invalidData = {\n    videoId: 'abc123',\n    videoUrl: 'https://example.com/video/abc123',\n    transcript: {\n      segments: [{ start: -1, end: 5, text: 'Hello' }],\n    },\n  };\n\n  const result = cacheTranscriptSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n\ntest('cacheTranscriptSchema - reject invalid videoUrl', () => {\n  const invalidData = {\n    videoId: 'abc123',\n    videoUrl: 'not-a-url',\n    transcript: {\n      segments: [{ start: 0, end: 5, text: 'Hello' }],\n    },\n  };\n\n  const result = cacheTranscriptSchema.safeParse(invalidData);\n  assert.equal(result.success, false);\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\validators\\assistantValidators.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 2000.",
        "line": 69,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 69,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 70,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 70,
        "endColumn": 34
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 74,
        "column": 12,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 74,
        "endColumn": 14
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 80,
        "column": 12,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 80,
        "endColumn": 14
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 115,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 115,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5000.",
        "line": 116,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 116,
        "endColumn": 38
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/validators/assistantValidators.js\n\nconst { z } = require('zod');\n\n/**\n * Assistant Validation Schemas\n *\n * Declarative Zod validation for assistant-related endpoints.\n * Applied via validate() middleware in routes.\n *\n * IMPORTANT: Field names MUST match the API client contract in /api/resources/lockinClient.ts\n */\n\n// UUID validation helper\nconst uuidSchema = z.string().uuid({ message: 'Must be a valid UUID' });\n\n// Constants matching service layer\nconst MAX_SELECTION_LENGTH = 50000;\nconst MAX_PAGE_CONTEXT_LENGTH = 100000;\nconst MAX_USER_MESSAGE_LENGTH = 10000;\nconst MAX_HISTORY_MESSAGES = 50;\n\n/**\n * Chat message schema for history array\n */\nconst chatMessageSchema = z.object({\n  role: z.enum(['user', 'assistant', 'system']),\n  content: z.string().min(1).max(MAX_USER_MESSAGE_LENGTH),\n});\n\n/**\n * Schema for main lockin AI request\n * POST /api/lockin\n *\n * Field names match the client contract:\n * - selection: The highlighted/selected text (optional for follow-up messages)\n * - mode: 'explain' for initial explanation, 'general' for follow-up\n * - chatHistory: Previous messages in the conversation\n * - newUserMessage: Follow-up question from user\n * - pageContext: Full page content for context\n * - pageUrl: URL of the source page\n * - courseCode: Academic course identifier\n * - language: Two-letter language code\n * - attachments: Array of asset IDs\n * - chatId: Existing chat session ID\n * - idempotencyKey: Optional key for request de-duplication\n */\nconst lockinRequestSchema = z\n  .object({\n    mode: z.enum(['explain', 'general'], {\n      errorMap: () => ({ message: 'Mode must be one of: explain, general' }),\n    }),\n    selection: z\n      .string()\n      .max(MAX_SELECTION_LENGTH, `Selection too long (max ${MAX_SELECTION_LENGTH} chars)`)\n      .optional()\n      .default(''),\n    chatHistory: z.array(chatMessageSchema).max(MAX_HISTORY_MESSAGES).optional().default([]),\n    newUserMessage: z\n      .string()\n      .max(MAX_USER_MESSAGE_LENGTH, `Message too long (max ${MAX_USER_MESSAGE_LENGTH} chars)`)\n      .optional()\n      .nullable(),\n    pageContext: z\n      .string()\n      .max(MAX_PAGE_CONTEXT_LENGTH, `Context too long (max ${MAX_PAGE_CONTEXT_LENGTH} chars)`)\n      .optional()\n      .nullable(),\n    pageUrl: z.string().max(2000, 'URL too long').optional().nullable(),\n    courseCode: z.string().max(50, 'Course code too long').optional().nullable(),\n    chatId: uuidSchema.optional().nullable(),\n    language: z\n      .string()\n      .max(10, 'Language code too long')\n      .optional()\n      .nullable()\n      .transform((val) => val?.toLowerCase()),\n    attachments: z\n      .array(uuidSchema)\n      .max(10, 'Maximum 10 attachments allowed')\n      .optional()\n      .default([]),\n    idempotencyKey: z.string().max(100, 'Idempotency key too long').optional().nullable(),\n  })\n  .refine(\n    (data) => {\n      // For initial requests (empty history), require either selection or attachments\n      const isInitialRequest = data.chatHistory.length === 0;\n      if (isInitialRequest) {\n        const hasSelection = data.selection && data.selection.trim().length > 0;\n        const hasAttachments = data.attachments && data.attachments.length > 0;\n        return hasSelection || hasAttachments;\n      }\n      // For follow-up requests, no additional requirements\n      return true;\n    },\n    {\n      message: 'Initial requests require either selection text or attachments',\n    },\n  );\n\n/**\n * Schema for chat ID parameter\n * Used in GET/DELETE /api/chats/:chatId\n */\nconst chatIdParamSchema = z.object({\n  chatId: uuidSchema,\n});\n\n/**\n * Schema for creating a chat session\n * POST /api/chats\n */\nconst createChatSessionSchema = z.object({\n  title: z.string().max(200, 'Title too long').optional().nullable(),\n  initialMessage: z.string().max(5000, 'Initial message too long').optional().nullable(),\n});\n\n/**\n * Schema for listing chats\n * GET /api/chats\n */\nconst listChatsQuerySchema = z.object({\n  limit: z.coerce.number().int().min(1).max(100).optional(),\n  cursor: z.string().optional(),\n});\n\n/**\n * Schema for generating chat title\n * POST /api/chats/:chatId/title\n */\nconst generateChatTitleSchema = z.object({\n  // No body required - just validates params\n});\n\n/**\n * Schema for asset ID parameter\n * DELETE /api/chat-assets/:assetId\n */\nconst assetIdParamSchema = z.object({\n  assetId: uuidSchema,\n});\n\nmodule.exports = {\n  lockinRequestSchema,\n  chatIdParamSchema,\n  createChatSessionSchema,\n  listChatsQuerySchema,\n  generateChatTitleSchema,\n  assetIdParamSchema,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\validators\\feedbackValidators.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 2000.",
        "line": 26,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 26,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 27,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 27,
        "endColumn": 34
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 28,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 28,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 29,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 29,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 30,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 30,
        "endColumn": 29
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5000.",
        "line": 47,
        "column": 10,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 47,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/validators/feedbackValidators.js\n\nconst { z } = require('zod');\n\n/**\n * Feedback Validation Schemas\n *\n * Declarative Zod validation for feedback-related endpoints.\n * Applied via validate() middleware in routes.\n *\n * IMPORTANT: Field names MUST match the API client contract in /api/resources/feedbackClient.ts\n */\n\n// UUID validation helper\nconst uuidSchema = z.string().uuid({ message: 'Must be a valid UUID' });\n\n// Valid feedback types (matches service layer and client)\nconst VALID_FEEDBACK_TYPES = ['bug', 'feature', 'question', 'other'];\n\n/**\n * Context schema for feedback metadata\n * Matches FeedbackContext interface in feedbackClient.ts\n */\nconst feedbackContextSchema = z\n  .object({\n    url: z.string().url().max(2000).optional(),\n    courseCode: z.string().max(50).optional(),\n    extensionVersion: z.string().max(20).optional(),\n    browser: z.string().max(200).optional(),\n    page: z.string().max(200).optional(),\n  })\n  .passthrough()\n  .optional()\n  .nullable();\n\n/**\n * Schema for creating feedback\n * POST /api/feedback\n */\nconst createFeedbackSchema = z.object({\n  type: z.enum(['bug', 'feature', 'question', 'other'], {\n    errorMap: () => ({ message: `Type must be one of: ${VALID_FEEDBACK_TYPES.join(', ')}` }),\n  }),\n  message: z\n    .string()\n    .min(1, 'Feedback message is required')\n    .max(5000, 'Message too long (max 5,000 chars)'),\n  context: feedbackContextSchema,\n});\n\n/**\n * Schema for listing feedback\n * GET /api/feedback\n */\nconst listFeedbackQuerySchema = z.object({\n  limit: z.coerce.number().int().min(1).max(100).optional(),\n});\n\n/**\n * Schema for feedback ID parameter\n * GET /api/feedback/:feedbackId\n */\nconst feedbackIdParamSchema = z.object({\n  feedbackId: uuidSchema,\n});\n\nmodule.exports = {\n  createFeedbackSchema,\n  listFeedbackQuerySchema,\n  feedbackIdParamSchema,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\validators\\index.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\validators\\middleware.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 27,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 27,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 61,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 61,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 93,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 93,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/validators/middleware.js\n\nconst { z } = require('zod');\n\n/**\n * Express middleware factory for Zod schema validation\n *\n * @param {z.ZodSchema} schema - Zod schema to validate against\n * @returns {Function} Express middleware\n *\n * @example\n * router.post('/notes', validate(createNoteSchema), createNote);\n */\nfunction validate(schema) {\n  return (req, res, next) => {\n    try {\n      // Validate request body against schema\n      const validated = schema.parse(req.body);\n\n      // Replace req.body with validated data (ensures type safety)\n      req.body = validated;\n\n      next();\n    } catch (error) {\n      // Zod validation error\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: 'Invalid request data',\n            details: error.errors.map((err) => ({\n              field: err.path.join('.'),\n              message: err.message,\n              code: err.code,\n            })),\n          },\n        });\n      }\n\n      // Unknown error, pass to error handler\n      next(error);\n    }\n  };\n}\n\n/**\n * Validate query parameters (GET requests)\n *\n * @param {z.ZodSchema} schema - Zod schema to validate against\n * @returns {Function} Express middleware\n */\nfunction validateQuery(schema) {\n  return (req, res, next) => {\n    try {\n      const validated = schema.parse(req.query);\n      req.query = validated;\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: 'Invalid query parameters',\n            details: error.errors.map((err) => ({\n              field: err.path.join('.'),\n              message: err.message,\n              code: err.code,\n            })),\n          },\n        });\n      }\n      next(error);\n    }\n  };\n}\n\n/**\n * Validate route parameters (e.g., :noteId)\n *\n * @param {z.ZodSchema} schema - Zod schema to validate against\n * @returns {Function} Express middleware\n */\nfunction validateParams(schema) {\n  return (req, res, next) => {\n    try {\n      const validated = schema.parse(req.params);\n      req.params = validated;\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: 'Invalid route parameters',\n            details: error.errors.map((err) => ({\n              field: err.path.join('.'),\n              message: err.message,\n              code: err.code,\n            })),\n          },\n        });\n      }\n      next(error);\n    }\n  };\n}\n\nmodule.exports = {\n  validate,\n  validateQuery,\n  validateParams,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\validators\\noteValidators.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 38,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 38,
        "endColumn": 45
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 83,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 83,
        "endColumn": 43
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 103,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 103,
        "endColumn": 43
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/validators/noteValidators.js\n\nconst { z } = require('zod');\nconst { MAX_NOTE_CONTENT_LENGTH, MAX_NOTE_TITLE_LENGTH } = require('../utils/noteLimits');\n\n/**\n * Note Validation Schemas\n *\n * Declarative validation for note-related endpoints.\n * Replaces imperative validation in controllers.\n */\n\n// UUID validation helper\nconst uuidSchema = z.string().uuid({ message: 'Must be a valid UUID' });\n\n// Lexical JSON schema (basic validation)\nconst lexicalJsonSchema = z.object({}).passthrough(); // Allow any object structure\n\n// Content limits\nconst MAX_CONTENT_LENGTH = MAX_NOTE_CONTENT_LENGTH;\n\n/**\n * Schema for creating a note\n * POST /api/notes\n */\nconst createNoteSchema = z\n  .object({\n    title: z.string().max(MAX_NOTE_TITLE_LENGTH).optional().nullable(),\n    content: z.string().optional().nullable(), // Legacy field\n    content_json: z.union([z.string(), lexicalJsonSchema]).optional().nullable(),\n    editor_version: z.string().optional().nullable(),\n    content_text: z.string().max(MAX_CONTENT_LENGTH).optional().nullable(),\n    clientNoteId: uuidSchema.optional().nullable(),\n    sourceSelection: z.string().optional().nullable(),\n    sourceUrl: z.union([z.string().url(), z.literal(''), z.null()]).optional(),\n    courseCode: z.string().optional().nullable(),\n    noteType: z.string().optional().nullable(),\n    tags: z.union([z.array(z.string().max(50)), z.string(), z.null()]).optional(),\n  })\n  .refine(\n    (data) => {\n      // Accept if valid Lexical format is present (content_json + editor_version)\n      // This is the preferred modern format\n      const hasLexical = data.content_json && data.editor_version;\n      if (hasLexical) {\n        return true;\n      }\n\n      // Otherwise, require legacy content with actual text\n      // Note: Frontend may send empty 'content' field as fallback when using Lexical,\n      // so we only validate legacy content if Lexical format is NOT present\n      const hasLegacy =\n        data.content && typeof data.content === 'string' && data.content.trim().length > 0;\n      return hasLegacy;\n    },\n    {\n      message:\n        'Note must contain either Lexical format (content_json + editor_version) or legacy format (content with text)',\n    },\n  );\n\n/**\n * Schema for updating a note\n * PUT /api/notes/:noteId\n */\nconst updateNoteSchema = createNoteSchema; // Same validation as create\n\n/**\n * Schema for note ID parameter\n * Used in GET/PUT/DELETE /api/notes/:noteId\n */\nconst noteIdParamSchema = z.object({\n  noteId: uuidSchema,\n});\n\n/**\n * Schema for searching notes\n * GET /api/notes/search\n */\nconst searchNotesSchema = z.object({\n  q: z.string().min(1, 'Query parameter (q) is required'),\n  courseCode: z.string().optional(),\n  k: z.coerce.number().int().min(1).max(50).optional(),\n});\n\n/**\n * Schema for listing notes\n * GET /api/notes\n */\nconst listNotesSchema = z.object({\n  sourceUrl: z.string().optional(),\n  courseCode: z.string().optional(),\n  limit: z.coerce.number().int().min(1).max(100).optional(),\n});\n\n/**\n * Schema for chat with notes\n * POST /api/notes/chat\n */\nconst chatWithNotesSchema = z.object({\n  query: z.string().min(1, 'Query is required and cannot be empty'),\n  courseCode: z.string().optional(),\n  k: z.coerce.number().int().min(1).max(20).optional(),\n});\n\n/**\n * Schema for toggling/setting starred status\n * PUT /api/notes/:noteId/star\n */\nconst setStarredSchema = z.object({\n  isStarred: z.boolean(),\n});\n\nmodule.exports = {\n  createNoteSchema,\n  updateNoteSchema,\n  noteIdParamSchema,\n  searchNotesSchema,\n  listNotesSchema,\n  chatWithNotesSchema,\n  setStarredSchema,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\backend\\validators\\transcriptValidators.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 28,
        "column": 58,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 28,
        "endColumn": 61
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 2000.",
        "line": 29,
        "column": 53,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 29,
        "endColumn": 57
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 38,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 38,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 59,
        "column": 58,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 59,
        "endColumn": 61
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 2000.",
        "line": 60,
        "column": 53,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 60,
        "endColumn": 57
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// backend/validators/transcriptValidators.js\n\nconst { z } = require('zod');\n\n/**\n * Transcript Validation Schemas\n *\n * Declarative Zod validation for transcript-related endpoints.\n * Applied via validate() middleware in routes.\n */\n\n// UUID validation helper\nconst uuidSchema = z.string().uuid({ message: 'Must be a valid UUID' });\n\n/**\n * Schema for job ID parameter\n * Used in GET/POST/PUT /api/transcripts/jobs/:id\n */\nconst jobIdParamSchema = z.object({\n  id: uuidSchema,\n});\n\n/**\n * Schema for creating a transcript job\n * POST /api/transcripts/jobs\n */\nconst createJobSchema = z.object({\n  videoId: z.string().min(1, 'Video ID is required').max(500, 'Video ID too long'),\n  videoUrl: z.string().url('Invalid video URL').max(2000, 'URL too long'),\n  provider: z\n    .enum(['panopto', 'youtube', 'vimeo', 'custom'], {\n      errorMap: () => ({ message: 'Provider must be one of: panopto, youtube, vimeo, custom' }),\n    })\n    .optional()\n    .default('custom'),\n  metadata: z\n    .object({\n      title: z.string().max(500).optional(),\n      duration: z.number().positive().optional(),\n    })\n    .passthrough()\n    .optional(),\n});\n\n/**\n * Schema for finalizing a transcript job\n * POST /api/transcripts/jobs/:id/finalize\n */\nconst finalizeJobSchema = z.object({\n  totalChunks: z.coerce.number().int().min(1, 'At least one chunk required'),\n  checksum: z.string().optional(),\n});\n\n/**\n * Schema for caching a transcript\n * POST /api/transcripts/cache\n */\nconst cacheTranscriptSchema = z.object({\n  videoId: z.string().min(1, 'Video ID is required').max(500),\n  videoUrl: z.string().url('Invalid video URL').max(2000),\n  transcript: z.object({\n    segments: z\n      .array(\n        z.object({\n          start: z.number().min(0),\n          end: z.number().min(0),\n          text: z.string(),\n        }),\n      )\n      .min(1, 'At least one segment required'),\n    language: z.string().optional(),\n    source: z.string().optional(),\n  }),\n  provider: z.string().optional(),\n});\n\nmodule.exports = {\n  jobIdParamSchema,\n  createJobSchema,\n  finalizeJobSchema,\n  cacheTranscriptSchema,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\__tests__\\backendAssistantController.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\__tests__\\backendChatPagination.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\__tests__\\backendOpenaiPrompt.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\__tests__\\node-shims.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\domain\\Note.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'NoteStatusSchema' is assigned a value but only used as a type. Allowed unused vars must match /^_/u.",
        "line": 39,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "usedOnlyAsType",
        "endLine": 39,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Note domain model (UI/editor agnostic).\n *\n * This file intentionally avoids importing React or Lexical types.\n * Lexical editor state is treated as opaque structured JSON and only\n * parsed/serialized inside the editor adapter layer.\n */\n\nimport { z } from 'zod';\nimport type { ZodError } from 'zod';\nimport { ValidationError } from '../errors';\n\nconst NoteContentVersionSchema = z.enum(['lexical_v1', 'legacy_html']);\n\nexport type NoteContentVersion = z.infer<typeof NoteContentVersionSchema>;\n\nconst NoteContentSchema = z\n  .object({\n    version: NoteContentVersionSchema,\n    /**\n     * Structured editor state (opaque to the domain layer).\n     * The Lexical editor serializes to JSON; we keep it as unknown here.\n     */\n    editorState: z.unknown(),\n    /**\n     * Optional HTML fallback from legacy contentEditable storage.\n     * Used only as a migration path.\n     */\n    legacyHtml: z.string().nullable().optional(),\n    /**\n     * Optional plain-text preview for list rendering/search.\n     */\n    plainText: z.string().nullable().optional(),\n  })\n  .passthrough();\n\nexport type NoteContent = z.infer<typeof NoteContentSchema>;\n\nconst NoteStatusSchema = z.enum(['idle', 'editing', 'saving', 'saved', 'error']);\nexport type NoteStatus = z.infer<typeof NoteStatusSchema>;\n\nconst NoteTypeSchema = z.enum([\n  'manual',\n  'definition',\n  'formula',\n  'concept',\n  'general',\n  'ai-generated',\n  'transcript',\n  'quiz',\n  'key_takeaways',\n]);\n\nexport type NoteType = z.infer<typeof NoteTypeSchema>;\n\nconst NoteAssetTypeSchema = z.enum(['image', 'document', 'audio', 'video', 'other']);\nexport type NoteAssetType = z.infer<typeof NoteAssetTypeSchema>;\n\nconst NoteAssetSchema = z.object({\n  id: z.string(),\n  noteId: z.string(),\n  userId: z.string(),\n  type: NoteAssetTypeSchema,\n  mimeType: z.string(),\n  storagePath: z.string(),\n  createdAt: z.string(), // ISO string from backend\n  url: z.string(),\n  fileName: z.string().nullable().optional(),\n});\n\nexport type NoteAsset = z.infer<typeof NoteAssetSchema>;\n\nconst NoteSchema = z\n  .object({\n    id: z.string().nullable(),\n    title: z.string().min(1),\n    content: NoteContentSchema,\n    sourceUrl: z.string().nullable(),\n    sourceSelection: z.string().nullable().optional(),\n    courseCode: z.string().nullable(),\n    noteType: NoteTypeSchema,\n    tags: z.array(z.string()),\n    createdAt: z.string().nullable(),\n    updatedAt: z.string().nullable(),\n    linkedLabel: z.string().optional(),\n    isStarred: z.boolean().optional(),\n    previewText: z.string().nullable().optional(),\n  })\n  .passthrough();\n\nexport type Note = z.infer<typeof NoteSchema>;\n\ntype ZodIssueDetails = {\n  issues: ZodError['issues'];\n  fieldErrors: Record<string, string[] | undefined>;\n  formErrors: string[];\n};\n\nfunction formatZodError(error: ZodError): ZodIssueDetails {\n  const flattened = error.flatten();\n  return {\n    issues: error.issues,\n    fieldErrors: flattened.fieldErrors,\n    formErrors: flattened.formErrors,\n  };\n}\n\nexport function parseNote(value: unknown, field = 'note'): Note {\n  const result = NoteSchema.safeParse(value);\n  if (result.success) {\n    return result.data;\n  }\n  throw new ValidationError(`Invalid ${field}`, field, {\n    details: formatZodError(result.error),\n  });\n}\n\nexport { NoteAssetSchema, NoteContentSchema, NoteSchema };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\domain\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\errors\\AppError.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\errors\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\network\\__tests__\\retry.test.ts",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 8,
        "column": 19,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 8,
        "endColumn": 22
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 300.",
        "line": 8,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 8,
        "endColumn": 38
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 10,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 10,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 300.",
        "line": 10,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 10,
        "endColumn": 46
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (53). Maximum allowed is 50.",
        "line": 17,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 77,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 19,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 19,
        "endColumn": 25
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 28,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 28,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 29,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 29,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 43,
        "column": 64,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 43,
        "endColumn": 67
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 52,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 59,
        "column": 13,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 59,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1797, 1812], "text": "(options?.signal) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 60,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 64,
        "endColumn": 12
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { afterEach, describe, expect, it, vi } from 'vitest';\nimport { fetchWithRetry } from '../retry';\n\nconst originalFetch = globalThis.fetch;\n\nfunction createResponse(status: number): Response {\n  return {\n    ok: status >= 200 && status < 300,\n    status,\n    statusText: status >= 200 && status < 300 ? 'OK' : 'Error',\n    headers: {\n      get: () => null,\n    },\n  } as unknown as Response;\n}\n\ndescribe('fetchWithRetry', () => {\n  afterEach(() => {\n    if (globalThis.fetch && 'mockRestore' in globalThis.fetch) {\n      (globalThis.fetch as unknown as { mockRestore: () => void }).mockRestore();\n    }\n    globalThis.fetch = originalFetch;\n  });\n\n  it('retries retryable responses and succeeds', async () => {\n    const fetchMock = vi\n      .fn()\n      .mockResolvedValueOnce(createResponse(500))\n      .mockResolvedValueOnce(createResponse(200));\n    globalThis.fetch = fetchMock as unknown as typeof fetch;\n\n    const response = await fetchWithRetry(\n      'https://example.com',\n      {},\n      { maxRetries: 1, baseDelayMs: 0, maxDelayMs: 0 },\n    );\n\n    expect(response.ok).toBe(true);\n    expect(fetchMock).toHaveBeenCalledTimes(2);\n  });\n\n  it('does not retry non-retryable responses', async () => {\n    const fetchMock = vi.fn().mockResolvedValue(createResponse(404));\n    globalThis.fetch = fetchMock as unknown as typeof fetch;\n\n    const response = await fetchWithRetry(\n      'https://example.com',\n      {},\n      { maxRetries: 3, baseDelayMs: 0, maxDelayMs: 0 },\n    );\n\n    expect(response.status).toBe(404);\n    expect(fetchMock).toHaveBeenCalledTimes(1);\n  });\n\n  it('throws timeout error when request exceeds timeout', async () => {\n    const fetchMock = vi.fn(async (_url: string, options?: RequestInit) => {\n      return new Promise((_resolve, reject) => {\n        if (options?.signal) {\n          options.signal.addEventListener('abort', () => {\n            const error = new Error('Aborted');\n            error.name = 'AbortError';\n            reject(error);\n          });\n        }\n      });\n    });\n    globalThis.fetch = fetchMock as unknown as typeof fetch;\n\n    await expect(\n      fetchWithRetry('https://example.com', {}, { maxRetries: 0, timeoutMs: 5 }),\n    ).rejects.toMatchObject({\n      code: 'TIMEOUT',\n    });\n    expect(fetchMock).toHaveBeenCalledTimes(1);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\network\\retry.ts",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 30,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 30,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 37,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 37,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [820, 830], "text": "overrides == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.3.",
        "line": 52,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 68,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 68,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1935, 1941], "text": "value == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1936, 1941], "text": "(value ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1935, 1941], "text": "!Boolean(value)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 85,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 85,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 85,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 85,
        "endColumn": 39
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 85,
        "column": 54,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 85,
        "endColumn": 57
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 87,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 87,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 92,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorAny",
        "endLine": 92,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2602, 2607], "text": "(Boolean(error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 106,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 106,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3098, 3105], "text": "(context != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3098, 3105], "text": "(context ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3098, 3105], "text": "(Boolean(context))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 121,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorAny",
        "endLine": 121,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3625, 3630], "text": "(Boolean(error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has too many lines (100). Maximum allowed is 50.",
        "line": 129,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 243,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has too many statements (60). Maximum allowed is 20.",
        "line": 129,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 243,
        "endColumn": 2
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has a complexity of 44. Maximum allowed is 15.",
        "line": 129,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 129,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 145,
        "column": 9,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 145,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [4440, 4463], "text": "(options.signal?.aborted) ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [4440, 4463], "text": "(options.signal?.aborted) === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 154,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 154,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 156,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 156,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4837, 4847], "text": "(controller != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 156,
        "column": 23,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 156,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4851, 4865], "text": "(options.signal != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 164,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 164,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5054, 5064], "text": "(controller != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 164,
        "column": 23,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 164,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareZero",
            "fix": { "range": [5068, 5084], "text": "(config.timeoutMs !== 0)" },
            "desc": "Change condition to check for 0 (`value !== 0`)"
          },
          {
            "messageId": "conditionFixCompareNaN",
            "fix": { "range": [5068, 5084], "text": "(!Number.isNaN(config.timeoutMs))" },
            "desc": "Change condition to check for NaN (`!Number.isNaN(value)`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5068, 5084], "text": "(Boolean(config.timeoutMs))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 173,
        "column": 11,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 173,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5312, 5330], "text": "(controller?.signal) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 175,
        "column": 18,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 175,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5399, 5413], "text": "options.signal != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 197,
        "column": 11,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 197,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [6167, 6190], "text": "((options.signal?.aborted) ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [6167, 6190], "text": "((options.signal?.aborted) === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 201,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 201,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6266, 6275], "text": "timeoutId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 202,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 202,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6312, 6322], "text": "(controller != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 202,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 202,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6326, 6340], "text": "(options.signal != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 208,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 208,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6459, 6471], "text": "(lastResponse != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 213,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 213,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6649, 6661], "text": "lastResponse != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 216,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorAny",
        "endLine": 216,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6714, 6723], "text": "(Boolean(lastError))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 219,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 219,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6788, 6800], "text": "(lastResponse != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 229,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 229,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7155, 7167], "text": "lastResponse != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 241,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 241,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7384, 7396], "text": "lastResponse != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 242,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorAny",
        "endLine": 242,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7427, 7436], "text": "(Boolean(lastError))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 33,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { TimeoutError } from '../errors';\n\nexport type RetryConfig = {\n  maxRetries: number;\n  baseDelayMs: number;\n  maxDelayMs: number;\n  timeoutMs: number;\n  retryableStatuses: number[];\n  retryOnServerError: boolean;\n  retryOnNetworkError: boolean;\n  retryOnTimeout: boolean;\n  fetcher?: typeof fetch;\n  onRetry?: (info: RetryEvent) => void;\n  context?: string;\n};\n\nexport type RetryEvent = {\n  attempt: number;\n  maxRetries: number;\n  delayMs: number;\n  status?: number;\n  error?: unknown;\n};\n\nexport const DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  baseDelayMs: 500,\n  maxDelayMs: 5000,\n  timeoutMs: 30000,\n  retryableStatuses: [429],\n  retryOnServerError: true,\n  retryOnNetworkError: true,\n  retryOnTimeout: true,\n};\n\nfunction normalizeConfig(overrides?: Partial<RetryConfig>): RetryConfig {\n  if (!overrides) return { ...DEFAULT_RETRY_CONFIG };\n  const retryableStatuses = Array.isArray(overrides.retryableStatuses)\n    ? overrides.retryableStatuses\n    : DEFAULT_RETRY_CONFIG.retryableStatuses;\n  return { ...DEFAULT_RETRY_CONFIG, ...overrides, retryableStatuses };\n}\n\nasync function sleep(ms: number): Promise<void> {\n  await new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function calculateBackoffDelay(\n  baseDelayMs: number,\n  maxDelayMs: number,\n  attempt: number,\n  jitterRatio: number = 0.3,\n): number {\n  const exponentialDelay = baseDelayMs * Math.pow(2, attempt);\n  const cappedDelay = Math.min(exponentialDelay, maxDelayMs);\n  const jitter = cappedDelay * Math.random() * jitterRatio;\n  return Math.floor(cappedDelay + jitter);\n}\n\nexport function calculateRetryDelay(attempt: number, config: RetryConfig): number {\n  return calculateBackoffDelay(config.baseDelayMs, config.maxDelayMs, attempt);\n}\n\nexport function parseRetryAfterMs(response: {\n  headers?: { get?: (name: string) => string | null };\n}): number | undefined {\n  const value = response.headers?.get?.('retry-after');\n  if (!value) return undefined;\n\n  const seconds = Number(value);\n  if (!Number.isNaN(seconds)) {\n    return Math.max(0, seconds * 1000);\n  }\n\n  const dateMs = Date.parse(value);\n  if (!Number.isNaN(dateMs)) {\n    return Math.max(0, dateMs - Date.now());\n  }\n\n  return undefined;\n}\n\nexport function isRetryableStatus(status: number, config: RetryConfig): boolean {\n  if (status === 0) return false;\n  if (status === 401 || status === 403 || status === 404) return false;\n  if (config.retryableStatuses.includes(status)) return true;\n  if (config.retryOnServerError && status >= 500) return true;\n  return false;\n}\n\nfunction isNetworkError(error: unknown): boolean {\n  if (!error) return false;\n  const message = error instanceof Error ? error.message : String(error);\n  return (\n    message.includes('Failed to fetch') ||\n    message.includes('NetworkError') ||\n    message.includes('Network request failed') ||\n    message.includes('ERR_NETWORK') ||\n    message.includes('ECONNRESET') ||\n    message.includes('ETIMEDOUT') ||\n    message.includes('EAI_AGAIN')\n  );\n}\n\nfunction createTimeoutError(timeoutMs: number, context?: string): TimeoutError {\n  const operation = context && context.length > 0 ? context : 'network request';\n  return new TimeoutError(operation, timeoutMs);\n}\n\nfunction isAbortError(error: unknown): boolean {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' ||\n      (error as Error & { code?: string }).code === 'ABORTED' ||\n      (error as Error & { code?: string }).code === 'ABORT_ERR' ||\n      (error as Error & { code?: string }).code === 'ERR_ABORTED')\n  );\n}\n\nfunction shouldRetryError(error: unknown, config: RetryConfig): boolean {\n  if (!error) return false;\n  const code = (error as { code?: string }).code;\n  if (code === 'TIMEOUT') return config.retryOnTimeout;\n  if (code === 'ABORTED') return false;\n  if (isNetworkError(error)) return config.retryOnNetworkError;\n  return false;\n}\n\nexport async function fetchWithRetry(\n  url: string,\n  options: RequestInit = {},\n  configOverrides: Partial<RetryConfig> = {},\n): Promise<Response> {\n  const config = normalizeConfig(configOverrides);\n  const fetcher = config.fetcher ?? globalThis.fetch;\n  if (typeof fetcher !== 'function') {\n    throw new Error('Fetch implementation is required.');\n  }\n\n  const maxAttempts = Math.max(0, config.maxRetries) + 1;\n  let lastError: unknown = null;\n  let lastResponse: Response | null = null;\n\n  for (let attempt = 0; attempt < maxAttempts; attempt += 1) {\n    if (options.signal?.aborted) {\n      const abortError = new Error('Request aborted');\n      abortError.name = 'AbortError';\n      throw abortError;\n    }\n\n    let timeoutId: ReturnType<typeof setTimeout> | undefined;\n    let timedOut = false;\n    const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;\n    const abortFromSignal = () => controller?.abort();\n\n    if (controller && options.signal) {\n      if (options.signal.aborted) {\n        controller.abort();\n      } else {\n        options.signal.addEventListener('abort', abortFromSignal, { once: true });\n      }\n    }\n\n    if (controller && config.timeoutMs && config.timeoutMs > 0) {\n      timeoutId = setTimeout(() => {\n        timedOut = true;\n        controller.abort();\n      }, config.timeoutMs);\n    }\n\n    try {\n      const requestInit: RequestInit = { ...options };\n      if (controller?.signal) {\n        requestInit.signal = controller.signal;\n      } else if (options.signal) {\n        requestInit.signal = options.signal;\n      }\n      const response = await fetcher(url, requestInit);\n      lastResponse = response;\n\n      if (response.ok || !isRetryableStatus(response.status, config)) {\n        return response;\n      }\n\n      lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);\n    } catch (error) {\n      if (isAbortError(error) && timedOut) {\n        lastError = createTimeoutError(config.timeoutMs, config.context);\n      } else if (isAbortError(error)) {\n        const abortError = new Error('Request aborted');\n        abortError.name = 'AbortError';\n        lastError = abortError;\n      } else {\n        lastError = error instanceof Error ? error : new Error(String(error));\n      }\n\n      if (options.signal?.aborted && !timedOut) {\n        throw lastError;\n      }\n    } finally {\n      if (timeoutId) clearTimeout(timeoutId);\n      if (controller && options.signal) {\n        options.signal.removeEventListener('abort', abortFromSignal);\n      }\n    }\n\n    const shouldRetry =\n      lastResponse && isRetryableStatus(lastResponse.status, config)\n        ? true\n        : shouldRetryError(lastError, config);\n\n    if (!shouldRetry || attempt >= maxAttempts - 1) {\n      if (lastResponse) {\n        return lastResponse;\n      }\n      throw lastError || new Error('Request failed');\n    }\n\n    const retryAfterMs = lastResponse ? parseRetryAfterMs(lastResponse) : undefined;\n    const delayMs =\n      typeof retryAfterMs === 'number' ? retryAfterMs : calculateRetryDelay(attempt, config);\n\n    if (typeof config.onRetry === 'function') {\n      const retryEvent: RetryEvent = {\n        attempt: attempt + 1,\n        maxRetries: config.maxRetries,\n        delayMs,\n      };\n      if (lastResponse) {\n        retryEvent.status = lastResponse.status;\n      }\n      if (lastError !== null) {\n        retryEvent.error = lastError;\n      }\n      config.onRetry(retryEvent);\n    }\n\n    await sleep(delayMs);\n  }\n\n  if (lastResponse) return lastResponse;\n  throw lastError || new Error('Request failed after retries');\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\services\\__tests__\\notesService.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\services\\notesService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\services\\notes\\noteContent.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\services\\notes\\notesServiceHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\services\\notes\\notesServiceTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\storage\\storageInterface.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\__tests__\\providerRegistry.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\__tests__\\videoDetection.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\__tests__\\webvttParser.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\fetchers\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\parsers\\echo360Parser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\parsers\\echo360\\recordUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\parsers\\echo360\\syllabusFetch.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\parsers\\echo360\\syllabusMedia.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\parsers\\echo360\\syllabusMediaUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\parsers\\echo360\\syllabusParser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\parsers\\echo360\\urlUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providerRegistry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\__tests__\\echo360Provider.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\__tests__\\html5Provider.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\__tests__\\panoptoProvider.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\echo360Provider.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\echo360\\asyncDetection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\echo360\\detection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\echo360\\htmlParsing.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\echo360\\provider.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\echo360\\resolveInfo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\echo360\\transcriptExtraction.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\echo360\\transcriptParsing.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\echo360\\urlBuilders.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\echo360\\urlUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\html5Provider.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\html5\\provider.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\panoptoProvider.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\panopto\\extraction.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\panopto\\linkDetection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\panopto\\provider.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\providers\\panopto\\urlUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\types\\echo360Types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\utils\\echo360Logger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\utils\\echo360Network.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\utils\\transcriptLogger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\videoDetection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\videoDetection\\context.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\videoDetection\\detectVideosSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\videoDetection\\domUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\videoDetection\\html5Detection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\videoDetection\\panoptoDetection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\transcripts\\webvttParser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\utils\\__tests__\\textUtils.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\utils\\logger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\utils\\textUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\utils\\timeout.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\core\\utils\\urlSanitizer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\eslint.config.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 15.",
        "line": 27,
        "column": 24,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 27,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 28,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 28,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 29,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 29,
        "endColumn": 37
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 30,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 30,
        "endColumn": 27
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 31,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 31,
        "endColumn": 32
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (549). Maximum allowed is 300.",
        "line": 311,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 574,
        "endColumn": 1
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import path from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport tseslint from '@typescript-eslint/eslint-plugin';\nimport tsParser from '@typescript-eslint/parser';\nimport importPlugin from 'eslint-plugin-import';\nimport prettierConfig from 'eslint-config-prettier';\n\nconst tsconfigRootDir = path.dirname(fileURLToPath(import.meta.url));\n\nconst qualityRules = {\n  'max-lines': [\n    'warn',\n    {\n      max: 300,\n      skipBlankLines: true,\n      skipComments: true,\n    },\n  ],\n  'max-lines-per-function': [\n    'warn',\n    {\n      max: 50,\n      skipBlankLines: true,\n      skipComments: true,\n    },\n  ],\n  complexity: ['warn', 15],\n  'max-depth': ['warn', 4],\n  'max-nested-callbacks': ['warn', 3],\n  'max-params': ['warn', 4],\n  'max-statements': ['warn', 20],\n  'no-magic-numbers': [\n    'warn',\n    {\n      ignore: [0, 1, -1, 2, 100, 1000],\n      ignoreArrayIndexes: true,\n      enforceConst: true,\n    },\n  ],\n  'prefer-const': 'warn',\n  'no-var': 'warn',\n  eqeqeq: ['warn', 'always'],\n  curly: ['warn', 'all'],\n  'no-else-return': 'warn',\n  'no-lonely-if': 'warn',\n  'no-unneeded-ternary': 'warn',\n  'no-eval': 'warn',\n  'no-implied-eval': 'warn',\n  'no-new-func': 'warn',\n  'no-script-url': 'warn',\n  'no-proto': 'warn',\n  'no-extend-native': 'warn',\n};\n\nconst errorRules = Object.fromEntries(\n  Object.entries(qualityRules).map(([rule, setting]) => {\n    if (Array.isArray(setting)) {\n      return [rule, ['error', ...setting.slice(1)]];\n    }\n    return [rule, 'error'];\n  }),\n);\n\n/** @type {import('eslint').Linter.FlatConfig[]} */\nexport default [\n  {\n    ignores: [\n      '**/node_modules/**',\n      'extension/dist/**',\n      '**/dist/**',\n      '**/build/**',\n      '**/coverage/**',\n    ],\n  },\n  {\n    files: ['**/*.{js,mjs,cjs,ts,tsx}'],\n    rules: qualityRules,\n  },\n  {\n    files: ['api/**/*.{js,mjs,cjs,ts,tsx}'],\n    rules: errorRules,\n  },\n\n  // Legacy globals guardrail: prefer canonical LockInContent runtime\n  {\n    files: ['extension/**/*.{js,mjs,cjs,ts,tsx}'],\n    ignores: ['extension/src/contentRuntime.ts'],\n    rules: {\n      'no-restricted-properties': [\n        'error',\n        {\n          object: 'Storage',\n          property: 'getLocal',\n          message: 'Use window.LockInContent.storage.getLocal instead of legacy Storage.getLocal.',\n        },\n        {\n          object: 'Storage',\n          property: 'setLocal',\n          message: 'Use window.LockInContent.storage.setLocal instead of legacy Storage.setLocal.',\n        },\n        {\n          object: 'Storage',\n          property: 'removeLocal',\n          message:\n            'Use window.LockInContent.storage.removeLocal instead of legacy Storage.removeLocal.',\n        },\n        {\n          object: 'MessageTypes',\n          property: 'GET_TAB_ID',\n          message:\n            'Use window.LockInContent.messaging.types.GET_TAB_ID instead of legacy MessageTypes.',\n        },\n        {\n          object: 'LockInContent',\n          property: 'Storage',\n          message: 'Legacy compat shim removed. Use window.LockInContent.storage.* instead.',\n        },\n        {\n          object: 'LockInContent',\n          property: 'MessageTypes',\n          message: 'Legacy compat shim removed. Use window.LockInContent.messaging.types instead.',\n        },\n      ],\n    },\n  },\n  {\n    files: ['**/*.{js,mjs,cjs}'],\n    languageOptions: {\n      ecmaVersion: 'latest',\n      sourceType: 'module',\n      globals: {\n        chrome: 'readonly',\n        browser: 'readonly',\n        window: 'readonly',\n        document: 'readonly',\n        console: 'readonly',\n        setTimeout: 'readonly',\n        clearTimeout: 'readonly',\n        setInterval: 'readonly',\n        clearInterval: 'readonly',\n      },\n    },\n    plugins: {\n      import: importPlugin,\n    },\n    rules: {\n      'import/no-duplicates': 'warn',\n    },\n  },\n  {\n    files: ['**/*.{ts,tsx}'],\n    languageOptions: {\n      parser: tsParser,\n      ecmaVersion: 'latest',\n      sourceType: 'module',\n      parserOptions: {\n        ecmaFeatures: { jsx: true },\n        project: './tsconfig.eslint.json',\n        tsconfigRootDir,\n      },\n      globals: {\n        chrome: 'readonly',\n        browser: 'readonly',\n        window: 'readonly',\n        document: 'readonly',\n        console: 'readonly',\n      },\n    },\n    plugins: {\n      '@typescript-eslint': tseslint,\n      import: importPlugin,\n    },\n    rules: {\n      'no-unused-vars': 'off',\n      '@typescript-eslint/no-unused-vars': [\n        'warn',\n        {\n          argsIgnorePattern: '^_',\n          varsIgnorePattern: '^_',\n          caughtErrorsIgnorePattern: '^_',\n        },\n      ],\n      '@typescript-eslint/no-explicit-any': 'error',\n      '@typescript-eslint/no-unsafe-assignment': 'error',\n      '@typescript-eslint/no-unsafe-call': 'error',\n      '@typescript-eslint/no-unsafe-member-access': 'error',\n      '@typescript-eslint/no-unsafe-return': 'error',\n      '@typescript-eslint/no-unsafe-argument': 'error',\n      '@typescript-eslint/no-floating-promises': 'error',\n      '@typescript-eslint/no-misused-promises': 'error',\n      '@typescript-eslint/promise-function-async': 'error',\n      '@typescript-eslint/await-thenable': 'error',\n      '@typescript-eslint/explicit-function-return-type': [\n        'warn',\n        {\n          allowExpressions: true,\n          allowTypedFunctionExpressions: true,\n        },\n      ],\n      '@typescript-eslint/strict-boolean-expressions': [\n        'warn',\n        {\n          allowString: false,\n          allowNumber: false,\n          allowNullableObject: false,\n        },\n      ],\n      '@typescript-eslint/switch-exhaustiveness-check': 'error',\n      '@typescript-eslint/consistent-type-imports': 'error',\n      '@typescript-eslint/consistent-type-exports': 'error',\n      '@typescript-eslint/naming-convention': [\n        'error',\n        { selector: 'interface', format: ['PascalCase'] },\n        { selector: 'typeAlias', format: ['PascalCase'] },\n        { selector: 'enum', format: ['PascalCase'] },\n        { selector: 'enumMember', format: ['UPPER_CASE'] },\n      ],\n      'import/no-duplicates': 'warn',\n    },\n  },\n  // Architectural boundaries:\n  // - /core must remain platform-agnostic and independent of other layers (ERROR)\n  {\n    files: ['core/**/*.{js,mjs,cjs,ts,tsx}'],\n    rules: {\n      'no-restricted-globals': [\n        'error',\n        {\n          name: 'chrome',\n          message: 'Chrome APIs are not allowed in core. Use extension/* wrappers or DI instead.',\n        },\n        {\n          name: 'window',\n          message: 'Browser globals are not allowed in core. Core must be platform-agnostic.',\n        },\n        {\n          name: 'document',\n          message: 'DOM globals are not allowed in core. Core must be platform-agnostic.',\n        },\n      ],\n      'no-restricted-imports': [\n        'error',\n        {\n          patterns: [\n            {\n              group: [\n                '**/api/**',\n                '@api/*',\n                '**/extension/**',\n                '**/backend/**',\n                '**/ui/**',\n                '**/integrations/**',\n                '**/shared/ui/**',\n                '@shared/ui',\n                '@shared/ui/*',\n                'express',\n                'react*',\n              ],\n              message:\n                'Core must remain platform-agnostic. No api/backend/extension/ui/integrations imports.',\n            },\n            {\n              group: ['chrome', 'window', 'document'],\n              message: 'Core must remain platform-agnostic. No browser globals imports.',\n            },\n          ],\n        },\n      ],\n    },\n  },\n  {\n    files: ['**/*.{ts,tsx}'],\n    ignores: ['core/**/*.{ts,tsx}'],\n    rules: {\n      '@typescript-eslint/no-unsafe-assignment': 'warn',\n      '@typescript-eslint/no-unsafe-call': 'warn',\n      '@typescript-eslint/no-unsafe-member-access': 'warn',\n      '@typescript-eslint/no-unsafe-return': 'warn',\n      '@typescript-eslint/no-unsafe-argument': 'warn',\n      '@typescript-eslint/no-floating-promises': 'warn',\n      '@typescript-eslint/no-misused-promises': 'warn',\n      '@typescript-eslint/promise-function-async': 'warn',\n      '@typescript-eslint/consistent-type-imports': 'warn',\n      '@typescript-eslint/consistent-type-exports': 'warn',\n      '@typescript-eslint/switch-exhaustiveness-check': 'warn',\n    },\n  },\n  // - /api must remain Chrome-free and extension-independent (ERROR)\n  {\n    files: ['api/**/*.{js,mjs,cjs,ts,tsx}'],\n    rules: {\n      'no-restricted-globals': [\n        'error',\n        {\n          name: 'chrome',\n          message: 'Chrome APIs are not allowed in api. Use DI instead.',\n        },\n        {\n          name: 'window',\n          message: 'Browser globals are not allowed in api. Api must be platform-agnostic.',\n        },\n        {\n          name: 'document',\n          message: 'DOM globals are not allowed in api. Api must be platform-agnostic.',\n        },\n      ],\n      'no-restricted-imports': [\n        'error',\n        {\n          patterns: [\n            {\n              group: [\n                '**/backend/**',\n                '**/extension/**',\n                '**/ui/**',\n                '**/integrations/**',\n                '**/shared/ui/**',\n                '@shared/ui',\n                '@shared/ui/*',\n                'express',\n                'react*',\n              ],\n              message:\n                'Api must remain Chrome-free, UI-free, and backend-agnostic (pure logic only).',\n            },\n            {\n              group: ['chrome', 'window', 'document'],\n              message: 'Api must remain platform-agnostic. No browser globals imports.',\n            },\n          ],\n        },\n      ],\n    },\n  },\n  {\n    files: ['backend/services/**/*.js'],\n    rules: {\n      'no-restricted-imports': [\n        'error',\n        {\n          patterns: [\n            {\n              group: ['**/controllers/**', '**/routes/**', '**/middleware/**'],\n              message: 'Services cannot import controllers/routes/middleware (layer violation).',\n            },\n            {\n              group: ['express'],\n              message: 'Services must not depend on Express (HTTP concern).',\n            },\n          ],\n        },\n      ],\n    },\n  },\n  {\n    files: ['backend/controllers/**/*.js'],\n    rules: {\n      'no-restricted-imports': [\n        'error',\n        {\n          patterns: [\n            {\n              group: ['**/repositories/**', '**/providers/**', '**/db/**'],\n              message: 'Controllers must call services only (no direct repo/provider/db access).',\n            },\n          ],\n        },\n      ],\n    },\n  },\n\n  // Exception: Allow DOM globals in core/api test files\n  {\n    files: [\n      'core/**/__tests__/**/*.{js,mjs,cjs,ts,tsx}',\n      'api/**/__tests__/**/*.{js,mjs,cjs,ts,tsx}',\n      'core/**/*.test.{js,mjs,cjs,ts,tsx}',\n      'api/**/*.test.{js,mjs,cjs,ts,tsx}',\n    ],\n    rules: {\n      'no-restricted-globals': 'off', // Allow document, window, etc. in tests\n      'no-restricted-imports': 'off',\n    },\n  },\n\n  // - /integrations (Site Adapters) must be pure DOM parsers (ERROR)\n  {\n    files: ['integrations/**/*.{js,mjs,cjs,ts,tsx}'],\n    rules: {\n      'no-restricted-globals': [\n        'error',\n        {\n          name: 'chrome',\n          message: 'Chrome APIs are not allowed in integrations. Adapters must be pure functions.',\n        },\n      ],\n      'no-restricted-imports': [\n        'error',\n        {\n          patterns: [\n            {\n              group: ['**/backend/**', '**/api/**', 'axios', 'node-fetch'],\n              message:\n                'Integrations must not make network calls. They only parse DOM and return data.',\n            },\n          ],\n        },\n      ],\n    },\n  },\n\n  // - /backend must not depend on frontend code (ERROR)\n  {\n    files: ['backend/**/*.{js,mjs,cjs,ts,tsx}'],\n    rules: {\n      'no-restricted-imports': [\n        'error',\n        {\n          patterns: [\n            {\n              group: ['**/api/**', '**/extension/**', '**/ui/**', '**/integrations/**', 'chrome'],\n              message: 'Backend cannot import api/frontend/extension code.',\n            },\n            {\n              // Prevent importing core files that might accidentally use browser types in comments/JSDoc validation if strict\n              // But core is allowed if it's pure. We'll allow core.\n              group: ['chrome'],\n              message: 'Backend cannot use Chrome types or APIs.',\n            },\n          ],\n        },\n      ],\n      'no-restricted-globals': [\n        'error',\n        {\n          name: 'chrome',\n          message: 'Chrome APIs are not allowed in backend.',\n        },\n        {\n          name: 'window',\n          message: 'Browser globals are not allowed in backend.',\n        },\n        {\n          name: 'document',\n          message: 'DOM globals are not allowed in backend.',\n        },\n      ],\n    },\n  },\n\n  // - /extension should prefer path aliases over deep relative imports (WARN-first)\n  {\n    files: ['extension/**/*.{js,mjs,cjs,ts,tsx}'],\n    rules: {\n      'no-restricted-imports': [\n        'warn',\n        {\n          patterns: [\n            {\n              group: ['**/backend/**'],\n              message: 'Extension cannot import backend code.',\n            },\n            {\n              group: ['../../../core/*', '../../../../core/*', '../../../../../core/*'],\n              message: 'Use @core/* path aliases instead of deep relative imports.',\n            },\n            {\n              group: ['../../../api/*', '../../../../api/*', '../../../../../api/*'],\n              message: 'Use @api/* path aliases instead of deep relative imports.',\n            },\n            {\n              group: ['../../../shared/*', '../../../../shared/*', '../../../../../shared/*'],\n              message: 'Use @shared/ui* path aliases instead of deep relative imports.',\n            },\n          ],\n        },\n      ],\n    },\n  },\n\n  // - /ui should avoid backend/extension/integrations + prefer path aliases (WARN-first)\n  {\n    files: ['ui/**/*.{js,mjs,cjs,ts,tsx}'],\n    rules: {\n      'no-restricted-imports': [\n        'warn',\n        {\n          patterns: [\n            {\n              group: ['**/backend/**', '**/extension/**', '**/integrations/**'],\n              message: 'UI cannot import backend/extension/integrations code.',\n            },\n            {\n              group: ['../../../core/*', '../../../../core/*', '../../../../../core/*'],\n              message: 'Use @core/* path aliases instead of deep relative imports.',\n            },\n            {\n              group: ['../../../api/*', '../../../../api/*', '../../../../../api/*'],\n              message: 'Use @api/* path aliases instead of deep relative imports.',\n            },\n            {\n              group: ['../../../shared/*', '../../../../shared/*', '../../../../../shared/*'],\n              message: 'Use @shared/ui* path aliases instead of deep relative imports.',\n            },\n          ],\n        },\n      ],\n    },\n  },\n\n  // Backend-specific configuration\n  {\n    files: ['backend/**/*.{js,mjs,cjs}'],\n    languageOptions: {\n      ecmaVersion: 'latest',\n      sourceType: 'commonjs', // Backend uses CommonJS (require/module.exports)\n      globals: {\n        process: 'readonly',\n        __dirname: 'readonly',\n        __filename: 'readonly',\n        Buffer: 'readonly',\n        console: 'readonly',\n        setTimeout: 'readonly',\n        clearTimeout: 'readonly',\n        setInterval: 'readonly',\n        clearInterval: 'readonly',\n        require: 'readonly',\n        module: 'readonly',\n        exports: 'readonly',\n        global: 'readonly',\n        fetch: 'readonly', // Node.js 18+ built-in\n        FormData: 'readonly', // Node.js 18+ built-in\n        Headers: 'readonly', // Node.js 18+ built-in\n        Request: 'readonly', // Node.js 18+ built-in\n        Response: 'readonly', // Node.js 18+ built-in\n        URL: 'readonly', // Node.js 18+ built-in\n        URLSearchParams: 'readonly', // Node.js 18+ built-in\n        AbortController: 'readonly', // Node.js 18+ built-in\n        AbortSignal: 'readonly', // Node.js 18+ built-in\n      },\n    },\n    rules: {\n      'no-console': 'off', // Allow console in backend\n      'no-unused-vars': ['warn', { argsIgnorePattern: '^_' }],\n      'no-undef': 'error',\n    },\n  },\n  {\n    files: ['backend/**/*.test.js'],\n    languageOptions: {\n      globals: {\n        test: 'readonly',\n        describe: 'readonly',\n        it: 'readonly',\n        before: 'readonly',\n        after: 'readonly',\n        beforeEach: 'readonly',\n        afterEach: 'readonly',\n      },\n    },\n    rules: {\n      'no-undef': 'off', // Test globals\n    },\n  },\n  {\n    files: ['**/__tests__/**/*.{js,mjs,cjs,ts,tsx}', '**/*.{test,spec}.{js,mjs,cjs,ts,tsx}'],\n    rules: {\n      'max-lines': 'off',\n      complexity: 'off',\n    },\n  },\n  prettierConfig,\n];\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\__tests__\\aiUtils.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\__tests__\\chromeClient.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (51). Maximum allowed is 50.",
        "line": 5,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 58,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import '../chromeClient.js';\n\nconst { chromeClient } = globalThis.LockInBackground;\n\ndescribe('chromeClient adapter', () => {\n  test('storage get resolves data', async () => {\n    const chromeMock = {\n      runtime: {},\n      storage: {\n        sync: {\n          get: (_keys, cb) => cb({ preferredLanguage: 'en' }),\n          set: (_data, cb) => cb(),\n          remove: (_keys, cb) => cb(),\n        },\n        local: {\n          get: (_keys, cb) => cb({}),\n          set: (_data, cb) => cb(),\n          remove: (_keys, cb) => cb(),\n        },\n      },\n      tabs: {\n        sendMessage: (_tabId, _message, cb) => cb({ ok: true }),\n      },\n    };\n\n    const client = chromeClient.createChromeClient(chromeMock);\n    const result = await client.storage.getSync(['preferredLanguage']);\n    expect(result.preferredLanguage).toBe('en');\n  });\n\n  test('storage get rejects on runtime.lastError', async () => {\n    const chromeMock = {\n      runtime: { lastError: null },\n      storage: {\n        sync: {\n          get: (_keys, cb) => {\n            chromeMock.runtime.lastError = { message: 'boom' };\n            cb({});\n            chromeMock.runtime.lastError = null;\n          },\n          set: (_data, cb) => cb(),\n          remove: (_keys, cb) => cb(),\n        },\n        local: {\n          get: (_keys, cb) => cb({}),\n          set: (_data, cb) => cb(),\n          remove: (_keys, cb) => cb(),\n        },\n      },\n      tabs: {\n        sendMessage: (_tabId, _message, cb) => cb({ ok: true }),\n      },\n    };\n\n    const client = chromeClient.createChromeClient(chromeMock);\n    await expect(client.storage.getSync(['preferredLanguage'])).rejects.toThrow('boom');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\__tests__\\router.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\__tests__\\validators.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\auth\\authService.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createAuthService' has too many lines (117). Maximum allowed is 50.",
        "line": 16,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 152,
        "endColumn": 4
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'refreshAccessToken' has too many lines (61). Maximum allowed is 50.",
        "line": 40,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 110,
        "endColumn": 6
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'refreshAccessToken' has too many statements (33). Maximum allowed is 20.",
        "line": 40,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 110,
        "endColumn": 6
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'refreshAccessToken' has a complexity of 19. Maximum allowed is 15.",
        "line": 40,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 40,
        "endColumn": 38
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3600.",
        "line": 93,
        "column": 55,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 93,
        "endColumn": 59
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'getAuthToken' has too many statements (22). Maximum allowed is 20.",
        "line": 112,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 147,
        "endColumn": 6
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n\n  function normalizeStoredSession(session) {\n    if (!session || typeof session !== 'object') return null;\n    return {\n      accessToken: session.accessToken || session.access_token || null,\n      refreshToken: session.refreshToken || session.refresh_token || null,\n      expiresAt: Number(session.expiresAt || session.expires_at || 0),\n      tokenType: session.tokenType || session.token_type || 'bearer',\n      user: session.user || null,\n    };\n  }\n\n  function createAuthService({ chromeClient, config, log, networkUtils, validators }) {\n    const AUTH_REFRESH_MAX_RETRIES = 2;\n    const AUTH_REFRESH_TIMEOUT_MS = 10000;\n    let refreshInFlight = null;\n    const runtimeValidators =\n      validators || registry.validators?.createRuntimeValidators?.() || null;\n    const validateAuthSession =\n      runtimeValidators?.validateAuthSession || ((value) => ({ ok: true, value: value || {} }));\n    const validateSupabaseTokenResponse =\n      runtimeValidators?.validateSupabaseTokenResponse ||\n      ((value) => ({ ok: true, value: value || {} }));\n\n    async function storageGet(key) {\n      return chromeClient.storage.getSync([key]);\n    }\n\n    async function storageSet(data) {\n      return chromeClient.storage.setSync(data);\n    }\n\n    async function storageRemove(key) {\n      return chromeClient.storage.removeSync(key);\n    }\n\n    async function refreshAccessToken(session) {\n      const supabaseUrl = config.getSupabaseUrl();\n      const anonKey = config.getSupabaseAnonKey();\n      if (!supabaseUrl || !anonKey || !session?.refreshToken) {\n        return null;\n      }\n\n      const requestOptions = {\n        method: 'POST',\n        headers: {\n          apikey: anonKey,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ refresh_token: session.refreshToken }),\n      };\n\n      const fetchWithRetry = networkUtils?.fetchWithRetry;\n      if (typeof fetchWithRetry !== 'function') {\n        log.error('Network utilities unavailable for auth refresh');\n        return null;\n      }\n\n      const response = await fetchWithRetry(\n        `${supabaseUrl}/auth/v1/token?grant_type=refresh_token`,\n        requestOptions,\n        AUTH_REFRESH_MAX_RETRIES,\n        AUTH_REFRESH_TIMEOUT_MS,\n      );\n\n      if (!response.ok) {\n        await storageRemove(config.getSessionStorageKey());\n        return null;\n      }\n\n      let payload = null;\n      try {\n        payload = await response.json();\n      } catch (error) {\n        log.error('Failed to parse refresh token response:', error);\n        return null;\n      }\n\n      const parsedPayload = validateSupabaseTokenResponse(payload);\n      if (!parsedPayload.ok) {\n        log.error('Invalid Supabase token response:', parsedPayload.error);\n        return null;\n      }\n      payload = parsedPayload.value;\n\n      if (!payload?.access_token) {\n        return null;\n      }\n\n      const expiresIn = Number(payload.expires_in) || 3600;\n      const nextSession = {\n        accessToken: payload.access_token,\n        refreshToken: payload.refresh_token || session.refreshToken,\n        expiresAt: Date.now() + expiresIn * 1000,\n        tokenType: payload.token_type || session.tokenType || 'bearer',\n        user: payload.user || session.user || null,\n      };\n\n      const validatedSession = validateAuthSession(nextSession);\n      if (!validatedSession.ok) {\n        log.error('Invalid auth session payload:', validatedSession.error);\n        return null;\n      }\n\n      await storageSet({ [config.getSessionStorageKey()]: validatedSession.value });\n      return nextSession.accessToken;\n    }\n\n    async function getAuthToken() {\n      const key = config.getSessionStorageKey();\n      try {\n        const result = await storageGet(key);\n        const session = normalizeStoredSession(result[key]);\n        const validated = validateAuthSession(session || {});\n        if (!validated.ok) {\n          log.error('Invalid auth session in storage:', validated.error);\n          return null;\n        }\n        const safeSession = validated.value;\n        if (!safeSession?.accessToken) return null;\n\n        const bufferMs = config.getTokenExpiryBufferMs();\n        const expiresAt = safeSession.expiresAt || 0;\n        if (expiresAt && expiresAt - bufferMs > Date.now()) {\n          return safeSession.accessToken;\n        }\n\n        if (!safeSession.refreshToken) {\n          return null;\n        }\n\n        if (!refreshInFlight) {\n          refreshInFlight = refreshAccessToken(safeSession).finally(() => {\n            refreshInFlight = null;\n          });\n        }\n\n        const refreshed = await refreshInFlight;\n        return refreshed || null;\n      } catch (error) {\n        log.error('Failed to read auth session:', error);\n        return null;\n      }\n    }\n\n    return {\n      getAuthToken,\n    };\n  }\n\n  registry.auth = {\n    createAuthService,\n    normalizeStoredSession,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\bootstrap.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\chromeClient.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createChromeClient' has too many lines (91). Maximum allowed is 50.",
        "line": 5,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 100,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n\n  function createChromeClient(chromeApi) {\n    function assertChrome(feature) {\n      if (!chromeApi) {\n        throw new Error(`Chrome API not available for ${feature}`);\n      }\n    }\n\n    function storageGet(area, keys) {\n      assertChrome(`storage.${area}.get`);\n      return new Promise((resolve, reject) => {\n        try {\n          chromeApi.storage[area].get(keys, (result) => {\n            const error = chromeApi.runtime?.lastError;\n            if (error) {\n              reject(new Error(error.message));\n              return;\n            }\n            resolve(result || {});\n          });\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }\n\n    function storageSet(area, data) {\n      assertChrome(`storage.${area}.set`);\n      return new Promise((resolve, reject) => {\n        try {\n          chromeApi.storage[area].set(data, () => {\n            const error = chromeApi.runtime?.lastError;\n            if (error) {\n              reject(new Error(error.message));\n              return;\n            }\n            resolve();\n          });\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }\n\n    function storageRemove(area, keys) {\n      assertChrome(`storage.${area}.remove`);\n      return new Promise((resolve, reject) => {\n        try {\n          chromeApi.storage[area].remove(keys, () => {\n            const error = chromeApi.runtime?.lastError;\n            if (error) {\n              reject(new Error(error.message));\n              return;\n            }\n            resolve();\n          });\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }\n\n    function sendTabMessage(tabId, message) {\n      assertChrome('tabs.sendMessage');\n      return new Promise((resolve, reject) => {\n        try {\n          chromeApi.tabs.sendMessage(tabId, message, (response) => {\n            const error = chromeApi.runtime?.lastError;\n            if (error) {\n              reject(new Error(error.message));\n              return;\n            }\n            resolve(response);\n          });\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }\n\n    return {\n      raw: chromeApi,\n      runtime: chromeApi?.runtime,\n      contextMenus: chromeApi?.contextMenus,\n      tabs: chromeApi?.tabs,\n      webNavigation: chromeApi?.webNavigation,\n      storage: {\n        getSync: (keys) => storageGet('sync', keys),\n        setSync: (data) => storageSet('sync', data),\n        removeSync: (keys) => storageRemove('sync', keys),\n        getLocal: (keys) => storageGet('local', keys),\n        setLocal: (data) => storageSet('local', data),\n        removeLocal: (keys) => storageRemove('local', keys),\n      },\n      sendTabMessage,\n    };\n  }\n\n  registry.chromeClient = {\n    createChromeClient,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\config.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60000.",
        "line": 31,
        "column": 54,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 31,
        "endColumn": 59
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60000.",
        "line": 33,
        "column": 49,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 33,
        "endColumn": 54
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n\n  function createConfig(lockinConfig) {\n    const configSource = lockinConfig || (root ? root.LOCKIN_CONFIG : null);\n\n    function getValue(key, fallback) {\n      if (!configSource) return fallback;\n      const value = configSource[key];\n      return value === undefined || value === null || value === '' ? fallback : value;\n    }\n\n    function getBackendUrl() {\n      return getValue('BACKEND_URL', 'http://localhost:3000');\n    }\n\n    function getSessionStorageKey() {\n      return getValue('SESSION_STORAGE_KEY', 'lockinSupabaseSession');\n    }\n\n    function getSupabaseUrl() {\n      return getValue('SUPABASE_URL', '');\n    }\n\n    function getSupabaseAnonKey() {\n      return getValue('SUPABASE_ANON_KEY', '');\n    }\n\n    function getTokenExpiryBufferMs() {\n      const raw = getValue('TOKEN_EXPIRY_BUFFER_MS', 60000);\n      const parsed = Number(raw);\n      return Number.isFinite(parsed) ? parsed : 60000;\n    }\n\n    return {\n      getValue,\n      getBackendUrl,\n      getSessionStorageKey,\n      getSupabaseUrl,\n      getSupabaseAnonKey,\n      getTokenExpiryBufferMs,\n    };\n  }\n\n  registry.config = {\n    createConfig,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\contextMenus.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\errors.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\handlers\\aiTranscriptionHandlers.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\handlers\\sessionHandlers.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\handlers\\settingsHandlers.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\handlers\\transcriptHandlers.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createTranscriptHandlers' has too many lines (55). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 63,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const handlers = registry.handlers || (registry.handlers = {});\n\n  function createTranscriptHandlers({ transcriptExtraction, panoptoMedia, log }) {\n    async function extractTranscriptHandler({ message, payload, respond: responder }) {\n      log.info('EXTRACT_TRANSCRIPT message received');\n      const video = message?.video ?? payload?.video;\n      if (!video) {\n        log.warn('No video provided in EXTRACT_TRANSCRIPT message');\n        return responder.errorWithFallback('No video provided', { error: 'No video provided' });\n      }\n      log.info('Processing EXTRACT_TRANSCRIPT for:', video.provider, video.id);\n      const result = await transcriptExtraction.extractTranscript(video);\n      log.info('EXTRACT_TRANSCRIPT result:', result.success);\n      if (!responder.hasMessaging) {\n        return result;\n      }\n      return result.success\n        ? responder.success(result)\n        : responder.error(result.error || 'Failed to extract transcript', result);\n    }\n\n    async function detectEcho360Handler({ payload, respond: responder }) {\n      const context = payload?.context;\n      const result = await transcriptExtraction.detectEcho360Videos(context);\n      if (!responder.hasMessaging) {\n        return result;\n      }\n      return result.success\n        ? responder.success(result)\n        : responder.error(result.error || 'Echo360 detection failed', result);\n    }\n\n    async function fetchPanoptoMediaHandler({ message, payload, sender, respond: responder }) {\n      log.info('FETCH_PANOPTO_MEDIA_URL message received');\n      const video = message?.video ?? payload?.video;\n      if (!video) {\n        log.warn('No video provided in FETCH_PANOPTO_MEDIA_URL message');\n        return responder.errorWithFallback('No video provided', {\n          success: false,\n          error: 'No video provided',\n        });\n      }\n      log.info('Fetching media URL for:', video.provider, video.id);\n      const result = await panoptoMedia.fetchPanoptoMediaUrl(video, { tabId: sender?.tab?.id });\n      log.info('FETCH_PANOPTO_MEDIA_URL result:', result.success);\n      if (!responder.hasMessaging) {\n        return result;\n      }\n      return result.success\n        ? responder.success(result)\n        : responder.error(result.error || 'Failed to fetch media URL', result);\n    }\n\n    return {\n      extractTranscript: extractTranscriptHandler,\n      EXTRACT_TRANSCRIPT: extractTranscriptHandler,\n      DETECT_ECHO360_VIDEOS: detectEcho360Handler,\n      FETCH_PANOPTO_MEDIA_URL: fetchPanoptoMediaHandler,\n    };\n  }\n\n  handlers.createTranscriptHandlers = createTranscriptHandlers;\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\index.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createBackgroundApp' has too many lines (117). Maximum allowed is 50.",
        "line": 5,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 130,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'createBackgroundApp' has too many statements (24). Maximum allowed is 20.",
        "line": 5,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 130,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n\n  function createBackgroundApp({\n    chrome,\n    messaging,\n    transcriptProviders,\n    networkUtils,\n    panoptoResolver,\n    lockinConfig,\n  }) {\n    const log = registry.logging.createLogger({ prefix: '[Lock-in BG]' });\n    const chromeClient = registry.chromeClient.createChromeClient(chrome);\n    const config = registry.config.createConfig(lockinConfig);\n    const respond = registry.responder.createResponder(messaging);\n    const transcriptsLog = log.withPrefix('[Transcripts]');\n    const runtimeValidators = registry.validators.createRuntimeValidators();\n\n    const sessionStore = registry.sessions.createSessionStore({\n      chromeClient,\n      log,\n      validators: runtimeValidators,\n    });\n    const settingsStore = registry.settings.createSettingsStore({\n      chromeClient,\n      log,\n      validators: runtimeValidators,\n    });\n    const authService = registry.auth.createAuthService({\n      chromeClient,\n      config,\n      log,\n      networkUtils,\n      validators: runtimeValidators,\n    });\n\n    const transcriptRegistry = registry.transcripts.registry.createTranscriptRegistry({\n      transcriptProviders,\n      log: transcriptsLog,\n    });\n    const createExtensionFetcher =\n      registry.transcripts.extensionFetcher.createExtensionFetcherFactory({\n        networkUtils,\n        transcriptProviders,\n      });\n    const transcriptExtraction = registry.transcripts.extraction.createTranscriptExtractionService({\n      transcriptProviders,\n      transcriptRegistry,\n      createExtensionFetcher,\n      log: transcriptsLog,\n    });\n    const panoptoMedia = registry.transcripts.panoptoMedia.createPanoptoMediaService({\n      transcriptProviders,\n      panoptoResolver,\n      createExtensionFetcher,\n      log: transcriptsLog,\n    });\n    const contentScriptMedia =\n      registry.transcripts.contentScriptMedia.createContentScriptMediaService({\n        chromeClient,\n        errors: registry.errors,\n        log: transcriptsLog,\n      });\n    const aiTranscription = registry.transcripts.aiTranscription.createAiTranscriptionService({\n      config,\n      auth: authService,\n      networkUtils,\n      chromeClient,\n      errors: registry.errors,\n      contentScriptMedia,\n      log: transcriptsLog,\n      validators: runtimeValidators,\n    });\n\n    const sessionHandlers = registry.handlers.createSessionHandlers({ sessionStore });\n    const settingsHandlers = registry.handlers.createSettingsHandlers({ settingsStore });\n    const transcriptHandlers = registry.handlers.createTranscriptHandlers({\n      transcriptExtraction,\n      panoptoMedia,\n      log: transcriptsLog,\n    });\n    const aiHandlers = registry.handlers.createAiTranscriptionHandlers({\n      aiTranscription,\n      contentScriptMedia,\n    });\n\n    const handlers = {\n      ...sessionHandlers,\n      ...settingsHandlers,\n      ...transcriptHandlers,\n      ...aiHandlers,\n    };\n\n    const validators = registry.validators.createMessageValidators();\n    const handleMessage = registry.router.createMessageRouter({\n      handlers,\n      validators,\n      getMessageType: registry.validators.getMessageType,\n      respond,\n      log,\n    });\n\n    function init() {\n      registry.contextMenus.registerContextMenus({ chromeClient, log });\n      registry.lifecycle.registerLifecycleListeners({ chromeClient, sessionStore, log });\n\n      if (messaging && typeof messaging.setupMessageListener === 'function') {\n        messaging.setupMessageListener(handleMessage);\n      } else if (chromeClient.runtime?.onMessage) {\n        chromeClient.runtime.onMessage.addListener((message, sender, sendResponse) => {\n          handleMessage(message, sender)\n            .then((response) => {\n              sendResponse(response);\n            })\n            .catch((error) => {\n              sendResponse({ error: error.message || String(error) });\n            });\n          return true;\n        });\n      }\n\n      log.info('Lock-in background service worker started');\n    }\n\n    return {\n      init,\n      handleMessage,\n    };\n  }\n\n  let initialized = false;\n\n  function initBackground(deps) {\n    if (initialized) return;\n    initialized = true;\n    const app = createBackgroundApp(deps);\n    app.init();\n    return app;\n  }\n\n  registry.index = {\n    createBackgroundApp,\n    initBackground,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\lifecycle.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\logging.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\responder.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\router.js",
    "messages": [
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'handleMessage' has a complexity of 20. Maximum allowed is 15.",
        "line": 6,
        "column": 12,
        "nodeType": "FunctionExpression",
        "messageId": "complex",
        "endLine": 6,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n\n  function createMessageRouter({ handlers, validators, getMessageType, respond, log }) {\n    return async function handleMessage(message, sender) {\n      const messageType = getMessageType\n        ? getMessageType(message)\n        : message?.type || message?.action;\n      const handler = messageType ? handlers?.[messageType] : null;\n\n      if (!handler) {\n        const errorMessage = `Unknown message type: ${messageType}`;\n        return respond.error(errorMessage);\n      }\n\n      const validator = validators?.[messageType];\n      let payload = message?.payload;\n      if (validator) {\n        const validation = validator(message);\n        if (validation && validation.ok === false) {\n          const errorMessage = validation.error || 'Invalid payload';\n          const fallback = validation.fallback || { error: errorMessage };\n          return respond.errorWithFallback(errorMessage, fallback, validation.meta);\n        }\n        if (validation && 'payload' in validation) {\n          payload = validation.payload;\n        }\n      }\n\n      try {\n        return await handler({ message, sender, payload, respond, log, messageType });\n      } catch (error) {\n        log.error('Error handling message:', error);\n        const errorMessage = error?.message || String(error);\n        return respond.error(errorMessage);\n      }\n    };\n  }\n\n  registry.router = {\n    createMessageRouter,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\sessions\\sessionStore.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createSessionStore' has too many lines (62). Maximum allowed is 50.",
        "line": 5,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 72,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n\n  function createSessionStore({ chromeClient, log, validators, prefix = 'lockin_session_' }) {\n    const runtimeValidators =\n      validators || registry.validators?.createRuntimeValidators?.() || null;\n    const validateSession =\n      runtimeValidators?.validateSession ||\n      ((value) => ({ ok: true, value: value || { chatHistory: [] } }));\n\n    function getSessionKey(tabId) {\n      return `${prefix}${tabId}`;\n    }\n\n    async function getSession(tabId) {\n      if (!tabId) return null;\n      const key = getSessionKey(tabId);\n      try {\n        const result = await chromeClient.storage.getLocal([key]);\n        const session = result[key] || null;\n        if (!session) return null;\n        const parsed = validateSession(session);\n        if (!parsed.ok) {\n          log.warn('Invalid session payload from storage:', parsed.error);\n          return null;\n        }\n        return parsed.value;\n      } catch (error) {\n        log.error('Failed to get session:', error);\n        return null;\n      }\n    }\n\n    async function saveSession(tabId, sessionData) {\n      if (!tabId) return;\n      const key = getSessionKey(tabId);\n      const parsed = validateSession(sessionData || {});\n      if (!parsed.ok) {\n        log.warn('Invalid session payload, storing sanitized fallback:', parsed.error);\n      }\n      const safeSession = parsed.ok ? parsed.value : parsed.fallback;\n      const storedSession = {\n        ...(safeSession || {}),\n        chatHistory: Array.isArray(safeSession?.chatHistory) ? safeSession.chatHistory : [],\n        updatedAt: Date.now(),\n      };\n\n      try {\n        await chromeClient.storage.setLocal({ [key]: storedSession });\n      } catch (error) {\n        log.error('Failed to save session:', error);\n      }\n    }\n\n    async function clearSession(tabId) {\n      if (!tabId) return;\n      const key = getSessionKey(tabId);\n      try {\n        await chromeClient.storage.removeLocal(key);\n      } catch (error) {\n        log.error('Failed to clear session:', error);\n      }\n    }\n\n    return {\n      getSessionKey,\n      getSession,\n      saveSession,\n      clearSession,\n    };\n  }\n\n  registry.sessions = {\n    createSessionStore,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\settings\\settingsStore.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\aiTranscription.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createAiTranscriptionService' has too many lines (268). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 295,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'createAiTranscriptionService' has too many statements (26). Maximum allowed is 20.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 295,
        "endColumn": 4
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Function 'createAiTranscriptionService' has a complexity of 16. Maximum allowed is 15.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 6,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 16,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 16,
        "endColumn": 36
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 16,
        "column": 39,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 16,
        "endColumn": 43
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 16,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 16,
        "endColumn": 50
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'runAiTranscriptionFlow' has too many lines (56). Maximum allowed is 50.",
        "line": 173,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 234,
        "endColumn": 6
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const transcripts = registry.transcripts || (registry.transcripts = {});\n\n  function createAiTranscriptionService({\n    config,\n    auth,\n    networkUtils,\n    chromeClient,\n    errors,\n    contentScriptMedia,\n    log,\n    validators,\n  }) {\n    const AI_UPLOAD_CHUNK_BYTES = 4 * 1024 * 1024;\n    const AI_POLL_INTERVAL_MS = 3000;\n    const AI_POLL_MAX_ATTEMPTS = 160;\n    const jobs = new Map();\n    const aiUtils = transcripts.aiUtils || {};\n    const helpersFactory = transcripts.aiTranscriptionHelpers?.createAiTranscriptionHelpers || null;\n    const requestsFactory =\n      transcripts.aiTranscriptionRequests?.createAiTranscriptionRequests || null;\n    const uploadServiceFactory =\n      transcripts.aiTranscriptionUpload?.createAiTranscriptionUploadService;\n    const pollingServiceFactory =\n      transcripts.aiTranscriptionPolling?.createAiTranscriptionPollingService;\n    const helpers =\n      helpersFactory?.({\n        aiUtils,\n        auth,\n        errors,\n        log,\n        chromeClient,\n        chunkBytes: AI_UPLOAD_CHUNK_BYTES,\n      }) || null;\n    const requests = requestsFactory?.({ config, networkUtils, aiUtils, validators }) || null;\n    const uploadService =\n      uploadServiceFactory?.({\n        config,\n        aiUtils,\n        errors,\n        contentScriptMedia,\n        log,\n        chunkBytes: AI_UPLOAD_CHUNK_BYTES,\n        networkUtils,\n      }) || null;\n    const pollingService =\n      requests && pollingServiceFactory\n        ? pollingServiceFactory({\n            config,\n            fetchJsonWithAuth: requests.fetchJsonWithAuth,\n            pollIntervalMs: AI_POLL_INTERVAL_MS,\n            pollMaxAttempts: AI_POLL_MAX_ATTEMPTS,\n            validators,\n          })\n        : null;\n\n    function requireHelpers() {\n      if (!helpers) {\n        throw errors.createErrorWithCode('AI transcription helpers unavailable.', 'NOT_AVAILABLE');\n      }\n      return helpers;\n    }\n    function requireRequests() {\n      if (!requests) {\n        throw errors.createErrorWithCode('AI transcription requests unavailable.', 'NOT_AVAILABLE');\n      }\n      return requests;\n    }\n    function requireUploadService() {\n      if (!uploadService) {\n        throw errors.createErrorWithCode('Upload service unavailable.', 'NOT_AVAILABLE');\n      }\n      return uploadService;\n    }\n    function requirePollingService() {\n      if (!pollingService) {\n        throw errors.createErrorWithCode('Polling service unavailable.', 'NOT_AVAILABLE');\n      }\n      return pollingService;\n    }\n\n    function createJobState(requestId) {\n      return {\n        requestId,\n        jobId: null,\n        abortController: new AbortController(),\n      };\n    }\n\n    async function prepareJobInputs({ video, signal }) {\n      const helper = requireHelpers();\n      const request = requireRequests();\n\n      helper.ensureVideoEligible(video);\n      const token = await helper.requireAuthToken();\n      const mediaUrlNormalized = aiUtils.normalizeMediaUrl\n        ? aiUtils.normalizeMediaUrl(video.mediaUrl)\n        : video.mediaUrl;\n      const headInfo = await request.fetchMediaHeadMetadata(video.mediaUrl, signal);\n      if (headInfo?.authRequired) {\n        throw errors.createErrorWithCode(\n          'Authentication required to access this media.',\n          'AUTH_REQUIRED',\n        );\n      }\n      const expectedTotalChunks = helper.resolveExpectedTotalChunks(headInfo);\n      const fingerprint = await helper.buildFingerprint({\n        mediaUrlNormalized,\n        headInfo,\n        durationMs: video.durationMs || null,\n      });\n      return { token, mediaUrlNormalized, expectedTotalChunks, fingerprint };\n    }\n\n    function buildJobPayload({ video, fingerprint, mediaUrlNormalized, expectedTotalChunks }) {\n      return {\n        fingerprint,\n        mediaUrl: video.mediaUrl,\n        mediaUrlNormalized,\n        durationMs: video.durationMs || null,\n        provider: video.provider || 'unknown',\n        expectedTotalChunks,\n      };\n    }\n\n    async function uploadAndFinalize({\n      jobId,\n      video,\n      token,\n      options,\n      expectedTotalChunks,\n      progress,\n      signal,\n      tabId,\n      requestId,\n    }) {\n      progress('uploading', { jobId, message: 'Uploading media...' });\n      const uploadStats = await requireUploadService().uploadMediaInChunks({\n        jobId,\n        mediaUrl: video.mediaUrl,\n        token,\n        signal,\n        onProgress: (info) => progress('uploading', { jobId, ...info }),\n        tabId,\n        requestId,\n      });\n      progress('processing', { jobId, message: 'Processing audio...' });\n      const helper = requireHelpers();\n      const expectedTotalChunksForFinalize = helper.resolveFinalizeChunkCount(\n        uploadStats,\n        expectedTotalChunks,\n      );\n      await requireRequests().finalizeTranscriptionJob({\n        jobId,\n        token,\n        options,\n        expectedTotalChunks: expectedTotalChunksForFinalize,\n        signal,\n      });\n    }\n\n    async function pollForTranscript({ jobId, token, progress, signal }) {\n      progress('polling', { jobId, message: 'Transcribing...' });\n      return requirePollingService().pollTranscriptJob({\n        jobId,\n        token,\n        signal,\n        onProgress: (info) => progress('polling', { jobId, ...info }),\n      });\n    }\n    async function runAiTranscriptionFlow({ video, options, progress, jobState }) {\n      const helper = requireHelpers();\n      const request = requireRequests();\n      const { token, mediaUrlNormalized, expectedTotalChunks, fingerprint } =\n        await prepareJobInputs({\n          video,\n          signal: jobState.abortController.signal,\n        });\n\n      const jobResponse = await request.createTranscriptionJob({\n        token,\n        payload: buildJobPayload({\n          video,\n          fingerprint,\n          mediaUrlNormalized,\n          expectedTotalChunks,\n        }),\n        signal: jobState.abortController.signal,\n      });\n\n      if (jobResponse?.job?.transcript) {\n        progress('completed', { message: 'Transcript ready.' });\n        return helper.buildSuccessResponse({\n          requestId: jobState.requestId,\n          jobId: jobResponse.job.id,\n          transcript: jobResponse.job.transcript,\n          cached: true,\n        });\n      }\n\n      const jobId = jobResponse?.job?.id || jobResponse?.jobId;\n      if (!jobId) {\n        throw new Error('Failed to create transcription job');\n      }\n\n      jobState.jobId = jobId;\n      await uploadAndFinalize({\n        jobId,\n        video,\n        token,\n        options,\n        expectedTotalChunks,\n        progress,\n        signal: jobState.abortController.signal,\n        tabId: jobState.tabId,\n        requestId: jobState.requestId,\n      });\n\n      const transcript = await pollForTranscript({\n        jobId,\n        token,\n        progress,\n        signal: jobState.abortController.signal,\n      });\n\n      progress('completed', { jobId, message: 'Transcript ready.' });\n      return helper.buildSuccessResponse({\n        requestId: jobState.requestId,\n        jobId,\n        transcript,\n      });\n    }\n\n    async function handleAiTranscriptionStart(payload, sender) {\n      const helper = requireHelpers();\n      const { video, options, requestId, tabId } = helper.buildRequestContext(payload, sender);\n\n      if (!video || !video.mediaUrl) {\n        return helper.buildFailureResponse({\n          requestId,\n          error: 'Media URL not available for AI transcription.',\n          errorCode: 'NOT_AVAILABLE',\n        });\n      }\n\n      const progress = helper.createProgressEmitter(tabId, requestId);\n      const jobState = { ...createJobState(requestId), tabId };\n      jobs.set(requestId, jobState);\n      progress('starting', { message: 'Preparing AI transcription...' });\n\n      try {\n        return await runAiTranscriptionFlow({ video, options, progress, jobState });\n      } catch (error) {\n        const failure = helper.resolveFailureResponse({ error, jobState, requestId });\n        progress(failure.progress.stage, {\n          jobId: jobState.jobId,\n          message: failure.progress.message,\n        });\n        return failure.response;\n      } finally {\n        jobs.delete(requestId);\n      }\n    }\n\n    async function handleAiTranscriptionCancel(payload) {\n      const requestId = payload?.requestId;\n      const jobId = payload?.jobId;\n\n      const jobState = requestId ? jobs.get(requestId) : null;\n      if (jobState?.abortController) {\n        jobState.abortController.abort();\n      }\n\n      const token = await auth.getAuthToken();\n      if (jobId && token) {\n        try {\n          await requireRequests().cancelTranscriptJob({ jobId, token });\n        } catch (error) {\n          log.warn('Failed to cancel transcript job:', error);\n        }\n      }\n\n      return { success: true, requestId, jobId };\n    }\n\n    return {\n      handleAiTranscriptionStart,\n      handleAiTranscriptionCancel,\n      listActiveTranscriptJobs: (args) => requireRequests().listActiveTranscriptJobs(args),\n      cancelAllActiveTranscriptJobs: (args) =>\n        requireRequests().cancelAllActiveTranscriptJobs(args),\n    };\n  }\n\n  transcripts.aiTranscription = {\n    createAiTranscriptionService,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\aiTranscriptionHelpers.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createAiTranscriptionHelpers' has too many lines (199). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 229,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 55,
        "column": 85,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 55,
        "endColumn": 87
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const transcripts = registry.transcripts || (registry.transcripts = {});\n\n  function createAiTranscriptionHelpers({ aiUtils, auth, errors, log, chromeClient, chunkBytes }) {\n    function createProgressEmitter(tabId, requestId) {\n      let lastStage = null;\n      let lastPercentBucket = null;\n\n      return (stage, info = {}) => {\n        if (!tabId) return;\n\n        const percent =\n          typeof info.percent === 'number' ? Math.max(0, Math.min(100, info.percent)) : undefined;\n        const percentBucket = typeof percent === 'number' ? Math.floor(percent) : null;\n        const shouldSkip =\n          stage === lastStage &&\n          percentBucket !== null &&\n          percentBucket === lastPercentBucket &&\n          !info.message;\n\n        if (shouldSkip) return;\n\n        lastStage = stage;\n        if (percentBucket !== null) {\n          lastPercentBucket = percentBucket;\n        }\n\n        try {\n          Promise.resolve(\n            chromeClient.sendTabMessage(tabId, {\n              type: 'TRANSCRIBE_MEDIA_AI_PROGRESS',\n              payload: {\n                requestId,\n                jobId: info.jobId || null,\n                stage,\n                message: info.message || null,\n                percent,\n              },\n            }),\n          ).catch((error) => {\n            log.warn('Failed to send progress update:', error);\n          });\n        } catch (error) {\n          log.warn('Failed to send progress update:', error);\n        }\n      };\n    }\n\n    function buildRequestContext(payload, sender) {\n      return {\n        video: payload?.video || null,\n        options: payload?.options || {},\n        requestId: payload?.requestId || `ai-${Date.now()}-${Math.random().toString(16).slice(2)}`,\n        tabId: sender?.tab?.id || null,\n      };\n    }\n\n    function ensureVideoEligible(video) {\n      if (aiUtils.isBlobUrl?.(video.mediaUrl)) {\n        throw errors.createErrorWithCode(\n          'This video uses a blob URL and cannot be accessed for AI transcription.',\n          'NOT_AVAILABLE',\n        );\n      }\n\n      if (video.drmDetected) {\n        const reason = video.drmReason ? ` (${video.drmReason})` : '';\n        throw errors.createErrorWithCode(\n          `This video appears to be DRM-protected${reason}. AI transcription is not available.`,\n          'NOT_AVAILABLE',\n        );\n      }\n    }\n\n    async function requireAuthToken() {\n      const token = await auth.getAuthToken();\n      if (!token) {\n        throw errors.createErrorWithCode(\n          'Please sign in to Lock-in to use AI transcription. Click the extension icon to sign in.',\n          'LOCKIN_AUTH_REQUIRED',\n        );\n      }\n      return token;\n    }\n\n    function resolveExpectedTotalChunks(headInfo) {\n      const headContentLength = headInfo?.contentLength ? Number(headInfo.contentLength) : null;\n      return Number.isFinite(headContentLength) && headContentLength > 0\n        ? Math.ceil(headContentLength / chunkBytes)\n        : null;\n    }\n\n    function buildFingerprintSource({ mediaUrlNormalized, headInfo, durationMs }) {\n      return [\n        mediaUrlNormalized,\n        headInfo?.etag || '',\n        headInfo?.lastModified || '',\n        headInfo?.contentLength || '',\n        durationMs || '',\n      ].join('|');\n    }\n\n    async function buildFingerprint({ mediaUrlNormalized, headInfo, durationMs }) {\n      const source = buildFingerprintSource({ mediaUrlNormalized, headInfo, durationMs });\n      if (typeof aiUtils.hashStringSha256 !== 'function') {\n        return source;\n      }\n      return aiUtils.hashStringSha256(source);\n    }\n\n    function resolveFinalizeChunkCount(uploadStats, expectedTotalChunks) {\n      return uploadStats?.totalChunks || expectedTotalChunks || uploadStats?.chunkCount || null;\n    }\n\n    function buildFailureResponse({ requestId, jobId, error, errorCode, status }) {\n      return {\n        success: false,\n        error: error || 'Failed to transcribe media.',\n        errorCode: errorCode || 'NOT_AVAILABLE',\n        jobId,\n        status: status || 'failed',\n        requestId,\n      };\n    }\n\n    function buildSuccessResponse({ requestId, jobId, transcript, cached }) {\n      return {\n        success: true,\n        transcript,\n        jobId,\n        status: 'completed',\n        cached: Boolean(cached),\n        requestId,\n      };\n    }\n\n    function resolveCanceledFailure({ jobState, requestId }) {\n      return {\n        progress: { stage: 'canceled', message: 'Canceled.' },\n        response: buildFailureResponse({\n          requestId,\n          jobId: jobState.jobId,\n          error: 'Transcription canceled.',\n          errorCode: 'CANCELED',\n          status: 'canceled',\n        }),\n      };\n    }\n\n    function resolveLockInAuthFailure({ jobState, requestId }) {\n      return {\n        progress: { stage: 'failed', message: 'Lock-in sign-in required.' },\n        response: buildFailureResponse({\n          requestId,\n          jobId: jobState.jobId,\n          error:\n            'Please sign in to Lock-in to use AI transcription. Click the extension icon to sign in.',\n          errorCode: 'LOCKIN_AUTH_REQUIRED',\n          status: 'failed',\n        }),\n      };\n    }\n\n    function resolveMediaAuthFailure({ jobState, requestId }) {\n      return {\n        progress: { stage: 'failed', message: 'Media authentication required.' },\n        response: buildFailureResponse({\n          requestId,\n          jobId: jobState.jobId,\n          error:\n            'Media authentication required. Please refresh the page and ensure you are logged in to the learning platform.',\n          errorCode: 'AUTH_REQUIRED',\n          status: 'failed',\n        }),\n      };\n    }\n\n    function resolveGenericFailure({ jobState, requestId, message, errorCode }) {\n      return {\n        progress: { stage: 'failed', message },\n        response: buildFailureResponse({\n          requestId,\n          jobId: jobState.jobId,\n          error: message || 'Failed to transcribe media.',\n          errorCode: errorCode || 'NOT_AVAILABLE',\n          status: 'failed',\n        }),\n      };\n    }\n\n    function resolveFailureResponse({ error, jobState, requestId }) {\n      const message = error instanceof Error ? error.message : String(error);\n      const errorCode = errors.getErrorCode(error);\n      const status = error?.status;\n\n      if (jobState.abortController.signal.aborted || message === 'CANCELED') {\n        return resolveCanceledFailure({ jobState, requestId });\n      }\n\n      if (errorCode === 'LOCKIN_AUTH_REQUIRED') {\n        return resolveLockInAuthFailure({ jobState, requestId });\n      }\n\n      if (\n        errorCode === 'AUTH_REQUIRED' ||\n        message === 'AUTH_REQUIRED' ||\n        aiUtils.isAuthStatus?.(status)\n      ) {\n        return resolveMediaAuthFailure({ jobState, requestId });\n      }\n\n      return resolveGenericFailure({ jobState, requestId, message, errorCode });\n    }\n\n    return {\n      createProgressEmitter,\n      buildRequestContext,\n      ensureVideoEligible,\n      requireAuthToken,\n      resolveExpectedTotalChunks,\n      buildFingerprint,\n      resolveFinalizeChunkCount,\n      buildFailureResponse,\n      buildSuccessResponse,\n      resolveFailureResponse,\n    };\n  }\n\n  transcripts.aiTranscriptionHelpers = {\n    createAiTranscriptionHelpers,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\aiTranscriptionPolling.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createAiTranscriptionPollingService' has too many lines (72). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 87,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const transcripts = registry.transcripts || (registry.transcripts = {});\n\n  function createAiTranscriptionPollingService({\n    config,\n    fetchJsonWithAuth,\n    pollIntervalMs,\n    pollMaxAttempts,\n    validators,\n  }) {\n    const runtimeValidators =\n      validators || registry.validators?.createRuntimeValidators?.() || null;\n    const validateJobResponse =\n      runtimeValidators?.validateTranscriptJobResponse ||\n      ((value) => ({ ok: true, value: value || { success: false } }));\n    const validateJob =\n      runtimeValidators?.validateTranscriptJob || ((value) => ({ ok: true, value: value || {} }));\n\n    async function fetchJobStatus({ jobId, token, signal }) {\n      const backendUrl = config.getBackendUrl();\n      const data = await fetchJsonWithAuth(`${backendUrl}/api/transcripts/jobs/${jobId}`, token, {\n        method: 'GET',\n        signal,\n      });\n      const parsed = validateJobResponse(data);\n      if (parsed.ok && parsed.value?.job) {\n        return parsed.value.job;\n      }\n\n      const jobParsed = validateJob(data);\n      if (jobParsed.ok) {\n        return jobParsed.value;\n      }\n\n      throw new Error(parsed.error || jobParsed.error || 'Invalid transcript job status response');\n    }\n\n    function resolveJobState(job) {\n      if (!job) return { status: 'unknown' };\n      if ((job.status === 'done' || job.status === 'completed') && job.transcript) {\n        return { status: 'done', transcript: job.transcript };\n      }\n      if (job.status === 'error' || job.status === 'failed') {\n        const errorMsg =\n          typeof job.error === 'string'\n            ? job.error\n            : job.error?.message || 'AI transcription failed';\n        return { status: 'error', error: errorMsg };\n      }\n      if (job.status === 'canceled') {\n        return { status: 'canceled' };\n      }\n      return { status: 'processing' };\n    }\n\n    async function pollTranscriptJob({ jobId, token, signal, onProgress }) {\n      for (let attempt = 0; attempt < pollMaxAttempts; attempt += 1) {\n        if (signal?.aborted) {\n          throw new Error('CANCELED');\n        }\n\n        const job = await fetchJobStatus({ jobId, token, signal });\n        const state = resolveJobState(job);\n\n        if (state.status === 'done') {\n          return state.transcript;\n        }\n        if (state.status === 'error') {\n          throw new Error(state.error || 'AI transcription failed');\n        }\n        if (state.status === 'canceled') {\n          throw new Error('CANCELED');\n        }\n\n        if (onProgress) {\n          onProgress({ message: 'Transcribing...' });\n        }\n        await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));\n      }\n\n      throw new Error('AI transcription timed out');\n    }\n\n    return { pollTranscriptJob };\n  }\n\n  transcripts.aiTranscriptionPolling = {\n    createAiTranscriptionPollingService,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\aiTranscriptionRequests.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createAiTranscriptionRequests' has too many lines (196). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 218,
        "endColumn": 4
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'fetchJsonWithAuth' has a complexity of 18. Maximum allowed is 15.",
        "line": 38,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 38,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const transcripts = registry.transcripts || (registry.transcripts = {});\n\n  function createAiTranscriptionRequests({ config, networkUtils, aiUtils, validators }) {\n    const fetchWithRetry = networkUtils?.fetchWithRetry;\n    const AUTH_REQUEST_MAX_RETRIES = 2;\n    const AUTH_REQUEST_TIMEOUT_MS = 15000;\n    const runtimeValidators =\n      validators || registry.validators?.createRuntimeValidators?.() || null;\n    const validateJobResponse =\n      runtimeValidators?.validateTranscriptJobResponse ||\n      ((value) => ({ ok: true, value: value || { success: false } }));\n    const validateJobListResponse =\n      runtimeValidators?.validateTranscriptJobListResponse ||\n      ((value) => ({ ok: true, value: value || { success: false, jobs: [] } }));\n    const validateCancelAllResponse =\n      runtimeValidators?.validateTranscriptCancelAllResponse ||\n      ((value) => ({ ok: true, value: value || { success: false, canceledIds: [] } }));\n\n    function buildAuthHeaders(token, extraHeaders) {\n      return Object.assign({}, extraHeaders || {}, {\n        Authorization: `Bearer ${token}`,\n      });\n    }\n\n    async function parseJsonResponse(response) {\n      const text = await response.text();\n      if (!text) return null;\n      try {\n        return JSON.parse(text);\n      } catch {\n        return null;\n      }\n    }\n\n    async function fetchJsonWithAuth(url, token, options = {}) {\n      if (typeof fetchWithRetry !== 'function') {\n        throw new Error('Network utilities unavailable');\n      }\n\n      const headers = buildAuthHeaders(token, options.headers);\n      const response = await fetchWithRetry(\n        url,\n        { ...options, headers },\n        AUTH_REQUEST_MAX_RETRIES,\n        AUTH_REQUEST_TIMEOUT_MS,\n      );\n      const data = await parseJsonResponse(response);\n\n      if (!response.ok) {\n        let message = 'Request failed';\n        if (data?.error?.message) {\n          message = data.error.message;\n        } else if (typeof data?.error === 'string') {\n          message = data.error;\n        } else if (typeof data?.message === 'string') {\n          message = data.message;\n        } else if (response.statusText) {\n          message = response.statusText;\n        }\n        const error = new Error(message);\n        if (data?.error?.code) {\n          error.code = data.error.code;\n        }\n        if (data?.error?.details) {\n          error.details = data.error.details;\n        }\n        error.status = response.status;\n        throw error;\n      }\n\n      return data;\n    }\n\n    async function fetchMediaHeadMetadata(mediaUrl, signal) {\n      try {\n        if (typeof fetchWithRetry !== 'function') {\n          throw new Error('Network utilities unavailable');\n        }\n        const response = await fetchWithRetry(mediaUrl, {\n          method: 'HEAD',\n          credentials: 'include',\n          signal,\n        });\n\n        if (aiUtils.isAuthStatus?.(response.status)) {\n          return { authRequired: true };\n        }\n\n        if (!response.ok) {\n          return { ok: false, status: response.status };\n        }\n\n        if (response.type === 'opaque') {\n          return { ok: false, opaque: true };\n        }\n\n        const etag = response.headers.get('etag');\n        const lastModified = response.headers.get('last-modified');\n        const contentLength = response.headers.get('content-length');\n        return {\n          ok: true,\n          etag: etag ? etag.trim() : '',\n          lastModified: lastModified ? lastModified.trim() : '',\n          contentLength: contentLength ? contentLength.trim() : '',\n        };\n      } catch (error) {\n        if (signal?.aborted) {\n          throw error;\n        }\n        const message = error instanceof Error ? error.message : String(error);\n        return { ok: false, error: message };\n      }\n    }\n\n    async function createTranscriptionJob({ token, payload, signal }) {\n      const backendUrl = config.getBackendUrl();\n      const data = await fetchJsonWithAuth(`${backendUrl}/api/transcripts/jobs`, token, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload),\n        signal,\n      });\n      const parsed = validateJobResponse(data);\n      if (!parsed.ok) {\n        throw new Error(parsed.error || 'Invalid transcript job response');\n      }\n      return parsed.value;\n    }\n\n    async function finalizeTranscriptionJob({\n      jobId,\n      token,\n      options,\n      expectedTotalChunks,\n      signal,\n    }) {\n      const backendUrl = config.getBackendUrl();\n      const payload = Object.assign({}, options || {});\n      if (expectedTotalChunks) {\n        payload.expectedTotalChunks = expectedTotalChunks;\n      }\n      const data = await fetchJsonWithAuth(\n        `${backendUrl}/api/transcripts/jobs/${jobId}/finalize`,\n        token,\n        {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(payload),\n          signal,\n        },\n      );\n      const parsed = validateJobResponse(data);\n      if (!parsed.ok) {\n        throw new Error(parsed.error || 'Invalid transcript finalize response');\n      }\n      return parsed.value;\n    }\n\n    async function cancelTranscriptJob({ jobId, token }) {\n      if (!jobId || !token) return;\n      const backendUrl = config.getBackendUrl();\n      const data = await fetchJsonWithAuth(\n        `${backendUrl}/api/transcripts/jobs/${jobId}/cancel`,\n        token,\n        {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({}),\n        },\n      );\n      const parsed = validateJobResponse(data);\n      if (!parsed.ok) {\n        throw new Error(parsed.error || 'Invalid transcript cancel response');\n      }\n      return parsed.value;\n    }\n\n    async function listActiveTranscriptJobs({ token }) {\n      if (!token) throw new Error('No auth token provided');\n      const backendUrl = config.getBackendUrl();\n      const data = await fetchJsonWithAuth(`${backendUrl}/api/transcripts/jobs/active`, token, {\n        method: 'GET',\n      });\n      const parsed = validateJobListResponse(data);\n      if (!parsed.ok) {\n        throw new Error(parsed.error || 'Invalid transcript list response');\n      }\n      return parsed.value;\n    }\n\n    async function cancelAllActiveTranscriptJobs({ token }) {\n      if (!token) throw new Error('No auth token provided');\n      const backendUrl = config.getBackendUrl();\n      const data = await fetchJsonWithAuth(`${backendUrl}/api/transcripts/jobs/cancel-all`, token, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({}),\n      });\n      const parsed = validateCancelAllResponse(data);\n      if (!parsed.ok) {\n        throw new Error(parsed.error || 'Invalid transcript cancel-all response');\n      }\n      return parsed.value;\n    }\n\n    return {\n      fetchJsonWithAuth,\n      fetchMediaHeadMetadata,\n      createTranscriptionJob,\n      finalizeTranscriptionJob,\n      cancelTranscriptJob,\n      listActiveTranscriptJobs,\n      cancelAllActiveTranscriptJobs,\n    };\n  }\n\n  transcripts.aiTranscriptionRequests = {\n    createAiTranscriptionRequests,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\aiTranscriptionUpload.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createAiTranscriptionUploadService' has too many lines (336). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 380,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 80,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 80,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 101,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 101,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 502.",
        "line": 101,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 101,
        "endColumn": 37
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 503.",
        "line": 101,
        "column": 39,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 101,
        "endColumn": 42
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 504.",
        "line": 101,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 101,
        "endColumn": 47
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'fetchDirectMediaResponse' has too many lines (66). Maximum allowed is 50.",
        "line": 120,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 195,
        "endColumn": 6
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'fetchDirectMediaResponse' has too many statements (28). Maximum allowed is 20.",
        "line": 120,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 195,
        "endColumn": 6
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 300.",
        "line": 144,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 144,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 144,
        "column": 54,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 144,
        "endColumn": 57
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'streamAndUploadResponse' has too many lines (65). Maximum allowed is 50.",
        "line": 251,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 323,
        "endColumn": 6
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'streamAndUploadResponse' has too many statements (36). Maximum allowed is 20.",
        "line": 251,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 323,
        "endColumn": 6
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'streamAndUploadResponse' has a complexity of 17. Maximum allowed is 15.",
        "line": 251,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 251,
        "endColumn": 43
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 303,
        "column": 49,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 303,
        "endColumn": 50
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (344). Maximum allowed is 300.",
        "line": 337,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 386,
        "endColumn": 1
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 15,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const transcripts = registry.transcripts || (registry.transcripts = {});\n\n  function createAiTranscriptionUploadService({\n    config,\n    aiUtils,\n    errors,\n    contentScriptMedia,\n    log,\n    chunkBytes,\n    networkUtils,\n  }) {\n    const fetchWithRetry = networkUtils?.fetchWithRetry;\n    const CHUNK_UPLOAD_TIMEOUT_MS = 30000;\n    const MEDIA_FETCH_MAX_RETRIES = 2;\n    const MEDIA_FETCH_TIMEOUT_MS = 20000;\n    const SSO_DOMAINS = [\n      'okta.com',\n      'auth0.com',\n      'login.microsoftonline.com',\n      'accounts.google.com',\n    ];\n\n    const isSsoRedirect = (url) => {\n      try {\n        const hostname = new URL(url).hostname.toLowerCase();\n        return SSO_DOMAINS.some((domain) => hostname.includes(domain));\n      } catch {\n        return false;\n      }\n    };\n\n    const isCdnUrl = (url) => {\n      try {\n        const hostname = new URL(url).hostname.toLowerCase();\n        return (\n          hostname.includes('cloudfront.net') ||\n          hostname.includes('cdn.') ||\n          hostname.includes('akamai') ||\n          hostname.includes('fastly') ||\n          hostname.includes('cloudflare')\n        );\n      } catch {\n        return false;\n      }\n    };\n\n    function buildChunkHeaders({ token, index, totalChunks }) {\n      const headers = {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/octet-stream',\n        'x-chunk-index': String(index),\n      };\n      if (totalChunks) {\n        headers['x-total-chunks'] = String(totalChunks);\n      }\n      return headers;\n    }\n\n    async function parseErrorPayload(response) {\n      const text = await response.text();\n      if (!text) return null;\n      try {\n        return JSON.parse(text);\n      } catch {\n        return null;\n      }\n    }\n\n    async function sendChunkWithRetry({\n      backendUrl,\n      jobId,\n      token,\n      signal,\n      chunk,\n      index,\n      totalChunks,\n      maxRetries = 5,\n    }) {\n      if (signal?.aborted) {\n        throw new Error('CANCELED');\n      }\n\n      const url = `${backendUrl}/api/transcripts/jobs/${jobId}/chunks`;\n      const requestOptions = {\n        method: 'PUT',\n        headers: buildChunkHeaders({ token, index, totalChunks }),\n        body: chunk,\n        signal,\n      };\n\n      if (typeof fetchWithRetry !== 'function') {\n        throw new Error('Network utilities unavailable');\n      }\n\n      const response = await fetchWithRetry(url, requestOptions, {\n        maxRetries,\n        timeoutMs: CHUNK_UPLOAD_TIMEOUT_MS,\n        retryableStatuses: [429, 502, 503, 504],\n        retryOnServerError: true,\n        onRetry: (info) => {\n          log.info(\n            `Retrying chunk ${index} in ${info.delayMs}ms (attempt ${info.attempt}/${maxRetries})`,\n          );\n        },\n      });\n\n      if (response.ok) {\n        return;\n      }\n\n      const data = await parseErrorPayload(response);\n      throw new Error(\n        data?.error?.message || data?.error || `Chunk upload failed: ${response.status}`,\n      );\n    }\n\n    async function fetchDirectMediaResponse(mediaUrl, signal) {\n      log.info('Attempting direct media fetch:', mediaUrl);\n      const initialOptions = {\n        method: 'GET',\n        credentials: 'include',\n        redirect: 'manual',\n        signal,\n      };\n      if (typeof fetchWithRetry !== 'function') {\n        throw errors.createErrorWithCode('Network utilities unavailable', 'NOT_AVAILABLE');\n      }\n\n      let response = await fetchWithRetry(\n        mediaUrl,\n        initialOptions,\n        MEDIA_FETCH_MAX_RETRIES,\n        MEDIA_FETCH_TIMEOUT_MS,\n      );\n\n      log.info('Initial response:', response.status, response.type);\n\n      const isRedirect =\n        response.type === 'opaqueredirect' ||\n        response.status === 0 ||\n        (response.status >= 300 && response.status < 400);\n\n      if (isRedirect) {\n        const location = response.headers.get('location');\n        log.info('Redirect detected, location:', location);\n\n        if (location) {\n          if (isSsoRedirect(location)) {\n            throw errors.createErrorWithCode(\n              'Your session has expired. Please refresh the page and log in again.',\n              'SESSION_EXPIRED',\n            );\n          }\n\n          const useCredentials = !isCdnUrl(location);\n          log.info('Following redirect, credentials:', useCredentials);\n\n          const redirectOptions = {\n            method: 'GET',\n            credentials: useCredentials ? 'include' : 'omit',\n            signal,\n          };\n          response = await fetchWithRetry(\n            location,\n            redirectOptions,\n            MEDIA_FETCH_MAX_RETRIES,\n            MEDIA_FETCH_TIMEOUT_MS,\n          );\n        } else {\n          log.info('No location header, falling back to content script');\n          throw errors.createErrorWithCode('CORS_BLOCKED', 'CORS_BLOCKED');\n        }\n      }\n\n      if (response.type === 'opaque') {\n        log.info('Got opaque response, will try content script fallback');\n        throw errors.createErrorWithCode('CORS_BLOCKED', 'CORS_BLOCKED');\n      }\n\n      if (!response.ok) {\n        if (aiUtils?.isAuthStatus?.(response.status)) {\n          throw errors.createErrorWithCode(\n            'Authentication required. Please refresh the page and log in.',\n            'AUTH_REQUIRED',\n          );\n        }\n        throw errors.createErrorWithCode(`HTTP ${response.status}`, 'FETCH_ERROR');\n      }\n\n      log.info('Direct fetch successful');\n      return response;\n    }\n\n    function shouldFallbackToContentScript(error) {\n      return (\n        error?.code === 'CORS_BLOCKED' ||\n        error?.code === 'NOT_AVAILABLE' ||\n        (error?.message &&\n          (error.message.includes('CORS') ||\n            error.message.includes('opaque') ||\n            error.message.includes('Failed to fetch') ||\n            error.message.includes('NetworkError')))\n      );\n    }\n\n    async function uploadViaContentScript({\n      tabId,\n      mediaUrl,\n      jobId,\n      requestId,\n      token,\n      signal,\n      onProgress,\n    }) {\n      let uploadedBytes = 0;\n      let chunkIndex = 0;\n\n      await contentScriptMedia.fetchMediaViaContentScript({\n        tabId,\n        mediaUrl,\n        jobId,\n        requestId,\n        onChunk: async (chunkBytes, index) => {\n          await sendChunkWithRetry({\n            backendUrl: config.getBackendUrl(),\n            jobId,\n            token,\n            signal,\n            chunk: chunkBytes,\n            index,\n          });\n          uploadedBytes += chunkBytes.length;\n          if (onProgress) {\n            onProgress({ bytesUploaded: uploadedBytes, chunkIndex: index });\n          }\n          chunkIndex = index + 1;\n        },\n      });\n\n      return {\n        chunkCount: chunkIndex,\n        totalChunks: chunkIndex,\n        totalBytes: uploadedBytes,\n        usedContentScript: true,\n      };\n    }\n\n    async function streamAndUploadResponse({ response, jobId, token, signal, onProgress }) {\n      if (!response.body || typeof response.body.getReader !== 'function') {\n        throw errors.createErrorWithCode(\n          'Streaming not supported for this media.',\n          'NOT_AVAILABLE',\n        );\n      }\n\n      const totalBytesHeader = response.headers.get('content-length');\n      const totalBytes = totalBytesHeader ? Number(totalBytesHeader) : null;\n      const totalChunks =\n        Number.isFinite(totalBytes) && totalBytes > 0 ? Math.ceil(totalBytes / chunkBytes) : null;\n\n      const reader = response.body.getReader();\n      let pending = new Uint8Array(0);\n      let uploadedBytes = 0;\n      let chunkIndex = 0;\n      const backendUrl = config.getBackendUrl();\n\n      const sendChunk = async (chunk) => {\n        await sendChunkWithRetry({\n          backendUrl,\n          jobId,\n          token,\n          signal,\n          chunk,\n          index: chunkIndex,\n          totalChunks,\n        });\n        chunkIndex += 1;\n      };\n\n      while (true) {\n        const { value, done } = await reader.read();\n        if (done) break;\n        if (!value) continue;\n\n        const combined = new Uint8Array(pending.length + value.length);\n        combined.set(pending);\n        combined.set(value, pending.length);\n        pending = combined;\n\n        while (pending.length >= chunkBytes) {\n          const chunk = pending.slice(0, chunkBytes);\n          pending = pending.slice(chunkBytes);\n          await sendChunk(chunk);\n          uploadedBytes += chunk.length;\n          if (totalBytes) {\n            const percent = Math.round((uploadedBytes / totalBytes) * 100);\n            if (onProgress) {\n              onProgress({ percent });\n            }\n          } else if (onProgress && chunkIndex % 5 === 0) {\n            onProgress({ message: `Uploaded ${chunkIndex} chunks` });\n          }\n        }\n      }\n\n      if (pending.length > 0) {\n        await sendChunk(pending);\n        uploadedBytes += pending.length;\n        if (totalBytes && onProgress) {\n          const percent = Math.round((uploadedBytes / totalBytes) * 100);\n          onProgress({ percent });\n        }\n      }\n\n      return {\n        chunkCount: chunkIndex,\n        totalChunks,\n        totalBytes,\n      };\n    }\n\n    async function uploadMediaInChunks({\n      jobId,\n      mediaUrl,\n      token,\n      signal,\n      onProgress,\n      tabId,\n      requestId,\n    }) {\n      let response;\n      try {\n        response = await fetchDirectMediaResponse(mediaUrl, signal);\n      } catch (error) {\n        if (shouldFallbackToContentScript(error) && tabId) {\n          log.info('Trying content script fallback for media fetch');\n          try {\n            return await uploadViaContentScript({\n              tabId,\n              mediaUrl,\n              jobId,\n              requestId,\n              token,\n              signal,\n              onProgress,\n            });\n          } catch (contentError) {\n            log.error('Content script fallback failed:', contentError);\n            throw errors.createErrorWithCode(\n              contentError?.message || 'Media could not be fetched via content script.',\n              contentError?.code || 'CONTENT_FETCH_ERROR',\n            );\n          }\n        }\n\n        if (error?.name === 'AbortError') throw error;\n        if (error?.code) throw error;\n\n        throw errors.createErrorWithCode(\n          'Media could not be fetched due to browser restrictions (CORS/opaque response) or network errors.',\n          'NOT_AVAILABLE',\n        );\n      }\n\n      return streamAndUploadResponse({\n        response,\n        jobId,\n        token,\n        signal,\n        onProgress,\n      });\n    }\n\n    return {\n      uploadMediaInChunks,\n    };\n  }\n\n  transcripts.aiTranscriptionUpload = {\n    createAiTranscriptionUploadService,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\aiUtils.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 59,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 59,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 59,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 59,
        "endColumn": 44
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 69,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 69,
        "endColumn": 24
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 36.",
        "line": 72,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 72,
        "endColumn": 38
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 83,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 83,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const transcripts = registry.transcripts || (registry.transcripts = {});\n\n  const TRACKING_QUERY_KEYS = new Set([\n    'utm_source',\n    'utm_medium',\n    'utm_campaign',\n    'utm_term',\n    'utm_content',\n    'utm_id',\n    'utm_name',\n    'gclid',\n    'dclid',\n    'fbclid',\n    'msclkid',\n    'yclid',\n    'igshid',\n    '_ga',\n    '_gid',\n    '_gac',\n    '_gl',\n    'mc_cid',\n    'mc_eid',\n    'hsa_acc',\n    'hsa_cam',\n    'hsa_grp',\n    'hsa_ad',\n    'hsa_src',\n    'hsa_tgt',\n    'hsa_kw',\n    'hsa_mt',\n    'hsa_net',\n    'hsa_ver',\n  ]);\n\n  function normalizeMediaUrl(mediaUrl) {\n    if (!mediaUrl) return '';\n    try {\n      const url = new URL(mediaUrl);\n      url.hash = '';\n      const params = url.searchParams;\n      for (const key of Array.from(params.keys())) {\n        const lowerKey = key.toLowerCase();\n        if (lowerKey.startsWith('utm_') || TRACKING_QUERY_KEYS.has(lowerKey)) {\n          params.delete(key);\n        }\n      }\n      const nextSearch = params.toString();\n      url.search = nextSearch ? `?${nextSearch}` : '';\n      return url.toString();\n    } catch {\n      return mediaUrl;\n    }\n  }\n\n  function isAuthStatus(status) {\n    return status === 401 || status === 403;\n  }\n\n  function isBlobUrl(mediaUrl) {\n    return typeof mediaUrl === 'string' && mediaUrl.startsWith('blob:');\n  }\n\n  function fallbackHash(value) {\n    let hash = 0;\n    for (let i = 0; i < value.length; i += 1) {\n      hash = (hash << 5) - hash + value.charCodeAt(i);\n      hash |= 0;\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  async function hashStringSha256(value) {\n    if (typeof crypto === 'undefined' || !crypto.subtle) {\n      return fallbackHash(value);\n    }\n    const encoded = new TextEncoder().encode(value);\n    const buffer = await crypto.subtle.digest('SHA-256', encoded);\n    const bytes = new Uint8Array(buffer);\n    return Array.from(bytes)\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  transcripts.aiUtils = {\n    TRACKING_QUERY_KEYS,\n    normalizeMediaUrl,\n    isAuthStatus,\n    isBlobUrl,\n    fallbackHash,\n    hashStringSha256,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\contentScriptMedia.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createContentScriptMediaService' has too many lines (81). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 104,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const transcripts = registry.transcripts || (registry.transcripts = {});\n\n  function createContentScriptMediaService({ chromeClient, errors, log }) {\n    const pendingMediaChunks = new Map();\n\n    function base64ToArrayBuffer(base64) {\n      const binary = atob(base64);\n      const len = binary.length;\n      const bytes = new Uint8Array(len);\n      for (let i = 0; i < len; i++) {\n        bytes[i] = binary.charCodeAt(i);\n      }\n      return bytes;\n    }\n\n    async function fetchMediaViaContentScript({ tabId, mediaUrl, jobId, requestId, onChunk }) {\n      log.info('Requesting content script to fetch media:', mediaUrl);\n\n      let resolveComplete;\n      let rejectComplete;\n      const completePromise = new Promise((resolve, reject) => {\n        resolveComplete = resolve;\n        rejectComplete = reject;\n      });\n\n      pendingMediaChunks.set(requestId, {\n        onChunk,\n        resolve: resolveComplete,\n        reject: rejectComplete,\n      });\n\n      try {\n        const result = await chromeClient.sendTabMessage(tabId, {\n          type: 'FETCH_MEDIA_FOR_TRANSCRIPTION',\n          payload: { mediaUrl, jobId, requestId },\n        });\n\n        log.info('Content script fetch result:', result);\n\n        if (!result || !result.success) {\n          throw errors.createErrorWithCode(\n            result?.error || 'Content script failed to fetch media',\n            result?.errorCode || 'CONTENT_FETCH_ERROR',\n          );\n        }\n\n        log.info('Waiting for all chunks to be uploaded...');\n        await completePromise;\n        log.info('All chunks uploaded successfully');\n\n        return result;\n      } catch (error) {\n        log.error('Content script media fetch error:', error);\n        throw error;\n      } finally {\n        pendingMediaChunks.delete(requestId);\n      }\n    }\n\n    async function handleMediaChunkMessage(message) {\n      const { requestId, chunkIndex, chunkData, chunkSize, isLast } = message.payload || {};\n\n      const handler = pendingMediaChunks.get(requestId);\n      if (!handler) {\n        log.warn('Received chunk for unknown request:', requestId);\n        return { received: false, error: 'UNKNOWN_REQUEST' };\n      }\n\n      log.info('Received chunk:', chunkIndex, 'size:', chunkSize, 'isLast:', isLast);\n\n      let chunkBytes = null;\n      if (chunkData instanceof ArrayBuffer) {\n        chunkBytes = new Uint8Array(chunkData);\n      } else if (ArrayBuffer.isView(chunkData)) {\n        chunkBytes = new Uint8Array(chunkData.buffer, chunkData.byteOffset, chunkData.byteLength);\n      } else if (typeof chunkData === 'string') {\n        chunkBytes = base64ToArrayBuffer(chunkData);\n      }\n\n      if (chunkSize > 0 && (!chunkBytes || chunkBytes.length === 0)) {\n        const error = new Error('Missing media chunk payload');\n        handler.reject(error);\n        throw error;\n      }\n\n      if (chunkBytes && chunkBytes.length > 0) {\n        await handler.onChunk(chunkBytes, chunkIndex, isLast);\n      }\n\n      if (isLast) {\n        handler.resolve({ success: true });\n      }\n\n      return { received: true };\n    }\n\n    return {\n      fetchMediaViaContentScript,\n      handleMediaChunkMessage,\n    };\n  }\n\n  transcripts.contentScriptMedia = {\n    createContentScriptMediaService,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\extensionFetcher.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\extraction.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createTranscriptExtractionService' has too many lines (140). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 154,
        "endColumn": 4
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'detectEcho360Videos' has too many lines (79). Maximum allowed is 50.",
        "line": 66,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 148,
        "endColumn": 6
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'detectEcho360Videos' has too many statements (25). Maximum allowed is 20.",
        "line": 66,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 148,
        "endColumn": 6
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'detectEcho360Videos' has a complexity of 17. Maximum allowed is 15.",
        "line": 66,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 66,
        "endColumn": 39
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const transcripts = registry.transcripts || (registry.transcripts = {});\n\n  function createTranscriptExtractionService({\n    transcriptProviders,\n    transcriptRegistry,\n    createExtensionFetcher,\n    log,\n  }) {\n    async function extractTranscript(video) {\n      log.info('handleTranscriptExtraction called');\n      if (!video || !video.provider) {\n        return {\n          success: false,\n          error: 'No video provider specified',\n          errorCode: 'INVALID_VIDEO',\n          aiTranscriptionAvailable: true,\n        };\n      }\n\n      if (!transcriptProviders) {\n        return {\n          success: false,\n          error: 'Transcript providers are not available',\n          errorCode: 'NOT_AVAILABLE',\n          aiTranscriptionAvailable: true,\n        };\n      }\n\n      transcriptRegistry.ensureProvidersRegistered();\n      const provider = transcriptRegistry.getProviderForVideo(video);\n      if (!provider || typeof provider.extractTranscript !== 'function') {\n        return {\n          success: false,\n          error: `Unsupported video provider: ${video.provider}`,\n          errorCode: 'NOT_AVAILABLE',\n          aiTranscriptionAvailable: true,\n        };\n      }\n\n      try {\n        const fetcher = createExtensionFetcher();\n        const result = await provider.extractTranscript(video, fetcher);\n        log.info('Transcript extraction completed', {\n          provider: provider.provider,\n          success: result.success,\n          errorCode: result.errorCode,\n          hasTranscript: !!result.transcript,\n          transcriptSegments: result.transcript?.segments?.length,\n        });\n        return result;\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        log.error('Transcript extraction failed:', message);\n        return {\n          success: false,\n          error: message || 'Failed to extract transcript',\n          errorCode: 'NOT_AVAILABLE',\n          aiTranscriptionAvailable: true,\n        };\n      }\n    }\n\n    async function detectEcho360Videos(context) {\n      log.info('handleEcho360VideoDetection called', {\n        hasContext: !!context,\n        pageUrl: context?.pageUrl,\n        iframeCount: Array.isArray(context?.iframes) ? context.iframes.length : 0,\n        iframes: context?.iframes,\n      });\n\n      if (!context || !context.pageUrl) {\n        log.warn('No detection context provided for Echo360');\n        return {\n          success: false,\n          error: 'No detection context provided',\n        };\n      }\n\n      if (transcriptProviders && transcriptProviders.Echo360Provider) {\n        try {\n          const provider = new transcriptProviders.Echo360Provider();\n          const fetcher = createExtensionFetcher();\n          const normalizedContext = {\n            pageUrl: context.pageUrl,\n            iframes: Array.isArray(context.iframes) ? context.iframes : [],\n          };\n          log.info('Echo360 provider created, starting detection', {\n            pageUrl: normalizedContext.pageUrl,\n            iframeCount: normalizedContext.iframes.length,\n            hasDetectVideosAsync: typeof provider.detectVideosAsync === 'function',\n            hasDetectVideosSync: typeof provider.detectVideosSync === 'function',\n          });\n\n          if (typeof provider.detectVideosAsync === 'function') {\n            log.info('Using async detection');\n            const videos = await provider.detectVideosAsync(normalizedContext, fetcher);\n            log.info('Echo360 async detection completed', {\n              videoCount: videos.length,\n              videos: videos.map((v) => ({\n                id: v.id,\n                provider: v.provider,\n                title: v.title,\n                lessonId: v.echoLessonId,\n                mediaId: v.echoMediaId,\n                baseUrl: v.echoBaseUrl,\n              })),\n            });\n            return { success: true, videos };\n          }\n          if (typeof provider.detectVideosSync === 'function') {\n            log.info('Using sync detection');\n            const videos = provider.detectVideosSync(normalizedContext);\n            log.info('Echo360 sync detection completed', {\n              videoCount: videos.length,\n              videos: videos.map((v) => ({\n                id: v.id,\n                provider: v.provider,\n                title: v.title,\n                lessonId: v.echoLessonId,\n                mediaId: v.echoMediaId,\n                baseUrl: v.echoBaseUrl,\n              })),\n            });\n            return { success: true, videos };\n          }\n          log.warn('Echo360 provider missing detection methods');\n        } catch (error) {\n          log.error('Echo360 detection failed', {\n            error: error?.message,\n            stack: error?.stack,\n            errorObject: error,\n          });\n          return {\n            success: false,\n            error: error?.message || 'Echo360 detection failed',\n          };\n        }\n      }\n\n      log.warn('Echo360 provider is not available');\n      return {\n        success: false,\n        error: 'Echo360 provider is not available',\n      };\n    }\n\n    return {\n      extractTranscript,\n      detectEcho360Videos,\n    };\n  }\n\n  transcripts.extraction = {\n    createTranscriptExtractionService,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\panoptoMedia.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createPanoptoMediaService' has too many lines (105). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 122,
        "endColumn": 4
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'fetchPanoptoMediaUrl' has too many lines (58). Maximum allowed is 50.",
        "line": 55,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 117,
        "endColumn": 6
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'fetchPanoptoMediaUrl' has a complexity of 17. Maximum allowed is 15.",
        "line": 55,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 55,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const transcripts = registry.transcripts || (registry.transcripts = {});\n\n  function createPanoptoMediaService({\n    transcriptProviders,\n    panoptoResolver,\n    createExtensionFetcher,\n    log,\n  }) {\n    const PanoptoMediaResolver = panoptoResolver?.PanoptoMediaResolver;\n\n    function buildFailure(error, errorCode) {\n      return {\n        success: false,\n        error,\n        errorCode,\n      };\n    }\n\n    async function resolvePanoptoInfo(video) {\n      if (video?.panoptoTenant && video?.id) {\n        return { info: { tenant: video.panoptoTenant, deliveryId: video.id } };\n      }\n\n      if (video?.embedUrl && typeof transcriptProviders?.extractPanoptoInfo === 'function') {\n        const info = transcriptProviders.extractPanoptoInfo(video.embedUrl);\n        if (info) {\n          return { info };\n        }\n      }\n\n      if (\n        video?.embedUrl &&\n        typeof transcriptProviders?.resolvePanoptoInfoFromWrapperUrl === 'function'\n      ) {\n        const fetcher = createExtensionFetcher();\n        const resolved = await transcriptProviders.resolvePanoptoInfoFromWrapperUrl(\n          video.embedUrl,\n          fetcher,\n        );\n        if (resolved.authRequired) {\n          return {\n            error: 'Authentication required. Please log in to Panopto.',\n            errorCode: 'AUTH_REQUIRED',\n          };\n        }\n        return { info: resolved.info };\n      }\n\n      return { info: null };\n    }\n\n    async function fetchPanoptoMediaUrl(video, options = {}) {\n      log.info('Fetching Panopto media URL for AI transcription');\n      log.info('Video:', {\n        id: video?.id,\n        provider: video?.provider,\n        embedUrl: video?.embedUrl,\n        panoptoTenant: video?.panoptoTenant,\n      });\n\n      if (video?.provider !== 'panopto') {\n        return buildFailure('Not a Panopto video');\n      }\n\n      try {\n        const tabId = options?.tabId || null;\n        const resolution = await resolvePanoptoInfo(video);\n        if (resolution.error) {\n          return buildFailure(resolution.error, resolution.errorCode);\n        }\n        const resolvedInfo = resolution.info;\n\n        if (!resolvedInfo) {\n          return buildFailure(\n            'Could not resolve this Panopto link. Open the video once and try again.',\n            'NOT_AVAILABLE',\n          );\n        }\n\n        if (\n          !PanoptoMediaResolver ||\n          typeof transcriptProviders?.buildPanoptoEmbedUrl !== 'function'\n        ) {\n          return buildFailure('Panopto helpers are not available.', 'NOT_AVAILABLE');\n        }\n\n        const resolvedEmbedUrl = transcriptProviders.buildPanoptoEmbedUrl(\n          resolvedInfo.tenant,\n          resolvedInfo.deliveryId,\n        );\n        const resolverResult = await PanoptoMediaResolver.resolve({\n          tenant: resolvedInfo.tenant,\n          deliveryId: resolvedInfo.deliveryId,\n          embedUrl: resolvedEmbedUrl,\n          tabId,\n        });\n        log.info('Panopto media URL fetch (v2) result:', resolverResult.ok);\n        return {\n          success: resolverResult.ok,\n          mediaUrl: resolverResult.mediaUrl,\n          mime: resolverResult.mime,\n          method: resolverResult.method,\n          error: resolverResult.message,\n          errorCode: resolverResult.errorCode,\n          debug: resolverResult.debug,\n        };\n      } catch (error) {\n        log.error('Error fetching Panopto media URL:', error);\n        return {\n          success: false,\n          error: error.message || 'Failed to fetch media URL',\n        };\n      }\n    }\n\n    return {\n      fetchPanoptoMediaUrl,\n    };\n  }\n\n  transcripts.panoptoMedia = {\n    createPanoptoMediaService,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\transcripts\\registry.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createTranscriptRegistry' has too many lines (57). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 70,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n  const transcripts = registry.transcripts || (registry.transcripts = {});\n\n  function createTranscriptRegistry({ transcriptProviders, log }) {\n    function getRegistry() {\n      if (!transcriptProviders || typeof transcriptProviders.getProviderRegistry !== 'function') {\n        return null;\n      }\n      return transcriptProviders.getProviderRegistry();\n    }\n\n    function resolveRegister(registryInstance) {\n      if (!registryInstance) return null;\n      if (typeof transcriptProviders?.registerProvider === 'function') {\n        return (provider) => transcriptProviders.registerProvider(provider);\n      }\n      if (typeof registryInstance.register === 'function') {\n        return (provider) => registryInstance.register(provider);\n      }\n      return null;\n    }\n\n    function ensureProvidersRegistered() {\n      const registryInstance = getRegistry();\n      if (!registryInstance) return;\n\n      const register = resolveRegister(registryInstance);\n      if (!register) return;\n\n      const existingProviders =\n        typeof registryInstance.getAll === 'function' ? registryInstance.getAll() : [];\n      const existingNames = new Set(\n        existingProviders.map((provider) => provider?.provider).filter(Boolean),\n      );\n\n      const providerClasses = [\n        transcriptProviders?.PanoptoProvider,\n        transcriptProviders?.Echo360Provider,\n        transcriptProviders?.Html5Provider,\n      ];\n\n      providerClasses.forEach((Provider) => {\n        if (typeof Provider !== 'function') return;\n        const instance = new Provider();\n        if (instance?.provider && existingNames.has(instance.provider)) {\n          return;\n        }\n        register(instance);\n        if (instance?.provider) {\n          existingNames.add(instance.provider);\n        }\n      });\n    }\n\n    function getProviderForVideo(video) {\n      const registryInstance = getRegistry();\n      if (!registryInstance || typeof registryInstance.getAll !== 'function') {\n        return null;\n      }\n      const providers = registryInstance.getAll();\n      return providers.find((provider) => provider.provider === video.provider) || null;\n    }\n\n    return {\n      ensureProvidersRegistered,\n      getProviderForVideo,\n    };\n  }\n\n  transcripts.registry = {\n    createTranscriptRegistry,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\background\\validators.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createFallbackValidators' has too many lines (80). Maximum allowed is 50.",
        "line": 15,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 94,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const registry = root.LockInBackground || (root.LockInBackground = {});\n\n  function getMessageType(message) {\n    if (!message || typeof message !== 'object') return undefined;\n    return message.type || message.action;\n  }\n\n  function ensureObject(value) {\n    if (value && typeof value === 'object') return value;\n    return {};\n  }\n\n  function createFallbackValidators() {\n    return {\n      getTabId: () => ({ ok: true }),\n      GET_TAB_ID: () => ({ ok: true }),\n      getSession: () => ({ ok: true }),\n      GET_SESSION: () => ({ ok: true }),\n      saveSession: (message) => ({\n        ok: true,\n        payload: {\n          sessionData: message?.sessionData ?? message?.payload?.sessionData,\n        },\n      }),\n      SAVE_SESSION: (message) => ({\n        ok: true,\n        payload: {\n          sessionData: message?.sessionData ?? message?.payload?.sessionData,\n        },\n      }),\n      clearSession: () => ({ ok: true }),\n      CLEAR_SESSION: () => ({ ok: true }),\n      getSettings: () => ({ ok: true }),\n      GET_SETTINGS: () => ({ ok: true }),\n      saveSettings: (message) => ({\n        ok: true,\n        payload: {\n          settings: ensureObject(message?.settings ?? message?.payload?.settings),\n        },\n      }),\n      UPDATE_SETTINGS: (message) => ({\n        ok: true,\n        payload: {\n          settings: ensureObject(message?.settings ?? message?.payload?.settings),\n        },\n      }),\n      extractTranscript: (message) => ({\n        ok: true,\n        payload: {\n          video: message?.video ?? message?.payload?.video,\n        },\n      }),\n      EXTRACT_TRANSCRIPT: (message) => ({\n        ok: true,\n        payload: {\n          video: message?.video ?? message?.payload?.video,\n        },\n      }),\n      DETECT_ECHO360_VIDEOS: (message) => ({\n        ok: true,\n        payload: {\n          context: message?.context ?? message?.payload?.context,\n        },\n      }),\n      FETCH_PANOPTO_MEDIA_URL: (message) => ({\n        ok: true,\n        payload: {\n          video: message?.video ?? message?.payload?.video,\n        },\n      }),\n      TRANSCRIBE_MEDIA_AI: (message) => ({\n        ok: true,\n        payload: ensureObject(message?.payload ?? message),\n      }),\n      MEDIA_CHUNK: (message) => ({\n        ok: true,\n        payload: ensureObject(message?.payload),\n      }),\n      LIST_ACTIVE_TRANSCRIPT_JOBS: (message) => ({\n        ok: true,\n        payload: {\n          token: message?.token ?? message?.payload?.token,\n        },\n      }),\n      CANCEL_ALL_ACTIVE_TRANSCRIPT_JOBS: (message) => ({\n        ok: true,\n        payload: {\n          token: message?.token ?? message?.payload?.token,\n        },\n      }),\n    };\n  }\n\n  function createMessageValidators() {\n    const schemaRegistry = root.LockInMessageSchemas;\n    if (schemaRegistry?.createMessageValidators) {\n      return schemaRegistry.createMessageValidators();\n    }\n    return createFallbackValidators();\n  }\n\n  function createRuntimeValidators() {\n    const schemaRegistry = root.LockInMessageSchemas;\n    if (schemaRegistry?.createRuntimeValidators) {\n      return schemaRegistry.createRuntimeValidators();\n    }\n    return {\n      validateSettings: (value) => ({ ok: true, value: value || {} }),\n      validateSession: (value) => ({ ok: true, value: value || { chatHistory: [] } }),\n      validateAuthSession: (value) => ({\n        ok: true,\n        value: value || {\n          accessToken: '',\n          refreshToken: '',\n          expiresAt: 0,\n          tokenType: 'bearer',\n          user: null,\n        },\n      }),\n      validateTranscriptJobResponse: (value) => ({\n        ok: true,\n        value: value || { success: false },\n      }),\n      validateTranscriptJob: (value) => ({\n        ok: true,\n        value: value || {},\n      }),\n      validateTranscriptJobListResponse: (value) => ({\n        ok: true,\n        value: value || { success: false, jobs: [] },\n      }),\n      validateTranscriptCancelAllResponse: (value) => ({\n        ok: true,\n        value: value || { success: false, canceledIds: [] },\n      }),\n    };\n  }\n\n  registry.validators = {\n    getMessageType,\n    createMessageValidators,\n    createRuntimeValidators,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\config.js",
    "messages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function has too many statements (23). Maximum allowed is 20.",
        "line": 4,
        "column": 4,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 76,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(function() {\n  \"use strict\";\n  const __vite_import_meta_env__ = {};\n  (function() {\n    const root = typeof window !== \"undefined\" ? window : self;\n    if (root.LOCKIN_CONFIG) {\n      return;\n    }\n    function getAppEnv() {\n      return (__vite_import_meta_env__[\"VITE_APP_ENV\"] || \"development\").toLowerCase();\n    }\n    function buildConfigByEnv() {\n      return {\n        development: {\n          url: \"http://127.0.0.1:54321\",\n          anonKey: \"eyJhbGciOiJFUzI1NiIsImtpZCI6ImI4MTI2OWYxLTIxZDgtNGYyZS1iNzE5LWMyMjQwYTg0MGQ5MCIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjIwODUzMTI3OTJ9.-08bHUdWcD_YxXv-K_RewsP3SeoaqIKCMGKCCRKbgau4GRa_WKXKgSO0fv8tSf9Ly4LCW7FU7kKFkSfNz4CtFQ\",\n          environment: \"development\",\n          backendUrl: \"http://localhost:3000\"\n        },\n        production: {\n          url: \"https://example-prod.supabase.co\",\n          anonKey: __vite_import_meta_env__[\"VITE_SUPABASE_ANON_KEY_PROD\"] || \"\",\n          environment: \"production\",\n          backendUrl: \"https://example-backend.example.com\"\n        }\n      };\n    }\n    function collectMissingEnvVars(envConfig, isProd) {\n      const missing = [];\n      if (!envConfig.anonKey) {\n        missing.push(isProd ? \"VITE_SUPABASE_ANON_KEY_PROD\" : \"VITE_SUPABASE_ANON_KEY_DEV\");\n      }\n      return missing;\n    }\n    function logMissingEnvVars(missing) {\n      if (missing.length > 0 && typeof console !== \"undefined\") {\n        console.warn(\"[Lock-in] Missing extension env vars:\", missing);\n      }\n    }\n    function logDevConfig(env, isProd, config) {\n      if (!isProd && typeof console !== \"undefined\") {\n        console.log(\"[Lock-in] Extension config loaded:\", {\n          environment: env,\n          supabase: config.SUPABASE_ENVIRONMENT,\n          backendUrl: config.BACKEND_URL\n        });\n      }\n    }\n    const appEnv = getAppEnv();\n    const isProduction = appEnv === \"production\";\n    const configByEnv = buildConfigByEnv();\n    const supabaseConfig = isProduction ? configByEnv.production : configByEnv.development;\n    const missingEnvVars = collectMissingEnvVars(supabaseConfig, isProduction);\n    const runtimeConfig = {\n      APP_ENV: appEnv,\n      IS_PRODUCTION: isProduction,\n      BACKEND_URL: supabaseConfig.backendUrl,\n      SUPABASE_URL: supabaseConfig.url,\n      SUPABASE_ANON_KEY: supabaseConfig.anonKey,\n      SUPABASE_ENVIRONMENT: supabaseConfig.environment,\n      SESSION_STORAGE_KEY: \"lockinSupabaseSession\",\n      TOKEN_EXPIRY_BUFFER_MS: 6e4,\n      DEBUG_PANOPTO_RESOLVER: !isProduction\n    };\n    const debugValue = __vite_import_meta_env__[\"VITE_DEBUG\"];\n    if (debugValue) {\n      runtimeConfig.DEBUG = debugValue;\n    }\n    const sentryDsn = __vite_import_meta_env__[\"VITE_SENTRY_DSN\"];\n    if (sentryDsn) {\n      runtimeConfig.SENTRY_DSN = sentryDsn;\n    }\n    root.LOCKIN_CONFIG = runtimeConfig;\n    logMissingEnvVars(missingEnvVars);\n    logDevConfig(appEnv, isProduction, runtimeConfig);\n  })();\n})();\n//# sourceMappingURL=config.js.map\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\contentScript-react.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 38,
        "column": 17,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 38,
        "endColumn": 19
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'bootstrap' has too many lines (106). Maximum allowed is 50.",
        "line": 46,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 174,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (26). Maximum allowed is 20.",
        "line": 78,
        "column": 23,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 167,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Lock-in Content Script (React) - Thin orchestrator\n *\n * Responsibilities:\n * - Ensure UI bundle and helpers are loaded\n * - Resolve site adapter and page context\n * - Wire the state store, session manager, and sidebar host\n * - Bind user interactions (Escape close)\n */\n\n// ============================================================================\n// Sentry Initialization (must be first)\n// ============================================================================\n\n// Initialize Sentry for error tracking (content script surface)\n// LockInSentry is loaded via dist/libs/sentry.js before this script (see manifest.json)\nif (typeof window !== 'undefined' && window.LockInSentry) {\n  window.LockInSentry.initSentry('content');\n}\n\nconst Runtime = window.LockInContent || {};\nconst Logger = Runtime.logger ||\n  window.LockInLogger || {\n    debug: () => {},\n    info: () => {},\n    warn: console.warn,\n    error: console.error,\n  };\nconst Storage = Runtime.storage || window.LockInStorage || null;\nconst Messaging = Runtime.messaging || window.LockInMessaging || null;\nconst ContentHelpers = Runtime || {};\n\nlet bootstrapPromise = null;\nlet hasBootstrapped = false;\n\nasync function waitForUIBundle(attempt = 0) {\n  if (window.LockInUI && window.LockInUI.createLockInSidebar) return true;\n  if (attempt > 50) {\n    Logger.error('LockInUI not available after waiting');\n    return false;\n  }\n  await new Promise((resolve) => setTimeout(resolve, 100));\n  return waitForUIBundle(attempt + 1);\n}\n\nasync function bootstrap() {\n  if (hasBootstrapped) {\n    Logger.debug('Skipping bootstrap: already initialized');\n    return;\n  }\n\n  if (bootstrapPromise) {\n    return bootstrapPromise;\n  }\n\n  Logger.debug('Starting content script bootstrap');\n\n  const {\n    resolveAdapterContext,\n    createStateStore,\n    createSidebarHost,\n    createSessionManager,\n    createInteractionController,\n  } = ContentHelpers;\n\n  if (\n    !resolveAdapterContext ||\n    !createStateStore ||\n    !createSidebarHost ||\n    !createSessionManager ||\n    !createInteractionController\n  ) {\n    Logger.error('Content helpers missing on window.LockInContent');\n    bootstrapPromise = null;\n    return;\n  }\n\n  bootstrapPromise = (async () => {\n    if (!(await waitForUIBundle())) return;\n\n    const apiClient = window.LockInAPI;\n    if (!apiClient) {\n      Logger.error('API client not available');\n      return;\n    }\n\n    // Validate API client has required methods\n    if (typeof apiClient.toggleNoteStar !== 'function') {\n      Logger.error(\n        'API client is missing toggleNoteStar method. Available methods:',\n        Object.keys(apiClient),\n      );\n      // Continue anyway - the error will be caught by the notes service\n    }\n\n    const { adapter, pageContext } = resolveAdapterContext(Logger);\n    const stateStore = createStateStore({ Storage, Logger });\n    const sidebarHost = createSidebarHost({ Logger, Storage });\n    const sessionManager = createSessionManager({\n      Messaging,\n      Logger,\n      stateStore,\n      origin: window.location.origin,\n    });\n\n    const updateSidebarFromState = (snapshot) => {\n      sidebarHost.updatePropsFromState(snapshot);\n    };\n\n    stateStore.subscribe(updateSidebarFromState);\n    stateStore.startSync();\n\n    const handleSidebarToggle = async () => {\n      const snapshot = stateStore.getSnapshot();\n      await stateStore.setSidebarOpen(!snapshot.isSidebarOpen);\n    };\n\n    const initialState = await stateStore.loadInitial();\n    sidebarHost.renderSidebar({\n      apiClient,\n      adapter,\n      pageContext,\n      state: initialState,\n      onToggle: handleSidebarToggle,\n      onClearPrefill: stateStore.clearPendingPrefill,\n    });\n\n    await sessionManager.getTabId();\n    await sessionManager.restoreSession();\n\n    const closeSidebar = async () => {\n      const snapshot = stateStore.getSnapshot();\n      if (snapshot.isSidebarOpen) {\n        await stateStore.setSidebarOpen(false);\n      }\n    };\n\n    const interactionController = createInteractionController({\n      stateStore,\n      onCloseSidebar: closeSidebar,\n      logger: Logger,\n    });\n\n    interactionController.bind();\n\n    if (Messaging && typeof Messaging.onMessage === 'function') {\n      Messaging.onMessage((message) => {\n        if (message?.type === 'PREFILL_CHAT_INPUT') {\n          const text = typeof message.payload?.text === 'string' ? message.payload.text : '';\n          if (!text.trim()) return undefined;\n          stateStore.setPendingPrefill(text);\n          stateStore.setActiveTab('chat');\n          if (!stateStore.getSnapshot().isSidebarOpen) {\n            stateStore.setSidebarOpen(true).catch((error) => {\n              Logger.warn('Failed to open sidebar for prefill:', error);\n            });\n          }\n        }\n        return undefined;\n      });\n    }\n\n    // Set up message handler for media fetch requests (for AI transcription)\n    setupMediaFetchHandler();\n\n    hasBootstrapped = true;\n  })();\n\n  try {\n    await bootstrapPromise;\n  } finally {\n    bootstrapPromise = null;\n  }\n}\n\n/**\n * Set up handler for FETCH_MEDIA_FOR_TRANSCRIPTION requests from background script.\n * This enables the content script to fetch authenticated media that may be blocked\n * by CORS when fetched from the background script.\n */\nfunction setupMediaFetchHandler() {\n  if (!Messaging || typeof Messaging.onMessage !== 'function') {\n    Logger.warn('[Lock-in] Messaging not available for media fetch handler');\n    return;\n  }\n\n  const MediaFetcher = window.LockInMediaFetcher;\n  if (!MediaFetcher) {\n    Logger.warn('[Lock-in] MediaFetcher not available');\n    return;\n  }\n\n  Messaging.onMessage(async (message, sender) => {\n    if (!message || typeof message !== 'object') return;\n\n    if (message.type === 'FETCH_MEDIA_FOR_TRANSCRIPTION') {\n      Logger.debug('[Lock-in] Received FETCH_MEDIA_FOR_TRANSCRIPTION request');\n      const { mediaUrl, jobId, requestId } = message.payload || {};\n\n      if (!mediaUrl || !jobId || !requestId) {\n        return { success: false, error: 'Missing required parameters' };\n      }\n\n      try {\n        const result = await MediaFetcher.handleMediaFetchRequest(\n          { mediaUrl, jobId, requestId },\n          async (chunkMessage) => {\n            // Send each chunk to the background script\n            await Messaging.sendToBackground(chunkMessage);\n          },\n        );\n        return result;\n      } catch (error) {\n        Logger.error('[Lock-in] Media fetch error:', error);\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        };\n      }\n    }\n\n    // Return undefined for unhandled messages\n    return undefined;\n  });\n\n  Logger.debug('[Lock-in] Media fetch handler registered');\n}\n\nfunction safeInit() {\n  if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id) {\n    bootstrap();\n  } else {\n    Logger.warn('Chrome extension API not available');\n  }\n}\n\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', safeInit);\n} else {\n  safeInit();\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\content\\__tests__\\stateStore.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createStateStore' has too many lines (244). Maximum allowed is 50.",
        "line": 11,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 290,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'createStateStore' has too many statements (35). Maximum allowed is 20.",
        "line": 11,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 290,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (240). Maximum allowed is 50.",
        "line": 292,
        "column": 24,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 608,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 42.",
        "line": 429,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 429,
        "endColumn": 38
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 456,
        "column": 58,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 456,
        "endColumn": 60
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 123.",
        "line": 462,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 462,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for stateStore\n *\n * Tests state management, persistence, and subscription functionality.\n */\n\nimport { describe, it, expect, beforeEach, vi } from 'vitest';\n\n// Mock the stateStore module by creating a testable version\n// Since stateStore is an IIFE, we'll test the factory function directly\nfunction createStateStore({ Storage, Logger }) {\n  const storage = Storage;\n  const DEFAULT_MODE = 'explain';\n  const DEFAULT_PREFS = {\n    preferredLanguage: 'en',\n  };\n\n  const log = Logger || { warn: console.warn };\n  const keys = (storage && storage.STORAGE_KEYS) || {};\n  const SIDEBAR_OPEN_KEY = keys.SIDEBAR_IS_OPEN || 'lockin_sidebar_isOpen';\n  const SIDEBAR_ACTIVE_TAB_KEY = keys.SIDEBAR_ACTIVE_TAB || 'lockin_sidebar_activeTab';\n  const CHAT_ID_STORAGE_KEY = keys.CURRENT_CHAT_ID || 'lockinCurrentChatId';\n  const MODE_KEY = keys.ACTIVE_MODE || 'lockinActiveMode';\n  const MODE_PREF_KEY = keys.MODE_PREFERENCE || 'modePreference';\n  const DEFAULT_MODE_KEY = keys.DEFAULT_MODE || 'defaultMode';\n  const LAST_USED_MODE_KEY = keys.LAST_USED_MODE || 'lastUsedMode';\n  const HIGHLIGHTING_KEY = keys.HIGHLIGHTING_ENABLED || 'highlightingEnabled';\n\n  const state = {\n    highlightingEnabled: true,\n    currentMode: DEFAULT_MODE,\n    isSidebarOpen: false,\n    pendingPrefill: '',\n    currentChatId: null,\n    currentActiveTab: 'chat',\n    sessionPreferences: { ...DEFAULT_PREFS },\n  };\n\n  const subscribers = new Set();\n  let unsubscribeStorage = null;\n\n  function getSnapshot() {\n    return { ...state };\n  }\n\n  function notify() {\n    const snapshot = getSnapshot();\n    subscribers.forEach((cb) => cb(snapshot));\n  }\n\n  function subscribe(callback) {\n    subscribers.add(callback);\n    return () => subscribers.delete(callback);\n  }\n\n  async function loadInitial() {\n    if (storage) {\n      try {\n        const data = await storage.get([\n          HIGHLIGHTING_KEY,\n          SIDEBAR_OPEN_KEY,\n          SIDEBAR_ACTIVE_TAB_KEY,\n        ]);\n        state.highlightingEnabled = data[HIGHLIGHTING_KEY] !== false;\n        if (typeof data[SIDEBAR_OPEN_KEY] === 'boolean') {\n          state.isSidebarOpen = data[SIDEBAR_OPEN_KEY];\n        }\n        if (typeof data[SIDEBAR_ACTIVE_TAB_KEY] === 'string') {\n          state.currentActiveTab = data[SIDEBAR_ACTIVE_TAB_KEY];\n        }\n      } catch (error) {\n        log.warn('Failed to load toggle state:', error);\n      }\n\n      await loadMode();\n      await loadChatId();\n    }\n\n    notify();\n    return getSnapshot();\n  }\n\n  async function loadMode() {\n    if (!storage) return state.currentMode;\n    try {\n      const data = await storage.get(MODE_KEY);\n      if (data[MODE_KEY]) {\n        state.currentMode = data[MODE_KEY];\n      }\n    } catch (error) {\n      log.warn('Failed to load mode:', error);\n    }\n    return state.currentMode;\n  }\n\n  async function determineDefaultMode() {\n    if (!storage) {\n      state.currentMode = DEFAULT_MODE;\n      notify();\n      return state.currentMode;\n    }\n\n    try {\n      const data = await storage.get([\n        MODE_PREF_KEY,\n        DEFAULT_MODE_KEY,\n        LAST_USED_MODE_KEY,\n        MODE_KEY,\n      ]);\n\n      if (data[MODE_KEY]) {\n        state.currentMode = data[MODE_KEY];\n      } else {\n        const modePref = data[MODE_PREF_KEY] || 'fixed';\n        if (modePref === 'lastUsed' && data[LAST_USED_MODE_KEY]) {\n          state.currentMode = data[LAST_USED_MODE_KEY];\n        } else {\n          state.currentMode = data[DEFAULT_MODE_KEY] || DEFAULT_MODE;\n        }\n      }\n    } catch (error) {\n      log.warn('Mode determination error:', error);\n      state.currentMode = DEFAULT_MODE;\n    }\n\n    notify();\n    return state.currentMode;\n  }\n\n  function setMode(mode) {\n    state.currentMode = mode || DEFAULT_MODE;\n    notify();\n  }\n\n  async function persistMode(mode) {\n    state.currentMode = mode || DEFAULT_MODE;\n    if (!storage) {\n      notify();\n      return state.currentMode;\n    }\n\n    try {\n      const data = await storage.get(MODE_PREF_KEY);\n      if (data[MODE_PREF_KEY] === 'lastUsed') {\n        await storage.set({ [LAST_USED_MODE_KEY]: state.currentMode });\n      }\n      await storage.set({ [MODE_KEY]: state.currentMode });\n    } catch (error) {\n      log.warn('Storage access error:', error);\n    }\n\n    notify();\n    return state.currentMode;\n  }\n\n  async function loadChatId() {\n    if (!storage) {\n      state.currentChatId = null;\n      return null;\n    }\n    try {\n      const data = await storage.getLocal(CHAT_ID_STORAGE_KEY);\n      state.currentChatId = data[CHAT_ID_STORAGE_KEY] || null;\n    } catch (error) {\n      log.warn('Failed to load chat ID:', error);\n      state.currentChatId = null;\n    }\n    return state.currentChatId;\n  }\n\n  async function setChatId(chatId) {\n    state.currentChatId = chatId || null;\n    if (!storage) {\n      notify();\n      return;\n    }\n\n    try {\n      if (!chatId) {\n        await storage.removeLocal(CHAT_ID_STORAGE_KEY);\n      } else {\n        await storage.setLocal(CHAT_ID_STORAGE_KEY, chatId);\n      }\n    } catch (error) {\n      log.warn('Failed to save chat ID:', error);\n    }\n\n    notify();\n  }\n\n  async function setSidebarOpen(isOpen) {\n    state.isSidebarOpen = !!isOpen;\n    if (storage) {\n      try {\n        await storage.set({ [SIDEBAR_OPEN_KEY]: state.isSidebarOpen });\n      } catch (error) {\n        log.warn('Failed to save sidebar state:', error);\n      }\n    }\n    notify();\n  }\n\n  function setPendingPrefill(text) {\n    state.pendingPrefill = typeof text === 'string' ? text : '';\n    notify();\n  }\n\n  function clearPendingPrefill() {\n    if (!state.pendingPrefill) return;\n    state.pendingPrefill = '';\n    notify();\n  }\n\n  function setActiveTab(tabId) {\n    if (typeof tabId === 'string') {\n      state.currentActiveTab = tabId;\n      if (storage) {\n        storage\n          .set({ [SIDEBAR_ACTIVE_TAB_KEY]: state.currentActiveTab })\n          .catch((error) => log.warn('Failed to save active tab:', error));\n      }\n      notify();\n    }\n  }\n\n  function setPreferences(preferences) {\n    state.sessionPreferences = {\n      ...state.sessionPreferences,\n      ...(preferences || {}),\n    };\n    notify();\n  }\n\n  function handleStorageChanges(changes, areaName) {\n    if (areaName === 'sync' && changes[HIGHLIGHTING_KEY]) {\n      state.highlightingEnabled = changes[HIGHLIGHTING_KEY].newValue !== false;\n    }\n\n    if (areaName === 'sync' && changes[MODE_KEY]) {\n      state.currentMode = changes[MODE_KEY].newValue;\n    }\n\n    if (areaName === 'sync' && changes[SIDEBAR_OPEN_KEY]) {\n      state.isSidebarOpen = changes[SIDEBAR_OPEN_KEY].newValue === true;\n    }\n\n    if (areaName === 'sync' && changes[SIDEBAR_ACTIVE_TAB_KEY]) {\n      if (typeof changes[SIDEBAR_ACTIVE_TAB_KEY].newValue === 'string') {\n        state.currentActiveTab = changes[SIDEBAR_ACTIVE_TAB_KEY].newValue;\n      }\n    }\n\n    if (areaName === 'local' && changes[CHAT_ID_STORAGE_KEY]) {\n      state.currentChatId = changes[CHAT_ID_STORAGE_KEY].newValue || null;\n    }\n\n    notify();\n  }\n\n  function startSync() {\n    if (!storage || !storage.onChanged) return () => {};\n    stopSync();\n    unsubscribeStorage = storage.onChanged(handleStorageChanges);\n    return unsubscribeStorage;\n  }\n\n  function stopSync() {\n    if (unsubscribeStorage) {\n      unsubscribeStorage();\n      unsubscribeStorage = null;\n    }\n  }\n\n  return {\n    loadInitial,\n    determineDefaultMode,\n    persistMode,\n    setMode,\n    setSidebarOpen,\n    setPendingPrefill,\n    clearPendingPrefill,\n    setChatId,\n    setActiveTab,\n    setPreferences,\n    getSnapshot,\n    subscribe,\n    startSync,\n    stopSync,\n  };\n}\n\ndescribe('StateStore', () => {\n  let mockStorage;\n  let mockLogger;\n  let stateStore;\n\n  beforeEach(() => {\n    mockStorage = {\n      get: vi.fn().mockResolvedValue({}),\n      set: vi.fn().mockResolvedValue(undefined),\n      getLocal: vi.fn().mockResolvedValue({}),\n      setLocal: vi.fn().mockResolvedValue(undefined),\n      removeLocal: vi.fn().mockResolvedValue(undefined),\n      onChanged: vi.fn(() => () => {}), // Returns unsubscribe function\n      STORAGE_KEYS: {},\n    };\n\n    mockLogger = {\n      warn: vi.fn(),\n      error: vi.fn(),\n      debug: vi.fn(),\n      info: vi.fn(),\n    };\n\n    stateStore = createStateStore({ Storage: mockStorage, Logger: mockLogger });\n  });\n\n  describe('getSnapshot', () => {\n    it('should return current state snapshot', () => {\n      const snapshot = stateStore.getSnapshot();\n      expect(snapshot).toHaveProperty('currentMode');\n      expect(snapshot).toHaveProperty('isSidebarOpen');\n      expect(snapshot).toHaveProperty('currentChatId');\n      expect(snapshot.currentMode).toBe('explain');\n      expect(snapshot.isSidebarOpen).toBe(false);\n    });\n  });\n\n  describe('subscribe', () => {\n    it('should notify subscribers on state changes', async () => {\n      const callback = vi.fn();\n      const unsubscribe = stateStore.subscribe(callback);\n\n      await stateStore.setSidebarOpen(true);\n\n      expect(callback).toHaveBeenCalled();\n      const snapshot = callback.mock.calls[0][0];\n      expect(snapshot.isSidebarOpen).toBe(true);\n\n      unsubscribe();\n    });\n\n    it('should allow unsubscribing', async () => {\n      const callback = vi.fn();\n      const unsubscribe = stateStore.subscribe(callback);\n      unsubscribe();\n\n      await stateStore.setSidebarOpen(true);\n\n      // Callback should not be called after unsubscribe\n      expect(callback).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('setSidebarOpen', () => {\n    it('should update sidebar state and persist', async () => {\n      await stateStore.setSidebarOpen(true);\n\n      expect(stateStore.getSnapshot().isSidebarOpen).toBe(true);\n      expect(mockStorage.set).toHaveBeenCalledWith({\n        lockin_sidebar_isOpen: true,\n      });\n    });\n\n    it('should work without storage', async () => {\n      const storeWithoutStorage = createStateStore({ Storage: null, Logger: mockLogger });\n      await storeWithoutStorage.setSidebarOpen(true);\n\n      expect(storeWithoutStorage.getSnapshot().isSidebarOpen).toBe(true);\n    });\n  });\n\n  describe('setMode', () => {\n    it('should update mode without persisting', () => {\n      stateStore.setMode('general');\n\n      expect(stateStore.getSnapshot().currentMode).toBe('general');\n      expect(mockStorage.set).not.toHaveBeenCalled();\n    });\n\n    it('should use default mode when mode is null', () => {\n      stateStore.setMode(null);\n      expect(stateStore.getSnapshot().currentMode).toBe('explain');\n    });\n  });\n\n  describe('persistMode', () => {\n    it('should update mode and persist to storage', async () => {\n      await stateStore.persistMode('general');\n\n      expect(stateStore.getSnapshot().currentMode).toBe('general');\n      expect(mockStorage.set).toHaveBeenCalledWith({\n        lockinActiveMode: 'general',\n      });\n    });\n\n    it(\"should save to lastUsed when mode preference is 'lastUsed'\", async () => {\n      mockStorage.get.mockResolvedValue({\n        modePreference: 'lastUsed',\n      });\n\n      await stateStore.persistMode('general');\n\n      // Storage.set is called twice: once for lastUsedMode, once for lockinActiveMode\n      expect(mockStorage.set).toHaveBeenCalledTimes(2);\n      expect(mockStorage.set).toHaveBeenNthCalledWith(1, {\n        lastUsedMode: 'general',\n      });\n      expect(mockStorage.set).toHaveBeenNthCalledWith(2, {\n        lockinActiveMode: 'general',\n      });\n    });\n  });\n\n  describe('setPendingPrefill', () => {\n    it('should update pending prefill text', () => {\n      stateStore.setPendingPrefill('Selected text');\n\n      expect(stateStore.getSnapshot().pendingPrefill).toBe('Selected text');\n    });\n\n    it('should handle empty string', () => {\n      stateStore.setPendingPrefill('');\n\n      expect(stateStore.getSnapshot().pendingPrefill).toBe('');\n    });\n\n    it('should ignore non-string values', () => {\n      stateStore.setPendingPrefill(42);\n\n      expect(stateStore.getSnapshot().pendingPrefill).toBe('');\n    });\n  });\n\n  describe('clearPendingPrefill', () => {\n    it('should clear pending prefill when present', () => {\n      stateStore.setPendingPrefill('Selected text');\n      stateStore.clearPendingPrefill();\n\n      expect(stateStore.getSnapshot().pendingPrefill).toBe('');\n    });\n\n    it('should noop when no prefill is set', () => {\n      stateStore.clearPendingPrefill();\n\n      expect(stateStore.getSnapshot().pendingPrefill).toBe('');\n    });\n  });\n\n  describe('setActiveTab', () => {\n    it('should update active tab and persist', async () => {\n      stateStore.setActiveTab('notes');\n\n      expect(stateStore.getSnapshot().currentActiveTab).toBe('notes');\n      // setActiveTab uses async storage.set, wait a bit\n      await new Promise((resolve) => setTimeout(resolve, 10));\n      expect(mockStorage.set).toHaveBeenCalled();\n    });\n\n    it('should not update for non-string values', () => {\n      const before = stateStore.getSnapshot().currentActiveTab;\n      stateStore.setActiveTab(123);\n      expect(stateStore.getSnapshot().currentActiveTab).toBe(before);\n    });\n  });\n\n  describe('setChatId', () => {\n    it('should update chat ID and persist to local storage', async () => {\n      await stateStore.setChatId('chat-123');\n\n      expect(stateStore.getSnapshot().currentChatId).toBe('chat-123');\n      expect(mockStorage.setLocal).toHaveBeenCalledWith('lockinCurrentChatId', 'chat-123');\n    });\n\n    it('should remove chat ID when set to null', async () => {\n      await stateStore.setChatId('chat-123');\n      await stateStore.setChatId(null);\n\n      expect(stateStore.getSnapshot().currentChatId).toBe(null);\n      expect(mockStorage.removeLocal).toHaveBeenCalledWith('lockinCurrentChatId');\n    });\n  });\n\n  describe('setPreferences', () => {\n    it('should update session preferences', () => {\n      stateStore.setPreferences({ preferredLanguage: 'es' });\n\n      const snapshot = stateStore.getSnapshot();\n      expect(snapshot.sessionPreferences.preferredLanguage).toBe('es');\n      expect(snapshot.sessionPreferences).toEqual({ preferredLanguage: 'es' });\n    });\n  });\n\n  describe('loadInitial', () => {\n    it('should load initial state from storage', async () => {\n      mockStorage.get.mockResolvedValue({\n        lockin_sidebar_isOpen: true,\n        lockin_sidebar_activeTab: 'notes',\n        highlightingEnabled: false,\n      });\n\n      const snapshot = await stateStore.loadInitial();\n\n      expect(snapshot.isSidebarOpen).toBe(true);\n      expect(snapshot.currentActiveTab).toBe('notes');\n      expect(snapshot.highlightingEnabled).toBe(false);\n    });\n\n    it('should handle storage errors gracefully', async () => {\n      mockStorage.get.mockRejectedValue(new Error('Storage error'));\n\n      const snapshot = await stateStore.loadInitial();\n\n      // Should still return a valid snapshot\n      expect(snapshot).toBeDefined();\n      expect(mockLogger.warn).toHaveBeenCalled();\n    });\n\n    it('should work without storage', async () => {\n      const storeWithoutStorage = createStateStore({ Storage: null, Logger: mockLogger });\n      const snapshot = await storeWithoutStorage.loadInitial();\n\n      expect(snapshot).toBeDefined();\n      expect(snapshot.currentMode).toBe('explain');\n    });\n  });\n\n  describe('determineDefaultMode', () => {\n    it('should use stored mode if available', async () => {\n      mockStorage.get.mockResolvedValue({\n        lockinActiveMode: 'general',\n      });\n\n      const mode = await stateStore.determineDefaultMode();\n\n      expect(mode).toBe('general');\n    });\n\n    it(\"should use lastUsed mode when preference is 'lastUsed'\", async () => {\n      mockStorage.get.mockResolvedValue({\n        modePreference: 'lastUsed',\n        lastUsedMode: 'general',\n      });\n\n      const mode = await stateStore.determineDefaultMode();\n\n      expect(mode).toBe('general');\n    });\n\n    it(\"should use default mode when preference is 'fixed'\", async () => {\n      mockStorage.get.mockResolvedValue({\n        modePreference: 'fixed',\n        defaultMode: 'general',\n      });\n\n      const mode = await stateStore.determineDefaultMode();\n\n      expect(mode).toBe('general');\n    });\n\n    it(\"should fallback to 'explain' when no preferences found\", async () => {\n      mockStorage.get.mockResolvedValue({});\n\n      const mode = await stateStore.determineDefaultMode();\n\n      expect(mode).toBe('explain');\n    });\n  });\n\n  describe('startSync and stopSync', () => {\n    it('should start storage sync', () => {\n      const unsubscribe = stateStore.startSync();\n\n      expect(mockStorage.onChanged).toHaveBeenCalled();\n      expect(typeof unsubscribe).toBe('function');\n    });\n\n    it('should stop storage sync', () => {\n      stateStore.startSync();\n      stateStore.stopSync();\n\n      // stopSync should clean up the subscription\n      expect(mockStorage.onChanged).toHaveBeenCalled();\n    });\n\n    it('should handle storage changes', () => {\n      const callback = vi.fn();\n      stateStore.subscribe(callback);\n\n      stateStore.startSync();\n\n      // Simulate storage change\n      const mockUnsubscribe = vi.fn();\n      mockStorage.onChanged.mockReturnValue(mockUnsubscribe);\n      const changeHandler = mockStorage.onChanged.mock.calls[0][0];\n\n      changeHandler(\n        {\n          lockinActiveMode: { newValue: 'general' },\n        },\n        'sync',\n      );\n\n      expect(callback).toHaveBeenCalled();\n      expect(stateStore.getSnapshot().currentMode).toBe('general');\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\content\\interactions.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\content\\mediaFetcher.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 11,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 11,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 11,
        "column": 24,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 11,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 11,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 11,
        "endColumn": 35
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 300.",
        "line": 77,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 77,
        "column": 50,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 53
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'fetchWithRedirectHandling' has too many lines (59). Maximum allowed is 50.",
        "line": 81,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 147,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'fetchWithRedirectHandling' has too many statements (25). Maximum allowed is 20.",
        "line": 81,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 147,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'streamResponseAsChunks' has too many statements (25). Maximum allowed is 20.",
        "line": 149,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 196,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'fetchMediaAsChunks' has too many lines (64). Maximum allowed is 50.",
        "line": 198,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 280,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'fetchMediaAsChunks' has too many statements (25). Maximum allowed is 20.",
        "line": 198,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 280,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 222,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 222,
        "endColumn": 34
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 222,
        "column": 58,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 222,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Media Fetcher for Content Script\n *\n * Handles fetching authenticated media that may be blocked by CORS\n * when fetched from the background script.\n *\n * Industry Best Practice: Use content script for same-origin media access\n * since content scripts run in the page's security context.\n */\n\nconst CHUNK_SIZE = 4 * 1024 * 1024; // 4MB chunks to match backend\nconst NetworkRetry = typeof window !== 'undefined' ? window.LockInNetworkRetry : null;\nconst MEDIA_FETCH_RETRY_CONFIG = {\n  maxRetries: 2,\n  timeoutMs: 20000,\n};\n\nfunction fetchWithRetry(url, options, overrides = {}) {\n  if (!NetworkRetry?.fetchWithRetry) {\n    throw new Error('Network retry utilities unavailable');\n  }\n  return NetworkRetry.fetchWithRetry(url, options, {\n    ...MEDIA_FETCH_RETRY_CONFIG,\n    ...overrides,\n    context: overrides.context || 'media fetch',\n  });\n}\n\n/**\n * Fetch media from a URL and return it as chunks\n * This runs in the content script context which has access to same-origin resources\n *\n * @param {string} mediaUrl - The URL of the media to fetch\n * @param {function} onChunk - Callback for each chunk: (chunk: Uint8Array | null, index: number, isLast: boolean) => Promise<void>\n * @param {AbortSignal} signal - Optional abort signal\n * @returns {Promise<{success: boolean, error?: string, totalBytes?: number}>}\n */\n/**\n * Known SSO/auth domains that indicate session expiration\n */\nconst SSO_DOMAINS = ['okta.com', 'auth0.com', 'login.microsoftonline.com', 'accounts.google.com'];\n\n/**\n * Check if a URL is an SSO/authentication redirect\n */\nfunction isSsoRedirect(url) {\n  try {\n    const hostname = new URL(url).hostname.toLowerCase();\n    return SSO_DOMAINS.some((domain) => hostname.includes(domain));\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if a URL is a CDN that doesn't need credentials\n */\nfunction isCdnUrl(url) {\n  try {\n    const hostname = new URL(url).hostname.toLowerCase();\n    return (\n      hostname.includes('cloudfront.net') ||\n      hostname.includes('cdn.') ||\n      hostname.includes('akamai') ||\n      hostname.includes('fastly') ||\n      hostname.includes('cloudflare')\n    );\n  } catch {\n    return false;\n  }\n}\n\nfunction isRedirectResponse(response) {\n  return (\n    response.type === 'opaqueredirect' ||\n    response.status === 0 ||\n    (response.status >= 300 && response.status < 400)\n  );\n}\n\nasync function fetchWithRedirectHandling(mediaUrl, signal) {\n  console.log('[Lock-in MediaFetcher] Fetching with credentials + manual redirect');\n  let response = await fetchWithRetry(mediaUrl, {\n    method: 'GET',\n    credentials: 'include',\n    redirect: 'manual',\n    signal,\n  });\n\n  console.log('[Lock-in MediaFetcher] Initial response:', response.status, response.type);\n\n  if (!isRedirectResponse(response)) {\n    return { response };\n  }\n\n  const location = response.headers.get('location');\n  console.log('[Lock-in MediaFetcher] Redirect detected, location:', location);\n\n  if (location) {\n    if (isSsoRedirect(location)) {\n      console.log('[Lock-in MediaFetcher] SSO redirect detected - session expired');\n      return {\n        error: 'Your session has expired. Please refresh the page and log in again.',\n        errorCode: 'SESSION_EXPIRED',\n      };\n    }\n\n    const useCredentials = !isCdnUrl(location);\n    console.log(\n      '[Lock-in MediaFetcher] Following redirect to:',\n      location,\n      'with credentials:',\n      useCredentials,\n    );\n\n    response = await fetchWithRetry(location, {\n      method: 'GET',\n      credentials: useCredentials ? 'include' : 'omit',\n      signal,\n    });\n    console.log('[Lock-in MediaFetcher] Redirect response:', response.status, response.statusText);\n    return { response };\n  }\n\n  console.log(\n    '[Lock-in MediaFetcher] No location header (cross-origin redirect), trying with same-origin credentials',\n  );\n  try {\n    response = await fetchWithRetry(mediaUrl, {\n      method: 'GET',\n      credentials: 'same-origin',\n      signal,\n    });\n    console.log('[Lock-in MediaFetcher] Same-origin credentials fetch succeeded:', response.status);\n    return { response };\n  } catch (sameOriginError) {\n    console.log('[Lock-in MediaFetcher] Same-origin fetch failed:', sameOriginError.message);\n    console.log('[Lock-in MediaFetcher] Retrying without credentials (CDN may have cached auth)');\n    response = await fetchWithRetry(mediaUrl, {\n      method: 'GET',\n      credentials: 'omit',\n      signal,\n    });\n  }\n\n  return { response };\n}\n\nasync function streamResponseAsChunks(response, onChunk) {\n  const reader = response.body.getReader();\n  let buffer = new Uint8Array(0);\n  let chunkIndex = 0;\n  let totalBytesRead = 0;\n\n  while (true) {\n    const { done, value } = await reader.read();\n\n    if (done) {\n      if (buffer.length > 0) {\n        console.log(\n          '[Lock-in MediaFetcher] Sending final chunk:',\n          chunkIndex,\n          'size:',\n          buffer.length,\n        );\n        await onChunk(buffer, chunkIndex, true);\n      } else {\n        console.log(\n          '[Lock-in MediaFetcher] Buffer empty at end (exact chunk boundary), sending completion signal',\n        );\n        await onChunk(null, chunkIndex, true);\n      }\n      break;\n    }\n\n    const newBuffer = new Uint8Array(buffer.length + value.length);\n    newBuffer.set(buffer);\n    newBuffer.set(value, buffer.length);\n    buffer = newBuffer;\n    totalBytesRead += value.length;\n\n    while (buffer.length >= CHUNK_SIZE) {\n      const chunk = buffer.slice(0, CHUNK_SIZE);\n      buffer = buffer.slice(CHUNK_SIZE);\n\n      console.log('[Lock-in MediaFetcher] Sending chunk:', chunkIndex, 'size:', chunk.length);\n      await onChunk(chunk, chunkIndex, false);\n      chunkIndex++;\n    }\n  }\n\n  return {\n    totalBytesRead,\n    chunksCount: buffer.length > 0 ? chunkIndex + 1 : chunkIndex,\n  };\n}\n\nasync function fetchMediaAsChunks(mediaUrl, onChunk, signal) {\n  console.log('[Lock-in MediaFetcher] Starting media fetch:', mediaUrl);\n\n  try {\n    // Use manual redirect handling to properly handle auth + CDN scenarios\n    // 1. Moodle requires cookies for auth\n    // 2. If authenticated, Moodle redirects to CDN with signed URL\n    // 3. CDN doesn't need cookies (signed URL) and returns Access-Control-Allow-Origin: *\n    // 4. credentials: 'include' + ACAO: * = CORS error\n    // Solution: Handle redirects manually, use credentials for origin, omit for CDN\n\n    const resolved = await fetchWithRedirectHandling(mediaUrl, signal);\n    if (resolved.errorCode) {\n      return {\n        success: false,\n        error: resolved.error,\n        errorCode: resolved.errorCode,\n      };\n    }\n\n    const response = resolved.response;\n\n    // Check final response\n    if (!response.ok) {\n      if (response.status === 401 || response.status === 403) {\n        return {\n          success: false,\n          error: 'Authentication required. Please refresh the page and ensure you are logged in.',\n          errorCode: 'AUTH_REQUIRED',\n        };\n      }\n      return {\n        success: false,\n        error: `HTTP ${response.status}: ${response.statusText}`,\n        errorCode: 'FETCH_ERROR',\n      };\n    }\n\n    if (!response.body) {\n      return {\n        success: false,\n        error: 'No response body available',\n        errorCode: 'NO_BODY',\n      };\n    }\n\n    const contentLength = response.headers.get('content-length');\n    const totalBytes = contentLength ? parseInt(contentLength, 10) : null;\n    console.log('[Lock-in MediaFetcher] Content-Length:', totalBytes);\n\n    const { totalBytesRead, chunksCount } = await streamResponseAsChunks(response, onChunk);\n    console.log('[Lock-in MediaFetcher] Fetch complete. Total bytes:', totalBytesRead);\n    return {\n      success: true,\n      totalBytes: totalBytesRead,\n      chunksCount,\n    };\n  } catch (error) {\n    console.error('[Lock-in MediaFetcher] Fetch error:', error);\n\n    if (error.name === 'AbortError') {\n      return { success: false, error: 'Fetch aborted', errorCode: 'ABORTED' };\n    }\n\n    const message = error instanceof Error ? error.message : String(error);\n\n    // Check for CORS/network errors - likely session expiration causing SSO redirect\n    if (\n      message.includes('Failed to fetch') ||\n      message.includes('NetworkError') ||\n      message.includes('CORS')\n    ) {\n      return {\n        success: false,\n        error:\n          'Could not fetch media. Your session may have expired - please refresh the page and ensure you are logged in.',\n        errorCode: 'CORS_ERROR',\n      };\n    }\n\n    return { success: false, error: message, errorCode: 'UNKNOWN_ERROR' };\n  }\n}\n\n/**\n * Handle media fetch request from background script\n *\n * @param {object} payload - { mediaUrl, jobId, requestId }\n * @param {function} sendChunk - Function to send chunk to background\n * @returns {Promise<object>}\n */\nasync function handleMediaFetchRequest(payload, sendChunk) {\n  const { mediaUrl, jobId, requestId } = payload;\n\n  console.log('[Lock-in MediaFetcher] Handling fetch request:', {\n    mediaUrl,\n    jobId,\n    requestId,\n  });\n\n  return fetchMediaAsChunks(mediaUrl, async (chunk, index, isLast) => {\n    const chunkBuffer =\n      chunk && chunk.byteLength\n        ? chunk.buffer.slice(chunk.byteOffset, chunk.byteOffset + chunk.byteLength)\n        : null;\n    await sendChunk({\n      type: 'MEDIA_CHUNK',\n      payload: {\n        requestId,\n        jobId,\n        chunkIndex: index,\n        chunkData: chunkBuffer,\n        chunkSize: chunk ? chunk.length : 0,\n        isLast,\n      },\n    });\n  });\n}\n\n/**\n * Convert ArrayBuffer/Uint8Array to base64 string\n */\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  const len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n\n/**\n * Convert base64 string to Uint8Array\n */\nfunction base64ToArrayBuffer(base64) {\n  const binary = atob(base64);\n  const len = binary.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n\n// Export for use in content script\nif (typeof window !== 'undefined') {\n  window.LockInMediaFetcher = {\n    fetchMediaAsChunks,\n    handleMediaFetchRequest,\n    arrayBufferToBase64,\n    base64ToArrayBuffer,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\content\\sessionManager.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createSessionManager' has too many lines (103). Maximum allowed is 50.",
        "line": 5,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 130,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session management helpers (tab ID + session restore/clear).\n */\n(function () {\n  function createSessionManager({ Messaging, Logger, stateStore, origin }) {\n    const log = Logger || { debug: () => {}, error: console.error };\n    let currentTabId = null;\n    const MESSAGE_TYPES = (Messaging && Messaging.types) || {\n      GET_TAB_ID: 'GET_TAB_ID',\n      GET_SESSION: 'GET_SESSION',\n      CLEAR_SESSION: 'CLEAR_SESSION',\n    };\n\n    async function sendMessage(type, payload) {\n      if (!Messaging || !chrome.runtime) return null;\n\n      try {\n        if (typeof Messaging.send === 'function') {\n          return await Messaging.send(type, payload);\n        }\n\n        if (typeof Messaging.sendToBackground === 'function') {\n          return await Messaging.sendToBackground({ type, payload });\n        }\n\n        if (typeof Messaging.sendMessage === 'function') {\n          return await Messaging.sendMessage({ type, payload });\n        }\n      } catch (error) {\n        log.error('Messaging failed:', error);\n      }\n\n      return null;\n    }\n\n    async function getTabId() {\n      if (!Messaging || !chrome.runtime) return null;\n\n      try {\n        const response = await sendMessage(MESSAGE_TYPES.GET_TAB_ID);\n        const tabId = response?.data?.tabId ?? response?.tabId;\n        if (typeof tabId === 'number') {\n          currentTabId = tabId;\n          log.debug('Tab ID:', currentTabId);\n          return currentTabId;\n        }\n      } catch (error) {\n        log.error('Failed to get tab ID:', error);\n      }\n\n      return currentTabId;\n    }\n\n    async function ensureTabId() {\n      if (!currentTabId) {\n        await getTabId();\n      }\n      return currentTabId;\n    }\n\n    function getSessionFromResponse(response) {\n      return response?.data?.session || response?.session;\n    }\n\n    async function applySession(session) {\n      stateStore.setPendingPrefill(session.selection || '');\n      stateStore.setMode(session.mode || 'explain');\n\n      if (session.chatId) {\n        await stateStore.setChatId(session.chatId);\n      }\n\n      if (session.selection) {\n        await stateStore.setSidebarOpen(true);\n      }\n    }\n\n    async function shouldSkipSession(session) {\n      if (!session || !session.isActive) {\n        return true;\n      }\n\n      if (session.origin && origin && session.origin !== origin) {\n        log.debug('Origin changed, not restoring session');\n        await clearSession();\n        return true;\n      }\n\n      if (session.isClosed) {\n        log.debug('Session was closed by user');\n        return true;\n      }\n\n      return false;\n    }\n\n    async function restoreSession() {\n      if (!Messaging || !chrome.runtime) return;\n      const tabId = await ensureTabId();\n      if (!tabId) return;\n\n      try {\n        const response = await sendMessage(MESSAGE_TYPES.GET_SESSION);\n        if (response && response.ok === false) return;\n\n        const session = getSessionFromResponse(response);\n        if (await shouldSkipSession(session)) return;\n        await applySession(session);\n      } catch (error) {\n        log.error('Failed to load session:', error);\n      }\n    }\n\n    async function clearSession() {\n      if (!Messaging || !chrome.runtime) return;\n\n      try {\n        await sendMessage(MESSAGE_TYPES.CLEAR_SESSION);\n      } catch (error) {\n        log.error('Failed to clear session:', error);\n      }\n    }\n\n    return {\n      getTabId,\n      restoreSession,\n      clearSession,\n      getCurrentTabId: () => currentTabId,\n    };\n  }\n\n  window.LockInContent = window.LockInContent || {};\n  window.LockInContent.createSessionManager = createSessionManager;\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\content\\sidebarHost.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createSidebarHost' has too many lines (186). Maximum allowed is 50.",
        "line": 6,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 215,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'ensurePageWrapper' has too many statements (22). Maximum allowed is 20.",
        "line": 91,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 127,
        "endColumn": 6
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * React sidebar host. Responsible for mounting/updating the UI bundle.\n * Layout sync (body classes) is handled by the React component itself.\n */\n(function () {\n  function createSidebarHost({ Logger, Storage }) {\n    const log = Logger || {\n      debug: () => {},\n      warn: console.warn,\n      error: console.error,\n    };\n    const PAGE_WRAPPER_ID = 'lockin-page-wrapper';\n    const LOCKIN_ROOT_ID = 'lockin-root';\n    const WRAPPER_SKIP_TAGS = new Set(['SCRIPT', 'STYLE', 'NOSCRIPT', 'LINK', 'META']);\n    let sidebarInstance = null;\n    let pageObserver = null;\n    const runtimeStorage =\n      typeof window !== 'undefined' && window.LockInContent && window.LockInContent.storage\n        ? window.LockInContent.storage\n        : Storage;\n\n    function injectStyles() {\n      log.debug('Styles verification: CSS should be loaded from manifest');\n    }\n\n    function shouldMoveNode(node, wrapper, lockinRoot) {\n      if (!node) return false;\n      if (node === wrapper || node === lockinRoot) return false;\n      if (node.nodeType === Node.COMMENT_NODE) return false;\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        const tag = node.tagName || '';\n        if (WRAPPER_SKIP_TAGS.has(tag)) return false;\n        // Don't move fixed/absolute positioned elements - they're likely modals/popups\n        // that need to stay as direct body children for correct stacking behavior\n        try {\n          const style = window.getComputedStyle(node);\n          const position = style.getPropertyValue('position');\n          if (position === 'fixed' || position === 'absolute') {\n            return false;\n          }\n          // Don't move elements with very high z-index (likely overlays)\n          const zIndex = parseInt(style.getPropertyValue('z-index'), 10);\n          if (!isNaN(zIndex) && zIndex > 1000) {\n            return false;\n          }\n        } catch (e) {\n          // getComputedStyle might fail on some elements, just skip the check\n        }\n      }\n      return true;\n    }\n\n    function moveNodeIntoWrapper(node, wrapper) {\n      if (!wrapper || !node) return;\n      if (node.nextSibling === wrapper && wrapper.firstChild) {\n        wrapper.insertBefore(node, wrapper.firstChild);\n        return;\n      }\n      wrapper.appendChild(node);\n    }\n\n    function startPageWrapperObserver(wrapper) {\n      if (!wrapper || pageObserver || typeof MutationObserver === 'undefined') {\n        return;\n      }\n      const body = document.body;\n      if (!body) return;\n\n      pageObserver = new MutationObserver((mutations) => {\n        const currentWrapper = document.getElementById(PAGE_WRAPPER_ID);\n        if (!currentWrapper) {\n          pageObserver.disconnect();\n          pageObserver = null;\n          ensurePageWrapper();\n          return;\n        }\n\n        const lockinRoot = document.getElementById(LOCKIN_ROOT_ID);\n        mutations.forEach((mutation) => {\n          mutation.addedNodes.forEach((node) => {\n            if (node.parentNode !== body) return;\n            if (!shouldMoveNode(node, currentWrapper, lockinRoot)) return;\n            moveNodeIntoWrapper(node, currentWrapper);\n          });\n        });\n      });\n\n      pageObserver.observe(body, { childList: true });\n    }\n\n    function ensurePageWrapper() {\n      if (typeof document === 'undefined') return null;\n      const body = document.body;\n      if (!body) return null;\n\n      let wrapper = document.getElementById(PAGE_WRAPPER_ID);\n      const lockinRoot = document.getElementById(LOCKIN_ROOT_ID);\n      if (wrapper) {\n        if (lockinRoot && lockinRoot.parentNode === wrapper) {\n          body.appendChild(lockinRoot);\n        }\n        if (lockinRoot && lockinRoot.parentNode === body) {\n          body.insertBefore(wrapper, lockinRoot);\n        }\n        startPageWrapperObserver(wrapper);\n        return wrapper;\n      }\n\n      wrapper = document.createElement('div');\n      wrapper.id = PAGE_WRAPPER_ID;\n\n      if (lockinRoot && lockinRoot.parentNode === body) {\n        body.insertBefore(wrapper, lockinRoot);\n      } else {\n        body.appendChild(wrapper);\n      }\n\n      const nodesToMove = [];\n      body.childNodes.forEach((node) => {\n        if (!shouldMoveNode(node, wrapper, lockinRoot)) return;\n        nodesToMove.push(node);\n      });\n\n      nodesToMove.forEach((node) => moveNodeIntoWrapper(node, wrapper));\n      startPageWrapperObserver(wrapper);\n      return wrapper;\n    }\n\n    function buildStorageAdapter() {\n      return {\n        get: async (key) => {\n          if (!runtimeStorage) return null;\n          try {\n            const data = await runtimeStorage.get(key);\n            return data[key];\n          } catch (error) {\n            log.warn('Storage get error:', error);\n            return null;\n          }\n        },\n        set: async (key, value) => {\n          if (!runtimeStorage) return;\n          try {\n            await runtimeStorage.set({ [key]: value });\n          } catch (error) {\n            log.warn('Storage set error:', error);\n          }\n        },\n        getLocal: async (key) => {\n          if (!runtimeStorage || !runtimeStorage.getLocal) return null;\n          try {\n            const data = await runtimeStorage.getLocal(key);\n            return data[key];\n          } catch (error) {\n            log.warn('Storage getLocal error:', error);\n            return null;\n          }\n        },\n        setLocal: async (key, value) => {\n          if (!runtimeStorage || !runtimeStorage.setLocal) return;\n          try {\n            await runtimeStorage.setLocal(key, value);\n          } catch (error) {\n            log.warn('Storage setLocal error:', error);\n          }\n        },\n      };\n    }\n\n    function renderSidebar({ apiClient, adapter, pageContext, state, onToggle, onClearPrefill }) {\n      if (!window.LockInUI || !window.LockInUI.createLockInSidebar) {\n        log.error('LockInUI.createLockInSidebar not available');\n        return;\n      }\n\n      const viewState = state || {};\n      injectStyles();\n      ensurePageWrapper();\n\n      const sidebarProps = {\n        apiClient,\n        isOpen: !!viewState.isSidebarOpen,\n        onToggle,\n        currentMode: viewState.currentMode,\n        pendingPrefill: viewState.pendingPrefill,\n        onClearPrefill,\n        pageContext,\n        adapter,\n        storage: buildStorageAdapter(),\n        activeTabExternal: viewState.currentActiveTab,\n      };\n\n      if (!sidebarInstance) {\n        log.debug('Creating new sidebar instance (first time)');\n        sidebarInstance = window.LockInUI.createLockInSidebar(sidebarProps);\n      } else {\n        sidebarInstance.updateProps(sidebarProps);\n      }\n    }\n\n    function updatePropsFromState(state) {\n      if (!sidebarInstance) return;\n      sidebarInstance.updateProps({\n        isOpen: !!state.isSidebarOpen,\n        currentMode: state.currentMode,\n        pendingPrefill: state.pendingPrefill,\n        activeTabExternal: state.currentActiveTab,\n      });\n    }\n\n    return {\n      renderSidebar,\n      updatePropsFromState,\n    };\n  }\n\n  window.LockInContent = window.LockInContent || {};\n  window.LockInContent.createSidebarHost = createSidebarHost;\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\content\\stateStore.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createStateStore' has too many lines (240). Maximum allowed is 50.",
        "line": 11,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 285,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'createStateStore' has too many statements (33). Maximum allowed is 20.",
        "line": 11,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 285,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Content script state store with persistence and storage syncing.\n * Keeps global state in one place so the orchestrator stays thin.\n */\n(function () {\n  const DEFAULT_MODE = 'explain';\n  const DEFAULT_PREFS = {\n    preferredLanguage: 'en',\n  };\n\n  function createStateStore({ Storage, Logger }) {\n    const storage = Storage;\n    const log = Logger || { warn: console.warn };\n    const keys = (storage && storage.STORAGE_KEYS) || {};\n    const SIDEBAR_OPEN_KEY = keys.SIDEBAR_IS_OPEN || 'lockin_sidebar_isOpen';\n    const SIDEBAR_ACTIVE_TAB_KEY = keys.SIDEBAR_ACTIVE_TAB || 'lockin_sidebar_activeTab';\n    const CHAT_ID_STORAGE_KEY = keys.CURRENT_CHAT_ID || 'lockinCurrentChatId';\n    const MODE_KEY = keys.ACTIVE_MODE || 'lockinActiveMode';\n    const MODE_PREF_KEY = keys.MODE_PREFERENCE || 'modePreference';\n    const DEFAULT_MODE_KEY = keys.DEFAULT_MODE || 'defaultMode';\n    const LAST_USED_MODE_KEY = keys.LAST_USED_MODE || 'lastUsedMode';\n    const HIGHLIGHTING_KEY = keys.HIGHLIGHTING_ENABLED || 'highlightingEnabled';\n\n    const state = {\n      highlightingEnabled: true,\n      currentMode: DEFAULT_MODE,\n      isSidebarOpen: false,\n      pendingPrefill: '',\n      currentChatId: null,\n      currentActiveTab: 'chat',\n      sessionPreferences: { ...DEFAULT_PREFS },\n    };\n\n    const subscribers = new Set();\n    let unsubscribeStorage = null;\n\n    function getSnapshot() {\n      return { ...state };\n    }\n\n    function notify() {\n      const snapshot = getSnapshot();\n      subscribers.forEach((cb) => cb(snapshot));\n    }\n\n    function subscribe(callback) {\n      subscribers.add(callback);\n      return () => subscribers.delete(callback);\n    }\n\n    async function loadInitial() {\n      if (storage) {\n        try {\n          const data = await storage.get([\n            HIGHLIGHTING_KEY,\n            SIDEBAR_OPEN_KEY,\n            SIDEBAR_ACTIVE_TAB_KEY,\n          ]);\n          state.highlightingEnabled = data[HIGHLIGHTING_KEY] !== false;\n          if (typeof data[SIDEBAR_OPEN_KEY] === 'boolean') {\n            state.isSidebarOpen = data[SIDEBAR_OPEN_KEY];\n          }\n          if (typeof data[SIDEBAR_ACTIVE_TAB_KEY] === 'string') {\n            state.currentActiveTab = data[SIDEBAR_ACTIVE_TAB_KEY];\n          }\n        } catch (error) {\n          log.warn('Failed to load toggle state:', error);\n        }\n\n        await loadMode();\n        await loadChatId();\n      }\n\n      notify();\n      return getSnapshot();\n    }\n\n    async function loadMode() {\n      if (!storage) return state.currentMode;\n      try {\n        const data = await storage.get(MODE_KEY);\n        if (data[MODE_KEY]) {\n          state.currentMode = data[MODE_KEY];\n        }\n      } catch (error) {\n        log.warn('Failed to load mode:', error);\n      }\n      return state.currentMode;\n    }\n\n    async function determineDefaultMode() {\n      if (!storage) {\n        state.currentMode = DEFAULT_MODE;\n        notify();\n        return state.currentMode;\n      }\n\n      try {\n        const data = await storage.get([\n          MODE_PREF_KEY,\n          DEFAULT_MODE_KEY,\n          LAST_USED_MODE_KEY,\n          MODE_KEY,\n        ]);\n\n        if (data[MODE_KEY]) {\n          state.currentMode = data[MODE_KEY];\n        } else {\n          const modePref = data[MODE_PREF_KEY] || 'fixed';\n          if (modePref === 'lastUsed' && data[LAST_USED_MODE_KEY]) {\n            state.currentMode = data[LAST_USED_MODE_KEY];\n          } else {\n            state.currentMode = data[DEFAULT_MODE_KEY] || DEFAULT_MODE;\n          }\n        }\n      } catch (error) {\n        log.warn('Mode determination error:', error);\n        state.currentMode = DEFAULT_MODE;\n      }\n\n      notify();\n      return state.currentMode;\n    }\n\n    function setMode(mode) {\n      state.currentMode = mode || DEFAULT_MODE;\n      notify();\n    }\n\n    async function persistMode(mode) {\n      state.currentMode = mode || DEFAULT_MODE;\n      if (!storage) {\n        notify();\n        return state.currentMode;\n      }\n\n      try {\n        const data = await storage.get(MODE_PREF_KEY);\n        if (data[MODE_PREF_KEY] === 'lastUsed') {\n          await storage.set({ [LAST_USED_MODE_KEY]: state.currentMode });\n        }\n        await storage.set({ [MODE_KEY]: state.currentMode });\n      } catch (error) {\n        log.warn('Storage access error:', error);\n      }\n\n      notify();\n      return state.currentMode;\n    }\n\n    async function loadChatId() {\n      if (!storage) {\n        state.currentChatId = null;\n        return null;\n      }\n      try {\n        const data = await storage.getLocal(CHAT_ID_STORAGE_KEY);\n        state.currentChatId = data[CHAT_ID_STORAGE_KEY] || null;\n      } catch (error) {\n        log.warn('Failed to load chat ID:', error);\n        state.currentChatId = null;\n      }\n      return state.currentChatId;\n    }\n\n    async function setChatId(chatId) {\n      state.currentChatId = chatId || null;\n      if (!storage) {\n        notify();\n        return;\n      }\n\n      try {\n        if (!chatId) {\n          await storage.removeLocal(CHAT_ID_STORAGE_KEY);\n        } else {\n          await storage.setLocal(CHAT_ID_STORAGE_KEY, chatId);\n        }\n      } catch (error) {\n        log.warn('Failed to save chat ID:', error);\n      }\n\n      notify();\n    }\n\n    async function setSidebarOpen(isOpen) {\n      state.isSidebarOpen = !!isOpen;\n      if (storage) {\n        try {\n          await storage.set({ [SIDEBAR_OPEN_KEY]: state.isSidebarOpen });\n        } catch (error) {\n          log.warn('Failed to save sidebar state:', error);\n        }\n      }\n      notify();\n    }\n\n    function setPendingPrefill(text) {\n      state.pendingPrefill = typeof text === 'string' ? text : '';\n      notify();\n    }\n\n    function clearPendingPrefill() {\n      if (!state.pendingPrefill) return;\n      state.pendingPrefill = '';\n      notify();\n    }\n\n    function setActiveTab(tabId) {\n      if (typeof tabId === 'string') {\n        state.currentActiveTab = tabId;\n        if (storage) {\n          storage\n            .set({ [SIDEBAR_ACTIVE_TAB_KEY]: state.currentActiveTab })\n            .catch((error) => log.warn('Failed to save active tab:', error));\n        }\n        notify();\n      }\n    }\n\n    function setPreferences(preferences) {\n      state.sessionPreferences = {\n        ...state.sessionPreferences,\n        ...(preferences || {}),\n      };\n      notify();\n    }\n\n    function handleStorageChanges(changes, areaName) {\n      if (areaName === 'sync' && changes[HIGHLIGHTING_KEY]) {\n        state.highlightingEnabled = changes[HIGHLIGHTING_KEY].newValue !== false;\n      }\n\n      if (areaName === 'sync' && changes[MODE_KEY]) {\n        state.currentMode = changes[MODE_KEY].newValue;\n      }\n\n      if (areaName === 'sync' && changes[SIDEBAR_OPEN_KEY]) {\n        state.isSidebarOpen = changes[SIDEBAR_OPEN_KEY].newValue === true;\n      }\n\n      if (areaName === 'sync' && changes[SIDEBAR_ACTIVE_TAB_KEY]) {\n        if (typeof changes[SIDEBAR_ACTIVE_TAB_KEY].newValue === 'string') {\n          state.currentActiveTab = changes[SIDEBAR_ACTIVE_TAB_KEY].newValue;\n        }\n      }\n\n      if (areaName === 'local' && changes[CHAT_ID_STORAGE_KEY]) {\n        state.currentChatId = changes[CHAT_ID_STORAGE_KEY].newValue || null;\n      }\n\n      notify();\n    }\n\n    function startSync() {\n      if (!storage || !storage.onChanged) return () => {};\n      stopSync();\n      unsubscribeStorage = storage.onChanged(handleStorageChanges);\n      return unsubscribeStorage;\n    }\n\n    function stopSync() {\n      if (unsubscribeStorage) {\n        unsubscribeStorage();\n        unsubscribeStorage = null;\n      }\n    }\n\n    return {\n      loadInitial,\n      determineDefaultMode,\n      persistMode,\n      setMode,\n      setSidebarOpen,\n      setPendingPrefill,\n      clearPendingPrefill,\n      setChatId,\n      setActiveTab,\n      setPreferences,\n      getSnapshot,\n      subscribe,\n      startSync,\n      stopSync,\n    };\n  }\n\n  window.LockInContent = window.LockInContent || {};\n  window.LockInContent.createStateStore = createStateStore;\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\popup.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 2000.",
        "line": 48,
        "column": 6,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 48,
        "endColumn": 10
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'initAuthSection' has too many lines (74). Maximum allowed is 50.",
        "line": 256,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 341,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (25). Maximum allowed is 20.",
        "line": 278,
        "column": 39,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 318,
        "endColumn": 4
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (327). Maximum allowed is 300.",
        "line": 384,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 415,
        "endColumn": 1
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Lock-in Popup Script\n * Handles settings management including authentication, privacy, and help/support\n */\n\n// ============================================================================\n// Sentry Initialization (must be first)\n// ============================================================================\n\n// Initialize Sentry immediately for error tracking (popup surface)\n// LockInSentry is loaded via dist/libs/sentry.js before this script\nif (typeof window !== 'undefined' && window.LockInSentry) {\n  window.LockInSentry.initSentry('popup');\n}\n\n// DOM elements\nconst statusMessage = document.getElementById('status-message');\nconst authForm = document.getElementById('auth-form');\nconst authEmailInput = document.getElementById('auth-email');\nconst authPasswordInput = document.getElementById('auth-password');\nconst authMessage = document.getElementById('auth-message');\nconst loggedOutView = document.getElementById('auth-view-logged-out');\nconst loggedInView = document.getElementById('auth-view-logged-in');\nconst authUserEmail = document.getElementById('auth-user-email');\nconst logoutButton = document.getElementById('logout-button');\nconst authTabs = document.querySelectorAll('.auth-tab');\nconst authSubmitButton = document.getElementById('auth-submit-button');\nconst authModeHint = document.getElementById('auth-mode-hint');\nconst passwordToggle = document.getElementById('password-toggle');\nconst passwordWrapper = document.getElementById('password-wrapper');\nconst forgotPasswordLink = document.getElementById('forgot-password-link');\nconst accountStatus = document.getElementById('account-status');\nconst accordionHeaders = document.querySelectorAll('.accordion-header');\nconst SUPABASE_CONFIG = window.LOCKIN_CONFIG || {};\n\nlet currentAuthMode = 'login';\n\n/**\n * Show status message\n */\nfunction showStatus(message, type = 'success') {\n  statusMessage.textContent = message;\n  statusMessage.className = `status-message ${type}`;\n\n  // Auto-hide after 2 seconds\n  setTimeout(() => {\n    statusMessage.className = 'status-message';\n  }, 2000);\n}\n\nfunction isSupabaseConfigured() {\n  if (!SUPABASE_CONFIG) {\n    return false;\n  }\n\n  const url = SUPABASE_CONFIG.SUPABASE_URL || '';\n  const anonKey = SUPABASE_CONFIG.SUPABASE_ANON_KEY || '';\n  const urlLooksValid = url && !url.includes('YOUR-PROJECT');\n  const keyLooksValid = anonKey && anonKey !== 'public-anon-key';\n  return Boolean(urlLooksValid && keyLooksValid);\n}\n\nfunction setAuthMessage(message, type = 'error') {\n  if (!authMessage) return;\n  authMessage.textContent = message || '';\n  authMessage.className = `auth-message ${type}`.trim();\n}\n\nfunction getFriendlyAuthError(error) {\n  const code = error?.code;\n  if (code === 'INVALID_LOGIN') {\n    return 'Incorrect email or password. Please try again.';\n  }\n  if (code === 'EMAIL_NOT_CONFIRMED') {\n    return 'Confirm your email address before signing in.';\n  }\n  if (code === 'EMAIL_CONFIRMATION_REQUIRED') {\n    return 'We sent you a confirmation email. Please verify it, then sign in.';\n  }\n  if (code === 'INVALID_EMAIL') {\n    return 'Enter a valid email address.';\n  }\n  if (code === 'USER_ALREADY_REGISTERED') {\n    return 'An account already exists for this email. Try logging in instead.';\n  }\n  return error?.message || \"We couldn't sign you in. Please try again.\";\n}\n\nfunction updateAuthModeUI() {\n  authTabs.forEach((tab) => {\n    const mode = tab.getAttribute('data-mode');\n    if (mode === currentAuthMode) {\n      tab.classList.add('active');\n    } else {\n      tab.classList.remove('active');\n    }\n  });\n\n  if (!authSubmitButton || !authModeHint) {\n    return;\n  }\n\n  const btnText = authSubmitButton.querySelector('.btn-text');\n\n  // Show/hide forgot password link\n  if (forgotPasswordLink) {\n    forgotPasswordLink.style.display = currentAuthMode === 'login' ? 'inline' : 'none';\n  }\n\n  if (currentAuthMode === 'login') {\n    if (btnText) btnText.textContent = 'Log in';\n    authModeHint.textContent = 'Use your Lock-in account email and password.';\n  } else if (currentAuthMode === 'signup') {\n    if (btnText) btnText.textContent = 'Create account';\n    authModeHint.textContent = 'Choose a password you will remember.';\n  }\n}\n\nfunction setAuthLoading(isLoading) {\n  if (!authSubmitButton) return;\n\n  const btnText = authSubmitButton.querySelector('.btn-text');\n  const btnSpinner = authSubmitButton.querySelector('.btn-spinner');\n\n  if (isLoading) {\n    authSubmitButton.disabled = true;\n    authSubmitButton.classList.add('loading');\n    if (btnText) btnText.style.opacity = '0';\n    if (btnSpinner) btnSpinner.style.display = 'flex';\n  } else {\n    authSubmitButton.disabled = false;\n    authSubmitButton.classList.remove('loading');\n    if (btnText) btnText.style.opacity = '1';\n    if (btnSpinner) btnSpinner.style.display = 'none';\n  }\n}\n\nasync function refreshAuthView() {\n  if (!window.LockInAuth || !loggedInView || !loggedOutView) {\n    return;\n  }\n\n  const session = await window.LockInAuth.getSession();\n  if (session?.accessToken) {\n    loggedOutView.classList.add('hidden');\n    loggedInView.classList.remove('hidden');\n    const email = session.user?.email || 'Signed in';\n    if (authUserEmail) {\n      authUserEmail.textContent = email;\n    }\n    if (accountStatus) {\n      accountStatus.textContent = email;\n      accountStatus.classList.add('signed-in');\n    }\n    setAuthMessage('Signed in', 'success');\n  } else {\n    loggedOutView.classList.remove('hidden');\n    loggedInView.classList.add('hidden');\n    if (accountStatus) {\n      accountStatus.textContent = 'Not signed in';\n      accountStatus.classList.remove('signed-in');\n    }\n    setAuthMessage('', '');\n  }\n}\n\nfunction disableAuthInputs() {\n  if (authForm) {\n    Array.from(authForm.elements).forEach((el) => {\n      el.disabled = true;\n    });\n  }\n  if (logoutButton) {\n    logoutButton.disabled = true;\n  }\n}\n\nfunction enableAuthInputs() {\n  if (authForm) {\n    Array.from(authForm.elements).forEach((el) => {\n      el.disabled = false;\n    });\n  }\n  if (logoutButton) {\n    logoutButton.disabled = false;\n  }\n}\n\nfunction initAccordions() {\n  accordionHeaders.forEach((header) => {\n    header.addEventListener('click', () => {\n      const section = header.getAttribute('data-section');\n      const content = document.getElementById(`${section}-content`);\n      const isExpanded = header.getAttribute('aria-expanded') === 'true';\n\n      // Toggle current section\n      header.setAttribute('aria-expanded', !isExpanded);\n      if (content) {\n        content.classList.toggle('collapsed', isExpanded);\n      }\n    });\n  });\n}\n\nfunction initPasswordToggle() {\n  if (!passwordToggle || !authPasswordInput) return;\n\n  const eyeOpen = passwordToggle.querySelector('.eye-open');\n  const eyeClosed = passwordToggle.querySelector('.eye-closed');\n\n  passwordToggle.addEventListener('click', () => {\n    const isPassword = authPasswordInput.type === 'password';\n    authPasswordInput.type = isPassword ? 'text' : 'password';\n\n    if (eyeOpen && eyeClosed) {\n      eyeOpen.style.display = isPassword ? 'none' : 'block';\n      eyeClosed.style.display = isPassword ? 'block' : 'none';\n    }\n\n    passwordToggle.setAttribute('aria-label', isPassword ? 'Hide password' : 'Show password');\n  });\n}\n\nfunction initForgotPassword() {\n  if (!forgotPasswordLink) return;\n\n  forgotPasswordLink.addEventListener('click', async () => {\n    const email = authEmailInput?.value?.trim();\n\n    if (!email) {\n      setAuthMessage('Enter your email address first', 'error');\n      authEmailInput?.focus();\n      return;\n    }\n\n    if (!window.LockInAuth?.resetPassword) {\n      setAuthMessage('Password reset is not available. Contact support.', 'error');\n      return;\n    }\n\n    disableAuthInputs();\n    setAuthMessage('Sending reset email...', 'success');\n\n    try {\n      await window.LockInAuth.resetPassword(email);\n      setAuthMessage('Check your email for a password reset link.', 'success');\n    } catch (error) {\n      console.error('Password reset error:', error);\n      setAuthMessage(error?.message || 'Failed to send reset email. Try again.', 'error');\n    } finally {\n      enableAuthInputs();\n    }\n  });\n}\n\nfunction initAuthSection() {\n  if (!authForm || !window.LockInAuth) {\n    return;\n  }\n\n  if (!isSupabaseConfigured()) {\n    disableAuthInputs();\n    setAuthMessage(\n      'Configure VITE_SUPABASE_URL_DEV and VITE_SUPABASE_ANON_KEY_DEV in .env, then rebuild the extension.',\n      'error',\n    );\n    return;\n  }\n\n  authTabs.forEach((tab) => {\n    tab.addEventListener('click', () => {\n      currentAuthMode = tab.getAttribute('data-mode') || 'login';\n      updateAuthModeUI();\n    });\n  });\n  updateAuthModeUI();\n\n  authForm.addEventListener('submit', async (event) => {\n    event.preventDefault();\n    const email = authEmailInput?.value?.trim();\n    const password = authPasswordInput?.value || '';\n\n    if (!email) {\n      setAuthMessage('Email is required', 'error');\n      return;\n    }\n\n    if (!password) {\n      setAuthMessage('Password is required', 'error');\n      return;\n    }\n\n    disableAuthInputs();\n    setAuthLoading(true);\n\n    const statusMsg = currentAuthMode === 'signup' ? 'Creating account...' : 'Signing you in...';\n    setAuthMessage(statusMsg, 'success');\n\n    try {\n      if (currentAuthMode === 'login') {\n        await window.LockInAuth.signInWithEmail(email, password);\n      } else {\n        await window.LockInAuth.signUpWithEmail(email, password);\n      }\n      setAuthMessage(\"You're signed in. Highlight text to start!\", 'success');\n\n      if (authPasswordInput) {\n        authPasswordInput.value = '';\n      }\n      refreshAuthView();\n    } catch (error) {\n      console.error('Lock-in auth sign-in error:', error);\n      setAuthMessage(getFriendlyAuthError(error), 'error');\n    } finally {\n      enableAuthInputs();\n      setAuthLoading(false);\n    }\n  });\n\n  if (logoutButton) {\n    logoutButton.addEventListener('click', async () => {\n      disableAuthInputs();\n      try {\n        await window.LockInAuth.signOut();\n        setAuthMessage('Signed out', 'success');\n        refreshAuthView();\n      } catch (error) {\n        console.error('Lock-in auth sign-out error:', error);\n        setAuthMessage('Failed to sign out', 'error');\n      } finally {\n        enableAuthInputs();\n      }\n    });\n  }\n\n  window.LockInAuth.onSessionChanged(() => {\n    refreshAuthView();\n  });\n\n  refreshAuthView();\n}\n\n// ============================================================================\n// Privacy Section\n// ============================================================================\n\nconst TELEMETRY_OPT_OUT_KEY = 'lockin_telemetry_disabled';\n\n/**\n * Check if this is an unpacked/development extension\n */\nfunction isDevelopmentExtension() {\n  try {\n    const manifest = chrome.runtime.getManifest();\n    // Unpacked extensions don't have update_url\n    return !manifest.update_url;\n  } catch {\n    return true;\n  }\n}\n\n/**\n * Initialize the privacy section with telemetry toggle and dev-only test button\n */\nasync function initPrivacySection() {\n  const toggle = document.getElementById('telemetry-toggle');\n  const testBtn = document.getElementById('sentry-test-button');\n\n  if (!toggle) return;\n\n  // Load current telemetry state\n  try {\n    const result = await chrome.storage.sync.get([TELEMETRY_OPT_OUT_KEY]);\n    toggle.checked = result[TELEMETRY_OPT_OUT_KEY] !== true;\n  } catch {\n    toggle.checked = true; // Default to enabled\n  }\n\n  // Save on change\n  toggle.addEventListener('change', async () => {\n    try {\n      await chrome.storage.sync.set({ [TELEMETRY_OPT_OUT_KEY]: !toggle.checked });\n      showStatus(\n        toggle.checked ? 'Error reporting enabled' : 'Error reporting disabled',\n        'success',\n      );\n    } catch (error) {\n      console.error('Failed to save telemetry preference:', error);\n      showStatus('Failed to save preference', 'error');\n    }\n  });\n\n  // Dev-only: show test button for unpacked extensions\n  if (testBtn && isDevelopmentExtension()) {\n    testBtn.style.display = 'block';\n    testBtn.addEventListener('click', () => {\n      if (window.LockInSentry && window.LockInSentry.isSentryInitialized()) {\n        const result = window.LockInSentry.sendTestEvents();\n        showStatus(result.message, result.success ? 'success' : 'error');\n      } else {\n        showStatus('Sentry not initialized - check DSN config', 'error');\n      }\n    });\n  }\n}\n\n// Initialize when popup opens\ndocument.addEventListener('DOMContentLoaded', () => {\n  initAccordions();\n  initPasswordToggle();\n  initForgotPassword();\n  initAuthSection();\n  initPrivacySection();\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\__tests__\\bootstrapInitOrder.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 15,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 15,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 22,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 22,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 23,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 23,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [572, 590], "text": "originalReadyState != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 31,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 31,
        "endColumn": 28
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createContentHelpers' has too many lines (81). Maximum allowed is 50.",
        "line": 55,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 146,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 55,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 55,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 7.",
        "line": 108,
        "column": 33,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 108,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 148,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 148,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `Promise<any>`.",
        "line": 150,
        "column": 3,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 150,
        "endColumn": 49
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (92). Maximum allowed is 50.",
        "line": 153,
        "column": 54,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 269,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 178,
        "column": 8,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 178,
        "endColumn": 10
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (23). Maximum allowed is 20.",
        "line": 224,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 268,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';\n\ntype BootstrapTestWindow = Omit<\n  typeof window,\n  'LockInContent' | 'LockInUI' | 'LockInAPI' | 'LockInLogger'\n> & {\n  LockInContent?: unknown;\n  LockInUI?: unknown;\n  LockInAPI?: unknown;\n  LockInLogger?: unknown;\n};\n\nconst originalReadyState = Object.getOwnPropertyDescriptor(document, 'readyState');\n\nfunction setReadyState(value: DocumentReadyState) {\n  Object.defineProperty(document, 'readyState', {\n    configurable: true,\n    get: () => value,\n  });\n}\n\nfunction resetReadyState() {\n  if (originalReadyState) {\n    Object.defineProperty(document, 'readyState', originalReadyState);\n  } else {\n    const mutableDocument = document as unknown as { readyState?: DocumentReadyState };\n    delete mutableDocument.readyState;\n  }\n}\n\nfunction setupChromeRuntime() {\n  const storageSync = {\n    get: vi.fn((_keys: string | string[], cb: (value: Record<string, unknown>) => void) => cb({})),\n    set: vi.fn((_data: Record<string, unknown>, cb: () => void = () => {}) => cb()),\n    remove: vi.fn((_keys: string | string[], cb: () => void = () => {}) => cb()),\n  };\n\n  const storageLocal = {\n    get: vi.fn((_keys: string | string[], cb: (value: Record<string, unknown>) => void) => cb({})),\n    set: vi.fn((_data: Record<string, unknown>, cb: () => void = () => {}) => cb()),\n    remove: vi.fn((_keys: string | string[], cb: () => void = () => {}) => cb()),\n  };\n\n  vi.stubGlobal('chrome', {\n    runtime: { id: 'test-runtime-id', lastError: null, sendMessage: vi.fn() },\n    storage: {\n      sync: storageSync,\n      local: storageLocal,\n      onChanged: { addListener: vi.fn(), removeListener: vi.fn() },\n    },\n    tabs: { sendMessage: vi.fn() },\n  });\n}\n\nfunction createContentHelpers() {\n  const logger = {\n    debug: vi.fn(),\n    info: vi.fn(),\n    warn: vi.fn(),\n    error: vi.fn(),\n  };\n\n  const state = {\n    isSidebarOpen: false,\n    currentMode: 'explain',\n    pendingPrefill: '',\n    currentActiveTab: 'chat',\n  };\n\n  const subscribers = new Set<(snapshot: typeof state) => void>();\n\n  const stateStore = {\n    subscribe: vi.fn((cb: (snapshot: typeof state) => void) => {\n      subscribers.add(cb);\n      return () => subscribers.delete(cb);\n    }),\n    startSync: vi.fn(),\n    loadInitial: vi.fn(async () => ({ ...state })),\n    getSnapshot: vi.fn(() => ({ ...state })),\n    setSidebarOpen: vi.fn(async (isOpen: boolean) => {\n      state.isSidebarOpen = isOpen;\n      subscribers.forEach((cb) => cb({ ...state }));\n    }),\n    persistMode: vi.fn(async (mode: string) => {\n      state.currentMode = mode;\n    }),\n    determineDefaultMode: vi.fn(() => state.currentMode),\n  };\n\n  const sidebarInstance = {\n    updateProps: vi.fn(),\n  };\n\n  const lockInUIFactory = {\n    createLockInSidebar: vi.fn((_props: Record<string, unknown>) => sidebarInstance),\n  };\n\n  const sidebarHost = {\n    renderSidebar: vi.fn((props: Record<string, unknown>) => {\n      lockInUIFactory.createLockInSidebar(props);\n    }),\n    updatePropsFromState: vi.fn((snapshot: typeof state) => {\n      sidebarInstance.updateProps(snapshot);\n    }),\n  };\n\n  const sessionManager = {\n    getTabId: vi.fn(async () => 7),\n    restoreSession: vi.fn(async () => {}),\n  };\n\n  const interactionController = {\n    bind: vi.fn(),\n  };\n\n  const lockInContent = {\n    logger,\n    resolveAdapterContext: vi.fn(() => ({\n      adapter: { id: 'adapter' },\n      pageContext: {\n        courseContext: { courseCode: 'ABC123', sourceUrl: 'https://example.test' },\n      },\n    })),\n    createStateStore: vi.fn(() => stateStore),\n    createSidebarHost: vi.fn(() => sidebarHost),\n    createSessionManager: vi.fn(() => sessionManager),\n    createInteractionController: vi.fn(() => interactionController),\n    storage: {},\n    messaging: {},\n  };\n\n  const apiClient = {\n    toggleNoteStar: vi.fn(),\n  };\n\n  return {\n    logger,\n    stateStore,\n    sidebarHost,\n    sessionManager,\n    interactionController,\n    lockInContent,\n    lockInUIFactory,\n    apiClient,\n  };\n}\n\nasync function loadContentScript() {\n  // @ts-expect-error - content script bundle is JS without types\n  return import('../../contentScript-react.js');\n}\n\ndescribe('contentScript-react bootstrap init order', () => {\n  beforeEach(() => {\n    vi.resetModules();\n    vi.unstubAllGlobals();\n    vi.useFakeTimers();\n  });\n\n  afterEach(() => {\n    resetReadyState();\n    vi.useRealTimers();\n  });\n\n  it('waits for a late LockInUI and still bootstraps without throwing', async () => {\n    const testWindow = window as BootstrapTestWindow;\n    const { logger, lockInContent, lockInUIFactory, apiClient, stateStore, interactionController } =\n      createContentHelpers();\n\n    setupChromeRuntime();\n    setReadyState('complete');\n\n    testWindow.LockInContent = lockInContent;\n    testWindow.LockInAPI = apiClient;\n\n    setTimeout(() => {\n      testWindow.LockInUI = lockInUIFactory;\n    }, 50);\n\n    await loadContentScript();\n    await vi.runAllTimersAsync();\n    await Promise.resolve();\n\n    expect(logger.error).not.toHaveBeenCalledWith('LockInUI not available after waiting');\n    expect(lockInContent.resolveAdapterContext).toHaveBeenCalledTimes(1);\n    expect(lockInContent.createSidebarHost).toHaveBeenCalledTimes(1);\n    expect(lockInContent.createStateStore).toHaveBeenCalledTimes(1);\n    expect(stateStore.startSync).toHaveBeenCalledTimes(1);\n    expect(lockInUIFactory.createLockInSidebar).toHaveBeenCalledTimes(1);\n    expect(interactionController.bind).toHaveBeenCalledTimes(1);\n  });\n\n  it('guards missing content runtime and succeeds once helpers appear', async () => {\n    const testWindow = window as BootstrapTestWindow;\n    const { logger, lockInContent, lockInUIFactory, apiClient, interactionController } =\n      createContentHelpers();\n\n    setupChromeRuntime();\n    setReadyState('complete');\n\n    testWindow.LockInLogger = logger;\n    delete testWindow.LockInContent;\n    delete testWindow.LockInUI;\n\n    await loadContentScript();\n    await vi.runAllTimersAsync();\n\n    expect(logger.error).toHaveBeenCalledWith('Content helpers missing on window.LockInContent');\n\n    testWindow.LockInContent = lockInContent;\n    testWindow.LockInAPI = apiClient;\n    testWindow.LockInUI = lockInUIFactory;\n\n    vi.resetModules();\n    await loadContentScript();\n    await vi.runAllTimersAsync();\n    await Promise.resolve();\n\n    expect(lockInContent.resolveAdapterContext).toHaveBeenCalledTimes(1);\n    expect(lockInUIFactory.createLockInSidebar).toHaveBeenCalledTimes(1);\n    expect(interactionController.bind).toHaveBeenCalledTimes(1);\n  });\n\n  it('is idempotent if bootstrap is triggered twice', async () => {\n    const testWindow = window as BootstrapTestWindow;\n    const { lockInContent, lockInUIFactory, apiClient, stateStore, interactionController } =\n      createContentHelpers();\n\n    setupChromeRuntime();\n    setReadyState('loading');\n\n    testWindow.LockInContent = lockInContent;\n    testWindow.LockInAPI = apiClient;\n    testWindow.LockInUI = lockInUIFactory;\n\n    const domReadyHandlers: Array<() => void> = [];\n    const originalAddEventListener = document.addEventListener;\n    vi.spyOn(document, 'addEventListener').mockImplementation(function (\n      this: Document,\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions,\n    ) {\n      if (type === 'DOMContentLoaded' && typeof listener === 'function') {\n        domReadyHandlers.push(listener as () => void);\n      }\n      return originalAddEventListener.call(this, type, listener, options);\n    });\n\n    await loadContentScript();\n\n    expect(domReadyHandlers.length).toBeGreaterThanOrEqual(1);\n\n    // Trigger bootstrap twice in quick succession\n    const handler = domReadyHandlers[0];\n    expect(handler).toBeDefined();\n    handler?.();\n    handler?.();\n\n    await vi.runAllTimersAsync();\n    await Promise.resolve();\n\n    expect(lockInContent.createStateStore).toHaveBeenCalledTimes(1);\n    expect(lockInContent.createSidebarHost).toHaveBeenCalledTimes(1);\n    expect(lockInUIFactory.createLockInSidebar).toHaveBeenCalledTimes(1);\n    expect(stateStore.subscribe).toHaveBeenCalledTimes(1);\n    expect(interactionController.bind).toHaveBeenCalledTimes(1);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\__tests__\\chromeStorage.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 45,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 45,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 48,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 48,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 51,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 51,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 54,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 54,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 57,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 57,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 60,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 60,
        "endColumn": 13
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (114). Maximum allowed is 50.",
        "line": 64,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 210,
        "endColumn": 2
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 67,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 69,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 68,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 68,
        "endColumn": 17
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 81,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 83,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 82,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 82,
        "endColumn": 17
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 91,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 95,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 94,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 94,
        "endColumn": 17
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 101,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 103,
        "endColumn": 8
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 111,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 113,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 112,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 112,
        "endColumn": 17
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 124,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 128,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 127,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 127,
        "endColumn": 17
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 136,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 138,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 137,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 137,
        "endColumn": 17
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 149,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 151,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 150,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 150,
        "endColumn": 17
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 159,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 163,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 162,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 162,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 182,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 182,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 184,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 184,
        "endColumn": 15
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 215,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 217,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 216,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 216,
        "endColumn": 17
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 228,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 230,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 229,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 229,
        "endColumn": 17
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 243,
        "column": 56,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 245,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 244,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 244,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 258,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 258,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 262,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 262,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 266,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 266,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 35,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for chromeStorage\n *\n * Tests Chrome storage adapter with mocked Chrome APIs.\n */\n\nimport { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { chromeStorage, chromeLocalStorage } from '../chromeStorage';\n\n// Mock Chrome APIs\nconst mockChromeStorageSync = {\n  get: vi.fn(),\n  set: vi.fn(),\n  remove: vi.fn(),\n};\n\nconst mockChromeStorageLocal = {\n  get: vi.fn(),\n  set: vi.fn(),\n  remove: vi.fn(),\n};\n\nconst mockChromeStorageOnChanged = {\n  addListener: vi.fn(),\n  removeListener: vi.fn(),\n};\n\n// Setup global chrome mock\nbeforeEach(() => {\n  // @ts-expect-error - Mocking Chrome APIs\n  global.chrome = {\n    storage: {\n      sync: mockChromeStorageSync,\n      local: mockChromeStorageLocal,\n      onChanged: mockChromeStorageOnChanged,\n    },\n    runtime: {\n      lastError: null,\n    },\n  };\n\n  // Reset all mocks\n  vi.clearAllMocks();\n  mockChromeStorageSync.get.mockImplementation((_keys, callback) => {\n    callback({});\n  });\n  mockChromeStorageSync.set.mockImplementation((_data, callback) => {\n    callback();\n  });\n  mockChromeStorageSync.remove.mockImplementation((_keys, callback) => {\n    callback();\n  });\n  mockChromeStorageLocal.get.mockImplementation((_keys, callback) => {\n    callback({});\n  });\n  mockChromeStorageLocal.set.mockImplementation((_data, callback) => {\n    callback();\n  });\n  mockChromeStorageLocal.remove.mockImplementation((_keys, callback) => {\n    callback();\n  });\n});\n\ndescribe('chromeStorage', () => {\n  describe('get', () => {\n    it('should get values from chrome.storage.sync', async () => {\n      mockChromeStorageSync.get.mockImplementation((_keys, callback) => {\n        callback({ key1: 'value1', key2: 'value2' });\n      });\n\n      const result = await chromeStorage.get(['key1', 'key2']);\n\n      expect(mockChromeStorageSync.get).toHaveBeenCalledWith(\n        ['key1', 'key2'],\n        expect.any(Function),\n      );\n      expect(result).toEqual({ key1: 'value1', key2: 'value2' });\n    });\n\n    it('should handle single key', async () => {\n      mockChromeStorageSync.get.mockImplementation((_key, callback) => {\n        callback({ key1: 'value1' });\n      });\n\n      const result = await chromeStorage.get('key1');\n\n      expect(result).toEqual({ key1: 'value1' });\n    });\n\n    it('should reject on Chrome runtime error', async () => {\n      mockChromeStorageSync.get.mockImplementation((_keys, callback) => {\n        // @ts-expect-error - Mocking Chrome error\n        global.chrome.runtime.lastError = { message: 'Storage error' };\n        callback({});\n      });\n\n      await expect(chromeStorage.get('key1')).rejects.toThrow('Storage error');\n    });\n\n    it('should reject on exception', async () => {\n      mockChromeStorageSync.get.mockImplementation(() => {\n        throw new Error('Unexpected error');\n      });\n\n      await expect(chromeStorage.get('key1')).rejects.toThrow('Unexpected error');\n    });\n  });\n\n  describe('set', () => {\n    it('should set values in chrome.storage.sync', async () => {\n      mockChromeStorageSync.set.mockImplementation((_data, callback) => {\n        callback();\n      });\n\n      await chromeStorage.set({ key1: 'value1', key2: 'value2' });\n\n      expect(mockChromeStorageSync.set).toHaveBeenCalledWith(\n        { key1: 'value1', key2: 'value2' },\n        expect.any(Function),\n      );\n    });\n\n    it('should reject on Chrome runtime error', async () => {\n      mockChromeStorageSync.set.mockImplementation((_data, callback) => {\n        // @ts-expect-error - Mocking Chrome error\n        global.chrome.runtime.lastError = { message: 'Storage error' };\n        callback();\n      });\n\n      await expect(chromeStorage.set({ key: 'value' })).rejects.toThrow('Storage error');\n    });\n  });\n\n  describe('remove', () => {\n    it('should remove keys from chrome.storage.sync', async () => {\n      mockChromeStorageSync.remove.mockImplementation((_keys, callback) => {\n        callback();\n      });\n\n      await chromeStorage.remove(['key1', 'key2']);\n\n      expect(mockChromeStorageSync.remove).toHaveBeenCalledWith(\n        ['key1', 'key2'],\n        expect.any(Function),\n      );\n    });\n\n    it('should handle single key', async () => {\n      mockChromeStorageSync.remove.mockImplementation((_key, callback) => {\n        callback();\n      });\n\n      await chromeStorage.remove('key1');\n\n      expect(mockChromeStorageSync.remove).toHaveBeenCalledWith('key1', expect.any(Function));\n    });\n\n    it('should reject on Chrome runtime error', async () => {\n      mockChromeStorageSync.remove.mockImplementation((_keys, callback) => {\n        // @ts-expect-error - Mocking Chrome error\n        global.chrome.runtime.lastError = { message: 'Storage error' };\n        callback();\n      });\n\n      await expect(chromeStorage.remove('key1')).rejects.toThrow('Storage error');\n    });\n  });\n\n  describe('onChanged', () => {\n    it('should subscribe to storage changes', () => {\n      const callback = vi.fn();\n      const unsubscribe = chromeStorage.onChanged(callback);\n\n      expect(mockChromeStorageOnChanged.addListener).toHaveBeenCalled();\n      expect(typeof unsubscribe).toBe('function');\n    });\n\n    it('should normalize Chrome storage change format', () => {\n      const callback = vi.fn();\n      chromeStorage.onChanged(callback);\n\n      const listener = mockChromeStorageOnChanged.addListener.mock.calls[0]?.[0];\n      expect(listener).toBeDefined();\n      listener?.(\n        {\n          key1: { oldValue: 'old', newValue: 'new' },\n          key2: { oldValue: undefined, newValue: 'added' },\n        },\n        'sync',\n      );\n\n      expect(callback).toHaveBeenCalledWith(\n        {\n          key1: { oldValue: 'old', newValue: 'new' },\n          key2: { oldValue: undefined, newValue: 'added' },\n        },\n        'sync',\n      );\n    });\n\n    it('should allow unsubscribing', () => {\n      const callback = vi.fn();\n      const unsubscribe = chromeStorage.onChanged(callback);\n\n      unsubscribe();\n\n      expect(mockChromeStorageOnChanged.removeListener).toHaveBeenCalled();\n    });\n  });\n});\n\ndescribe('chromeLocalStorage', () => {\n  describe('get', () => {\n    it('should get values from chrome.storage.local', async () => {\n      mockChromeStorageLocal.get.mockImplementation((_keys, callback) => {\n        callback({ key1: 'value1' });\n      });\n\n      const result = await chromeLocalStorage.get(['key1']);\n\n      expect(mockChromeStorageLocal.get).toHaveBeenCalledWith(['key1'], expect.any(Function));\n      expect(result).toEqual({ key1: 'value1' });\n    });\n  });\n\n  describe('set', () => {\n    it('should set values in chrome.storage.local', async () => {\n      mockChromeStorageLocal.set.mockImplementation((_data, callback) => {\n        callback();\n      });\n\n      await chromeLocalStorage.set({ key1: 'value1' });\n\n      expect(mockChromeStorageLocal.set).toHaveBeenCalledWith(\n        { key1: 'value1' },\n        expect.any(Function),\n      );\n    });\n  });\n\n  describe('remove', () => {\n    it('should remove keys from chrome.storage.local', async () => {\n      mockChromeStorageLocal.remove.mockImplementation((_keys, callback) => {\n        callback();\n      });\n\n      await chromeLocalStorage.remove(['key1']);\n\n      expect(mockChromeStorageLocal.remove).toHaveBeenCalledWith(['key1'], expect.any(Function));\n    });\n  });\n\n  describe('onChanged', () => {\n    it('should only fire for local storage changes', () => {\n      const callback = vi.fn();\n      chromeLocalStorage.onChanged(callback);\n\n      const listener = mockChromeStorageOnChanged.addListener.mock.calls[0]?.[0];\n      expect(listener).toBeDefined();\n\n      // Should ignore sync changes\n      listener?.({ key1: { newValue: 'value' } }, 'sync');\n      expect(callback).not.toHaveBeenCalled();\n\n      // Should fire for local changes\n      listener?.({ key1: { newValue: 'value' } }, 'local');\n      expect(callback).toHaveBeenCalled();\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\__tests__\\contentRuntimeSurface.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (68). Maximum allowed is 50.",
        "line": 5,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 90,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 13,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "unsafeReturn",
        "endLine": 13,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 13,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 13,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 14,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "unsafeReturn",
        "endLine": 14,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 14,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 14,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 15,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "unsafeReturn",
        "endLine": 15,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 15,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 15,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 18,
        "column": 44,
        "nodeType": "CallExpression",
        "messageId": "unsafeReturn",
        "endLine": 18,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 18,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 18,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 21,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "unsafeReturn",
        "endLine": 21,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 21,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 21,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 22,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "unsafeReturn",
        "endLine": 22,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 22,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 22,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 31,
        "column": 37,
        "nodeType": "CallExpression",
        "messageId": "unsafeReturn",
        "endLine": 31,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 31,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 31,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 36,
        "column": 41,
        "nodeType": "CallExpression",
        "messageId": "unsafeReturn",
        "endLine": 36,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 36,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 36,
        "endColumn": 43
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 17,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { beforeEach, describe, expect, it, vi } from 'vitest';\nimport { STORAGE_KEYS } from '../storage';\nimport type { LockInContentRuntime } from '../contentRuntime';\n\ndescribe('contentRuntime surface', () => {\n  let createContentRuntime: () => LockInContentRuntime;\n  let mockStorageLocalGet: ReturnType<typeof vi.fn>;\n\n  beforeEach(async () => {\n    vi.resetModules();\n\n    const mockStorageSync = {\n      get: vi.fn((_, cb) => cb({})),\n      set: vi.fn((_, cb) => cb()),\n      remove: vi.fn((_, cb) => cb()),\n    };\n\n    mockStorageLocalGet = vi.fn((_, cb) => cb({}));\n    const mockStorageLocal = {\n      get: mockStorageLocalGet,\n      set: vi.fn((_, cb) => cb()),\n      remove: vi.fn((_, cb) => cb()),\n    };\n\n    const mockOnChanged = {\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n    };\n\n    const mockRuntime = {\n      sendMessage: vi.fn((_, cb) => cb({ data: { tabId: 1 } })),\n      lastError: null,\n    };\n\n    const mockTabs = {\n      sendMessage: vi.fn((_, __, cb) => cb({})),\n    };\n\n    // @ts-expect-error - chrome is provided by the browser\n    global.chrome = {\n      storage: {\n        sync: mockStorageSync,\n        local: mockStorageLocal,\n        onChanged: mockOnChanged,\n      },\n      runtime: mockRuntime,\n      tabs: mockTabs,\n    };\n\n    ({ createContentRuntime } = await import('../contentRuntime'));\n    // ensure clean slate for window runtime\n    delete window.LockInContent;\n  });\n\n  it('exposes a versioned runtime with required keys on window', () => {\n    const runtime = createContentRuntime();\n    window.LockInContent = runtime;\n\n    expect(window.LockInContent).toBeDefined();\n    expect(runtime.__version).toBe('1.0');\n    expect(window.LockInContent.__version).toBe('1.0');\n    expect(window.LockInContent.storage).toBeDefined();\n    expect(window.LockInContent.messaging).toBeDefined();\n    expect(window.LockInContent.session).toBeDefined();\n    expect(window.LockInContent.logger).toBeDefined();\n    expect(typeof runtime.storage.getLocal).toBe('function');\n    expect(typeof runtime.messaging.types.GET_TAB_ID).toBe('string');\n    expect(typeof runtime.session.getSession).toBe('function');\n    expect(typeof runtime.logger.info).toBe('function');\n    // legacy compat surface must not exist\n    // @ts-expect-error - legacy compat removed\n    expect(window.LockInContent.Storage).toBeUndefined();\n    // @ts-expect-error - legacy compat removed\n    expect(window.LockInContent.MessageTypes).toBeUndefined();\n  });\n\n  it('provides storage helpers that can be called (regression for missing getLocal)', async () => {\n    const mockChatId = 'chat-123';\n    mockStorageLocalGet.mockImplementation(\n      (_keys: string | string[], cb: (value: Record<string, unknown>) => void) =>\n        cb({ [STORAGE_KEYS.CURRENT_CHAT_ID]: mockChatId }),\n    );\n\n    const runtime = createContentRuntime();\n    const chatId = await runtime.session.loadChatId();\n\n    expect(chatId).toBe(mockChatId);\n    expect(mockStorageLocalGet).toHaveBeenCalled();\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\__tests__\\initApiSurface.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (64). Maximum allowed is 50.",
        "line": 32,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 108,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { beforeEach, describe, expect, it, vi } from 'vitest';\n\nimport { API_CLIENT_EXPECTED_KEYS } from '@api/__tests__/expectedApiClientKeys';\nimport type { AuthClient } from '@api/auth';\nimport type { ApiClient } from '@api/client';\n\nconst AUTH_CLIENT_EXPECTED_KEYS = [\n  'signUpWithEmail',\n  'signInWithEmail',\n  'signOut',\n  'getSession',\n  'getCurrentUser',\n  'getValidAccessToken',\n  'getAccessToken',\n  'onSessionChanged',\n] as const;\n\ntype InitApiTestWindow = typeof window & {\n  LOCKIN_CONFIG?: {\n    BACKEND_URL: string;\n    SUPABASE_URL: string;\n    SUPABASE_ANON_KEY: string;\n    SESSION_STORAGE_KEY: string;\n    TOKEN_EXPIRY_BUFFER_MS: number;\n  };\n  LockInAPI?: ApiClient;\n  LockInAuth?: AuthClient;\n  apiClient?: ApiClient;\n  authClient?: AuthClient;\n};\n\ndescribe('initApi global surface', () => {\n  let testWindow: InitApiTestWindow;\n\n  beforeEach(() => {\n    vi.resetModules();\n    vi.unstubAllGlobals();\n    vi.stubGlobal('fetch', vi.fn());\n    testWindow = window as InitApiTestWindow;\n\n    const storageSync = {\n      get: vi.fn((_key, cb: (value: Record<string, unknown>) => void) => cb({})),\n      set: vi.fn((_data, cb: () => void) => cb()),\n      remove: vi.fn((_keys, cb: () => void) => cb()),\n    };\n\n    const storageLocal = {\n      get: vi.fn((_key, cb: (value: Record<string, unknown>) => void) => cb({})),\n      set: vi.fn((_data, cb: () => void) => cb()),\n      remove: vi.fn((_keys, cb: () => void) => cb()),\n    };\n\n    const onChanged = {\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n    };\n\n    vi.stubGlobal('chrome', {\n      storage: {\n        sync: storageSync,\n        local: storageLocal,\n        onChanged,\n      },\n      runtime: {\n        lastError: null,\n      },\n    });\n\n    testWindow.LOCKIN_CONFIG = {\n      BACKEND_URL: 'http://example.test',\n      SUPABASE_URL: 'https://supabase.test',\n      SUPABASE_ANON_KEY: 'anon-key',\n      SESSION_STORAGE_KEY: 'lockinSupabaseSession',\n      TOKEN_EXPIRY_BUFFER_MS: 60000,\n    };\n\n    delete testWindow.LockInAPI;\n    delete testWindow.LockInAuth;\n    delete testWindow.apiClient;\n    delete testWindow.authClient;\n  });\n\n  it('initializes and exposes stable LockInAPI/LockInAuth globals with compat aliases', async () => {\n    const { initClients } = await import('../initApi');\n    const lockInApi = testWindow.LockInAPI as ApiClient;\n    const lockInAuth = testWindow.LockInAuth as AuthClient;\n\n    expect(lockInApi).toBeDefined();\n    expect(lockInAuth).toBeDefined();\n\n    expect(Object.keys(lockInApi).sort()).toEqual([...API_CLIENT_EXPECTED_KEYS]);\n    expect(Object.keys(lockInAuth).sort()).toEqual([...AUTH_CLIENT_EXPECTED_KEYS].sort());\n\n    API_CLIENT_EXPECTED_KEYS.forEach((key) => {\n      expect(typeof lockInApi[key as keyof ApiClient]).toBe('function');\n    });\n    AUTH_CLIENT_EXPECTED_KEYS.forEach((key) => {\n      expect(typeof lockInAuth[key as keyof AuthClient]).toBe('function');\n    });\n\n    expect(testWindow.apiClient).toBe(lockInApi);\n    expect(testWindow.authClient).toBe(lockInAuth);\n\n    const { apiClient, authClient } = initClients();\n    expect(apiClient).toBe(lockInApi);\n    expect(authClient).toBe(lockInAuth);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\__tests__\\manifestOrder.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 6,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 6,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 9,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 9,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .content_scripts on an `any` value.",
        "line": 9,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 9,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 12,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 12,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 14,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 14,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [0] on an `any` value.",
        "line": 14,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "unsafeMemberExpression",
        "endLine": 14,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 17,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 17,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [0] on an `any` value.",
        "line": 37,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "unsafeMemberExpression",
        "endLine": 37,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 38,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 38,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .indexOf on an `any` value.",
        "line": 38,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 38,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 1,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `number | bigint`.",
        "line": 39,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "unsafeArgument",
        "endLine": 39,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 39,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 39,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .indexOf on an `any` value.",
        "line": 39,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 39,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 41,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 41,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .indexOf on an `any` value.",
        "line": 41,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 41,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 1,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `number | bigint`.",
        "line": 42,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "unsafeArgument",
        "endLine": 42,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 42,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 42,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .indexOf on an `any` value.",
        "line": 42,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 42,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [scripts.length - 1] on an `any` value.",
        "line": 44,
        "column": 20,
        "nodeType": "BinaryExpression",
        "messageId": "unsafeMemberExpression",
        "endLine": 44,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 44,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 44,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 20,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, expect, it } from 'vitest';\n\nimport manifestJson from '../../manifest.json';\n\ndescribe('manifest content_scripts order', () => {\n  const manifest = JSON.parse(JSON.stringify(manifestJson));\n\n  it('keeps the content_scripts js list stable and ordered', () => {\n    const contentScripts = manifest.content_scripts;\n\n    expect(Array.isArray(contentScripts)).toBe(true);\n    expect(contentScripts.length).toBeGreaterThan(0);\n\n    const scripts = contentScripts[0]?.js;\n\n    expect(Array.isArray(scripts)).toBe(true);\n    expect(scripts.length).toBeGreaterThan(0);\n\n    const expectedScripts = Object.freeze([\n      'config.js',\n      'dist/libs/sentry.js',\n      'dist/libs/initApi.js',\n      'dist/libs/contentLibs.js',\n      'content/stateStore.js',\n      'content/sidebarHost.js',\n      'content/sessionManager.js',\n      'content/interactions.js',\n      'src/networkRetry.js',\n      'content/mediaFetcher.js',\n      'dist/ui/index.js',\n      'contentScript-react.js',\n    ]);\n\n    // If you intentionally change manifest scripts/order, update this expected array.\n    expect(scripts).toEqual(expectedScripts);\n\n    expect(scripts[0]).toBe('config.js');\n    expect(scripts.indexOf('dist/libs/initApi.js')).toBeLessThan(\n      scripts.indexOf('dist/libs/contentLibs.js'),\n    );\n    expect(scripts.indexOf('dist/ui/index.js')).toBeLessThan(\n      scripts.indexOf('contentScript-react.js'),\n    );\n    expect(scripts[scripts.length - 1]).toBe('contentScript-react.js');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\__tests__\\networkRetry.test.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 9,
        "column": 19,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 9,
        "endColumn": 22
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 300.",
        "line": 9,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 9,
        "endColumn": 38
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 11,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 11,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 300.",
        "line": 11,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 11,
        "endColumn": 46
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (59). Maximum allowed is 50.",
        "line": 18,
        "column": 47,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 84,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 29,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 29,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 30,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 30,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 48,
        "column": 64,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 48,
        "endColumn": 67
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 61,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 61,
        "endColumn": 37
      },
      {
        "ruleId": "max-nested-callbacks",
        "severity": 1,
        "message": "Too many nested callbacks (4). Maximum allowed is 3.",
        "line": 69,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 73,
        "endColumn": 12
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { afterEach, describe, expect, it, vi } from 'vitest';\nimport '../networkRetry.js';\n\nconst { fetchWithRetry } = globalThis.LockInNetworkRetry;\nconst originalFetch = globalThis.fetch;\n\nfunction createResponse(status) {\n  return {\n    ok: status >= 200 && status < 300,\n    status,\n    statusText: status >= 200 && status < 300 ? 'OK' : 'Error',\n    headers: {\n      get: () => null,\n    },\n  };\n}\n\ndescribe('LockInNetworkRetry.fetchWithRetry', () => {\n  afterEach(() => {\n    if (globalThis.fetch && globalThis.fetch.mockRestore) {\n      globalThis.fetch.mockRestore();\n    }\n    globalThis.fetch = originalFetch;\n  });\n\n  it('retries retryable responses and succeeds', async () => {\n    const fetchMock = vi\n      .fn()\n      .mockResolvedValueOnce(createResponse(500))\n      .mockResolvedValueOnce(createResponse(200));\n    globalThis.fetch = fetchMock;\n\n    const response = await fetchWithRetry(\n      'https://example.com',\n      {},\n      {\n        maxRetries: 1,\n        baseDelayMs: 0,\n        maxDelayMs: 0,\n      },\n    );\n\n    expect(response.ok).toBe(true);\n    expect(fetchMock).toHaveBeenCalledTimes(2);\n  });\n\n  it('does not retry non-retryable responses', async () => {\n    const fetchMock = vi.fn().mockResolvedValue(createResponse(404));\n    globalThis.fetch = fetchMock;\n\n    const response = await fetchWithRetry(\n      'https://example.com',\n      {},\n      {\n        maxRetries: 3,\n        baseDelayMs: 0,\n        maxDelayMs: 0,\n      },\n    );\n\n    expect(response.status).toBe(404);\n    expect(fetchMock).toHaveBeenCalledTimes(1);\n  });\n\n  it('throws timeout error when request exceeds timeout', async () => {\n    const fetchMock = vi.fn((_url, options) => {\n      return new Promise((_, reject) => {\n        if (options?.signal) {\n          options.signal.addEventListener('abort', () => {\n            const error = new Error('Aborted');\n            error.name = 'AbortError';\n            reject(error);\n          });\n        }\n      });\n    });\n    globalThis.fetch = fetchMock;\n\n    await expect(\n      fetchWithRetry('https://example.com', {}, { maxRetries: 0, timeoutMs: 5 }),\n    ).rejects.toMatchObject({ code: 'TIMEOUT' });\n    expect(fetchMock).toHaveBeenCalledTimes(1);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\chromeStorage.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 19,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 19,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [638, 662], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 35,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 35,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1074, 1098], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 51,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 51,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1476, 1500], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 69,
        "column": 7,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 69,
        "endColumn": 9
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 74,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 74,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2204, 2211], "text": "change == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 76,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 76,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 77,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 77,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 101,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 101,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2950, 2974], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 117,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 117,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3387, 3411], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 133,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 133,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3790, 3814], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 151,
        "column": 7,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 151,
        "endColumn": 9
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 158,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 158,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4533, 4540], "text": "change == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 160,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 160,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 161,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 161,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 14,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Chrome Storage Adapter\n *\n * Implements StorageInterface using Chrome's storage.sync API.\n * This is the bridge between the Chrome-agnostic core code and Chrome-specific storage.\n */\n\nimport type { StorageInterface } from '../../core/storage/storageInterface';\n\n/**\n * Chrome storage implementation of StorageInterface\n * Uses chrome.storage.sync for cross-device persistence\n */\nexport const chromeStorage: StorageInterface = {\n  async get<T = unknown>(key: string | string[]): Promise<Record<string, T>> {\n    return new Promise((resolve, reject) => {\n      try {\n        chrome.storage.sync.get(key, (result) => {\n          if (chrome.runtime.lastError) {\n            reject(new Error(chrome.runtime.lastError.message));\n          } else {\n            resolve(result as Record<string, T>);\n          }\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n\n  async set<T = unknown>(data: Record<string, T>): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        chrome.storage.sync.set(data, () => {\n          if (chrome.runtime.lastError) {\n            reject(new Error(chrome.runtime.lastError.message));\n          } else {\n            resolve();\n          }\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n\n  async remove(keys: string | string[]): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        chrome.storage.sync.remove(keys, () => {\n          if (chrome.runtime.lastError) {\n            reject(new Error(chrome.runtime.lastError.message));\n          } else {\n            resolve();\n          }\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n\n  onChanged<T = unknown>(\n    callback: (changes: Record<string, { oldValue?: T; newValue?: T }>, areaName: string) => void,\n  ): () => void {\n    const listener = (\n      changes: { [key: string]: chrome.storage.StorageChange },\n      areaName: string,\n    ) => {\n      // Convert Chrome's StorageChange format to our interface format\n      const normalizedChanges: Record<string, { oldValue?: T; newValue?: T }> = {};\n      for (const key in changes) {\n        const change = changes[key];\n        if (!change) continue;\n        normalizedChanges[key] = {\n          oldValue: change.oldValue,\n          newValue: change.newValue,\n        };\n      }\n      callback(normalizedChanges, areaName);\n    };\n\n    chrome.storage.onChanged.addListener(listener);\n\n    // Return unsubscribe function\n    return () => {\n      chrome.storage.onChanged.removeListener(listener);\n    };\n  },\n};\n\n/**\n * Chrome local storage implementation\n * Uses chrome.storage.local for larger, device-specific data\n */\nexport const chromeLocalStorage: StorageInterface = {\n  async get<T = unknown>(key: string | string[]): Promise<Record<string, T>> {\n    return new Promise((resolve, reject) => {\n      try {\n        chrome.storage.local.get(key, (result) => {\n          if (chrome.runtime.lastError) {\n            reject(new Error(chrome.runtime.lastError.message));\n          } else {\n            resolve(result as Record<string, T>);\n          }\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n\n  async set<T = unknown>(data: Record<string, T>): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        chrome.storage.local.set(data, () => {\n          if (chrome.runtime.lastError) {\n            reject(new Error(chrome.runtime.lastError.message));\n          } else {\n            resolve();\n          }\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n\n  async remove(keys: string | string[]): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        chrome.storage.local.remove(keys, () => {\n          if (chrome.runtime.lastError) {\n            reject(new Error(chrome.runtime.lastError.message));\n          } else {\n            resolve();\n          }\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n\n  onChanged<T = unknown>(\n    callback: (changes: Record<string, { oldValue?: T; newValue?: T }>, areaName: string) => void,\n  ): () => void {\n    const listener = (\n      changes: { [key: string]: chrome.storage.StorageChange },\n      areaName: string,\n    ) => {\n      // Only fire for local storage changes\n      if (areaName !== 'local') return;\n\n      const normalizedChanges: Record<string, { oldValue?: T; newValue?: T }> = {};\n      for (const key in changes) {\n        const change = changes[key];\n        if (!change) continue;\n        normalizedChanges[key] = {\n          oldValue: change.oldValue,\n          newValue: change.newValue,\n        };\n      }\n      callback(normalizedChanges, areaName);\n    };\n\n    chrome.storage.onChanged.addListener(listener);\n\n    return () => {\n      chrome.storage.onChanged.removeListener(listener);\n    };\n  },\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\config.ts",
    "messages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function has too many statements (24). Maximum allowed is 20.",
        "line": 11,
        "column": 2,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 113,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 29,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 29,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [853, 871], "text": "root.LOCKIN_CONFIG != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 33,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 33,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 34,
        "column": 5,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 34,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 34,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 34,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 34,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 34,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [929, 960], "text": "(Boolean(import.meta.env['VITE_APP_ENV']))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .toLowerCase on an `any` value.",
        "line": 34,
        "column": 63,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 34,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 37,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 37,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 40,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 40,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 40,
        "column": 14,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 40,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1078, 1118],
              "text": "(Boolean(import.meta.env['VITE_SUPABASE_URL_DEV']))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 41,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 41,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 41,
        "column": 18,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 41,
        "endColumn": 63,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1143, 1188],
              "text": "(Boolean(import.meta.env['VITE_SUPABASE_ANON_KEY_DEV']))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 43,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 43,
        "endColumn": 87
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 43,
        "column": 21,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 43,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1252, 1291],
              "text": "(Boolean(import.meta.env['VITE_BACKEND_URL_DEV']))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 46,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 46,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 46,
        "column": 14,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 46,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1362, 1403],
              "text": "(Boolean(import.meta.env['VITE_SUPABASE_URL_PROD']))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 47,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 47,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 47,
        "column": 18,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 47,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1428, 1474],
              "text": "(Boolean(import.meta.env['VITE_SUPABASE_ANON_KEY_PROD']))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 49,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 51,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 50,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 50,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1547, 1587],
              "text": "(Boolean(import.meta.env['VITE_BACKEND_URL_PROD']))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 56,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 56,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 58,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 58,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1833, 1847], "text": "envConfig.url.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1833, 1847], "text": "envConfig.url === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1833, 1847], "text": "!Boolean(envConfig.url)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 61,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 61,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1946, 1964], "text": "envConfig.anonKey.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1946, 1964], "text": "envConfig.anonKey === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1946, 1964], "text": "!Boolean(envConfig.anonKey)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 67,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 67,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 73,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 73,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 83,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 83,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 90,
        "column": 5,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 90,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 92,
        "column": 5,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 92,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 93,
        "column": 5,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 93,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 94,
        "column": 5,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 94,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 100,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 100,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 101,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorAny",
        "endLine": 101,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3365, 3375], "text": "Boolean(debugValue)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 102,
        "column": 5,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 102,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 104,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 104,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 105,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorAny",
        "endLine": 105,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3483, 3492], "text": "Boolean(sentryDsn)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 106,
        "column": 5,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 106,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 1,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 112,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 112,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 37,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Extension Runtime Configuration\n *\n * Environment-aware configuration injected at build time via Vite.\n * Set VITE_APP_ENV=production for prod builds, defaults to development.\n *\n * Build commands:\n * - Development: npm run build (uses DEV Supabase)\n * - Production: VITE_APP_ENV=production npm run build (uses PROD Supabase)\n */\n(function () {\n  type LockInConfig = {\n    APP_ENV: string;\n    IS_PRODUCTION: boolean;\n    BACKEND_URL: string;\n    SUPABASE_URL: string;\n    SUPABASE_ANON_KEY: string;\n    SUPABASE_ENVIRONMENT: 'development' | 'production';\n    SESSION_STORAGE_KEY: string;\n    TOKEN_EXPIRY_BUFFER_MS: number;\n    DEBUG_PANOPTO_RESOLVER: boolean;\n    DEBUG?: string;\n    SENTRY_DSN?: string;\n  };\n\n  const root = (typeof window !== 'undefined' ? window : self) as typeof globalThis & {\n    LOCKIN_CONFIG?: LockInConfig;\n  };\n  if (root.LOCKIN_CONFIG) {\n    return;\n  }\n\n  function getAppEnv() {\n    return (import.meta.env['VITE_APP_ENV'] || 'development').toLowerCase();\n  }\n\n  function buildConfigByEnv() {\n    return {\n      development: {\n        url: import.meta.env['VITE_SUPABASE_URL_DEV'] || '',\n        anonKey: import.meta.env['VITE_SUPABASE_ANON_KEY_DEV'] || '',\n        environment: 'development',\n        backendUrl: import.meta.env['VITE_BACKEND_URL_DEV'] || 'http://localhost:3000',\n      },\n      production: {\n        url: import.meta.env['VITE_SUPABASE_URL_PROD'] || '',\n        anonKey: import.meta.env['VITE_SUPABASE_ANON_KEY_PROD'] || '',\n        environment: 'production',\n        backendUrl:\n          import.meta.env['VITE_BACKEND_URL_PROD'] ||\n          'https://lock-in-backend.australiaeast.azurecontainerapps.io',\n      },\n    } as const;\n  }\n\n  function collectMissingEnvVars(envConfig: { url: string; anonKey: string }, isProd: boolean) {\n    const missing: string[] = [];\n    if (!envConfig.url) {\n      missing.push(isProd ? 'VITE_SUPABASE_URL_PROD' : 'VITE_SUPABASE_URL_DEV');\n    }\n    if (!envConfig.anonKey) {\n      missing.push(isProd ? 'VITE_SUPABASE_ANON_KEY_PROD' : 'VITE_SUPABASE_ANON_KEY_DEV');\n    }\n    return missing;\n  }\n\n  function logMissingEnvVars(missing: string[]) {\n    if (missing.length > 0 && typeof console !== 'undefined') {\n      console.warn('[Lock-in] Missing extension env vars:', missing);\n    }\n  }\n\n  function logDevConfig(env: string, isProd: boolean, config: LockInConfig) {\n    if (!isProd && typeof console !== 'undefined') {\n      console.log('[Lock-in] Extension config loaded:', {\n        environment: env,\n        supabase: config.SUPABASE_ENVIRONMENT,\n        backendUrl: config.BACKEND_URL,\n      });\n    }\n  }\n\n  const appEnv = getAppEnv();\n  const isProduction = appEnv === 'production';\n  const configByEnv = buildConfigByEnv();\n  const supabaseConfig = isProduction ? configByEnv.production : configByEnv.development;\n  const missingEnvVars = collectMissingEnvVars(supabaseConfig, isProduction);\n\n  const runtimeConfig: LockInConfig = {\n    APP_ENV: appEnv,\n    IS_PRODUCTION: isProduction,\n    BACKEND_URL: supabaseConfig.backendUrl,\n    SUPABASE_URL: supabaseConfig.url,\n    SUPABASE_ANON_KEY: supabaseConfig.anonKey,\n    SUPABASE_ENVIRONMENT: supabaseConfig.environment,\n    SESSION_STORAGE_KEY: 'lockinSupabaseSession',\n    TOKEN_EXPIRY_BUFFER_MS: 60000,\n    DEBUG_PANOPTO_RESOLVER: !isProduction,\n  };\n  const debugValue = import.meta.env['VITE_DEBUG'];\n  if (debugValue) {\n    runtimeConfig.DEBUG = debugValue;\n  }\n  const sentryDsn = import.meta.env['VITE_SENTRY_DSN'];\n  if (sentryDsn) {\n    runtimeConfig.SENTRY_DSN = sentryDsn;\n  }\n\n  root.LOCKIN_CONFIG = runtimeConfig;\n\n  logMissingEnvVars(missingEnvVars);\n  logDevConfig(appEnv, isProduction, runtimeConfig);\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\contentLibs.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\contentRuntime.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 59,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 59,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1871, 1878], "text": "urlCode != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1871, 1878], "text": "urlCode ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1871, 1878], "text": "Boolean(urlCode)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 63,
        "column": 20,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorString",
        "endLine": 63,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1940, 1959], "text": "((dom.body?.innerText).length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1940, 1959], "text": "((dom.body?.innerText) !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1940, 1959], "text": "(Boolean((dom.body?.innerText)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 66,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 66,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2071, 2079], "text": "(bodyCode != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2071, 2079], "text": "(bodyCode ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2071, 2079], "text": "(Boolean(bodyCode))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 88,
        "column": 15,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorObject",
        "endLine": 88,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 91,
        "column": 27,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 91,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 96,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 96,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2953, 2978], "text": "courseContext.courseCode == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2954, 2978], "text": "(courseContext.courseCode ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2953, 2978], "text": "!Boolean(courseContext.courseCode)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 98,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 98,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3064, 3072], "text": "inferred != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3064, 3072], "text": "inferred ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3064, 3072], "text": "Boolean(inferred)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createSessionApi' has too many lines (62). Maximum allowed is 50.",
        "line": 165,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 231,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { logger, type Logger } from './logger';\nimport { messaging, type Messaging } from './messaging';\nimport { storage, STORAGE_KEYS, type Storage, type StorageChange } from './storage';\nimport { getAdapterForUrl, GenericAdapter } from '../../integrations';\nimport type { BaseAdapter } from '../../integrations/adapters/baseAdapter';\nimport type { PageContext } from '../../core/domain/types';\n\ntype MessageType = keyof typeof MESSAGE_TYPES;\n\nconst MESSAGE_TYPES = {\n  GET_TAB_ID: 'GET_TAB_ID',\n  GET_SESSION: 'GET_SESSION',\n  SAVE_SESSION: 'SAVE_SESSION',\n  CLEAR_SESSION: 'CLEAR_SESSION',\n  GET_SETTINGS: 'GET_SETTINGS',\n  UPDATE_SETTINGS: 'UPDATE_SETTINGS',\n} as const;\n\nexport type RuntimeStorage = Storage & {\n  getLocal: Storage['getLocal'];\n  setLocal: Storage['setLocal'];\n  removeLocal: Storage['removeLocal'];\n};\n\nexport interface RuntimeMessaging extends Messaging {\n  types: typeof MESSAGE_TYPES;\n  send: <T = unknown>(type: (typeof MESSAGE_TYPES)[MessageType], payload?: unknown) => Promise<T>;\n}\n\nexport interface RuntimeSession {\n  getTabId: () => Promise<number | null>;\n  getSession: () => Promise<unknown>;\n  clearSession: () => Promise<void>;\n  loadChatId: () => Promise<string | null>;\n}\n\nexport type LockInContentRuntime = {\n  __version: '1.0';\n  logger: Logger;\n  storage: RuntimeStorage;\n  messaging: RuntimeMessaging;\n  session: RuntimeSession;\n  resolveAdapterContext: typeof resolveAdapterContext;\n};\n\ninterface LoggerInterface {\n  error?: (...args: unknown[]) => void;\n  warn?: (...args: unknown[]) => void;\n  debug?: (...args: unknown[]) => void;\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction inferCourseCode(dom: Document, url: string): string | null {\n  const urlMatch = url.match(/\\b([A-Z]{3}\\d{4})\\b/i);\n  const urlCode = urlMatch?.[1];\n  if (urlCode) {\n    return urlCode.toUpperCase();\n  }\n\n  const bodyText = dom.body?.innerText || '';\n  const codeMatch = bodyText.match(/\\b([A-Z]{3}\\d{4})\\b/i);\n  const bodyCode = codeMatch?.[1];\n  return bodyCode ? bodyCode.toUpperCase() : null;\n}\n\nexport function resolveAdapterContext(loggerInstance?: LoggerInterface): {\n  adapter: BaseAdapter;\n  pageContext: PageContext;\n} {\n  const log = {\n    error: loggerInstance?.error ?? console.error,\n    warn: loggerInstance?.warn ?? console.warn,\n    debug: loggerInstance?.debug ?? (() => {}),\n  };\n\n  let adapter: BaseAdapter = new GenericAdapter();\n  let pageContext: PageContext = {\n    url: window.location.href,\n    title: document.title,\n    heading: document.title,\n    courseContext: { courseCode: null, sourceUrl: window.location.href },\n  };\n\n  try {\n    adapter = getAdapterForUrl(window.location.href) || adapter;\n    pageContext = adapter.getPageContext(document, window.location.href);\n\n    const courseContext = pageContext.courseContext || {\n      courseCode: null,\n      sourceUrl: window.location.href,\n    };\n\n    if (!courseContext.courseCode) {\n      const inferred = inferCourseCode(document, window.location.href);\n      if (inferred) {\n        pageContext = {\n          ...pageContext,\n          courseContext: {\n            ...courseContext,\n            courseCode: inferred,\n          },\n        };\n      }\n    }\n  } catch (error) {\n    log.error('Failed to get page context:', error);\n  }\n\n  return { adapter, pageContext };\n}\n\nfunction createStorageApi(log: Logger): RuntimeStorage {\n  return {\n    ...storage,\n    async getLocal<T = unknown>(keys: string | string[]): Promise<Record<string, T>> {\n      try {\n        return await storage.getLocal<T>(keys);\n      } catch (error) {\n        log.warn('Storage.getLocal failed:', error);\n        throw error;\n      }\n    },\n    async setLocal(key: string, value: unknown): Promise<void> {\n      try {\n        await storage.setLocal(key, value);\n      } catch (error) {\n        log.warn('Storage.setLocal failed:', error);\n        throw error;\n      }\n    },\n    async removeLocal(keys: string | string[]): Promise<void> {\n      try {\n        await storage.removeLocal(keys);\n      } catch (error) {\n        log.warn('Storage.removeLocal failed:', error);\n        throw error;\n      }\n    },\n    onChanged(\n      callback: (changes: Record<string, StorageChange>, areaName: string) => void,\n    ): () => void {\n      return storage.onChanged(callback);\n    },\n  };\n}\n\nfunction createMessagingApi(log: Logger): RuntimeMessaging {\n  return {\n    ...messaging,\n    types: MESSAGE_TYPES,\n    async send<T = unknown>(type: (typeof MESSAGE_TYPES)[MessageType], payload?: unknown) {\n      try {\n        return await messaging.sendToBackground<T>({ type, payload });\n      } catch (error) {\n        log.error('[Lock-in] Messaging send failed:', error);\n        throw error;\n      }\n    },\n  };\n}\n\nfunction createSessionApi(\n  log: Logger,\n  runtimeMessaging: RuntimeMessaging,\n  runtimeStorage: RuntimeStorage,\n): RuntimeSession {\n  let cachedTabId: number | null = null;\n\n  async function getTabId(): Promise<number | null> {\n    try {\n      const response = await runtimeMessaging.send<unknown>(runtimeMessaging.types.GET_TAB_ID);\n      const responseRecord = isRecord(response) ? response : {};\n      const dataRecord = isRecord(responseRecord['data']) ? responseRecord['data'] : {};\n      const tabId =\n        typeof dataRecord['tabId'] === 'number'\n          ? dataRecord['tabId']\n          : typeof responseRecord['tabId'] === 'number'\n            ? responseRecord['tabId']\n            : null;\n      if (typeof tabId === 'number') {\n        cachedTabId = tabId;\n        return tabId;\n      }\n      return cachedTabId;\n    } catch (error) {\n      log.error('[Lock-in] Failed to get tab ID:', error);\n      return cachedTabId;\n    }\n  }\n\n  async function getSession(): Promise<unknown> {\n    try {\n      const response = await runtimeMessaging.send<unknown>(runtimeMessaging.types.GET_SESSION);\n      const responseRecord = isRecord(response) ? response : {};\n      const dataRecord = isRecord(responseRecord['data']) ? responseRecord['data'] : {};\n      return dataRecord['session'] ?? responseRecord['session'] ?? null;\n    } catch (error) {\n      log.error('[Lock-in] Failed to get session:', error);\n      return null;\n    }\n  }\n\n  async function clearSession(): Promise<void> {\n    try {\n      await runtimeMessaging.send(runtimeMessaging.types.CLEAR_SESSION);\n    } catch (error) {\n      log.error('[Lock-in] Failed to clear session:', error);\n    }\n  }\n\n  async function loadChatId(): Promise<string | null> {\n    try {\n      const data = await runtimeStorage.getLocal<string>(STORAGE_KEYS.CURRENT_CHAT_ID);\n      const chatId = data[STORAGE_KEYS.CURRENT_CHAT_ID];\n      return typeof chatId === 'string' ? chatId : null;\n    } catch (error) {\n      log.warn('Failed to load chat ID:', error);\n      return null;\n    }\n  }\n\n  return {\n    getTabId,\n    getSession,\n    clearSession,\n    loadChatId,\n  };\n}\n\nexport function createContentRuntime(): LockInContentRuntime {\n  const runtimeLogger = logger;\n  const runtimeStorage = createStorageApi(runtimeLogger);\n  const runtimeMessaging = createMessagingApi(runtimeLogger);\n  const runtimeSession = createSessionApi(runtimeLogger, runtimeMessaging, runtimeStorage);\n\n  const runtime: LockInContentRuntime = {\n    __version: '1.0',\n    logger: runtimeLogger,\n    storage: runtimeStorage,\n    messaging: runtimeMessaging,\n    session: runtimeSession,\n    resolveAdapterContext,\n  };\n\n  return runtime;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\globals.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\initApi.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 32,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 32,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1045, 1063], "text": "(config.BACKEND_URL != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1045, 1063], "text": "(config.BACKEND_URL ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1045, 1063], "text": "(Boolean(config.BACKEND_URL))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 33,
        "column": 18,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 33,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1109, 1128], "text": "(config.SUPABASE_URL != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1109, 1128], "text": "(config.SUPABASE_URL ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1109, 1128], "text": "(Boolean(config.SUPABASE_URL))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 34,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 34,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1157, 1181], "text": "(config.SUPABASE_ANON_KEY != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1157, 1181], "text": "(config.SUPABASE_ANON_KEY ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1157, 1181], "text": "(Boolean(config.SUPABASE_ANON_KEY))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 35,
        "column": 24,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 35,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1212, 1238], "text": "(config.SESSION_STORAGE_KEY != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1212, 1238], "text": "(config.SESSION_STORAGE_KEY ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1212, 1238], "text": "(Boolean(config.SESSION_STORAGE_KEY))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 36,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 36,
        "endColumn": 63,
        "suggestions": [
          {
            "messageId": "conditionFixCompareZero",
            "fix": {
              "range": [1292, 1329],
              "text": "(Number(config.TOKEN_EXPIRY_BUFFER_MS) !== 0)"
            },
            "desc": "Change condition to check for 0 (`value !== 0`)"
          },
          {
            "messageId": "conditionFixCompareNaN",
            "fix": {
              "range": [1292, 1329],
              "text": "(!Number.isNaN(Number(config.TOKEN_EXPIRY_BUFFER_MS)))"
            },
            "desc": "Change condition to check for NaN (`!Number.isNaN(value)`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1292, 1329],
              "text": "(Boolean(Number(config.TOKEN_EXPIRY_BUFFER_MS)))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60000.",
        "line": 36,
        "column": 67,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 36,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 47,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 47,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1633, 1640], "text": "fetcher != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 72,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 72,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2304, 2311], "text": "fetcher != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 87,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 87,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2694, 2707], "text": "cachedClients != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 113,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 113,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3364, 3377], "text": "(cachedClients != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Initialize API and Auth Clients for Extension\n *\n * This file wires together the Chrome-specific storage with the Chrome-agnostic\n * API and auth clients. It is the bridge between extension code and shared code.\n *\n * This is bundled by vite.config.initApi.ts into extension/dist/libs/initApi.js (IIFE format)\n * and exposes window.LockInAuth and window.LockInAPI for use by content scripts.\n */\n\nimport { createAuthClient, type AuthClient } from '../../api/auth';\nimport { createApiClient, type ApiClient } from '../../api/client';\nimport { chromeStorage } from './chromeStorage';\n\n/**\n * Extension configuration from window.LOCKIN_CONFIG (set by config.js)\n */\nexport interface LockInConfig {\n  backendUrl: string;\n  supabaseUrl: string;\n  supabaseAnonKey: string;\n  sessionStorageKey: string;\n  tokenExpiryBufferMs: number;\n}\n\n/**\n * Get config from window (set by config.js)\n */\nexport function getConfig(): LockInConfig {\n  const config = typeof window !== 'undefined' ? (window.LOCKIN_CONFIG ?? {}) : {};\n  return {\n    backendUrl: config.BACKEND_URL || 'http://localhost:3000',\n    supabaseUrl: config.SUPABASE_URL || '',\n    supabaseAnonKey: config.SUPABASE_ANON_KEY || '',\n    sessionStorageKey: config.SESSION_STORAGE_KEY || 'lockinSupabaseSession',\n    tokenExpiryBufferMs: Number(config.TOKEN_EXPIRY_BUFFER_MS) || 60000,\n  };\n}\n\n/**\n * Initialize auth client with Chrome storage\n */\nexport function initAuthClient(): AuthClient {\n  const config = getConfig();\n  const fetcher = typeof globalThis.fetch === 'function' ? globalThis.fetch : undefined;\n  const deps: Parameters<typeof createAuthClient>[2] = {};\n  if (fetcher) {\n    deps.fetcher = fetcher;\n  }\n  return createAuthClient(\n    {\n      supabaseUrl: config.supabaseUrl,\n      supabaseAnonKey: config.supabaseAnonKey,\n      sessionStorageKey: config.sessionStorageKey,\n      tokenExpiryBufferMs: config.tokenExpiryBufferMs,\n    },\n    chromeStorage,\n    deps,\n  );\n}\n\n/**\n * Initialize API client with auth client\n */\nexport function initApiClient(authClient: AuthClient): ApiClient {\n  const config = getConfig();\n  const fetcher = typeof globalThis.fetch === 'function' ? globalThis.fetch : undefined;\n  const apiConfig: Parameters<typeof createApiClient>[0] = {\n    backendUrl: config.backendUrl,\n    authClient,\n  };\n  if (fetcher) {\n    apiConfig.fetcher = fetcher;\n  }\n  return createApiClient(apiConfig);\n}\n\n/**\n * Cached clients for singleton pattern\n */\nlet cachedClients: { authClient: AuthClient; apiClient: ApiClient } | null = null;\n\n/**\n * Initialize both clients and expose globally for backward compatibility\n */\nexport function initClients(): { authClient: AuthClient; apiClient: ApiClient } {\n  if (cachedClients) {\n    return cachedClients;\n  }\n\n  const authClient = initAuthClient();\n  const apiClient = initApiClient(authClient);\n\n  cachedClients = { authClient, apiClient };\n\n  // Expose globally for legacy code and content scripts\n  if (typeof window !== 'undefined') {\n    window.LockInAuth = authClient;\n    window.LockInAPI = apiClient;\n\n    // Also expose as authClient/apiClient for backward compatibility\n    window.authClient = authClient;\n    window.apiClient = apiClient;\n  }\n\n  return cachedClients;\n}\n\n/**\n * Get cached clients (or initialize if not cached)\n */\nexport function getClients(): { authClient: AuthClient; apiClient: ApiClient } {\n  return cachedClients || initClients();\n}\n\n// Auto-initialize when loaded in browser context\nif (typeof window !== 'undefined') {\n  initClients();\n}\n\n// Re-export types for convenience\nexport type { AuthClient } from '../../api/auth';\nexport type { ApiClient } from '../../api/client';\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\logger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\messageSchemas.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 72,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorAny",
        "endLine": 72,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1859, 1864], "text": "(Boolean(value))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createMessageValidators' has too many lines (95). Maximum allowed is 50.",
        "line": 78,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 172,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Message schema validation for background/content script messaging.\n *\n * Bundled into extension/dist/libs/messageSchemas.js and exposed as LockInMessageSchemas.\n */\n\nimport { z } from 'zod';\nimport { createRuntimeValidators, type RuntimeValidators } from './runtimeSchemas';\n\nexport type MessageValidationResult =\n  | { ok: true; payload?: Record<string, unknown> }\n  | {\n      ok: false;\n      error: string;\n      meta?: Record<string, unknown>;\n      fallback?: Record<string, unknown>;\n    };\n\ntype MessageValidator = (message: unknown) => MessageValidationResult;\n\nconst OptionalRecord = z.record(z.unknown()).nullable().optional();\nconst OptionalUnknown = z.unknown().optional();\n\nconst MessageWithPayloadSchema = z\n  .object({\n    payload: z.record(z.unknown()).optional(),\n  })\n  .passthrough();\n\nconst SessionMessageSchema = z\n  .object({\n    sessionData: OptionalUnknown,\n    payload: z.object({ sessionData: OptionalUnknown }).optional(),\n  })\n  .passthrough();\n\nconst SettingsMessageSchema = z\n  .object({\n    settings: OptionalRecord,\n    payload: z.object({ settings: OptionalRecord }).optional(),\n  })\n  .passthrough();\n\nconst VideoMessageSchema = z\n  .object({\n    video: OptionalUnknown,\n    payload: z.object({ video: OptionalUnknown }).optional(),\n  })\n  .passthrough();\n\nconst ContextMessageSchema = z\n  .object({\n    context: OptionalUnknown,\n    payload: z.object({ context: OptionalUnknown }).optional(),\n  })\n  .passthrough();\n\nconst TokenMessageSchema = z\n  .object({\n    token: z.string().optional(),\n    payload: z.object({ token: z.string().optional() }).optional(),\n  })\n  .passthrough();\n\nconst errorFromZod = (error: z.ZodError): MessageValidationResult => ({\n  ok: false,\n  error: 'Invalid message format',\n  meta: { issues: error.issues },\n});\n\nconst ensureObject = (value: unknown): Record<string, unknown> => {\n  if (value && typeof value === 'object' && !Array.isArray(value)) {\n    return value as Record<string, unknown>;\n  }\n  return {};\n};\n\nexport function createMessageValidators(): Record<string, MessageValidator> {\n  return {\n    getTabId: () => ({ ok: true }),\n    GET_TAB_ID: () => ({ ok: true }),\n    getSession: () => ({ ok: true }),\n    GET_SESSION: () => ({ ok: true }),\n    saveSession: (message) => {\n      const parsed = SessionMessageSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return {\n        ok: true,\n        payload: {\n          sessionData: parsed.data.sessionData ?? parsed.data.payload?.sessionData,\n        },\n      };\n    },\n    SAVE_SESSION: (message) => {\n      const parsed = SessionMessageSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return {\n        ok: true,\n        payload: {\n          sessionData: parsed.data.sessionData ?? parsed.data.payload?.sessionData,\n        },\n      };\n    },\n    clearSession: () => ({ ok: true }),\n    CLEAR_SESSION: () => ({ ok: true }),\n    getSettings: () => ({ ok: true }),\n    GET_SETTINGS: () => ({ ok: true }),\n    saveSettings: (message) => {\n      const parsed = SettingsMessageSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return {\n        ok: true,\n        payload: {\n          settings: ensureObject(parsed.data.settings ?? parsed.data.payload?.settings),\n        },\n      };\n    },\n    UPDATE_SETTINGS: (message) => {\n      const parsed = SettingsMessageSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return {\n        ok: true,\n        payload: {\n          settings: ensureObject(parsed.data.settings ?? parsed.data.payload?.settings),\n        },\n      };\n    },\n    extractTranscript: (message) => {\n      const parsed = VideoMessageSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return { ok: true, payload: { video: parsed.data.video ?? parsed.data.payload?.video } };\n    },\n    EXTRACT_TRANSCRIPT: (message) => {\n      const parsed = VideoMessageSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return { ok: true, payload: { video: parsed.data.video ?? parsed.data.payload?.video } };\n    },\n    DETECT_ECHO360_VIDEOS: (message) => {\n      const parsed = ContextMessageSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return {\n        ok: true,\n        payload: { context: parsed.data.context ?? parsed.data.payload?.context },\n      };\n    },\n    FETCH_PANOPTO_MEDIA_URL: (message) => {\n      const parsed = VideoMessageSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return { ok: true, payload: { video: parsed.data.video ?? parsed.data.payload?.video } };\n    },\n    TRANSCRIBE_MEDIA_AI: (message) => {\n      const parsed = MessageWithPayloadSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return { ok: true, payload: ensureObject(parsed.data.payload ?? parsed.data) };\n    },\n    MEDIA_CHUNK: (message) => {\n      const parsed = MessageWithPayloadSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return { ok: true, payload: ensureObject(parsed.data.payload) };\n    },\n    LIST_ACTIVE_TRANSCRIPT_JOBS: (message) => {\n      const parsed = TokenMessageSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return { ok: true, payload: { token: parsed.data.token ?? parsed.data.payload?.token } };\n    },\n    CANCEL_ALL_ACTIVE_TRANSCRIPT_JOBS: (message) => {\n      const parsed = TokenMessageSchema.safeParse(message);\n      if (!parsed.success) return errorFromZod(parsed.error);\n      return { ok: true, payload: { token: parsed.data.token ?? parsed.data.payload?.token } };\n    },\n  };\n}\n\nconst root = typeof globalThis !== 'undefined' ? globalThis : self;\ntype MessageSchemaRegistry = {\n  createMessageValidators: () => Record<string, MessageValidator>;\n  createRuntimeValidators?: () => RuntimeValidators;\n};\n\nconst rootWithRegistry = root as typeof globalThis & {\n  LockInMessageSchemas?: MessageSchemaRegistry;\n};\n\nconst registry: MessageSchemaRegistry = rootWithRegistry.LockInMessageSchemas ?? {\n  createMessageValidators,\n};\n\nregistry.createMessageValidators = createMessageValidators;\nregistry.createRuntimeValidators = createRuntimeValidators;\nrootWithRegistry.LockInMessageSchemas = registry;\n\nexport { registry as LockInMessageSchemas };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\messaging.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createMessaging' has too many lines (67). Maximum allowed is 50.",
        "line": 36,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 109,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 38,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "missingAsync",
        "endLine": 38,
        "endColumn": 34,
        "fix": { "range": [933, 933], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 42,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 42,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1138, 1162], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 93,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "missingAsync",
        "endLine": 93,
        "endColumn": 27,
        "fix": { "range": [2596, 2596], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 97,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 97,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2813, 2837], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "/**\n * Chrome Messaging Wrapper for Extension Content Scripts\n *\n * Provides type-safe messaging between content scripts, background script,\n * and other extension components.\n * Exposes window.LockInMessaging for use by content scripts.\n *\n * This is bundled by vite.config.contentLibs.ts into extension/dist/libs/\n */\n\nexport interface Messaging {\n  /**\n   * Send a message to the background script\n   */\n  sendToBackground: <T = unknown>(message: unknown) => Promise<T>;\n\n  /**\n   * Listen for messages from background or other parts of extension\n   */\n  onMessage: (\n    callback: (\n      message: unknown,\n      sender: chrome.runtime.MessageSender,\n    ) => unknown | Promise<unknown>,\n  ) => () => void;\n\n  /**\n   * Send message to a specific tab\n   */\n  sendToTab: <T = unknown>(tabId: number, message: unknown) => Promise<T>;\n}\n\n/**\n * Create the messaging wrapper\n */\nfunction createMessaging(): Messaging {\n  return {\n    sendToBackground<T = unknown>(message: unknown): Promise<T> {\n      return new Promise((resolve, reject) => {\n        try {\n          chrome.runtime.sendMessage(message, (response: T) => {\n            if (chrome.runtime.lastError) {\n              reject(new Error(chrome.runtime.lastError.message));\n            } else {\n              resolve(response);\n            }\n          });\n        } catch (err) {\n          reject(err);\n        }\n      });\n    },\n\n    onMessage(\n      callback: (\n        message: unknown,\n        sender: chrome.runtime.MessageSender,\n      ) => unknown | Promise<unknown>,\n    ): () => void {\n      const listener = (\n        message: unknown,\n        sender: chrome.runtime.MessageSender,\n        sendResponse: (response?: unknown) => void,\n      ): boolean | void => {\n        try {\n          const result = callback(message, sender);\n\n          if (result instanceof Promise) {\n            result.then(sendResponse).catch((err: Error) => {\n              console.error('[Lock-in] Message handler error:', err);\n              sendResponse({ error: err.message });\n            });\n            return true; // Keep channel open for async response\n          }\n\n          if (result !== undefined) {\n            sendResponse(result);\n          }\n        } catch (err) {\n          console.error('[Lock-in] Message handler error:', err);\n          sendResponse({ error: err instanceof Error ? err.message : 'Unknown error' });\n        }\n      };\n\n      chrome.runtime.onMessage.addListener(listener);\n\n      // Return unsubscribe function\n      return () => {\n        chrome.runtime.onMessage.removeListener(listener);\n      };\n    },\n\n    sendToTab<T = unknown>(tabId: number, message: unknown): Promise<T> {\n      return new Promise((resolve, reject) => {\n        try {\n          chrome.tabs.sendMessage(tabId, message, (response: T) => {\n            if (chrome.runtime.lastError) {\n              reject(new Error(chrome.runtime.lastError.message));\n            } else {\n              resolve(response);\n            }\n          });\n        } catch (err) {\n          reject(err);\n        }\n      });\n    },\n  };\n}\n\n// Create and expose messaging\nconst messaging = createMessaging();\n\n// Expose globally for content scripts\nif (typeof window !== 'undefined') {\n  window.LockInMessaging = messaging;\n}\n\nexport { messaging };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\networkRetry.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 9,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 9,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.3.",
        "line": 30,
        "column": 51,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 30,
        "endColumn": 54
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 53,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 53,
        "endColumn": 23
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 53,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 53,
        "endColumn": 41
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 53,
        "column": 56,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 53,
        "endColumn": 59
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 55,
        "column": 48,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 55,
        "endColumn": 51
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has too many lines (81). Maximum allowed is 50.",
        "line": 108,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 203,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has too many statements (48). Maximum allowed is 20.",
        "line": 108,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 203,
        "endColumn": 4
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has a complexity of 35. Maximum allowed is 15.",
        "line": 108,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 108,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n\n  const DEFAULT_RETRY_CONFIG = {\n    maxRetries: 3,\n    baseDelayMs: 500,\n    maxDelayMs: 5000,\n    timeoutMs: 30000,\n    retryableStatuses: [429],\n    retryOnServerError: true,\n    retryOnNetworkError: true,\n    retryOnTimeout: true,\n  };\n\n  function normalizeConfig(overrides) {\n    if (!overrides) return { ...DEFAULT_RETRY_CONFIG };\n    const retryableStatuses = Array.isArray(overrides.retryableStatuses)\n      ? overrides.retryableStatuses\n      : DEFAULT_RETRY_CONFIG.retryableStatuses;\n    return { ...DEFAULT_RETRY_CONFIG, ...overrides, retryableStatuses };\n  }\n\n  function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  function calculateRetryDelay(attempt, config) {\n    const exponentialDelay = config.baseDelayMs * Math.pow(2, attempt);\n    const cappedDelay = Math.min(exponentialDelay, config.maxDelayMs);\n    const jitter = cappedDelay * (Math.random() * 0.3);\n    return Math.floor(cappedDelay + jitter);\n  }\n\n  function parseRetryAfterMs(response) {\n    const value = response.headers?.get?.('retry-after');\n    if (!value) return undefined;\n\n    const seconds = Number(value);\n    if (!Number.isNaN(seconds)) {\n      return Math.max(0, seconds * 1000);\n    }\n\n    const dateMs = Date.parse(value);\n    if (!Number.isNaN(dateMs)) {\n      return Math.max(0, dateMs - Date.now());\n    }\n\n    return undefined;\n  }\n\n  function isRetryableStatus(status, config) {\n    if (status === 0) return false;\n    if (status === 401 || status === 403 || status === 404) return false;\n    if (config.retryableStatuses.includes(status)) return true;\n    if (config.retryOnServerError && status >= 500) return true;\n    return false;\n  }\n\n  function isNetworkError(error) {\n    if (!error) return false;\n    const message = error instanceof Error ? error.message : String(error);\n    return (\n      message.includes('Failed to fetch') ||\n      message.includes('NetworkError') ||\n      message.includes('Network request failed') ||\n      message.includes('ERR_NETWORK') ||\n      message.includes('ECONNRESET') ||\n      message.includes('ETIMEDOUT') ||\n      message.includes('EAI_AGAIN')\n    );\n  }\n\n  function createTimeoutError(timeoutMs, context) {\n    const label = context ? `${context} ` : '';\n    const error = new Error(`${label}timed out after ${timeoutMs}ms`);\n    error.code = 'TIMEOUT';\n    error.name = 'TimeoutError';\n    return error;\n  }\n\n  function isAbortError(error) {\n    return error instanceof Error && error.name === 'AbortError';\n  }\n\n  function shouldRetryError(error, config) {\n    if (!error) return false;\n    if (error.code === 'TIMEOUT') return config.retryOnTimeout;\n    if (error.code === 'ABORTED') return false;\n    if (isNetworkError(error)) return config.retryOnNetworkError;\n    return false;\n  }\n\n  async function withTimeout(promise, timeoutMs, context) {\n    if (!timeoutMs || timeoutMs <= 0) return promise;\n\n    let timeoutId;\n    const timeoutPromise = new Promise((_, reject) => {\n      timeoutId = setTimeout(() => reject(createTimeoutError(timeoutMs, context)), timeoutMs);\n    });\n\n    try {\n      return await Promise.race([promise, timeoutPromise]);\n    } finally {\n      if (timeoutId) clearTimeout(timeoutId);\n    }\n  }\n\n  async function fetchWithRetry(url, options = {}, configOverrides = {}) {\n    const config = normalizeConfig(configOverrides);\n    const fetcher = config.fetcher || root.fetch;\n    if (typeof fetcher !== 'function') {\n      throw new Error('Fetch implementation is required.');\n    }\n\n    const maxAttempts = Math.max(0, config.maxRetries) + 1;\n    let lastError = null;\n    let lastResponse = null;\n\n    for (let attempt = 0; attempt < maxAttempts; attempt += 1) {\n      if (options.signal?.aborted) {\n        const abortError = new Error('Request aborted');\n        abortError.name = 'AbortError';\n        throw abortError;\n      }\n\n      let timeoutId;\n      let timedOut = false;\n      const controller = new AbortController();\n      const abortFromSignal = () => controller.abort();\n\n      if (options.signal) {\n        if (options.signal.aborted) {\n          controller.abort();\n        } else {\n          options.signal.addEventListener('abort', abortFromSignal, { once: true });\n        }\n      }\n\n      if (config.timeoutMs && config.timeoutMs > 0) {\n        timeoutId = setTimeout(() => {\n          timedOut = true;\n          controller.abort();\n        }, config.timeoutMs);\n      }\n\n      try {\n        const response = await fetcher(url, { ...options, signal: controller.signal });\n        lastResponse = response;\n\n        if (response.ok || !isRetryableStatus(response.status, config)) {\n          return response;\n        }\n\n        lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);\n      } catch (error) {\n        if (isAbortError(error) && timedOut) {\n          lastError = createTimeoutError(config.timeoutMs, config.context);\n        } else {\n          lastError = error instanceof Error ? error : new Error(String(error));\n        }\n\n        if (options.signal?.aborted && !timedOut) {\n          throw lastError;\n        }\n      } finally {\n        if (timeoutId) clearTimeout(timeoutId);\n        if (options.signal) {\n          options.signal.removeEventListener('abort', abortFromSignal);\n        }\n      }\n\n      const shouldRetry =\n        lastResponse && isRetryableStatus(lastResponse.status, config)\n          ? true\n          : shouldRetryError(lastError, config);\n\n      if (!shouldRetry || attempt >= maxAttempts - 1) {\n        if (lastResponse) {\n          return lastResponse;\n        }\n        throw lastError || new Error('Request failed');\n      }\n\n      const retryAfterMs = lastResponse ? parseRetryAfterMs(lastResponse) : undefined;\n      const delayMs =\n        typeof retryAfterMs === 'number' ? retryAfterMs : calculateRetryDelay(attempt, config);\n\n      if (typeof config.onRetry === 'function') {\n        config.onRetry({\n          attempt: attempt + 1,\n          maxRetries: config.maxRetries,\n          delayMs,\n          status: lastResponse?.status,\n          error: lastError,\n        });\n      }\n\n      await sleep(delayMs);\n    }\n\n    if (lastResponse) return lastResponse;\n    throw lastError || new Error('Request failed after retries');\n  }\n\n  root.LockInNetworkRetry = {\n    DEFAULT_RETRY_CONFIG,\n    fetchWithRetry,\n    withTimeout,\n    parseRetryAfterMs,\n  };\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\networkUtils.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 10,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 10,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 34,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 34,
        "endColumn": 45
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 34,
        "column": 69,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 34,
        "endColumn": 72
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 37,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 37,
        "endColumn": 44
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 40,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 40,
        "endColumn": 44
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 43,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 43,
        "endColumn": 32
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has too many lines (68). Maximum allowed is 50.",
        "line": 63,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 143,
        "endColumn": 4
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has too many parameters (5). Maximum allowed is 4.",
        "line": 63,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 63,
        "endColumn": 32
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has too many statements (35). Maximum allowed is 20.",
        "line": 63,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 143,
        "endColumn": 4
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'fetchWithRetry' has a complexity of 17. Maximum allowed is 15.",
        "line": 63,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 63,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 167,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 167,
        "endColumn": 34
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 167,
        "column": 58,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 167,
        "endColumn": 61
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 200,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 200,
        "endColumn": 34
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 200,
        "column": 58,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 200,
        "endColumn": 61
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 233,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 233,
        "endColumn": 34
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 233,
        "column": 58,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 233,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const root = typeof globalThis !== 'undefined' ? globalThis : self;\n  const NetworkRetry = root.LockInNetworkRetry || null;\n\n  const fallbackDefaults = {\n    maxRetries: 3,\n    baseDelayMs: 500,\n    maxDelayMs: 5000,\n    timeoutMs: 30000,\n    retryableStatuses: [429],\n    retryOnServerError: true,\n    retryOnNetworkError: true,\n    retryOnTimeout: true,\n  };\n\n  const defaultConfig = NetworkRetry?.DEFAULT_RETRY_CONFIG || fallbackDefaults;\n\n  const RETRY_CONFIG = {\n    maxRetries: defaultConfig.maxRetries,\n    baseDelayMs: defaultConfig.baseDelayMs,\n    maxDelayMs: defaultConfig.maxDelayMs,\n    timeoutMs: defaultConfig.timeoutMs,\n  };\n\n  function backoffDelay(attempt) {\n    const delay = Math.min(\n      RETRY_CONFIG.baseDelayMs * Math.pow(2, attempt),\n      RETRY_CONFIG.maxDelayMs,\n    );\n    return new Promise((resolve) => setTimeout(resolve, delay));\n  }\n\n  function isRetryableError(error, response) {\n    if (response && (response.status === 401 || response.status === 403)) {\n      return false;\n    }\n    if (response && response.status === 404) {\n      return false;\n    }\n    if (!response || response.status >= 500) {\n      return true;\n    }\n    if (response.status === 429) {\n      return true;\n    }\n    return false;\n  }\n\n  function normalizeRetryConfig(maxRetriesOrConfig, timeoutMs, overrides) {\n    if (maxRetriesOrConfig && typeof maxRetriesOrConfig === 'object') {\n      return { ...defaultConfig, ...maxRetriesOrConfig };\n    }\n    const merged = { ...defaultConfig, ...(overrides || {}) };\n    if (typeof maxRetriesOrConfig === 'number') {\n      merged.maxRetries = maxRetriesOrConfig;\n    }\n    if (typeof timeoutMs === 'number') {\n      merged.timeoutMs = timeoutMs;\n    }\n    return merged;\n  }\n\n  async function fetchWithRetry(url, options = {}, maxRetriesOrConfig, timeoutMs, overrides) {\n    const config = normalizeRetryConfig(maxRetriesOrConfig, timeoutMs, overrides);\n\n    if (NetworkRetry?.fetchWithRetry) {\n      const onRetry =\n        config.onRetry ||\n        ((info) => {\n          console.log(\n            `[Lock-in] Retry attempt ${info.attempt}/${config.maxRetries} after ${info.delayMs}ms`,\n          );\n        });\n\n      return NetworkRetry.fetchWithRetry(url, options, {\n        ...config,\n        context: config.context || 'fetch',\n        onRetry,\n      });\n    }\n\n    let lastError;\n    let lastResponse;\n\n    for (let attempt = 0; attempt <= config.maxRetries; attempt += 1) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), config.timeoutMs);\n\n        const fetchOptions = {\n          ...options,\n          signal: controller.signal,\n        };\n\n        console.log(\n          `[Lock-in] Fetching (attempt ${attempt + 1}/${config.maxRetries + 1}): ${url.substring(0, 100)}...`,\n        );\n        const response = await fetch(url, fetchOptions);\n        clearTimeout(timeoutId);\n        lastResponse = response;\n\n        console.log(`[Lock-in] Response status: ${response.status} ${response.statusText}`);\n\n        if (response.ok || !isRetryableError(null, response)) {\n          return response;\n        }\n\n        lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);\n      } catch (error) {\n        lastError = error;\n        console.error(`[Lock-in] Fetch error (attempt ${attempt + 1}):`, error.message || error);\n\n        if (error.name === 'AbortError') {\n          console.warn(`[Lock-in] Request timeout after ${config.timeoutMs}ms`);\n          lastError = new Error(`Request timeout after ${config.timeoutMs}ms`);\n        } else if (error.message === 'Failed to fetch') {\n          console.warn(\n            '[Lock-in] Network error: Failed to fetch. Possible causes: CORS, DNS, or network connectivity',\n          );\n        }\n\n        if (attempt < config.maxRetries) {\n          console.log(\n            `[Lock-in] Retrying in ${RETRY_CONFIG.baseDelayMs * Math.pow(2, attempt)}ms...`,\n          );\n          await backoffDelay(attempt);\n          continue;\n        }\n      }\n\n      if (attempt < config.maxRetries && isRetryableError(lastError, lastResponse)) {\n        console.log(\n          `[Lock-in] Retrying in ${RETRY_CONFIG.baseDelayMs * Math.pow(2, attempt)}ms...`,\n        );\n        await backoffDelay(attempt);\n      }\n    }\n\n    if (lastResponse) {\n      return lastResponse;\n    }\n    throw lastError;\n  }\n\n  async function fetchWithCredentials(url) {\n    console.log('[Lock-in] fetchWithCredentials:', url.substring(0, 100));\n\n    try {\n      new URL(url);\n    } catch (e) {\n      console.error('[Lock-in] Invalid URL:', url, e);\n      throw new Error('Invalid URL provided');\n    }\n\n    const response = await fetchWithRetry(url, {\n      method: 'GET',\n      credentials: 'include',\n      mode: 'cors',\n      headers: {\n        Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Chrome Extension)',\n      },\n    });\n\n    if (!response.ok) {\n      console.error(`[Lock-in] Response not OK: ${response.status} ${response.statusText}`);\n      if (response.status === 401 || response.status === 403) {\n        throw new Error('AUTH_REQUIRED');\n      }\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const text = await response.text();\n    console.log(`[Lock-in] Fetched ${text.length} bytes successfully`);\n    return text;\n  }\n\n  async function fetchVttContent(url) {\n    console.log('[Lock-in] fetchVttContent:', url.substring(0, 100));\n\n    try {\n      new URL(url);\n    } catch (e) {\n      console.error('[Lock-in] Invalid caption URL:', url, e);\n      throw new Error('Invalid caption URL');\n    }\n\n    const response = await fetchWithRetry(url, {\n      method: 'GET',\n      credentials: 'include',\n      mode: 'cors',\n      headers: {\n        Accept: 'text/vtt,text/plain,*/*',\n        'User-Agent': 'Mozilla/5.0 (Chrome Extension)',\n      },\n    });\n\n    if (!response.ok) {\n      console.error(`[Lock-in] VTT fetch failed: ${response.status} ${response.statusText}`);\n      if (response.status === 401 || response.status === 403) {\n        throw new Error('AUTH_REQUIRED');\n      }\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const text = await response.text();\n    console.log(`[Lock-in] Fetched VTT: ${text.length} bytes`);\n    return text;\n  }\n\n  async function fetchHtmlWithRedirectInfo(url) {\n    console.log('[Lock-in] fetchHtmlWithRedirectInfo:', url.substring(0, 100));\n\n    try {\n      new URL(url);\n    } catch (e) {\n      console.error('[Lock-in] Invalid URL:', url, e);\n      throw new Error('Invalid URL provided');\n    }\n\n    const response = await fetchWithRetry(url, {\n      method: 'GET',\n      credentials: 'include',\n      mode: 'cors',\n      headers: {\n        Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Chrome Extension)',\n      },\n    });\n\n    if (!response.ok) {\n      console.error(`[Lock-in] Response not OK: ${response.status} ${response.statusText}`);\n      if (response.status === 401 || response.status === 403) {\n        throw new Error('AUTH_REQUIRED');\n      }\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const html = await response.text();\n    return {\n      html,\n      finalUrl: response.url || url,\n      redirected: response.redirected,\n      status: response.status,\n    };\n  }\n\n  if (typeof self !== 'undefined') {\n    self.LockInNetworkUtils = {\n      RETRY_CONFIG,\n      backoffDelay,\n      isRetryableError,\n      fetchWithRetry,\n      fetchWithCredentials,\n      fetchVttContent,\n      fetchHtmlWithRedirectInfo,\n    };\n  }\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\panoptoResolver.js",
    "messages": [
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Function 'resolvePanoptoContext' has a complexity of 19. Maximum allowed is 15.",
        "line": 36,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 36,
        "endColumn": 33
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'resolveCandidateMediaUrl' has too many lines (64). Maximum allowed is 50.",
        "line": 159,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 227,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 197,
        "column": 28,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 197,
        "endColumn": 31
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async method 'resolve' has too many lines (79). Maximum allowed is 50.",
        "line": 230,
        "column": 5,
        "nodeType": "Property",
        "messageId": "exceed",
        "endLine": 318,
        "endColumn": 6
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async method 'resolve' has a complexity of 20. Maximum allowed is 15.",
        "line": 230,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "complex",
        "endLine": 230,
        "endColumn": 18
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async method 'resolve' has too many statements (24). Maximum allowed is 20.",
        "line": 230,
        "column": 18,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 318,
        "endColumn": 6
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 247,
        "column": 86,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 247,
        "endColumn": 88
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const NetworkUtils =\n    typeof self !== 'undefined' && self.LockInNetworkUtils ? self.LockInNetworkUtils : null;\n  const { fetchWithCredentials } = NetworkUtils || {};\n  const TranscriptProviders =\n    typeof self !== 'undefined' && self.LockInTranscriptProviders\n      ? self.LockInTranscriptProviders\n      : null;\n  const { buildPanoptoEmbedUrl, buildPanoptoViewerUrl, extractPanoptoInfo } =\n    TranscriptProviders || {};\n\n  const Helpers =\n    typeof self !== 'undefined' && self.LockInPanoptoResolverHelpers\n      ? self.LockInPanoptoResolverHelpers\n      : {};\n  const Runtime =\n    typeof self !== 'undefined' && self.LockInPanoptoResolverRuntime\n      ? self.LockInPanoptoResolverRuntime\n      : {};\n  const Network =\n    typeof self !== 'undefined' && self.LockInPanoptoResolverNetwork\n      ? self.LockInPanoptoResolverNetwork\n      : {};\n\n  const {\n    isPanoptoResolverDebugEnabled,\n    createPanoptoResolverLogger,\n    extractPanoptoMediaCandidatesFromHtml,\n    dedupeAndSortPanoptoCandidates,\n    buildPanoptoPodcastDownloadUrl,\n    truncateUrl,\n  } = Helpers;\n  const { runPanoptoRuntimeProbe } = Runtime;\n  const { probePanoptoMediaUrl } = Network;\n\n  function resolvePanoptoContext({ tenant, deliveryId, viewerUrl, embedUrl }) {\n    let resolvedTenant = tenant;\n    let resolvedDeliveryId = deliveryId;\n    let resolvedViewerUrl = viewerUrl;\n    let resolvedEmbedUrl = embedUrl;\n\n    if (!resolvedViewerUrl || !resolvedTenant || !resolvedDeliveryId) {\n      const info = extractPanoptoInfo ? extractPanoptoInfo(embedUrl || viewerUrl || '') : null;\n      if (info) {\n        resolvedTenant = resolvedTenant || info.tenant;\n        resolvedDeliveryId = resolvedDeliveryId || info.deliveryId;\n      }\n    }\n\n    if (!resolvedViewerUrl && resolvedTenant && resolvedDeliveryId && buildPanoptoViewerUrl) {\n      resolvedViewerUrl = buildPanoptoViewerUrl(resolvedTenant, resolvedDeliveryId);\n    }\n\n    if (!resolvedEmbedUrl && resolvedTenant && resolvedDeliveryId && buildPanoptoEmbedUrl) {\n      resolvedEmbedUrl = buildPanoptoEmbedUrl(resolvedTenant, resolvedDeliveryId);\n    }\n\n    return {\n      resolvedTenant,\n      resolvedDeliveryId,\n      resolvedViewerUrl,\n      resolvedEmbedUrl,\n      primaryUrl: resolvedViewerUrl || resolvedEmbedUrl,\n    };\n  }\n\n  async function collectHtmlCandidates({ url, step, state, logger }) {\n    const started = Date.now();\n    try {\n      const html = await fetchWithCredentials(url);\n      const result = extractPanoptoMediaCandidatesFromHtml(html, url);\n      state.candidates.push(...result.candidates);\n      if (result.podcastDisabled) {\n        state.podcastDisabled = true;\n        state.disabledReason = result.disabledReason || state.disabledReason;\n      }\n      if (result.downloadEnabled) {\n        state.downloadEnabled = true;\n      }\n      logger.debug(step, {\n        status: 'ok',\n        url,\n        elapsedMs: Date.now() - started,\n        meta: {\n          candidateCount: result.candidates.length,\n          podcastDisabled: result.podcastDisabled,\n          downloadEnabled: result.downloadEnabled,\n        },\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      if (message === 'AUTH_REQUIRED') {\n        state.authRequired = true;\n      }\n      logger.debug(step, {\n        status: 'error',\n        url,\n        elapsedMs: Date.now() - started,\n        meta: { error: message },\n      });\n    }\n  }\n\n  async function collectRuntimeCandidates({ tabId, state, logger }) {\n    if (typeof runPanoptoRuntimeProbe !== 'function') {\n      return;\n    }\n    const runtime = await runPanoptoRuntimeProbe(tabId, logger);\n    state.candidates.push(...runtime.candidates);\n    if (runtime.podcastDisabled) {\n      state.podcastDisabled = true;\n      state.disabledReason = runtime.disabledReason || state.disabledReason;\n    }\n    if (runtime.downloadEnabled) {\n      state.downloadEnabled = true;\n    }\n  }\n\n  function addPodcastCandidate({ resolvedTenant, resolvedDeliveryId, state }) {\n    const podcastDownloadUrl = buildPanoptoPodcastDownloadUrl\n      ? buildPanoptoPodcastDownloadUrl(resolvedTenant, resolvedDeliveryId)\n      : null;\n    if (podcastDownloadUrl) {\n      state.candidates.push({\n        url: podcastDownloadUrl,\n        source: 'derived:podcast-download',\n      });\n    }\n  }\n\n  function buildNoCandidatesResponse({ state, primaryUrl, logger }) {\n    if (state.podcastDisabled) {\n      logger.warn('resolve', {\n        status: 'podcast-disabled',\n        url: primaryUrl,\n        meta: { disabledReason: state.disabledReason },\n      });\n      return {\n        ok: false,\n        errorCode: 'PODCAST_DISABLED',\n        message:\n          'Panopto downloads are disabled for this video. Ask your instructor to enable podcast downloads.',\n      };\n    }\n    if (state.authRequired) {\n      return {\n        ok: false,\n        errorCode: 'AUTH_REQUIRED',\n        message: 'Authentication required. Please log in to Panopto and try again.',\n      };\n    }\n    return {\n      ok: false,\n      errorCode: 'NOT_AVAILABLE',\n      message: 'No downloadable media URL found. This video may not allow downloads.',\n    };\n  }\n\n  async function resolveCandidateMediaUrl({ orderedCandidates, state, logger }) {\n    if (typeof probePanoptoMediaUrl !== 'function') {\n      return {\n        ok: false,\n        errorCode: 'NOT_AVAILABLE',\n        message: 'Panopto network probe unavailable.',\n      };\n    }\n\n    for (const candidate of orderedCandidates) {\n      const probe = await probePanoptoMediaUrl(candidate.url, logger);\n      if (probe.ok) {\n        logger.info('resolve', {\n          status: 'ok',\n          url: candidate.url,\n          finalUrl: probe.finalUrl,\n        });\n        return {\n          ok: true,\n          mediaUrl: probe.finalUrl || candidate.url,\n          mime: probe.contentType || null,\n          method: candidate.source || 'unknown',\n        };\n      }\n\n      if (probe.errorCode === 'AUTH_REQUIRED') {\n        logger.warn('resolve', {\n          status: 'auth-required',\n          url: candidate.url,\n        });\n        return {\n          ok: false,\n          errorCode: 'AUTH_REQUIRED',\n          message:\n            'Authentication required to access this Panopto download. Please log in and try again.',\n        };\n      }\n\n      if (probe.status === 403 && state.podcastDisabled) {\n        logger.warn('resolve', {\n          status: 'podcast-disabled',\n          url: candidate.url,\n          meta: { disabledReason: state.disabledReason },\n        });\n        return {\n          ok: false,\n          errorCode: 'PODCAST_DISABLED',\n          message:\n            'Panopto downloads are disabled for this video. Ask your instructor to enable podcast downloads.',\n        };\n      }\n    }\n\n    if (state.podcastDisabled) {\n      return {\n        ok: false,\n        errorCode: 'PODCAST_DISABLED',\n        message:\n          'Panopto downloads are disabled for this video. Ask your instructor to enable podcast downloads.',\n      };\n    }\n\n    return {\n      ok: false,\n      errorCode: 'NOT_ALLOWED',\n      message:\n        'Panopto denied access to the download URL. Downloads may be disabled for your account.',\n    };\n  }\n\n  const PanoptoMediaResolver = {\n    async resolve({ tenant, deliveryId, viewerUrl, embedUrl, tabId, jobId }) {\n      if (\n        typeof extractPanoptoInfo !== 'function' ||\n        typeof buildPanoptoViewerUrl !== 'function' ||\n        typeof buildPanoptoEmbedUrl !== 'function' ||\n        typeof fetchWithCredentials !== 'function' ||\n        typeof extractPanoptoMediaCandidatesFromHtml !== 'function' ||\n        typeof dedupeAndSortPanoptoCandidates !== 'function' ||\n        typeof createPanoptoResolverLogger !== 'function'\n      ) {\n        return {\n          ok: false,\n          errorCode: 'NOT_AVAILABLE',\n          message: 'Panopto helpers are unavailable.',\n        };\n      }\n\n      const resolvedJobId = jobId || `panopto-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n      const debugEnabled = isPanoptoResolverDebugEnabled ? isPanoptoResolverDebugEnabled() : false;\n      const logger = createPanoptoResolverLogger(resolvedJobId, debugEnabled);\n\n      const context = resolvePanoptoContext({ tenant, deliveryId, viewerUrl, embedUrl });\n      if (!context.primaryUrl) {\n        return {\n          ok: false,\n          errorCode: 'INVALID_VIDEO',\n          message: 'Panopto viewer URL not available.',\n        };\n      }\n\n      logger.info('start', { status: 'begin', url: context.primaryUrl });\n\n      const state = {\n        candidates: [],\n        podcastDisabled: false,\n        downloadEnabled: false,\n        disabledReason: null,\n        authRequired: false,\n      };\n\n      if (context.resolvedViewerUrl) {\n        await collectHtmlCandidates({\n          url: context.resolvedViewerUrl,\n          step: 'viewer-html',\n          state,\n          logger,\n        });\n      }\n      if (context.resolvedEmbedUrl && context.resolvedEmbedUrl !== context.resolvedViewerUrl) {\n        await collectHtmlCandidates({\n          url: context.resolvedEmbedUrl,\n          step: 'embed-html',\n          state,\n          logger,\n        });\n      }\n\n      if (state.candidates.length === 0) {\n        await collectRuntimeCandidates({ tabId, state, logger });\n      }\n\n      if (context.resolvedTenant && context.resolvedDeliveryId) {\n        addPodcastCandidate({\n          resolvedTenant: context.resolvedTenant,\n          resolvedDeliveryId: context.resolvedDeliveryId,\n          state,\n        });\n      }\n\n      const orderedCandidates = dedupeAndSortPanoptoCandidates(state.candidates);\n      if (debugEnabled && truncateUrl) {\n        logger.debug('candidates', {\n          status: 'list',\n          meta: {\n            count: orderedCandidates.length,\n            urls: orderedCandidates.map((candidate) => ({\n              url: truncateUrl(candidate.url),\n              source: candidate.source,\n            })),\n          },\n        });\n      }\n\n      if (orderedCandidates.length === 0) {\n        return buildNoCandidatesResponse({ state, primaryUrl: context.primaryUrl, logger });\n      }\n\n      return resolveCandidateMediaUrl({ orderedCandidates, state, logger });\n    },\n  };\n\n  if (typeof self !== 'undefined') {\n    self.LockInPanoptoResolver = {\n      PanoptoMediaResolver,\n    };\n  }\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\panoptoResolverHelpers.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 120.",
        "line": 50,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 50,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 120.",
        "line": 51,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 51,
        "endColumn": 33
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'extractPanoptoMediaCandidatesFromHtml' has too many statements (27). Maximum allowed is 20.",
        "line": 123,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 163,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 169,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 169,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  function getConfigValue(key, fallback) {\n    if (typeof self === 'undefined' || !self.LOCKIN_CONFIG) {\n      return fallback;\n    }\n    const value = self.LOCKIN_CONFIG[key];\n    return value === undefined || value === null || value === '' ? fallback : value;\n  }\n\n  function decodeEscapedUrl(url) {\n    return url\n      .replace(/\\\\u([0-9a-fA-F]{4})/g, (_m, hex) => String.fromCharCode(parseInt(hex, 16)))\n      .replace(/\\\\\\//g, '/')\n      .replace(/\\\\\\\\/g, '\\\\')\n      .replace(/\\\\\"/g, '\"')\n      .replace(/&amp;/g, '&')\n      .replace(/&quot;/g, '\"')\n      .replace(/&#x2F;/gi, '/')\n      .replace(/&#x3D;/gi, '=')\n      .replace(/&#39;/g, \"'\")\n      .trim();\n  }\n\n  const PANOPTO_MEDIA_EXTENSIONS = ['.mp4', '.m4a', '.mp3'];\n  const PANOPTO_MEDIA_HINTS = ['/podcast/', 'podcast', 'download'];\n\n  function parseBooleanConfig(value) {\n    if (typeof value === 'boolean') return value;\n    if (typeof value === 'number') return value !== 0;\n    if (typeof value === 'string') {\n      const normalized = value.trim().toLowerCase();\n      return ['1', 'true', 'yes', 'on', 'debug', 'trace'].includes(normalized);\n    }\n    return false;\n  }\n\n  function isPanoptoResolverDebugEnabled() {\n    const direct = getConfigValue('DEBUG_PANOPTO_RESOLVER', null);\n    if (direct !== null) return parseBooleanConfig(direct);\n    const legacy = getConfigValue('DEBUG_PANOPTO', null);\n    if (legacy !== null) return parseBooleanConfig(legacy);\n    const debug = getConfigValue('DEBUG', null);\n    if (debug !== null) return parseBooleanConfig(debug);\n    const level = getConfigValue('LOG_LEVEL', '');\n    return typeof level === 'string' && ['debug', 'trace'].includes(level.toLowerCase());\n  }\n\n  function truncateUrl(value) {\n    if (!value || typeof value !== 'string') return '';\n    if (value.length <= 120) return value;\n    return `${value.slice(0, 120)}...`;\n  }\n\n  function createPanoptoResolverLogger(jobId, debugEnabled) {\n    const prefix = '[Lock-in PanoptoResolver]';\n    const startMs = Date.now();\n\n    const log = (level, step, data, always) => {\n      if (!always && !debugEnabled) return;\n      const elapsedMs =\n        data && typeof data.elapsedMs === 'number' ? data.elapsedMs : Date.now() - startMs;\n      const status = data && data.status ? ` status=${data.status}` : '';\n      const url = data && data.url ? ` url=${truncateUrl(data.url)}` : '';\n      const finalUrl = data && data.finalUrl ? ` finalUrl=${truncateUrl(data.finalUrl)}` : '';\n      const meta = data && data.meta ? data.meta : null;\n      const line = `${prefix} jobId=${jobId} step=${step}${status}${url}${finalUrl} ms=${elapsedMs}`;\n      if (meta) {\n        console[level](line, meta);\n      } else {\n        console[level](line);\n      }\n    };\n\n    return {\n      debug: (step, data) => log('debug', step, data, false),\n      info: (step, data) => log('info', step, data, true),\n      warn: (step, data) => log('warn', step, data, true),\n      error: (step, data) => log('error', step, data, true),\n      isDebugEnabled: () => debugEnabled,\n    };\n  }\n\n  function buildPanoptoPodcastDownloadUrl(tenant, deliveryId) {\n    if (!tenant || !deliveryId) return null;\n    const url = new URL(\n      `https://${tenant}/Panopto/Podcast/Download/${encodeURIComponent(deliveryId)}.mp4`,\n    );\n    url.searchParams.set('mediaTargetType', 'videoPodcast');\n    return url.toString();\n  }\n\n  function looksLikePanoptoMediaUrl(url) {\n    if (!url) return false;\n    const lower = url.toLowerCase();\n    if (lower.startsWith('blob:') || lower.startsWith('data:')) {\n      return false;\n    }\n    if (lower.includes('.m3u8')) {\n      return false;\n    }\n    if (PANOPTO_MEDIA_EXTENSIONS.some((ext) => lower.includes(ext))) {\n      return true;\n    }\n    return PANOPTO_MEDIA_HINTS.some((hint) => lower.includes(hint));\n  }\n\n  function normalizePanoptoCandidateUrl(rawUrl, baseUrl) {\n    if (!rawUrl) return null;\n    let cleaned = rawUrl;\n    if (rawUrl.includes('\\\\u')) {\n      cleaned = decodeEscapedUrl(rawUrl);\n    }\n\n    try {\n      const url = new URL(cleaned, baseUrl);\n      url.hash = '';\n      return url.toString();\n    } catch {\n      return null;\n    }\n  }\n\n  function extractPanoptoMediaCandidatesFromHtml(html, baseUrl) {\n    const candidates = [];\n    let podcastDisabled = false;\n    let downloadEnabled = false;\n    let disabledReason = null;\n\n    if (!html || typeof html !== 'string') {\n      return { candidates, podcastDisabled, downloadEnabled, disabledReason };\n    }\n\n    const urlMatches = html.match(/https?:\\/\\/[^\"'\\\\s<>]+/gi) || [];\n    for (const match of urlMatches) {\n      if (!looksLikePanoptoMediaUrl(match)) continue;\n      const normalized = normalizePanoptoCandidateUrl(match, baseUrl);\n      if (normalized) {\n        candidates.push({ url: normalized, source: 'html:url' });\n      }\n    }\n\n    const jsonMatches = html.match(/\"(?:DownloadUrl|downloadUrl)\"\\s*:\\s*\"([^\"]+)\"/gi) || [];\n    for (const match of jsonMatches) {\n      const [, urlRaw] = match.match(/\"([^\"]+)\"/) || [];\n      if (!urlRaw) continue;\n      const decoded = decodeEscapedUrl(urlRaw);\n      if (!looksLikePanoptoMediaUrl(decoded)) continue;\n      const normalized = normalizePanoptoCandidateUrl(decoded, baseUrl);\n      if (normalized) {\n        candidates.push({ url: normalized, source: 'html:json' });\n      }\n    }\n\n    if (/PodcastDownloadEnabled\\s*:\\s*false/i.test(html)) {\n      podcastDisabled = true;\n      disabledReason = 'Podcast downloads disabled';\n    }\n    if (/DownloadEnabled\\s*:\\s*true/i.test(html)) {\n      downloadEnabled = true;\n    }\n\n    return { candidates, podcastDisabled, downloadEnabled, disabledReason };\n  }\n\n  function scorePanoptoCandidate(candidate) {\n    if (!candidate?.url) return 0;\n    const url = candidate.url.toLowerCase();\n    let score = 0;\n    if (url.includes('/podcast/')) score += 3;\n    if (url.includes('download')) score += 2;\n    if (url.endsWith('.mp4')) score += 2;\n    if (url.endsWith('.m4a') || url.endsWith('.mp3')) score += 1;\n    if (candidate.source && candidate.source.includes('derived')) score += 1;\n    return score;\n  }\n\n  function dedupeAndSortPanoptoCandidates(candidates) {\n    const seen = new Set();\n    const deduped = [];\n    for (const candidate of candidates) {\n      const url = candidate?.url;\n      if (!url || seen.has(url)) continue;\n      seen.add(url);\n      deduped.push(candidate);\n    }\n    return deduped.sort((a, b) => scorePanoptoCandidate(b) - scorePanoptoCandidate(a));\n  }\n\n  if (typeof self !== 'undefined') {\n    self.LockInPanoptoResolverHelpers = {\n      getConfigValue,\n      decodeEscapedUrl,\n      parseBooleanConfig,\n      isPanoptoResolverDebugEnabled,\n      truncateUrl,\n      createPanoptoResolverLogger,\n      buildPanoptoPodcastDownloadUrl,\n      looksLikePanoptoMediaUrl,\n      normalizePanoptoCandidateUrl,\n      extractPanoptoMediaCandidatesFromHtml,\n      scorePanoptoCandidate,\n      dedupeAndSortPanoptoCandidates,\n    };\n  }\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\panoptoResolverNetwork.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 401.",
        "line": 10,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 10,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 403.",
        "line": 10,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 10,
        "endColumn": 44
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'probePanoptoMediaUrl' has too many lines (73). Maximum allowed is 50.",
        "line": 13,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 93,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'probePanoptoMediaUrl' has too many statements (23). Maximum allowed is 20.",
        "line": 13,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 93,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  const NetworkUtils =\n    typeof self !== 'undefined' && self.LockInNetworkUtils ? self.LockInNetworkUtils : null;\n  const { fetchWithRetry } = NetworkUtils || {};\n\n  const PANOPTO_RESOLVER_TIMEOUT_MS = 15000;\n  const PANOPTO_RESOLVER_RANGE_HEADER = 'bytes=0-0';\n\n  function isAuthStatus(status) {\n    return status === 401 || status === 403;\n  }\n\n  async function probePanoptoMediaUrl(url, logger) {\n    const started = Date.now();\n    try {\n      if (typeof fetchWithRetry !== 'function') {\n        throw new Error('Network utilities unavailable');\n      }\n      const response = await fetchWithRetry(\n        url,\n        {\n          method: 'GET',\n          credentials: 'include',\n          redirect: 'follow',\n          headers: {\n            Range: PANOPTO_RESOLVER_RANGE_HEADER,\n            Accept: 'video/*,audio/*,*/*',\n          },\n        },\n        1,\n        PANOPTO_RESOLVER_TIMEOUT_MS,\n      );\n\n      const status = response.status;\n      const contentType = response.headers.get('content-type') || '';\n      const contentRange = response.headers.get('content-range') || '';\n      const finalUrl = response.url || url;\n\n      if (response.body && typeof response.body.cancel === 'function') {\n        try {\n          response.body.cancel();\n        } catch {\n          // Ignore stream cancel errors\n        }\n      }\n\n      logger.debug('range-probe', {\n        url,\n        finalUrl,\n        elapsedMs: Date.now() - started,\n        meta: {\n          status,\n          contentType,\n          contentRange,\n        },\n      });\n\n      if (isAuthStatus(status)) {\n        return {\n          ok: false,\n          status,\n          errorCode: 'AUTH_REQUIRED',\n          finalUrl,\n          contentType,\n        };\n      }\n\n      if (!response.ok) {\n        return { ok: false, status, finalUrl, contentType };\n      }\n\n      if (contentType.toLowerCase().includes('text/html')) {\n        return {\n          ok: false,\n          status,\n          errorCode: 'AUTH_REQUIRED',\n          finalUrl,\n          contentType,\n        };\n      }\n\n      return { ok: true, status, finalUrl, contentType };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.debug('range-probe', {\n        status: 'error',\n        url,\n        elapsedMs: Date.now() - started,\n        meta: { error: message },\n      });\n      return { ok: false, error: message };\n    }\n  }\n\n  if (typeof self !== 'undefined') {\n    self.LockInPanoptoResolverNetwork = {\n      isAuthStatus,\n      probePanoptoMediaUrl,\n    };\n  }\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\panoptoResolverRuntime.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'panoptoRuntimeProbe' has too many lines (145). Maximum allowed is 50.",
        "line": 2,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 162,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'panoptoRuntimeProbe' has too many statements (31). Maximum allowed is 20.",
        "line": 2,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 162,
        "endColumn": 4
      },
      {
        "ruleId": "no-script-url",
        "severity": 1,
        "message": "Script URL is a form of eval.",
        "line": 20,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "unexpectedScriptURL",
        "endLine": 20,
        "endColumn": 55
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 147,
        "column": 65,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 147,
        "endColumn": 67
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'runPanoptoRuntimeProbe' has too many lines (64). Maximum allowed is 50.",
        "line": 191,
        "column": 3,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 258,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "(() => {\n  function panoptoRuntimeProbe() {\n    const candidates = [];\n    const seen = new Set();\n    let podcastDisabled = false;\n    let downloadEnabled = false;\n    let disabledReason = null;\n\n    const decodeEscaped = (value) =>\n      value\n        .replace(/\\\\u([0-9a-fA-F]{4})/g, (_m, hex) => String.fromCharCode(parseInt(hex, 16)))\n        .replace(/\\\\\\//g, '/')\n        .replace(/\\\\\\\\/g, '\\\\')\n        .replace(/\\\\\"/g, '\"')\n        .trim();\n\n    const normalizeUrl = (rawUrl) => {\n      if (!rawUrl) return null;\n      const decoded = decodeEscaped(rawUrl);\n      if (!decoded || decoded.startsWith('javascript:')) return null;\n      try {\n        return new URL(decoded, window.location.href).toString();\n      } catch {\n        return decoded;\n      }\n    };\n\n    const looksLikeMediaUrl = (url) => {\n      if (!url) return false;\n      const lower = url.toLowerCase();\n      if (lower.startsWith('blob:') || lower.startsWith('data:')) return false;\n      if (lower.includes('.m3u8')) return false;\n      if (['.mp4', '.m4a', '.mp3'].some((ext) => lower.includes(ext))) {\n        return true;\n      }\n      return ['/podcast/', 'podcast', 'download'].some((hint) => lower.includes(hint));\n    };\n\n    const addCandidate = (rawUrl, source) => {\n      const normalized = normalizeUrl(rawUrl);\n      if (!normalized || !looksLikeMediaUrl(normalized)) return;\n      if (seen.has(normalized)) return;\n      seen.add(normalized);\n      candidates.push({ url: normalized, source });\n    };\n\n    const metaTags = document.querySelectorAll(\n      'meta[property=\"og:video\"], meta[property=\"og:video:secure_url\"], meta[name=\"og:video\"], meta[name=\"og:video:secure_url\"]',\n    );\n    metaTags.forEach((meta) => {\n      const content = meta.getAttribute('content');\n      if (content) {\n        addCandidate(content, 'runtime:og:video');\n      }\n    });\n\n    const dataUrlNodes = document.querySelectorAll(\n      '[data-podcast-url], [data-download-url], [data-stream-url], [data-video-url]',\n    );\n    dataUrlNodes.forEach((node) => {\n      const attrs = ['data-podcast-url', 'data-download-url', 'data-stream-url', 'data-video-url'];\n      attrs.forEach((attr) => {\n        const value = node.getAttribute(attr);\n        if (value) {\n          addCandidate(value, 'runtime:data-url');\n        }\n      });\n    });\n\n    const anchors = document.querySelectorAll('a[href]');\n    anchors.forEach((anchor) => {\n      const href = anchor.getAttribute('href');\n      if (href && /podcast|download/i.test(href)) {\n        addCandidate(href, 'runtime:link');\n      }\n    });\n\n    const downloadControls = document.querySelectorAll(\n      '[aria-label*=\"Download\" i], [title*=\"Download\" i], [data-tooltip*=\"Download\" i]',\n    );\n    downloadControls.forEach((control) => {\n      const ariaDisabled = control.getAttribute('aria-disabled');\n      const isDisabled = control.hasAttribute('disabled') || ariaDisabled === 'true';\n      if (isDisabled && !podcastDisabled) {\n        podcastDisabled = true;\n        disabledReason = 'download-control-disabled';\n      }\n    });\n\n    const rootObjects = [\n      { name: 'Panopto', value: window.Panopto },\n      { name: 'panopto', value: window.panopto },\n      { name: 'PanoptoViewer', value: window.PanoptoViewer },\n      { name: '__PANOPTO_STATE__', value: window.__PANOPTO_STATE__ },\n      { name: '__INITIAL_STATE__', value: window.__INITIAL_STATE__ },\n    ];\n\n    const visited = new WeakSet();\n    const maxDepth = 4;\n    let inspected = 0;\n    const maxNodes = 1500;\n\n    const scan = (value, path, depth) => {\n      if (!value || typeof value !== 'object') return;\n      if (visited.has(value)) return;\n      if (inspected > maxNodes) return;\n      visited.add(value);\n      inspected += 1;\n      if (depth > maxDepth) return;\n\n      Object.keys(value).forEach((key) => {\n        try {\n          const next = value[key];\n          const nextPath = `${path}.${key}`;\n          if (typeof next === 'string') {\n            if (looksLikeMediaUrl(next)) {\n              addCandidate(next, `runtime:${nextPath}`);\n            }\n          } else if (typeof next === 'boolean') {\n            const lowerKey = key.toLowerCase();\n            if (lowerKey.includes('download') || lowerKey.includes('podcast')) {\n              if (next === false && !podcastDisabled) {\n                podcastDisabled = true;\n                disabledReason = `state:${nextPath}`;\n              }\n              if (next === true) {\n                downloadEnabled = true;\n              }\n            }\n          } else if (typeof next === 'object' && next) {\n            scan(next, nextPath, depth + 1);\n          }\n        } catch {\n          // Ignore access errors\n        }\n      });\n    };\n\n    rootObjects.forEach((root) => {\n      if (root.value && typeof root.value === 'object') {\n        scan(root.value, root.name, 0);\n      }\n    });\n\n    if (typeof performance !== 'undefined' && performance.getEntriesByType) {\n      const entries = performance.getEntriesByType('resource');\n      for (let i = 0; i < entries.length && candidates.length < 20; i += 1) {\n        const entry = entries[i];\n        if (entry && typeof entry.name === 'string' && looksLikeMediaUrl(entry.name)) {\n          addCandidate(entry.name, 'runtime:perf');\n        }\n      }\n    }\n\n    return {\n      pageUrl: window.location.href,\n      candidates,\n      podcastDisabled,\n      downloadEnabled,\n      disabledReason,\n    };\n  }\n\n  function executeScriptInTab(tabId, func) {\n    return new Promise((resolve, reject) => {\n      if (\n        typeof chrome === 'undefined' ||\n        !chrome.scripting ||\n        typeof chrome.scripting.executeScript !== 'function'\n      ) {\n        reject(new Error('chrome.scripting.executeScript unavailable'));\n        return;\n      }\n      chrome.scripting.executeScript(\n        {\n          target: { tabId, allFrames: true },\n          world: 'MAIN',\n          func,\n        },\n        (results) => {\n          if (chrome.runtime.lastError) {\n            reject(new Error(chrome.runtime.lastError.message));\n            return;\n          }\n          resolve(results || []);\n        },\n      );\n    });\n  }\n\n  async function runPanoptoRuntimeProbe(tabId, logger) {\n    if (!tabId) {\n      logger.debug('runtime-probe', {\n        status: 'skipped',\n        meta: { reason: 'no-tab-id' },\n      });\n      return { candidates: [], podcastDisabled: false, downloadEnabled: false };\n    }\n\n    const started = Date.now();\n    try {\n      const results = await executeScriptInTab(tabId, panoptoRuntimeProbe);\n      const candidates = [];\n      let podcastDisabled = false;\n      let downloadEnabled = false;\n      let disabledReason = null;\n      let frameCount = 0;\n\n      results.forEach((entry) => {\n        const data = entry && entry.result ? entry.result : null;\n        if (!data || !data.candidates) return;\n        const pageUrl = typeof data.pageUrl === 'string' ? data.pageUrl : '';\n        if (pageUrl && !pageUrl.includes('panopto')) return;\n        frameCount += 1;\n        data.candidates.forEach((candidate) => {\n          if (!candidate || !candidate.url) return;\n          candidates.push({\n            url: candidate.url,\n            source: candidate.source || 'runtime',\n            frameUrl: pageUrl,\n          });\n        });\n        if (data.podcastDisabled) {\n          podcastDisabled = true;\n          disabledReason = data.disabledReason || disabledReason;\n        }\n        if (data.downloadEnabled) {\n          downloadEnabled = true;\n        }\n      });\n\n      logger.debug('runtime-probe', {\n        status: 'ok',\n        elapsedMs: Date.now() - started,\n        meta: {\n          frameCount,\n          candidateCount: candidates.length,\n          podcastDisabled,\n          downloadEnabled,\n        },\n      });\n\n      return { candidates, podcastDisabled, downloadEnabled, disabledReason };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.warn('runtime-probe', {\n        status: 'error',\n        elapsedMs: Date.now() - started,\n        meta: { error: message },\n      });\n      return {\n        candidates: [],\n        podcastDisabled: false,\n        downloadEnabled: false,\n        error: message,\n      };\n    }\n  }\n\n  if (typeof self !== 'undefined') {\n    self.LockInPanoptoResolverRuntime = {\n      runPanoptoRuntimeProbe,\n    };\n  }\n})();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\runtimeSchemas.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 107,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 107,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\n\nexport type ValidationResult<T> =\n  | { ok: true; value: T }\n  | { ok: false; error: string; issues?: z.ZodIssue[]; fallback: T };\n\nconst SettingsSchema = z\n  .object({\n    preferredLanguage: z.string().min(1).optional(),\n  })\n  .passthrough();\n\nconst SessionSchema = z\n  .object({\n    chatId: z.string().min(1).optional().nullable(),\n    mode: z.enum(['explain', 'general']).optional(),\n    selection: z.string().optional().nullable(),\n    origin: z.string().optional().nullable(),\n    isActive: z.boolean().optional(),\n    isClosed: z.boolean().optional(),\n    chatHistory: z.array(z.unknown()).optional(),\n    updatedAt: z.number().optional(),\n  })\n  .passthrough()\n  .transform((data) => ({\n    ...data,\n    chatHistory: Array.isArray(data.chatHistory) ? data.chatHistory : [],\n  }));\n\nconst AuthSessionSchema = z\n  .object({\n    accessToken: z.string().min(1),\n    refreshToken: z.string().min(1),\n    expiresAt: z.number(),\n    tokenType: z.string().min(1),\n    user: z.record(z.unknown()).nullable().optional(),\n  })\n  .passthrough();\n\nconst SupabaseTokenResponseSchema = z\n  .object({\n    access_token: z.string().optional(),\n    refresh_token: z.string().optional(),\n    expires_in: z.number().int().positive().optional(),\n    token_type: z.string().optional(),\n    user: z.record(z.unknown()).nullable().optional(),\n  })\n  .passthrough();\n\nconst TranscriptJobSchema = z\n  .object({\n    id: z.string().nullable().optional(),\n    status: z.string().optional(),\n    error: z.unknown().optional(),\n    transcript: z.unknown().optional(),\n    cached: z.boolean().optional(),\n    fingerprint: z.string().optional(),\n    mediaUrl: z.string().optional(),\n    createdAt: z.string().optional(),\n    updatedAt: z.string().optional(),\n  })\n  .passthrough();\n\nconst TranscriptJobResponseSchema = z\n  .object({\n    success: z.boolean(),\n    job: TranscriptJobSchema.optional(),\n    jobId: z.string().optional(),\n  })\n  .passthrough();\n\nconst TranscriptJobListResponseSchema = z\n  .object({\n    success: z.boolean(),\n    jobs: z.array(TranscriptJobSchema).optional(),\n    count: z.number().optional(),\n    limit: z.number().optional(),\n  })\n  .passthrough();\n\nconst TranscriptCancelAllResponseSchema = z\n  .object({\n    success: z.boolean(),\n    canceledCount: z.number().optional(),\n    canceledIds: z.array(z.string()).optional(),\n  })\n  .passthrough();\n\nfunction safeParse<T>(\n  schema: z.ZodType<T>,\n  value: unknown,\n  error: string,\n  fallback: T,\n): ValidationResult<T> {\n  const result = schema.safeParse(value);\n  if (result.success) {\n    return { ok: true, value: result.data };\n  }\n  return {\n    ok: false,\n    error,\n    issues: result.error.issues,\n    fallback,\n  };\n}\n\nexport function createRuntimeValidators() {\n  return {\n    validateSettings: (value: unknown) =>\n      safeParse(SettingsSchema, value, 'Invalid settings payload', {}),\n    validateSession: (value: unknown) =>\n      safeParse(SessionSchema, value, 'Invalid session payload', {\n        chatHistory: [],\n      }),\n    validateAuthSession: (value: unknown) =>\n      safeParse(AuthSessionSchema, value, 'Invalid auth session payload', {\n        accessToken: '',\n        refreshToken: '',\n        expiresAt: 0,\n        tokenType: 'bearer',\n        user: null,\n      }),\n    validateSupabaseTokenResponse: (value: unknown) =>\n      safeParse(SupabaseTokenResponseSchema, value, 'Invalid Supabase token response', {}),\n    validateTranscriptJobResponse: (value: unknown) =>\n      safeParse(TranscriptJobResponseSchema, value, 'Invalid transcript job response', {\n        success: false,\n      }),\n    validateTranscriptJob: (value: unknown) =>\n      safeParse(TranscriptJobSchema, value, 'Invalid transcript job payload', {}),\n    validateTranscriptJobListResponse: (value: unknown) =>\n      safeParse(TranscriptJobListResponseSchema, value, 'Invalid transcript job list response', {\n        success: false,\n        jobs: [],\n      }),\n    validateTranscriptCancelAllResponse: (value: unknown) =>\n      safeParse(\n        TranscriptCancelAllResponseSchema,\n        value,\n        'Invalid transcript bulk cancel response',\n        { success: false, canceledIds: [] },\n      ),\n  };\n}\n\nexport type RuntimeValidators = ReturnType<typeof createRuntimeValidators>;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\sentry.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 118,
        "column": 13,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 118,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3845, 3866], "text": "(manifest?.update_url) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3846, 3866], "text": "((manifest?.update_url) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3845, 3866], "text": "!Boolean((manifest?.update_url))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 140,
        "column": 7,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 140,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 150,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 150,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [4970, 4984], "text": "(BUILD_TIME_DSN.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [4970, 4984], "text": "(BUILD_TIME_DSN !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4970, 4984], "text": "(Boolean(BUILD_TIME_DSN))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 156,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 156,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5242, 5251], "text": "(configDsn != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5242, 5251], "text": "(configDsn ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5242, 5251], "text": "(Boolean(configDsn))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 168,
        "column": 12,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorString",
        "endLine": 168,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": {
              "range": [5472, 5530],
              "text": "((globalWithChrome.chrome?.runtime?.getManifest?.()?.version).length > 0)"
            },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": {
              "range": [5472, 5530],
              "text": "((globalWithChrome.chrome?.runtime?.getManifest?.()?.version) !== \"\")"
            },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [5472, 5530],
              "text": "(Boolean((globalWithChrome.chrome?.runtime?.getManifest?.()?.version)))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 185,
        "column": 10,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorObject",
        "endLine": 185,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 201,
        "column": 9,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorObject",
        "endLine": 201,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 217,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 217,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6953, 6957], "text": "(url == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6954, 6957], "text": "(url ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6953, 6957], "text": "(!Boolean(url))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 227,
        "column": 13,
        "nodeType": "LogicalExpression",
        "messageId": "conditionErrorString",
        "endLine": 227,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [7362, 7388], "text": "(base.split('#')[0] ?? base).length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [7362, 7388], "text": "(base.split('#')[0] ?? base) !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7362, 7388], "text": "Boolean((base.split('#')[0] ?? base))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 260,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 260,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8207, 8219], "text": "breadcrumbs == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 264,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 264,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8318, 8332], "text": "sanitized.data != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 274,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 274,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [8681, 8692], "text": "Boolean(data['url'])" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 277,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 277,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [8777, 8789], "text": "Boolean(data['from'])" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 280,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 280,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [8876, 8886], "text": "Boolean(data['to'])" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'beforeSendScrubber' has too many statements (27). Maximum allowed is 20.",
        "line": 291,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 344,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 293,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 293,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9174, 9192], "text": "(event.request?.url) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [9174, 9192], "text": "(event.request?.url) ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [9174, 9192], "text": "Boolean((event.request?.url))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 295,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 295,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9266, 9278], "text": "sanitizedUrl != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [9266, 9278], "text": "sanitizedUrl ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [9266, 9278], "text": "Boolean(sanitizedUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 301,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 301,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9385, 9402], "text": "event.transaction != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [9385, 9402], "text": "event.transaction ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [9385, 9402], "text": "Boolean(event.transaction)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 302,
        "column": 25,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 302,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [9430, 9465],
              "text": "(stripQueryParams(event.transaction) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": {
              "range": [9430, 9465],
              "text": "(stripQueryParams(event.transaction) ?? \"\")"
            },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [9430, 9465],
              "text": "(Boolean(stripQueryParams(event.transaction)))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 306,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 306,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9524, 9546], "text": "(event.request?.headers) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 314,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 314,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9771, 9793], "text": "(event.request?.cookies) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 319,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 319,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9875, 9886], "text": "event.extra != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 330,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 330,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [10225, 10235], "text": "event.user != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 339,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 339,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [10468, 10488], "text": "sanitizedBreadcrumbs != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'initSentry' has too many lines (84). Maximum allowed is 50.",
        "line": 366,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 492,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'initSentry' has too many statements (34). Maximum allowed is 20.",
        "line": 366,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 492,
        "endColumn": 2
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'initSentry' has a complexity of 19. Maximum allowed is 15.",
        "line": 366,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 366,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 389,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 389,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [12051, 12055], "text": "(dsn == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [12052, 12055], "text": "(dsn ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [12051, 12055], "text": "(!Boolean(dsn))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 390,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 390,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [12074, 12077], "text": "(dsn != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [12074, 12077], "text": "(dsn ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [12074, 12077], "text": "(Boolean(dsn))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 30.",
        "line": 390,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 390,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 396,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 396,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [12185, 12189], "text": "dsn == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [12186, 12189], "text": "(dsn ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [12185, 12189], "text": "!Boolean(dsn)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.1.",
        "line": 427,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 427,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 510,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 510,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [15464, 15477], "text": "(sentryClient == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 510,
        "column": 27,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 510,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [15482, 15493], "text": "(Boolean(event.error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (401). Maximum allowed is 300.",
        "line": 515,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 681,
        "endColumn": 1
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 515,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 515,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [15599, 15613], "text": "(event.filename.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [15599, 15613], "text": "(event.filename !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [15599, 15613], "text": "(Boolean(event.filename))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 529,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 529,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [16027, 16040], "text": "sentryClient == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 551,
        "column": 9,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorObject",
        "endLine": 551,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 556,
        "column": 9,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 556,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [16932, 16932], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [16932, 16932], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 2000.",
        "line": 556,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 556,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 572,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 572,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [17349, 17362], "text": "(sentryClient == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 572,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 572,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [17366, 17378], "text": "(sentryScope == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 579,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 579,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [17526, 17533], "text": "context != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 594,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 594,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [17905, 17918], "text": "sentryClient == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 604,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 604,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [18150, 18162], "text": "sentryScope == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 2000.",
        "line": 628,
        "column": 53,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 628,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 629,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 629,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [18648, 18661], "text": "sentryClient == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 644,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 644,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [18968, 18981], "text": "sentryClient == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 48,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Sentry Error Tracking for Lock-in Browser Extension\n *\n * Uses the browser extension pattern with manual BrowserClient + Scope setup\n * per Sentry best practices. See:\n * https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/\n *\n * Privacy:\n * - No user IDs sent (anonymous error tracking)\n * - Query params stripped from all URLs\n * - Request/response bodies redacted\n * - Auth headers removed\n * - Long strings and user content keys redacted\n *\n * Surfaces:\n * - sidebar: React sidebar UI (ui/extension/index.tsx)\n * - content: Content script orchestrator (contentScript-react.js)\n * - background: MV3 service worker (background.js)\n * - popup: Popup settings page (popup.js)\n */\n\nimport {\n  BrowserClient,\n  defaultStackParser,\n  getDefaultIntegrations,\n  makeFetchTransport,\n  Scope,\n  type ErrorEvent,\n  type EventHint,\n  type Breadcrumb,\n} from '@sentry/browser';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type Surface = 'sidebar' | 'content' | 'background' | 'popup';\n\ntype ChromeManifest = {\n  update_url?: string;\n  version?: string;\n};\n\ntype ChromeRuntimeLike = {\n  getManifest?: () => ChromeManifest;\n  onSuspend?: { addListener: (listener: () => void) => void };\n};\n\ntype ChromeStorageSyncLike = {\n  get: (keys: string[]) => Promise<Record<string, unknown>>;\n  set: (items: Record<string, unknown>) => Promise<void>;\n};\n\ntype ChromeLike = {\n  runtime?: ChromeRuntimeLike;\n  storage?: { sync?: ChromeStorageSyncLike };\n};\n\ntype GlobalWithChrome = typeof globalThis & {\n  chrome?: ChromeLike;\n  LOCKIN_CONFIG?: { SENTRY_DSN?: string };\n  LockInSentry?: LockInSentryApi;\n};\n\ntype LockInSentryApi = {\n  initSentry: (surface: Surface) => Promise<boolean>;\n  captureError: (error: Error, context?: Record<string, unknown>) => void;\n  captureMessage: (message: string, level?: 'info' | 'warning' | 'error') => void;\n  setContext: (name: string, context: Record<string, unknown>) => void;\n  getSentryScope: () => Scope | null;\n  isSentryInitialized: () => boolean;\n  flushSentry: (timeout?: number) => Promise<void>;\n  sendTestEvents: () => { success: boolean; message: string };\n  setTelemetryEnabled: (enabled: boolean) => Promise<void>;\n  setupMv3Lifecycle: () => void;\n};\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n// Telemetry opt-out storage key\nconst TELEMETRY_OPT_OUT_KEY = 'lockin_telemetry_disabled';\n\n// Keys in event.extra that likely contain user content and should be redacted\nconst SENSITIVE_EXTRA_KEYS =\n  /transcript|note|selection|prompt|message|content|chat|caption|text|query|input|output/i;\n\n// Maximum string length before redaction\nconst MAX_STRING_LENGTH = 500;\n\n// ============================================================================\n// Environment Detection\n// ============================================================================\n\n// Detect if we're in a service worker (background) or window context\nconst isServiceWorker =\n  typeof self !== 'undefined' &&\n  typeof window === 'undefined' &&\n  'ServiceWorkerGlobalScope' in self;\n\n// Get the global context (window or self)\nconst globalContext: typeof globalThis = isServiceWorker\n  ? (self as typeof globalThis)\n  : typeof window !== 'undefined'\n    ? window\n    : globalThis;\nconst globalWithChrome = globalContext as GlobalWithChrome;\n\n/**\n * Check if this is an unpacked/development extension\n * Unpacked extensions don't have update_url in their manifest\n */\nfunction isDevelopmentBuild(): boolean {\n  try {\n    const manifest = globalWithChrome.chrome?.runtime?.getManifest?.();\n    // Unpacked extensions don't have update_url\n    return !manifest?.update_url;\n  } catch {\n    return true; // Default to dev if we can't check\n  }\n}\n\nconst isDevelopment = isDevelopmentBuild();\nconst isTestEnv =\n  typeof process !== 'undefined' &&\n  (process.env?.['NODE_ENV'] === 'test' ||\n    process.env?.['VITEST'] === 'true' ||\n    process.env?.['VITEST'] === '1');\n\n// ============================================================================\n// DSN Resolution\n// ============================================================================\n\n/**\n * Build-time injected DSN.\n * Vite replaces this with the actual DSN string at build time via the define config.\n * We use a separate constant to avoid complex typeof checks on import.meta which break in service workers.\n */\nconst BUILD_TIME_DSN: string = import.meta.env['VITE_SENTRY_DSN'];\n\n/**\n * Get Sentry DSN from build-time injection or fallback sources\n * Priority:\n * 1. Vite build-time injection via import.meta.env (now via BUILD_TIME_DSN)\n * 2. LOCKIN_CONFIG (for legacy support)\n */\nfunction getSentryDsn(): string | undefined {\n  // Primary: Build-time injected DSN (Vite replaces the constant at build)\n  if (BUILD_TIME_DSN && BUILD_TIME_DSN !== '' && !BUILD_TIME_DSN.includes('import.meta')) {\n    return BUILD_TIME_DSN;\n  }\n\n  // Fallback: LOCKIN_CONFIG (for popup/content script where config.js loads first)\n  const configDsn = globalWithChrome.LOCKIN_CONFIG?.SENTRY_DSN;\n  if (configDsn && configDsn !== '__SENTRY_DSN__' && configDsn !== '') {\n    return configDsn;\n  }\n\n  return undefined;\n}\n\n/**\n * Get extension version from Chrome runtime\n */\nfunction getExtensionVersion(): string {\n  try {\n    return globalWithChrome.chrome?.runtime?.getManifest?.()?.version || 'unknown';\n  } catch {\n    return 'unknown';\n  }\n}\n\n// ============================================================================\n// Telemetry Opt-Out\n// ============================================================================\n\n/**\n * Check if user has opted out of telemetry\n * Returns a promise that resolves to true if telemetry is ENABLED\n */\nasync function isTelemetryEnabled(): Promise<boolean> {\n  try {\n    const chrome = globalWithChrome.chrome;\n    if (!chrome?.storage?.sync) {\n      return true; // Default to enabled if storage not available\n    }\n    const result = await chrome.storage.sync.get([TELEMETRY_OPT_OUT_KEY]);\n    return result[TELEMETRY_OPT_OUT_KEY] !== true;\n  } catch {\n    return true; // Default to enabled on error\n  }\n}\n\n/**\n * Set telemetry opt-out preference\n */\nexport async function setTelemetryEnabled(enabled: boolean): Promise<void> {\n  try {\n    const chrome = globalWithChrome.chrome;\n    if (chrome?.storage?.sync) {\n      await chrome.storage.sync.set({ [TELEMETRY_OPT_OUT_KEY]: !enabled });\n    }\n  } catch {\n    // Ignore storage errors\n  }\n}\n\n// ============================================================================\n// Privacy Scrubbing Utilities\n// ============================================================================\n\n/**\n * Strip query parameters from a URL string\n */\nfunction stripQueryParams(url: string | undefined): string | undefined {\n  if (!url || typeof url !== 'string') return url;\n  try {\n    const parsed = new URL(url, 'http://placeholder');\n    parsed.search = '';\n    parsed.hash = '';\n    // Return just the path if it was relative, otherwise full URL\n    return url.startsWith('http') ? parsed.toString().replace(/\\/$/, '') : parsed.pathname;\n  } catch {\n    // Fallback: simple split\n    const base = url.split('?')[0] ?? '';\n    return (base.split('#')[0] ?? base) || base;\n  }\n}\n\n/**\n * Redact long strings in an object (recursive)\n */\nfunction redactLongStrings(obj: unknown, maxLen: number = MAX_STRING_LENGTH): unknown {\n  if (obj === null || obj === undefined) return obj;\n\n  if (typeof obj === 'string') {\n    return obj.length > maxLen ? `[REDACTED: ${obj.length} chars]` : obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((item) => redactLongStrings(item, maxLen));\n  }\n\n  if (typeof obj === 'object') {\n    const result: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(obj)) {\n      result[key] = redactLongStrings(value, maxLen);\n    }\n    return result;\n  }\n\n  return obj;\n}\n\n/**\n * Sanitize breadcrumbs to remove sensitive data\n */\nfunction sanitizeBreadcrumbs(breadcrumbs: Breadcrumb[] | undefined): Breadcrumb[] | undefined {\n  if (!breadcrumbs) return breadcrumbs;\n\n  return breadcrumbs.map((bc) => {\n    const sanitized = { ...bc };\n    if (sanitized.data) {\n      const data = { ...(sanitized.data as Record<string, unknown>) };\n      sanitized.data = data;\n      // Remove request/response bodies\n      delete data['body'];\n      delete data['response'];\n      delete data['request'];\n      delete data['responseBody'];\n      delete data['requestBody'];\n      // Strip query params from URLs\n      if (data['url']) {\n        data['url'] = stripQueryParams(data['url'] as string);\n      }\n      if (data['from']) {\n        data['from'] = stripQueryParams(data['from'] as string);\n      }\n      if (data['to']) {\n        data['to'] = stripQueryParams(data['to'] as string);\n      }\n    }\n    return sanitized;\n  });\n}\n\n/**\n * Comprehensive beforeSend scrubbing for privacy\n */\nfunction beforeSendScrubber(event: ErrorEvent, _hint: EventHint): ErrorEvent | null {\n  // Strip URL query params\n  if (event.request?.url) {\n    const sanitizedUrl = stripQueryParams(event.request.url);\n    if (sanitizedUrl) {\n      event.request.url = sanitizedUrl;\n    }\n  }\n\n  // Strip query params from transaction name\n  if (event.transaction) {\n    event.transaction = stripQueryParams(event.transaction) || event.transaction;\n  }\n\n  // Redact auth headers\n  if (event.request?.headers) {\n    delete event.request.headers['Authorization'];\n    delete event.request.headers['authorization'];\n    delete event.request.headers['Cookie'];\n    delete event.request.headers['cookie'];\n  }\n\n  // Remove cookies\n  if (event.request?.cookies) {\n    event.request.cookies = {};\n  }\n\n  // Redact user content in extras\n  if (event.extra) {\n    for (const key of Object.keys(event.extra)) {\n      if (SENSITIVE_EXTRA_KEYS.test(key)) {\n        event.extra[key] = '[REDACTED]';\n      }\n    }\n    // Redact long strings anywhere in extras\n    event.extra = redactLongStrings(event.extra) as Record<string, unknown>;\n  }\n\n  // Remove user data that might have been attached\n  if (event.user) {\n    delete event.user.id;\n    delete event.user.email;\n    delete event.user.username;\n    delete event.user.ip_address;\n  }\n\n  // Sanitize breadcrumbs\n  const sanitizedBreadcrumbs = sanitizeBreadcrumbs(event.breadcrumbs);\n  if (sanitizedBreadcrumbs) {\n    event.breadcrumbs = sanitizedBreadcrumbs;\n  }\n\n  return event;\n}\n\n// ============================================================================\n// Module State\n// ============================================================================\n\nlet sentryScope: Scope | null = null;\nlet sentryClient: BrowserClient | null = null;\nlet isInitialized = false;\nlet currentSurface: Surface | null = null;\n\n// ============================================================================\n// Initialization\n// ============================================================================\n\n/**\n * Initialize Sentry error tracking for the browser extension.\n * Uses isolated BrowserClient + Scope (not Sentry.init) per browser extension best practices.\n *\n * @param surface - Surface identifier for error grouping\n * @returns Promise that resolves to true if initialization succeeded\n */\nexport async function initSentry(surface: Surface): Promise<boolean> {\n  if (isInitialized) {\n    if (isDevelopment && !isTestEnv) {\n      console.log(`[Sentry] Already initialized for surface: ${currentSurface}`);\n    }\n    return true;\n  }\n\n  // Check telemetry opt-out\n  const telemetryEnabled = await isTelemetryEnabled();\n  if (!telemetryEnabled) {\n    if (isDevelopment && !isTestEnv) {\n      console.log('[Sentry] Telemetry disabled by user preference');\n    }\n    return false;\n  }\n\n  const dsn = getSentryDsn();\n\n  // Debug logging for troubleshooting\n  if (isDevelopment && !isTestEnv) {\n    console.log('[Sentry] Initialization debug:', {\n      surface,\n      hasDsn: !!dsn,\n      dsnPrefix: dsn ? dsn.substring(0, 30) + '...' : 'none',\n      isServiceWorker,\n      telemetryEnabled,\n    });\n  }\n\n  if (!dsn) {\n    if (isDevelopment && !isTestEnv) {\n      console.log('[Sentry] No DSN configured, skipping initialization');\n    }\n    return false;\n  }\n\n  try {\n    // Filter out integrations that use global state (required for browser extensions)\n    const integrations = getDefaultIntegrations({}).filter(\n      (integration) =>\n        !['BrowserApiErrors', 'Breadcrumbs', 'GlobalHandlers'].includes(integration.name),\n    );\n\n    const client = new BrowserClient({\n      dsn,\n      transport: makeFetchTransport,\n      stackParser: defaultStackParser,\n      integrations,\n\n      // Enable debug mode in development\n      debug: isDevelopment,\n\n      // Environment and release\n      environment: isDevelopment ? 'development' : 'production',\n      release: `lockin-extension@${getExtensionVersion()}`,\n\n      // PRIVACY: Never send PII\n      sendDefaultPii: false,\n\n      // Performance: Sample 10% in production\n      tracesSampleRate: isDevelopment ? 1.0 : 0.1,\n\n      // Error quality\n      attachStacktrace: true,\n      normalizeDepth: 5,\n\n      // PRIVACY: Comprehensive scrubbing before send\n      beforeSend: (event, _hint) => beforeSendScrubber(event, _hint),\n\n      // Noise filtering\n      ignoreErrors: [\n        // Extension lifecycle (not actionable)\n        'Extension context invalidated',\n        'The message port closed',\n        'Could not establish connection',\n        'Receiving end does not exist',\n\n        // Browser quirks\n        'ResizeObserver loop',\n        'ResizeObserver loop limit exceeded',\n\n        // Network errors (usually user's connection)\n        'Network request failed',\n        'Failed to fetch',\n        'NetworkError',\n        'Load failed',\n        'net::ERR_',\n\n        // User actions\n        'AbortError',\n        'The operation was aborted',\n      ],\n    });\n\n    // Create isolated scope for this extension\n    sentryScope = new Scope();\n    sentryScope.setClient(client);\n    sentryClient = client;\n\n    // Set surface tag\n    sentryScope.setTag('surface', surface);\n    sentryScope.setTag('extensionVersion', getExtensionVersion());\n    currentSurface = surface;\n\n    // Initialize client AFTER setting on scope\n    client.init();\n\n    // Set up custom error listeners (replaces GlobalHandlers for isolated scope)\n    // Only in window context (not service worker)\n    if (!isServiceWorker) {\n      setupErrorListeners();\n    }\n\n    isInitialized = true;\n\n    if (isDevelopment && !isTestEnv) {\n      console.log(`[Sentry]  Initialized successfully for surface: ${surface}`);\n    }\n\n    return true;\n  } catch (err) {\n    // Fail silently - don't break the extension if Sentry fails\n    console.error('[Sentry] Failed to initialize:', err);\n    return false;\n  }\n}\n\n// ============================================================================\n// Error Listeners\n// ============================================================================\n\n/**\n * Set up custom error listeners for unhandled errors.\n * Since we removed GlobalHandlers (required for browser extensions),\n * we add our own listeners that route to the isolated scope.\n */\nfunction setupErrorListeners(): void {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  // Capture unhandled errors\n  window.addEventListener('error', (event) => {\n    if (!sentryClient || !event.error) {\n      return;\n    }\n\n    // Check if this error comes from our extension context\n    const filename = event.filename || '';\n    const isOurError =\n      filename.includes('chrome-extension://') ||\n      filename.includes('dist/ui/') ||\n      filename.includes('dist/libs/') ||\n      filename.includes('extension/');\n\n    if (isOurError || isDevelopment) {\n      sentryClient.captureException(event.error);\n    }\n  });\n\n  // Capture unhandled promise rejections\n  window.addEventListener('unhandledrejection', (event) => {\n    if (!sentryClient) {\n      return;\n    }\n\n    const error = event.reason instanceof Error ? event.reason : new Error(String(event.reason));\n\n    sentryClient.captureException(error);\n  });\n}\n\n// ============================================================================\n// MV3 Lifecycle (Service Worker)\n// ============================================================================\n\n/**\n * Set up MV3 service worker lifecycle handlers.\n * Call this from background.js after initSentry('background').\n * Ensures pending events are flushed before the service worker suspends.\n */\nexport function setupMv3Lifecycle(): void {\n  try {\n    const chrome = globalWithChrome.chrome;\n    if (chrome?.runtime?.onSuspend) {\n      chrome.runtime.onSuspend.addListener(() => {\n        if (isDevelopment && !isTestEnv) {\n          console.log('[Sentry] Service worker suspending, flushing events...');\n        }\n        flushSentry(2000);\n      });\n    }\n  } catch {\n    // Ignore if chrome.runtime not available\n  }\n}\n\n// ============================================================================\n// Public API\n// ============================================================================\n\n/**\n * Capture an error with optional context\n */\nexport function captureError(error: Error, context?: Record<string, unknown>): void {\n  if (!sentryClient || !sentryScope) {\n    if (isDevelopment && !isTestEnv) {\n      console.warn('[Sentry] Not initialized, error not captured:', error);\n    }\n    return;\n  }\n\n  if (context) {\n    sentryScope.setExtras(context);\n  }\n\n  // Use client.captureException with scope hint for isolated BrowserClient pattern\n  sentryClient.captureException(error, { captureContext: sentryScope });\n}\n\n/**\n * Capture a message (for non-error events)\n */\nexport function captureMessage(\n  message: string,\n  level: 'info' | 'warning' | 'error' = 'info',\n): void {\n  if (!sentryClient) {\n    return;\n  }\n  sentryClient.captureMessage(message, level);\n}\n\n/**\n * Set additional context that will be included in error reports\n */\nexport function setContext(name: string, context: Record<string, unknown>): void {\n  if (!sentryScope) {\n    return;\n  }\n  sentryScope.setContext(name, context);\n}\n\n/**\n * Get the Sentry scope (for advanced usage)\n */\nexport function getSentryScope(): Scope | null {\n  return sentryScope;\n}\n\n/**\n * Check if Sentry is initialized\n */\nexport function isSentryInitialized(): boolean {\n  return isInitialized;\n}\n\n/**\n * Flush pending events\n * Call this before the service worker suspends or page unloads\n */\nexport async function flushSentry(timeout: number = 2000): Promise<void> {\n  if (!sentryClient) {\n    return;\n  }\n  try {\n    await sentryClient.flush(timeout);\n  } catch {\n    // Ignore flush errors\n  }\n}\n\n/**\n * Test function to verify Sentry is working.\n * Sends both a message and an error to verify integration.\n */\nexport function sendTestEvents(): { success: boolean; message: string } {\n  if (!sentryClient) {\n    return { success: false, message: 'Sentry not initialized' };\n  }\n\n  try {\n    // Send test message\n    sentryClient.captureMessage(`Sentry test message from ${currentSurface}`, 'info');\n\n    // Send test error\n    const testError = new Error(`Sentry test error from ${currentSurface}`);\n    sentryClient.captureException(testError);\n\n    return { success: true, message: `Test events sent from ${currentSurface}` };\n  } catch (err) {\n    return { success: false, message: `Failed to send: ${err}` };\n  }\n}\n\n// ============================================================================\n// Global Exposure (for non-bundled consumers like popup.js)\n// ============================================================================\n\n// Expose on global context for popup.js and other non-bundled scripts\nif (typeof globalContext !== 'undefined') {\n  globalWithChrome.LockInSentry = {\n    initSentry,\n    captureError,\n    captureMessage,\n    setContext,\n    getSentryScope,\n    isSentryInitialized,\n    flushSentry,\n    sendTestEvents,\n    setTelemetryEnabled,\n    setupMv3Lifecycle,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\extension\\src\\storage.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 60,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 60,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2127, 2134], "text": "schema == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 81,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 81,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2758, 2765], "text": "schema == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createStorage' has too many lines (122). Maximum allowed is 50.",
        "line": 126,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 258,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 130,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "missingAsync",
        "endLine": 130,
        "endColumn": 21,
        "fix": { "range": [4025, 4025], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 134,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 134,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4229, 4253], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 137,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 137,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 147,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "missingAsync",
        "endLine": 147,
        "endColumn": 8,
        "fix": { "range": [4601, 4601], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 152,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 152,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4865, 4889], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 164,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "missingAsync",
        "endLine": 164,
        "endColumn": 11,
        "fix": { "range": [5113, 5113], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 168,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 168,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5291, 5315], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 180,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "missingAsync",
        "endLine": 180,
        "endColumn": 26,
        "fix": { "range": [5539, 5539], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 184,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 184,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5749, 5773], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 187,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 187,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 197,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "missingAsync",
        "endLine": 197,
        "endColumn": 13,
        "fix": { "range": [6123, 6123], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 202,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 202,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6405, 6429], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 214,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "missingAsync",
        "endLine": 214,
        "endColumn": 16,
        "fix": { "range": [6653, 6653], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 218,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 218,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6837, 6861], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 236,
        "column": 9,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 236,
        "endColumn": 11
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 241,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 241,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7562, 7569], "text": "change == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 6,
    "source": "import { z } from 'zod';\n\n/**\n * Chrome Storage Wrapper for Extension Content Scripts\n *\n * Provides storage abstraction with both sync and local storage support.\n * Exposes window.LockInStorage for use by content scripts.\n *\n * This is bundled by vite.config.contentLibs.ts into extension/dist/libs/\n */\n\n/**\n * Storage keys used throughout the extension\n */\nexport const STORAGE_KEYS = {\n  SIDEBAR_IS_OPEN: 'lockin_sidebar_isOpen',\n  SIDEBAR_ACTIVE_TAB: 'lockin_sidebar_activeTab',\n  CURRENT_CHAT_ID: 'lockinCurrentChatId',\n  ACTIVE_MODE: 'lockinActiveMode',\n  MODE_PREFERENCE: 'modePreference',\n  DEFAULT_MODE: 'defaultMode',\n  LAST_USED_MODE: 'lastUsedMode',\n  HIGHLIGHTING_ENABLED: 'highlightingEnabled',\n  SELECTED_NOTE_ID: 'lockin_selectedNoteId',\n} as const;\n\nexport type StorageKey = (typeof STORAGE_KEYS)[keyof typeof STORAGE_KEYS];\n\nconst MODE_SCHEMA = z.enum(['explain', 'general']);\nconst MODE_PREFERENCE_SCHEMA = z.enum(['fixed', 'lastUsed']);\nconst SIDEBAR_TAB_SCHEMA = z.enum(['chat', 'notes', 'tool']);\nconst NON_EMPTY_STRING_SCHEMA = z.string().min(1);\nconst NULLABLE_STRING_SCHEMA = z.string().min(1).nullable();\nconst BOOLEAN_SCHEMA = z.boolean();\n\nconst SYNC_SCHEMA_MAP: Record<string, z.ZodTypeAny> = {\n  [STORAGE_KEYS.SIDEBAR_IS_OPEN]: BOOLEAN_SCHEMA,\n  [STORAGE_KEYS.SIDEBAR_ACTIVE_TAB]: SIDEBAR_TAB_SCHEMA,\n  [STORAGE_KEYS.ACTIVE_MODE]: MODE_SCHEMA,\n  [STORAGE_KEYS.MODE_PREFERENCE]: MODE_PREFERENCE_SCHEMA,\n  [STORAGE_KEYS.DEFAULT_MODE]: MODE_SCHEMA,\n  [STORAGE_KEYS.LAST_USED_MODE]: MODE_SCHEMA,\n  [STORAGE_KEYS.HIGHLIGHTING_ENABLED]: BOOLEAN_SCHEMA,\n  [STORAGE_KEYS.SELECTED_NOTE_ID]: NULLABLE_STRING_SCHEMA,\n};\n\nconst LOCAL_SCHEMA_MAP: Record<string, z.ZodTypeAny> = {\n  [STORAGE_KEYS.CURRENT_CHAT_ID]: NON_EMPTY_STRING_SCHEMA,\n  [STORAGE_KEYS.SIDEBAR_IS_OPEN]: BOOLEAN_SCHEMA,\n};\n\nfunction sanitizeStorageValues(\n  values: Record<string, unknown>,\n  schemaMap: Record<string, z.ZodTypeAny>,\n  areaLabel: string,\n): Record<string, unknown> {\n  const sanitized: Record<string, unknown> = { ...values };\n  Object.entries(values).forEach(([key, value]) => {\n    const schema = schemaMap[key];\n    if (!schema) return;\n    const parsed = schema.safeParse(value);\n    if (parsed.success) {\n      sanitized[key] = parsed.data;\n      return;\n    }\n    delete sanitized[key];\n    console.warn(`[LockInStorage] Invalid ${areaLabel} value for ${key}`, parsed.error.issues);\n  });\n  return sanitized;\n}\n\nfunction validateStorageWrite(\n  data: Record<string, unknown>,\n  schemaMap: Record<string, z.ZodTypeAny>,\n  areaLabel: string,\n): Record<string, unknown> {\n  const sanitized: Record<string, unknown> = {};\n  const invalidKeys: string[] = [];\n  Object.entries(data).forEach(([key, value]) => {\n    const schema = schemaMap[key];\n    if (!schema) {\n      sanitized[key] = value;\n      return;\n    }\n    const parsed = schema.safeParse(value);\n    if (parsed.success) {\n      sanitized[key] = parsed.data;\n    } else {\n      invalidKeys.push(key);\n    }\n  });\n  if (invalidKeys.length > 0) {\n    throw new Error(`Invalid ${areaLabel} storage value(s): ${invalidKeys.join(', ')}`);\n  }\n  return sanitized;\n}\n\n/**\n * Storage change event\n */\nexport interface StorageChange {\n  oldValue?: unknown;\n  newValue?: unknown;\n}\n\n/**\n * Storage interface\n */\nexport interface Storage {\n  STORAGE_KEYS: typeof STORAGE_KEYS;\n  get: <T = unknown>(keys: string | string[]) => Promise<Record<string, T>>;\n  set: (data: Record<string, unknown>) => Promise<void>;\n  remove: (keys: string | string[]) => Promise<void>;\n  getLocal: <T = unknown>(keys: string | string[]) => Promise<Record<string, T>>;\n  setLocal: (key: string, value: unknown) => Promise<void>;\n  removeLocal: (keys: string | string[]) => Promise<void>;\n  onChanged: (\n    callback: (changes: Record<string, StorageChange>, areaName: string) => void,\n  ) => () => void;\n}\n\n/**\n * Create storage wrapper using chrome.storage.sync\n * (sync storage syncs across user's Chrome instances)\n */\nfunction createStorage(): Storage {\n  return {\n    STORAGE_KEYS,\n\n    get<T = unknown>(keys: string | string[]): Promise<Record<string, T>> {\n      return new Promise((resolve, reject) => {\n        try {\n          chrome.storage.sync.get(keys, (result) => {\n            if (chrome.runtime.lastError) {\n              reject(new Error(chrome.runtime.lastError.message));\n            } else {\n              const sanitized = sanitizeStorageValues(result || {}, SYNC_SCHEMA_MAP, 'sync');\n              resolve(sanitized as Record<string, T>);\n            }\n          });\n        } catch (err) {\n          reject(err);\n        }\n      });\n    },\n\n    set(data: Record<string, unknown>): Promise<void> {\n      return new Promise((resolve, reject) => {\n        try {\n          const sanitized = validateStorageWrite(data, SYNC_SCHEMA_MAP, 'sync');\n          chrome.storage.sync.set(sanitized, () => {\n            if (chrome.runtime.lastError) {\n              reject(new Error(chrome.runtime.lastError.message));\n            } else {\n              resolve();\n            }\n          });\n        } catch (err) {\n          reject(err);\n        }\n      });\n    },\n\n    remove(keys: string | string[]): Promise<void> {\n      return new Promise((resolve, reject) => {\n        try {\n          chrome.storage.sync.remove(keys, () => {\n            if (chrome.runtime.lastError) {\n              reject(new Error(chrome.runtime.lastError.message));\n            } else {\n              resolve();\n            }\n          });\n        } catch (err) {\n          reject(err);\n        }\n      });\n    },\n\n    getLocal<T = unknown>(keys: string | string[]): Promise<Record<string, T>> {\n      return new Promise((resolve, reject) => {\n        try {\n          chrome.storage.local.get(keys, (result) => {\n            if (chrome.runtime.lastError) {\n              reject(new Error(chrome.runtime.lastError.message));\n            } else {\n              const sanitized = sanitizeStorageValues(result || {}, LOCAL_SCHEMA_MAP, 'local');\n              resolve(sanitized as Record<string, T>);\n            }\n          });\n        } catch (err) {\n          reject(err);\n        }\n      });\n    },\n\n    setLocal(key: string, value: unknown): Promise<void> {\n      return new Promise((resolve, reject) => {\n        try {\n          const sanitized = validateStorageWrite({ [key]: value }, LOCAL_SCHEMA_MAP, 'local');\n          chrome.storage.local.set(sanitized, () => {\n            if (chrome.runtime.lastError) {\n              reject(new Error(chrome.runtime.lastError.message));\n            } else {\n              resolve();\n            }\n          });\n        } catch (err) {\n          reject(err);\n        }\n      });\n    },\n\n    removeLocal(keys: string | string[]): Promise<void> {\n      return new Promise((resolve, reject) => {\n        try {\n          chrome.storage.local.remove(keys, () => {\n            if (chrome.runtime.lastError) {\n              reject(new Error(chrome.runtime.lastError.message));\n            } else {\n              resolve();\n            }\n          });\n        } catch (err) {\n          reject(err);\n        }\n      });\n    },\n\n    onChanged(\n      callback: (changes: Record<string, StorageChange>, areaName: string) => void,\n    ): () => void {\n      const listener = (\n        changes: { [key: string]: chrome.storage.StorageChange },\n        areaName: string,\n      ) => {\n        // Convert Chrome's StorageChange format to our interface format\n        const normalizedChanges: Record<string, StorageChange> = {};\n        for (const key in changes) {\n          const change = changes[key];\n          if (!change) continue;\n          normalizedChanges[key] = {\n            oldValue: change.oldValue,\n            newValue: change.newValue,\n          };\n        }\n        callback(normalizedChanges, areaName);\n      };\n\n      chrome.storage.onChanged.addListener(listener);\n\n      // Return unsubscribe function\n      return () => {\n        chrome.storage.onChanged.removeListener(listener);\n      };\n    },\n  };\n}\n\n// Create and expose storage\nconst storage = createStorage();\n\n// Expose globally for content scripts\nif (typeof window !== 'undefined') {\n  window.LockInStorage = storage;\n}\n\nexport { storage };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\integrations\\__tests__\\index.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (55). Maximum allowed is 50.",
        "line": 13,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 79,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for adapter factory (integrations/index.ts)\n *\n * Tests adapter selection logic.\n */\n\nimport { describe, it, expect } from 'vitest';\nimport { getAdapterForUrl, getCurrentAdapter } from '../index';\nimport { MoodleAdapter } from '../adapters/moodleAdapter';\nimport { EdstemAdapter } from '../adapters/edstemAdapter';\nimport { GenericAdapter } from '../adapters/baseAdapter';\n\ndescribe('Adapter Factory', () => {\n  describe('getAdapterForUrl', () => {\n    it('should return MoodleAdapter for Moodle URLs', () => {\n      const adapter = getAdapterForUrl('https://learning.monash.edu/course/view.php?id=123');\n      expect(adapter).toBeInstanceOf(MoodleAdapter);\n    });\n\n    it('should return EdstemAdapter for Edstem URLs', () => {\n      const adapter = getAdapterForUrl('https://edstem.org/us/courses/12345');\n      expect(adapter).toBeInstanceOf(EdstemAdapter);\n    });\n\n    it('should return GenericAdapter for unknown URLs', () => {\n      const adapter = getAdapterForUrl('https://example.com/page');\n      expect(adapter).toBeInstanceOf(GenericAdapter);\n    });\n\n    it('should prefer MoodleAdapter over GenericAdapter for Moodle URLs', () => {\n      const adapter = getAdapterForUrl('https://learning.monash.edu/mod/page/view.php');\n      expect(adapter).toBeInstanceOf(MoodleAdapter);\n      expect(adapter).not.toBeInstanceOf(GenericAdapter);\n    });\n\n    it('should prefer EdstemAdapter over GenericAdapter for Edstem URLs', () => {\n      const adapter = getAdapterForUrl('https://edstem.org/au/courses/67890');\n      expect(adapter).toBeInstanceOf(EdstemAdapter);\n      expect(adapter).not.toBeInstanceOf(GenericAdapter);\n    });\n  });\n\n  describe('getCurrentAdapter', () => {\n    it('should return GenericAdapter when window is undefined', () => {\n      // Save original window\n      const globalAny = globalThis as typeof globalThis & { window?: Window };\n      const originalWindow = globalAny.window;\n      delete (globalAny as { window?: Window }).window;\n\n      try {\n        const adapter = getCurrentAdapter();\n        expect(adapter).toBeInstanceOf(GenericAdapter);\n      } finally {\n        // Restore window\n        globalAny.window = originalWindow;\n      }\n    });\n\n    it('should return adapter based on current URL when window is available', () => {\n      // Mock window.location\n      const originalLocation = window.location;\n      Object.defineProperty(window, 'location', {\n        value: { href: 'https://learning.monash.edu/course/view.php?id=123' },\n        writable: true,\n      });\n\n      try {\n        const adapter = getCurrentAdapter();\n        expect(adapter).toBeInstanceOf(MoodleAdapter);\n      } finally {\n        // Restore location\n        Object.defineProperty(window, 'location', {\n          value: originalLocation,\n          writable: true,\n        });\n      }\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\integrations\\adapters\\__tests__\\baseAdapter.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (110). Maximum allowed is 50.",
        "line": 11,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 142,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for GenericAdapter (baseAdapter)\n *\n * Tests the fallback adapter for unknown sites.\n */\n\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { JSDOM } from 'jsdom';\nimport { GenericAdapter } from '../baseAdapter';\n\ndescribe('GenericAdapter', () => {\n  let adapter: GenericAdapter;\n  let document: Document;\n\n  function createDocument(url: string = 'https://example.com/page'): Document {\n    const dom = new JSDOM(\n      `<!DOCTYPE html>\n      <html>\n        <head>\n          <title>Test Page</title>\n        </head>\n        <body></body>\n      </html>`,\n      {\n        url,\n        pretendToBeVisual: true,\n      },\n    );\n    return dom.window.document;\n  }\n\n  beforeEach(() => {\n    adapter = new GenericAdapter();\n    document = createDocument();\n  });\n\n  describe('canHandle', () => {\n    it('should return true for any URL (fallback adapter)', () => {\n      expect(adapter.canHandle('https://example.com')).toBe(true);\n      expect(adapter.canHandle('https://unknown-site.com')).toBe(true);\n      expect(adapter.canHandle('http://localhost:3000')).toBe(true);\n    });\n  });\n\n  describe('getCourseCode', () => {\n    it(\"should return null (generic adapter doesn't extract course codes)\", () => {\n      document.title = 'FIT1045 - Course';\n      const h1 = document.createElement('h1');\n      h1.textContent = 'FIT1045 Content';\n      document.body.appendChild(h1);\n\n      const code = adapter.getCourseCode(document);\n      expect(code).toBe(null);\n    });\n  });\n\n  describe('getWeek', () => {\n    it(\"should return null (generic adapter doesn't extract weeks)\", () => {\n      const h2 = document.createElement('h2');\n      h2.textContent = 'Week 5';\n      document.body.appendChild(h2);\n\n      const week = adapter.getWeek(document);\n      expect(week).toBe(null);\n    });\n  });\n\n  describe('getTopic', () => {\n    it('should extract topic from h1', () => {\n      const h1 = document.createElement('h1');\n      h1.textContent = 'Introduction to Arrays';\n      document.body.appendChild(h1);\n\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe('Introduction to Arrays');\n    });\n\n    it('should extract topic from h2 if h1 not present', () => {\n      const h2 = document.createElement('h2');\n      h2.textContent = 'Lecture Notes';\n      document.body.appendChild(h2);\n\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe('Lecture Notes');\n    });\n\n    it('should prefer h1 over h2', () => {\n      const h1 = document.createElement('h1');\n      h1.textContent = 'Main Topic';\n      document.body.appendChild(h1);\n\n      const h2 = document.createElement('h2');\n      h2.textContent = 'Sub Topic';\n      document.body.appendChild(h2);\n\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe('Main Topic');\n    });\n\n    it('should return null when no heading found', () => {\n      document.body.textContent = 'No headings here';\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe(null);\n    });\n  });\n\n  describe('getCourseContext', () => {\n    it('should return minimal context with sourceUrl', () => {\n      const url = 'https://example.com/page';\n      const context = adapter.getCourseContext(document, url);\n\n      expect(context.courseCode).toBe(null);\n      expect(context.sourceUrl).toBe(url);\n    });\n  });\n\n  describe('getPageContext', () => {\n    it('should build complete page context', () => {\n      document.title = 'Page Title';\n      const h1 = document.createElement('h1');\n      h1.textContent = 'Page Heading';\n      document.body.appendChild(h1);\n\n      const url = 'https://example.com/page';\n      const context = adapter.getPageContext(document, url);\n\n      expect(context.url).toBe(url);\n      expect(context.title).toBe('Page Title');\n      expect(context.heading).toBe('Page Heading');\n      expect(context.courseContext).toBeDefined();\n      expect(context.courseContext.courseCode).toBe(null);\n    });\n\n    it('should use title as heading fallback', () => {\n      document.title = 'Page Title';\n      const url = 'https://example.com/page';\n      const context = adapter.getPageContext(document, url);\n\n      expect(context.heading).toBe('Page Title');\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\integrations\\adapters\\__tests__\\edstemAdapter.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (156). Maximum allowed is 50.",
        "line": 11,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 200,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for EdstemAdapter\n *\n * Tests DOM-based adapter logic using jsdom.\n */\n\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { JSDOM } from 'jsdom';\nimport { EdstemAdapter } from '../edstemAdapter';\n\ndescribe('EdstemAdapter', () => {\n  let adapter: EdstemAdapter;\n  let document: Document;\n\n  function createDocument(url: string = 'https://edstem.org/us/courses/12345'): Document {\n    const dom = new JSDOM(\n      `<!DOCTYPE html>\n      <html>\n        <head>\n          <title>Test Page</title>\n        </head>\n        <body></body>\n      </html>`,\n      {\n        url,\n        pretendToBeVisual: true,\n      },\n    );\n    return dom.window.document;\n  }\n\n  beforeEach(() => {\n    adapter = new EdstemAdapter();\n    document = createDocument();\n  });\n\n  describe('canHandle', () => {\n    it('should return true for Edstem URLs', () => {\n      expect(adapter.canHandle('https://edstem.org/us/courses/12345')).toBe(true);\n      expect(adapter.canHandle('http://edstem.org')).toBe(true);\n      expect(adapter.canHandle('https://edstem.org/au/courses/67890')).toBe(true);\n    });\n\n    it('should return false for non-Edstem URLs', () => {\n      expect(adapter.canHandle('https://learning.monash.edu')).toBe(false);\n      expect(adapter.canHandle('https://example.com')).toBe(false);\n    });\n  });\n\n  describe('getCourseCode', () => {\n    it('should extract course code from page title', () => {\n      document.title = 'FIT1045 - Introduction to Programming';\n      const code = adapter.getCourseCode(document);\n      expect(code).toBe('FIT1045');\n    });\n\n    it('should extract course code from h1 heading', () => {\n      const h1 = document.createElement('h1');\n      h1.textContent = 'MAT1830 - Discrete Mathematics';\n      document.body.appendChild(h1);\n\n      const code = adapter.getCourseCode(document);\n      expect(code).toBe('MAT1830');\n    });\n\n    it('should extract course code from h1 heading (h2 not checked by adapter)', () => {\n      // Note: EdstemAdapter only checks title and h1, not h2\n      const h1 = document.createElement('h1');\n      h1.textContent = 'FIT1045 Course Content';\n      document.body.appendChild(h1);\n\n      const code = adapter.getCourseCode(document);\n      expect(code).toBe('FIT1045');\n    });\n\n    it('should return null when no course code found', () => {\n      document.title = 'General Course Page';\n      document.body.textContent = 'Welcome to the course';\n      const code = adapter.getCourseCode(document);\n      expect(code).toBe(null);\n    });\n\n    it('should handle case-insensitive course codes', () => {\n      document.title = 'fit1045 - Introduction';\n      const code = adapter.getCourseCode(document);\n      expect(code).toBe('FIT1045');\n    });\n  });\n\n  describe('getWeek', () => {\n    it('should return null (not yet implemented)', () => {\n      const h1 = document.createElement('h1');\n      h1.textContent = 'Week 5 Content';\n      document.body.appendChild(h1);\n\n      const week = adapter.getWeek(document);\n      expect(week).toBe(null);\n    });\n  });\n\n  describe('getTopic', () => {\n    it('should extract topic from h1', () => {\n      const h1 = document.createElement('h1');\n      h1.textContent = 'Introduction to Arrays';\n      document.body.appendChild(h1);\n\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe('Introduction to Arrays');\n    });\n\n    it('should extract topic from h2 if h1 not present', () => {\n      const h2 = document.createElement('h2');\n      h2.textContent = 'Lecture Notes';\n      document.body.appendChild(h2);\n\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe('Lecture Notes');\n    });\n\n    it('should prefer h1 over h2', () => {\n      const h1 = document.createElement('h1');\n      h1.textContent = 'Main Topic';\n      document.body.appendChild(h1);\n\n      const h2 = document.createElement('h2');\n      h2.textContent = 'Sub Topic';\n      document.body.appendChild(h2);\n\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe('Main Topic');\n    });\n\n    it('should return null when no heading found', () => {\n      document.body.textContent = 'No headings here';\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe(null);\n    });\n  });\n\n  describe('getCourseContext', () => {\n    it('should build complete course context', () => {\n      document.title = 'FIT1045 - Introduction';\n      const h1 = document.createElement('h1');\n      h1.textContent = 'Welcome to FIT1045';\n      document.body.appendChild(h1);\n\n      const url = 'https://edstem.org/us/courses/12345';\n      const context = adapter.getCourseContext(document, url);\n\n      expect(context.courseCode).toBe('FIT1045');\n      expect(context.topic).toBe('Welcome to FIT1045');\n      expect(context.sourceUrl).toBe(url);\n      expect(context.sourceLabel).toBe('Welcome to FIT1045');\n    });\n\n    it('should handle missing course code gracefully', () => {\n      document.title = 'General Course Page';\n      document.body.textContent = 'No course code here';\n      const url = 'https://edstem.org/us/courses/12345';\n      const context = adapter.getCourseContext(document, url);\n\n      expect(context.courseCode).toBe(null);\n      expect(context.sourceUrl).toBe(url);\n    });\n\n    it('should use course code as sourceLabel when topic is missing', () => {\n      document.title = 'FIT1045 - Course';\n      const url = 'https://edstem.org/us/courses/12345';\n      const context = adapter.getCourseContext(document, url);\n\n      expect(context.courseCode).toBe('FIT1045');\n      expect(context.sourceLabel).toBe('FIT1045');\n    });\n  });\n\n  describe('getPageContext', () => {\n    it('should build complete page context', () => {\n      document.title = 'Course Page - Edstem';\n      const h1 = document.createElement('h1');\n      h1.textContent = 'Welcome';\n      document.body.appendChild(h1);\n\n      const url = 'https://edstem.org/us/courses/12345';\n      const context = adapter.getPageContext(document, url);\n\n      expect(context.url).toBe(url);\n      expect(context.title).toBe('Course Page - Edstem');\n      expect(context.heading).toBe('Welcome');\n      expect(context.courseContext).toBeDefined();\n    });\n\n    it('should use title as heading fallback', () => {\n      document.title = 'Course Page Title';\n      const url = 'https://edstem.org/us/courses/12345';\n      const context = adapter.getPageContext(document, url);\n\n      expect(context.heading).toBe('Course Page Title');\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\integrations\\adapters\\__tests__\\jsdom.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\integrations\\adapters\\__tests__\\moodleAdapter.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (178). Maximum allowed is 50.",
        "line": 11,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 228,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 83,
        "column": 13,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 83,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 83,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 83,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2785, 2801], "text": "(Boolean(this.textContent))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .textContent on an `any` value.",
        "line": 83,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 83,
        "endColumn": 36
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 112,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 112,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 121,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 121,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 52.",
        "line": 137,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 137,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 7.",
        "line": 195,
        "column": 33,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 195,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for MoodleAdapter\n *\n * Tests DOM-based adapter logic using jsdom.\n */\n\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { JSDOM } from 'jsdom';\nimport { MoodleAdapter } from '../moodleAdapter';\n\ndescribe('MoodleAdapter', () => {\n  let adapter: MoodleAdapter;\n  let document: Document;\n\n  function createDocumentWithLocation(courseId: string = '123'): Document {\n    // Use JSDOM to create a document with proper location support\n    const dom = new JSDOM(\n      `<!DOCTYPE html>\n      <html>\n        <head>\n          <title>Test Page</title>\n        </head>\n        <body></body>\n      </html>`,\n      {\n        url: `https://learning.monash.edu/course/view.php?id=${courseId}`,\n        pretendToBeVisual: true,\n      },\n    );\n    return dom.window.document;\n  }\n\n  beforeEach(() => {\n    adapter = new MoodleAdapter();\n    // Clear localStorage between tests to avoid cached course codes\n    if (typeof localStorage !== 'undefined') {\n      localStorage.clear();\n    }\n    document = createDocumentWithLocation();\n  });\n\n  describe('canHandle', () => {\n    it('should return true for Moodle URLs', () => {\n      expect(adapter.canHandle('https://learning.monash.edu/course/view.php')).toBe(true);\n      expect(adapter.canHandle('http://learning.monash.edu/mod/page/view.php')).toBe(true);\n    });\n\n    it('should return false for non-Moodle URLs', () => {\n      expect(adapter.canHandle('https://edstem.org')).toBe(false);\n      expect(adapter.canHandle('https://example.com')).toBe(false);\n    });\n  });\n\n  describe('getCourseCode', () => {\n    it('should extract course code from meta tags', () => {\n      const meta = document.createElement('meta');\n      meta.setAttribute('property', 'og:title');\n      meta.setAttribute('content', 'FIT1045 - Introduction to Programming');\n      document.head.appendChild(meta);\n\n      const code = adapter.getCourseCode(document);\n      expect(code).toBe('FIT1045');\n    });\n\n    it('should extract course code from headings', () => {\n      const h1 = document.createElement('h1');\n      h1.textContent = 'FIT1045 Course Page';\n      document.body.appendChild(h1);\n\n      const code = adapter.getCourseCode(document);\n      expect(code).toBe('FIT1045');\n    });\n\n    it('should extract course code from body text', () => {\n      // Use a different course ID to avoid cache conflicts\n      const doc = createDocumentWithLocation('456');\n      // Set innerHTML and ensure innerText is available (jsdom may not have innerText)\n      doc.body.innerHTML = 'Welcome to MAT1830 - Discrete Mathematics';\n      // Polyfill innerText if not available (jsdom doesn't always support it)\n      if (!('innerText' in doc.body)) {\n        Object.defineProperty(doc.body, 'innerText', {\n          get() {\n            return this.textContent || '';\n          },\n          configurable: true,\n        });\n      }\n      const code = adapter.getCourseCode(doc);\n      expect(code).toBe('MAT1830');\n    });\n\n    it('should return null when no course code found', () => {\n      // Use a different course ID to avoid cache conflicts\n      const doc = createDocumentWithLocation('789');\n      doc.body.textContent = 'Welcome to the course';\n      const code = adapter.getCourseCode(doc);\n      expect(code).toBe(null);\n    });\n  });\n\n  describe('getWeek', () => {\n    it('should extract week number from section info', () => {\n      const sectionInfo = document.createElement('div');\n      sectionInfo.setAttribute('data-region', 'section-info');\n      const textMuted = document.createElement('div');\n      textMuted.className = 'text-muted';\n      textMuted.textContent = 'Week 5';\n      sectionInfo.appendChild(textMuted);\n      document.body.appendChild(sectionInfo);\n\n      const week = adapter.getWeek(document);\n      expect(week).toBe(5);\n    });\n\n    it('should extract week number from headings', () => {\n      const h2 = document.createElement('h2');\n      h2.textContent = 'Week 3';\n      document.body.appendChild(h2);\n\n      const week = adapter.getWeek(document);\n      expect(week).toBe(3);\n    });\n\n    it('should return null when no week found', () => {\n      document.body.textContent = 'General content without week';\n      const week = adapter.getWeek(document);\n      expect(week).toBe(null);\n    });\n\n    it('should handle week numbers 1-52', () => {\n      const h2 = document.createElement('h2');\n      h2.textContent = 'Week 1';\n      document.body.appendChild(h2);\n      expect(adapter.getWeek(document)).toBe(1);\n\n      h2.textContent = 'Week 52';\n      expect(adapter.getWeek(document)).toBe(52);\n    });\n\n    it('should return null for invalid week numbers', () => {\n      const h2 = document.createElement('h2');\n      h2.textContent = 'Week 0';\n      document.body.appendChild(h2);\n      expect(adapter.getWeek(document)).toBe(null);\n\n      h2.textContent = 'Week 53';\n      expect(adapter.getWeek(document)).toBe(null);\n    });\n  });\n\n  describe('getTopic', () => {\n    it('should extract topic from h1', () => {\n      const h1 = document.createElement('h1');\n      h1.textContent = 'Introduction to Arrays';\n      document.body.appendChild(h1);\n\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe('Introduction to Arrays');\n    });\n\n    it('should extract topic from h2 if h1 not present', () => {\n      const h2 = document.createElement('h2');\n      h2.textContent = 'Lecture Notes';\n      document.body.appendChild(h2);\n\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe('Lecture Notes');\n    });\n\n    it('should return null when no heading found', () => {\n      document.body.textContent = 'No headings here';\n      const topic = adapter.getTopic(document);\n      expect(topic).toBe(null);\n    });\n  });\n\n  describe('getCourseContext', () => {\n    it('should build complete course context', () => {\n      const h1 = document.createElement('h1');\n      h1.textContent = 'FIT1045 - Introduction';\n      document.body.appendChild(h1);\n\n      const sectionInfo = document.createElement('div');\n      sectionInfo.setAttribute('data-region', 'section-info');\n      const textMuted = document.createElement('div');\n      textMuted.className = 'text-muted';\n      textMuted.textContent = 'Week 7';\n      sectionInfo.appendChild(textMuted);\n      document.body.appendChild(sectionInfo);\n\n      const url = 'https://learning.monash.edu/course/view.php?id=123';\n      const context = adapter.getCourseContext(document, url);\n\n      expect(context.courseCode).toBe('FIT1045');\n      expect(context.week).toBe(7);\n      expect(context.topic).toBe('FIT1045 - Introduction');\n      expect(context.sourceUrl).toBe(url);\n    });\n\n    it('should handle missing course code gracefully', () => {\n      // Use a different course ID to avoid cache conflicts\n      const doc = createDocumentWithLocation('999');\n      doc.body.textContent = 'No course code here';\n      const url = 'https://learning.monash.edu/course/view.php';\n      const context = adapter.getCourseContext(doc, url);\n\n      expect(context.courseCode).toBe(null);\n      expect(context.sourceUrl).toBe(url);\n    });\n  });\n\n  describe('getPageContext', () => {\n    it('should build complete page context', () => {\n      document.title = 'Course Page - Moodle';\n      const h1 = document.createElement('h1');\n      h1.textContent = 'Welcome';\n      document.body.appendChild(h1);\n\n      const url = 'https://learning.monash.edu/course/view.php';\n      const context = adapter.getPageContext(document, url);\n\n      expect(context.url).toBe(url);\n      expect(context.title).toBe('Course Page - Moodle');\n      expect(context.heading).toBe('Welcome');\n      expect(context.courseContext).toBeDefined();\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\integrations\\adapters\\baseAdapter.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 63,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 63,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1486, 1493], "text": "(heading != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1486, 1493], "text": "(heading ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1486, 1493], "text": "(Boolean(heading))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 74,
        "column": 21,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 74,
        "endColumn": 69,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [1724, 1772],
              "text": "((dom.querySelector('h1, h2')?.textContent?.trim()) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": {
              "range": [1724, 1772],
              "text": "((dom.querySelector('h1, h2')?.textContent?.trim()) ?? \"\")"
            },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1724, 1772],
              "text": "(Boolean((dom.querySelector('h1, h2')?.textContent?.trim())))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Base Adapter Interface for Site-Specific Integrations\n *\n * Each supported site (Moodle, Edstem, etc.) implements this interface\n * to extract course context from the DOM.\n */\n\nimport type { CourseContext, PageContext } from '../../core/domain/types';\n\n/**\n * Base adapter interface that all site adapters must implement\n */\nexport interface BaseAdapter {\n  /**\n   * Check if this adapter can handle the given URL\n   */\n  canHandle(url: string): boolean;\n\n  /**\n   * Extract course code from the page DOM\n   */\n  getCourseCode(dom: Document): string | null;\n\n  /**\n   * Extract week number from the page DOM\n   */\n  getWeek(dom: Document): number | null;\n\n  /**\n   * Extract topic/title from the page DOM\n   */\n  getTopic(dom: Document): string | null;\n\n  /**\n   * Extract full course context from the page\n   */\n  getCourseContext(dom: Document, url: string): CourseContext;\n\n  /**\n   * Extract full page context (title, heading, course info)\n   */\n  getPageContext(dom: Document, url: string): PageContext;\n}\n\n/**\n * Generic adapter for unknown sites (fallback)\n */\nexport class GenericAdapter implements BaseAdapter {\n  canHandle(_url: string): boolean {\n    return true; // Fallback adapter handles everything\n  }\n\n  getCourseCode(_dom: Document): string | null {\n    return null;\n  }\n\n  getWeek(_dom: Document): number | null {\n    return null;\n  }\n\n  getTopic(dom: Document): string | null {\n    const heading = dom.querySelector('h1, h2')?.textContent?.trim();\n    return heading || null;\n  }\n\n  getCourseContext(_dom: Document, url: string): CourseContext {\n    return {\n      courseCode: null,\n      sourceUrl: url,\n    };\n  }\n\n  getPageContext(dom: Document, url: string): PageContext {\n    const heading = dom.querySelector('h1, h2')?.textContent?.trim() || dom.title;\n    return {\n      url,\n      title: dom.title,\n      heading,\n      courseContext: this.getCourseContext(dom, url),\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\integrations\\adapters\\edstemAdapter.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 29,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 29,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [828, 832], "text": "(text != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [828, 832], "text": "(text ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [828, 832], "text": "(Boolean(text))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 30,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 30,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [851, 855], "text": "code != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [851, 855], "text": "code ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [851, 855], "text": "Boolean(code)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 43,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 43,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1136, 1143], "text": "(heading != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1136, 1143], "text": "(heading ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1136, 1143], "text": "(Boolean(heading))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 54,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 54,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1401, 1406], "text": "topic != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1401, 1406], "text": "topic ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1401, 1406], "text": "Boolean(topic)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 57,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 57,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1469, 1474], "text": "(topic != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1469, 1474], "text": "(topic ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1469, 1474], "text": "(Boolean(topic))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 57,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 57,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1478, 1488], "text": "(courseCode != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1478, 1488], "text": "(courseCode ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1478, 1488], "text": "(Boolean(courseCode))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 58,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 58,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1504, 1515], "text": "sourceLabel.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1504, 1515], "text": "sourceLabel !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1504, 1515], "text": "Boolean(sourceLabel)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 65,
        "column": 21,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 65,
        "endColumn": 69,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [1671, 1719],
              "text": "((dom.querySelector('h1, h2')?.textContent?.trim()) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": {
              "range": [1671, 1719],
              "text": "((dom.querySelector('h1, h2')?.textContent?.trim()) ?? \"\")"
            },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1671, 1719],
              "text": "(Boolean((dom.querySelector('h1, h2')?.textContent?.trim())))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Edstem Adapter\n *\n * Extracts course context from Edstem pages.\n */\n\nimport type { BaseAdapter } from './baseAdapter';\nimport type { CourseContext, PageContext } from '../../core/domain/types';\nimport { extractCourseCodeFromText } from '../../core/utils/textUtils';\n\n/**\n * Edstem-specific adapter\n */\nexport class EdstemAdapter implements BaseAdapter {\n  canHandle(url: string): boolean {\n    return url.includes('edstem.org');\n  }\n\n  getCourseCode(dom: Document): string | null {\n    // Edstem course codes might be in:\n    // - Page title\n    // - Breadcrumbs\n    // - Course header\n    const title = dom.title;\n    const heading = dom.querySelector('h1')?.textContent?.trim();\n\n    const candidates = [title, heading].filter(Boolean);\n    for (const text of candidates) {\n      const code = extractCourseCodeFromText(text || '');\n      if (code) return code;\n    }\n\n    return null;\n  }\n\n  getWeek(_dom: Document): number | null {\n    // TODO: Extract week from Edstem structure\n    return null;\n  }\n\n  getTopic(dom: Document): string | null {\n    const heading = dom.querySelector('h1, h2')?.textContent?.trim();\n    return heading || null;\n  }\n\n  getCourseContext(dom: Document, url: string): CourseContext {\n    const courseCode = this.getCourseCode(dom);\n    const topic = this.getTopic(dom);\n\n    const context: CourseContext = {\n      courseCode,\n      sourceUrl: url,\n    };\n    if (topic) {\n      context.topic = topic;\n    }\n    const sourceLabel = topic || courseCode || '';\n    if (sourceLabel) {\n      context.sourceLabel = sourceLabel;\n    }\n    return context;\n  }\n\n  getPageContext(dom: Document, url: string): PageContext {\n    const heading = dom.querySelector('h1, h2')?.textContent?.trim() || dom.title;\n    const courseContext = this.getCourseContext(dom, url);\n\n    return {\n      url,\n      title: dom.title,\n      heading,\n      courseContext,\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\integrations\\adapters\\moodleAdapter.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 36,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 36,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1029, 1036], "text": "content != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1029, 1036], "text": "content ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1029, 1036], "text": "Boolean(content)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 52,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 52,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1469, 1473], "text": "text.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1469, 1473], "text": "text !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1469, 1473], "text": "Boolean(text)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 57,
        "column": 22,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorString",
        "endLine": 57,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1587, 1606], "text": "((dom.body?.innerText).length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1587, 1606], "text": "((dom.body?.innerText) !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1587, 1606], "text": "(Boolean((dom.body?.innerText)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 58,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 58,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1622, 1630], "text": "bodyText.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1622, 1630], "text": "bodyText !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1622, 1630], "text": "Boolean(bodyText)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 8000.",
        "line": 59,
        "column": 49,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 59,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 65,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 65,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1850, 1854], "text": "code != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1850, 1854], "text": "code ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1850, 1854], "text": "Boolean(code)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 68,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 68,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1970, 1978], "text": "courseId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1970, 1978], "text": "courseId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1970, 1978], "text": "Boolean(courseId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 77,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 77,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2171, 2179], "text": "courseId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2171, 2179], "text": "courseId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2171, 2179], "text": "Boolean(courseId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Method 'getWeek' has too many lines (52). Maximum allowed is 50.",
        "line": 90,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "exceed",
        "endLine": 163,
        "endColumn": 4
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Method 'getWeek' has a complexity of 23. Maximum allowed is 15.",
        "line": 90,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "complex",
        "endLine": 90,
        "endColumn": 10
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Method 'getWeek' has too many statements (33). Maximum allowed is 20.",
        "line": 90,
        "column": 10,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 163,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 113,
        "column": 22,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorString",
        "endLine": 113,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3462, 3484], "text": "((el.textContent?.trim()).length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3462, 3484], "text": "((el.textContent?.trim()) !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3462, 3484], "text": "(Boolean((el.textContent?.trim())))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 116,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 116,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3589, 3598], "text": "weekToken != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3589, 3598], "text": "weekToken ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3589, 3598], "text": "Boolean(weekToken)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 52.",
        "line": 118,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 118,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 132,
        "column": 22,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorString",
        "endLine": 132,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [4146, 4168], "text": "((el.textContent?.trim()).length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [4146, 4168], "text": "((el.textContent?.trim()) !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4146, 4168], "text": "(Boolean((el.textContent?.trim())))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 136,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 136,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4360, 4369], "text": "weekToken != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4360, 4369], "text": "weekToken ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4360, 4369], "text": "Boolean(weekToken)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 52.",
        "line": 138,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 138,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 148,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 148,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4810, 4824], "text": "sectionContent != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 149,
        "column": 21,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 149,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [4848, 4874], "text": "(sectionContent.textContent.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [4848, 4874], "text": "(sectionContent.textContent !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4848, 4874], "text": "(Boolean(sectionContent.textContent))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 300.",
        "line": 149,
        "column": 68,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 149,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 153,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 153,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5095, 5104], "text": "weekToken != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5095, 5104], "text": "weekToken ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5095, 5104], "text": "Boolean(weekToken)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 52.",
        "line": 155,
        "column": 39,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 155,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 170,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 170,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5485, 5492], "text": "(heading != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5485, 5492], "text": "(heading ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5485, 5492], "text": "(Boolean(heading))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 187,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 187,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 187,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 187,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5936, 5939], "text": "(raw != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5936, 5939], "text": "(raw ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5936, 5939], "text": "(Boolean(raw))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of a value of type `any`.",
        "line": 188,
        "column": 7,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 188,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 188,
        "column": 14,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 188,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5977, 5994], "text": "(Boolean(mapping[courseId]))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [courseId] on an `any` value.",
        "line": 188,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 188,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 199,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 199,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [6274, 6283], "text": "(courseId.length === 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [6274, 6283], "text": "(courseId === \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6274, 6283], "text": "(!Boolean(courseId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 199,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 199,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [6287, 6298], "text": "(courseCode.length === 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [6287, 6298], "text": "(courseCode === \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6287, 6298], "text": "(!Boolean(courseCode))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 202,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 204,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 202,
        "column": 24,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 202,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [6342, 6379],
              "text": "(this.getStoredCourseMapping(courseId) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": {
              "range": [6342, 6379],
              "text": "(this.getStoredCourseMapping(courseId) ?? \"\")"
            },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [6342, 6379],
              "text": "(Boolean(this.getStoredCourseMapping(courseId)))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 203,
        "column": 22,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 203,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [6401, 6449],
              "text": "(localStorage.getItem('lockin:monashCourseCodes') != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": {
              "range": [6401, 6449],
              "text": "(localStorage.getItem('lockin:monashCourseCodes') ?? \"\")"
            },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [6401, 6449],
              "text": "(Boolean(localStorage.getItem('lockin:monashCourseCodes')))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [courseId] on an `any` value.",
        "line": 206,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 206,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 208,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 208,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 227,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 227,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7086, 7096], "text": "courseCode != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7086, 7096], "text": "courseCode ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7086, 7096], "text": "Boolean(courseCode)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 233,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 233,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7211, 7216], "text": "topic != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7211, 7216], "text": "topic ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7211, 7216], "text": "Boolean(topic)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 236,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 236,
        "endColumn": 63,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7312, 7317], "text": "(topic != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7312, 7317], "text": "(topic ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7312, 7317], "text": "(Boolean(topic))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 236,
        "column": 67,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 236,
        "endColumn": 77,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7321, 7331], "text": "(courseCode != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7321, 7331], "text": "(courseCode ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7321, 7331], "text": "(Boolean(courseCode))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 237,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 237,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [7347, 7358], "text": "sourceLabel.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [7347, 7358], "text": "sourceLabel !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7347, 7358], "text": "Boolean(sourceLabel)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 247,
        "column": 21,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 247,
        "endColumn": 69,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [7553, 7601],
              "text": "((dom.querySelector('h1, h2')?.textContent?.trim()) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": {
              "range": [7553, 7601],
              "text": "((dom.querySelector('h1, h2')?.textContent?.trim()) ?? \"\")"
            },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [7553, 7601],
              "text": "(Boolean((dom.querySelector('h1, h2')?.textContent?.trim())))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 41,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Moodle Adapter for Monash University Learning Management System\n *\n * Extracts course codes and context from Moodle pages.\n */\n\nimport type { BaseAdapter } from './baseAdapter';\nimport type { CourseContext, PageContext } from '../../core/domain/types';\nimport { extractCourseCodeFromText } from '../../core/utils/textUtils';\n\n/**\n * Moodle-specific adapter for learning.monash.edu\n */\nexport class MoodleAdapter implements BaseAdapter {\n  constructor() {}\n\n  canHandle(url: string): boolean {\n    return url.includes('learning.monash.edu');\n  }\n\n  /**\n   * Get course code from page DOM\n   */\n  getCourseCode(dom: Document): string | null {\n    // Try multiple strategies to find course code\n    const candidateTexts: string[] = [];\n\n    // 1. Check meta tags\n    const metaSelectors = [\n      'meta[property=\"og:title\"]',\n      'meta[name=\"twitter:title\"]',\n      'meta[name=\"title\"]',\n    ];\n    metaSelectors.forEach((selector) => {\n      const content = dom.querySelector(selector)?.getAttribute('content');\n      if (content) candidateTexts.push(content);\n    });\n\n    // 2. Check headings\n    const headingSelectors = [\n      'h1',\n      'h2',\n      '.page-header-headings',\n      '.page-header-headings h1',\n      '.course-title',\n      '.breadcrumb',\n      \"[data-region='course-header']\",\n    ];\n    headingSelectors.forEach((selector) => {\n      dom.querySelectorAll(selector).forEach((el) => {\n        const text = el.textContent?.trim();\n        if (text) candidateTexts.push(text);\n      });\n    });\n\n    // 3. Check body text (first 8000 chars)\n    const bodyText = dom.body?.innerText || '';\n    if (bodyText) {\n      candidateTexts.push(bodyText.substring(0, 8000));\n    }\n\n    // Try to extract course code from candidates\n    for (const text of candidateTexts) {\n      const code = extractCourseCodeFromText(text);\n      if (code) {\n        // Cache the mapping if we have a course ID\n        const courseId = this.getCourseId(dom);\n        if (courseId) {\n          this.persistCourseMapping(courseId, code);\n        }\n        return code;\n      }\n    }\n\n    // Fallback: check cached mapping\n    const courseId = this.getCourseId(dom);\n    if (courseId) {\n      return this.getStoredCourseMapping(courseId);\n    }\n\n    return null;\n  }\n\n  /**\n   * Extract week number from Moodle page\n   *\n   * Looks for the \"Week X\" label that appears above topic headings on Moodle learning pages.\n   * Only returns a week if found in a specific, reliable location (not in general content).\n   */\n  getWeek(dom: Document): number | null {\n    // Pattern: \"Week 1\", \"Week 2\", etc. (case insensitive)\n    const weekPattern = /^\\s*Week\\s+(\\d{1,2})\\s*$/i;\n\n    // First strategy: Look for a standalone \"Week X\" text element\n    // On Moodle, this appears as a separate element above the topic title\n    // It's often in a <strong> or standalone text near the section header\n\n    // Check section info areas and headings - these should have ONLY \"Week X\"\n    const preciseSelectors = [\n      // Moodle section info region\n      '[data-region=\"section-info\"] .text-muted',\n      '[data-region=\"section-info\"]',\n      // Activity header area\n      '.activity-header .text-muted',\n      '.page-header-headings .text-muted',\n      // Breadcrumb might have it\n      '.breadcrumb-item.active',\n    ];\n\n    for (const selector of preciseSelectors) {\n      const elements = dom.querySelectorAll(selector);\n      for (const el of elements) {\n        const text = el.textContent?.trim() || '';\n        const match = text.match(weekPattern);\n        const weekToken = match?.[1];\n        if (weekToken) {\n          const weekNum = parseInt(weekToken, 10);\n          if (weekNum > 0 && weekNum <= 52) {\n            return weekNum;\n          }\n        }\n      }\n    }\n\n    // Second strategy: Look for \"Week X\" as a small heading or label\n    // Check h2, h3, strong elements but only if they contain JUST \"Week X\"\n    const headingSelectors = ['h2', 'h3', 'h4', 'strong', '.section-title'];\n\n    for (const selector of headingSelectors) {\n      const elements = dom.querySelectorAll(selector);\n      for (const el of elements) {\n        const text = el.textContent?.trim() || '';\n        // Only match if the element contains just \"Week X\" (possibly with whitespace)\n        const match = text.match(weekPattern);\n        const weekToken = match?.[1];\n        if (weekToken) {\n          const weekNum = parseInt(weekToken, 10);\n          if (weekNum > 0 && weekNum <= 52) {\n            return weekNum;\n          }\n        }\n      }\n    }\n\n    // Third strategy: Look for Week X at the very start of the main content\n    // The week label on Moodle pages is typically in the first 300 chars of section content\n    const sectionContent = dom.querySelector('.course-content .section, #region-main .content');\n    if (sectionContent) {\n      const text = (sectionContent.textContent || '').substring(0, 300);\n      // Look for \"Week X\" at the start of content (possibly after whitespace)\n      const startMatch = text.match(/^\\s*Week\\s+(\\d{1,2})\\b/i);\n      const weekToken = startMatch?.[1];\n      if (weekToken) {\n        const weekNum = parseInt(weekToken, 10);\n        if (weekNum > 0 && weekNum <= 52) {\n          return weekNum;\n        }\n      }\n    }\n\n    // No reliable week indicator found\n    return null;\n  }\n\n  /**\n   * Extract topic/title from page\n   */\n  getTopic(dom: Document): string | null {\n    const heading = dom.querySelector('h1, h2')?.textContent?.trim();\n    return heading || null;\n  }\n\n  /**\n   * Get course ID from URL query params\n   */\n  private getCourseId(dom: Document): string | null {\n    const url = new URL(dom.location.href);\n    return url.searchParams.get('id');\n  }\n\n  /**\n   * Get stored course code mapping from localStorage\n   */\n  private getStoredCourseMapping(courseId: string): string | null {\n    try {\n      const raw = localStorage.getItem('lockin:monashCourseCodes');\n      const mapping = raw ? JSON.parse(raw) : {};\n      return mapping[courseId] || null;\n    } catch (error) {\n      console.warn('Failed to read cached Monash course codes', error);\n      return null;\n    }\n  }\n\n  /**\n   * Persist course code mapping to localStorage\n   */\n  private persistCourseMapping(courseId: string, courseCode: string): void {\n    if (!courseId || !courseCode) return;\n\n    try {\n      const existing = this.getStoredCourseMapping(courseId)\n        ? JSON.parse(localStorage.getItem('lockin:monashCourseCodes') || '{}')\n        : {};\n\n      if (existing[courseId] === courseCode) return;\n\n      const next = { ...existing, [courseId]: courseCode };\n      localStorage.setItem('lockin:monashCourseCodes', JSON.stringify(next));\n    } catch (error) {\n      console.warn('Failed to persist Monash course code', error);\n    }\n  }\n\n  /**\n   * Get full course context\n   */\n  getCourseContext(dom: Document, url: string): CourseContext {\n    const courseCode = this.getCourseCode(dom);\n    const topic = this.getTopic(dom);\n    const week = this.getWeek(dom);\n\n    const context: CourseContext = {\n      courseCode,\n      sourceUrl: url,\n    };\n    if (courseCode) {\n      context.courseName = courseCode;\n    }\n    if (week !== null) {\n      context.week = week;\n    }\n    if (topic) {\n      context.topic = topic;\n    }\n    const sourceLabel = week !== null ? `Week ${week}` : topic || courseCode || '';\n    if (sourceLabel) {\n      context.sourceLabel = sourceLabel;\n    }\n    return context;\n  }\n\n  /**\n   * Get full page context\n   */\n  getPageContext(dom: Document, url: string): PageContext {\n    const heading = dom.querySelector('h1, h2')?.textContent?.trim() || dom.title;\n    const courseContext = this.getCourseContext(dom, url);\n\n    return {\n      url,\n      title: dom.title,\n      heading,\n      courseContext,\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\integrations\\index.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 36,
        "column": 41,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 36,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-exports",
        "severity": 1,
        "message": "Type export BaseAdapter is not a value and should be exported using `export type`.",
        "line": 43,
        "column": 1,
        "nodeType": "ExportNamedDeclaration",
        "messageId": "singleExportIsType",
        "endLine": 43,
        "endColumn": 70,
        "fix": {
          "range": [1144, 1211],
          "text": "export type { BaseAdapter };\nexport { GenericAdapter, MoodleAdapter, EdstemAdapter "
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "/**\n * Site Adapter Factory\n *\n * Selects the appropriate adapter based on the current URL.\n */\n\nimport type { BaseAdapter } from './adapters/baseAdapter';\nimport { GenericAdapter } from './adapters/baseAdapter';\nimport { MoodleAdapter } from './adapters/moodleAdapter';\nimport { EdstemAdapter } from './adapters/edstemAdapter';\n\n// Registry of all adapters (order matters - more specific first)\nconst adapters: BaseAdapter[] = [\n  new MoodleAdapter(),\n  new EdstemAdapter(),\n  new GenericAdapter(), // Fallback - must be last\n];\n\n/**\n * Get the appropriate adapter for the given URL\n */\nexport function getAdapterForUrl(url: string): BaseAdapter {\n  for (const adapter of adapters) {\n    if (adapter.canHandle(url)) {\n      return adapter;\n    }\n  }\n  // Should never reach here since GenericAdapter handles everything\n  return new GenericAdapter();\n}\n\n/**\n * Get adapter for current page\n */\nexport function getCurrentAdapter(): BaseAdapter {\n  if (typeof window === 'undefined' || !window.location) {\n    return new GenericAdapter();\n  }\n  return getAdapterForUrl(window.location.href);\n}\n\n// Export adapter classes for direct use if needed\nexport { BaseAdapter, GenericAdapter, MoodleAdapter, EdstemAdapter };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\postcss.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\scripts\\ci\\check-complexity-delta.js",
    "messages": [
      {
        "ruleId": "max-depth",
        "severity": 1,
        "message": "Blocks are nested too deeply (5). Maximum allowed is 4.",
        "line": 28,
        "column": 9,
        "nodeType": "IfStatement",
        "messageId": "tooDeeply",
        "endLine": 30,
        "endColumn": 10
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import fs from 'node:fs';\n\nconst input = fs.readFileSync(0, 'utf8').trim();\n\nif (!input) {\n  console.log('No ESLint JSON input provided.');\n  process.exit(0);\n}\n\nlet results;\ntry {\n  results = JSON.parse(input);\n} catch (error) {\n  console.error('Invalid ESLint JSON input.');\n  process.exit(1);\n}\n\nconst complexityMessages = [];\nlet maxComplexity = 0;\n\nfor (const result of results) {\n  for (const message of result.messages || []) {\n    if (message.ruleId === 'complexity') {\n      complexityMessages.push(message);\n      const match = /complexity of (\\d+)/i.exec(message.message || '');\n      if (match) {\n        const value = Number(match[1]);\n        if (!Number.isNaN(value)) {\n          maxComplexity = Math.max(maxComplexity, value);\n        }\n      }\n    }\n  }\n}\n\nconst errorCount = complexityMessages.filter((message) => message.severity === 2).length;\n\nif (errorCount > 0) {\n  console.error(`Complexity errors detected: ${errorCount}`);\n  process.exit(1);\n}\n\nif (complexityMessages.length > 0) {\n  console.log(\n    `Complexity warnings detected: ${complexityMessages.length}. Max complexity: ${maxComplexity || 'unknown'}.`,\n  );\n} else {\n  console.log('No complexity findings detected.');\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\scripts\\ci\\verify-build.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\scripts\\dev\\check-doc-links.mjs",
    "messages": [
      {
        "ruleId": "no-script-url",
        "severity": 1,
        "message": "Script URL is a form of eval.",
        "line": 91,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "unexpectedScriptURL",
        "endLine": 91,
        "endColumn": 35
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { execSync } from 'node:child_process';\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nconst repoRoot = process.cwd();\n\nfunction getMarkdownFiles() {\n  try {\n    const output = execSync('git ls-files \"*.md\"', {\n      cwd: repoRoot,\n      stdio: ['ignore', 'pipe', 'ignore'],\n      encoding: 'utf8',\n    });\n\n    return output\n      .split(/\\r?\\n/)\n      .map((line) => line.trim())\n      .filter((line) => line.length > 0);\n  } catch (error) {\n    // Fallback: simple recursive scan that skips common large folders.\n    const results = [];\n    const skip = new Set(['.git', 'node_modules', 'coverage', 'dist', 'build']);\n\n    function walk(dir) {\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\n      for (const entry of entries) {\n        if (skip.has(entry.name)) {\n          continue;\n        }\n\n        const fullPath = path.join(dir, entry.name);\n        if (entry.isDirectory()) {\n          walk(fullPath);\n          continue;\n        }\n\n        if (entry.isFile() && entry.name.toLowerCase().endsWith('.md')) {\n          results.push(path.relative(repoRoot, fullPath));\n        }\n      }\n    }\n\n    walk(repoRoot);\n    return results;\n  }\n}\n\nfunction stripCode(content) {\n  // Remove fenced code blocks first, then inline code.\n  const withoutFences = content.replace(/```[\\s\\S]*?```/g, '');\n  return withoutFences.replace(/`[^`\\n]*`/g, '');\n}\n\nfunction extractLinks(content) {\n  const sanitized = stripCode(content);\n  const links = [];\n  const linkRegex = /!?\\[[^\\]]*]\\(([^)]+)\\)/g;\n\n  let match;\n  while ((match = linkRegex.exec(sanitized)) !== null) {\n    links.push(match[1]);\n  }\n\n  return links;\n}\n\nfunction normalizeTarget(rawTarget) {\n  const trimmed = rawTarget.trim();\n  if (trimmed.length === 0) {\n    return null;\n  }\n\n  // Remove optional title by taking the first token or <...> block.\n  const angleMatch = trimmed.match(/^<([^>]+)>/);\n  const firstToken = angleMatch ? angleMatch[1] : trimmed.split(/\\s+/)[0];\n  if (!firstToken) {\n    return null;\n  }\n\n  // Ignore anchors and external protocols.\n  if (firstToken.startsWith('#')) {\n    return null;\n  }\n\n  const lower = firstToken.toLowerCase();\n  if (\n    lower.startsWith('http://') ||\n    lower.startsWith('https://') ||\n    lower.startsWith('mailto:') ||\n    lower.startsWith('tel:') ||\n    lower.startsWith('javascript:') ||\n    lower.startsWith('data:')\n  ) {\n    return null;\n  }\n\n  // Strip query and anchor fragments for file existence checks.\n  const [withoutQuery] = firstToken.split('?');\n  const [withoutHash] = withoutQuery.split('#');\n\n  try {\n    return decodeURIComponent(withoutHash);\n  } catch {\n    return withoutHash;\n  }\n}\n\nfunction candidatePaths(fromFile, targetPath) {\n  const fromDir = path.dirname(path.join(repoRoot, fromFile));\n\n  const repoRelative = targetPath.startsWith('/')\n    ? path.join(repoRoot, targetPath.slice(1))\n    : path.resolve(fromDir, targetPath);\n\n  const candidates = new Set();\n  candidates.add(repoRelative);\n\n  const ext = path.extname(repoRelative);\n  if (!ext) {\n    candidates.add(`${repoRelative}.md`);\n    candidates.add(path.join(repoRelative, 'README.md'));\n  } else if (ext.toLowerCase() !== '.md') {\n    // Allow linking to other file types directly.\n    candidates.add(repoRelative);\n  }\n\n  return Array.from(candidates);\n}\n\nfunction pathExistsAny(candidates) {\n  return candidates.some((candidate) => fs.existsSync(candidate));\n}\n\nconst markdownFiles = getMarkdownFiles();\nconst errors = [];\n\nfor (const file of markdownFiles) {\n  const fullPath = path.join(repoRoot, file);\n  const content = fs.readFileSync(fullPath, 'utf8');\n  const rawLinks = extractLinks(content);\n\n  for (const rawTarget of rawLinks) {\n    const target = normalizeTarget(rawTarget);\n    if (!target) {\n      continue;\n    }\n\n    const candidates = candidatePaths(file, target);\n    if (!pathExistsAny(candidates)) {\n      errors.push({\n        file,\n        target,\n        checked: candidates.map((c) => path.relative(repoRoot, c)),\n      });\n    }\n  }\n}\n\nif (errors.length > 0) {\n  console.error('Broken markdown links detected:\\n');\n  for (const error of errors) {\n    console.error(`- ${error.file}: ${error.target}`);\n  }\n  console.error(`\\nTotal broken links: ${errors.length}`);\n  process.exit(1);\n}\n\nconsole.log(`Doc link check passed (${markdownFiles.length} markdown files).`);\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\shared\\ui\\components\\Button.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 17,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 17,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 45,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 45,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1366, 1374], "text": "(disabled ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1366, 1374], "text": "(disabled === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Button Component\n *\n * Reusable button component with variants.\n * Uses Tailwind CSS for styling.\n */\n\nimport React from 'react';\n\nexport interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  variant?: 'primary' | 'secondary' | 'ghost' | 'danger';\n  size?: 'sm' | 'md' | 'lg';\n  isLoading?: boolean;\n  children: React.ReactNode;\n}\n\nexport function Button({\n  variant = 'primary',\n  size = 'md',\n  isLoading = false,\n  disabled,\n  className = '',\n  children,\n  ...props\n}: ButtonProps) {\n  const baseClasses =\n    'font-medium transition-colors rounded-md focus:outline-none focus:ring-2 focus:ring-offset-1 disabled:opacity-50 disabled:cursor-not-allowed';\n\n  const variantClasses = {\n    primary: 'bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800 focus:ring-blue-500',\n    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 active:bg-gray-400 focus:ring-gray-500',\n    ghost: 'bg-transparent text-gray-700 hover:bg-gray-100 active:bg-gray-200 focus:ring-gray-400',\n    danger: 'bg-red-600 text-white hover:bg-red-700 active:bg-red-800 focus:ring-red-500',\n  };\n\n  const sizeClasses = {\n    sm: 'px-2 py-1 text-sm',\n    md: 'px-4 py-2 text-base',\n    lg: 'px-6 py-3 text-lg',\n  };\n\n  return (\n    <button\n      className={`${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${className}`}\n      disabled={disabled || isLoading}\n      aria-busy={isLoading}\n      {...props}\n    >\n      <span className=\"flex items-center justify-center gap-2\">\n        {isLoading && (\n          <span\n            className=\"h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent\"\n            aria-hidden\n          />\n        )}\n        <span className={isLoading ? 'opacity-80' : undefined}>{children}</span>\n      </span>\n    </button>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\shared\\ui\\components\\Card.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 17,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 17,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 22,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 22,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [553, 560], "text": "(onClick != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Card Component\n *\n * Reusable card component for content containers.\n * Uses Tailwind CSS for styling.\n */\n\nimport React from 'react';\n\nexport interface CardProps {\n  children: React.ReactNode;\n  className?: string;\n  onClick?: () => void;\n  isActive?: boolean;\n}\n\nexport function Card({ children, className = '', onClick, isActive = false }: CardProps) {\n  return (\n    <div\n      className={`p-3 border rounded-lg bg-white transition-colors ${\n        isActive ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:border-gray-300'\n      } ${onClick ? 'cursor-pointer' : ''} ${className}`}\n      onClick={onClick}\n    >\n      {children}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\shared\\ui\\components\\ConfirmDialog.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'ConfirmDialog' has too many lines (121). Maximum allowed is 50.",
        "line": 33,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 169,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 33,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 33,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 53,
        "column": 10,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 53,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 63,
        "column": 46,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 63,
        "endColumn": 48
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useRef, useCallback } from 'react';\nimport { AlertTriangle, X } from 'lucide-react';\n\nexport interface ConfirmDialogProps {\n  /** Whether the dialog is open */\n  isOpen: boolean;\n  /** Called when dialog should close */\n  onClose: () => void;\n  /** Called when user confirms the action */\n  onConfirm: () => void;\n  /** Dialog title */\n  title: string;\n  /** Dialog description/message */\n  description: string;\n  /** Text for confirm button */\n  confirmLabel?: string;\n  /** Text for cancel button */\n  cancelLabel?: string;\n  /** Variant affects styling - 'danger' for destructive actions */\n  variant?: 'default' | 'danger';\n  /** Whether confirm action is in progress */\n  isLoading?: boolean;\n}\n\n/**\n * A reusable confirmation dialog component following industry best practices:\n * - Accessible with proper ARIA attributes and focus management\n * - Keyboard support (Escape to close, Tab trapping)\n * - Click outside to close\n * - Smooth animations\n * - Supports loading state\n */\nexport function ConfirmDialog({\n  isOpen,\n  onClose,\n  onConfirm,\n  title,\n  description,\n  confirmLabel = 'Confirm',\n  cancelLabel = 'Cancel',\n  variant = 'default',\n  isLoading = false,\n}: ConfirmDialogProps) {\n  const dialogRef = useRef<HTMLDivElement>(null);\n  const cancelButtonRef = useRef<HTMLButtonElement>(null);\n\n  // Focus management: focus cancel button when dialog opens\n  useEffect(() => {\n    if (isOpen) {\n      // Small delay to ensure dialog is rendered\n      const timer = setTimeout(() => {\n        cancelButtonRef.current?.focus();\n      }, 50);\n      return () => clearTimeout(timer);\n    }\n    return undefined;\n  }, [isOpen]);\n\n  // Handle Escape key to close\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape' && !isLoading) {\n        onClose();\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [isOpen, isLoading, onClose]);\n\n  // Prevent body scroll when dialog is open\n  useEffect(() => {\n    if (isOpen) {\n      const originalOverflow = document.body.style.overflow;\n      document.body.style.overflow = 'hidden';\n      return () => {\n        document.body.style.overflow = originalOverflow;\n      };\n    }\n    return undefined;\n  }, [isOpen]);\n\n  const handleBackdropClick = useCallback(\n    (e: React.MouseEvent) => {\n      if (e.target === e.currentTarget && !isLoading) {\n        onClose();\n      }\n    },\n    [isLoading, onClose],\n  );\n\n  const handleConfirm = useCallback(() => {\n    if (!isLoading) {\n      onConfirm();\n    }\n  }, [isLoading, onConfirm]);\n\n  if (!isOpen) return null;\n\n  const isDanger = variant === 'danger';\n\n  return (\n    <div className=\"lockin-confirm-backdrop\" onClick={handleBackdropClick} role=\"presentation\">\n      <div\n        ref={dialogRef}\n        className=\"lockin-confirm-dialog\"\n        role=\"alertdialog\"\n        aria-modal=\"true\"\n        aria-labelledby=\"confirm-dialog-title\"\n        aria-describedby=\"confirm-dialog-description\"\n      >\n        <div className=\"lockin-confirm-header\">\n          <div className={`lockin-confirm-icon ${isDanger ? 'is-danger' : ''}`}>\n            <AlertTriangle size={24} strokeWidth={2} />\n          </div>\n          <button\n            type=\"button\"\n            className=\"lockin-confirm-close\"\n            onClick={onClose}\n            disabled={isLoading}\n            aria-label=\"Close dialog\"\n          >\n            <X size={18} strokeWidth={2} />\n          </button>\n        </div>\n\n        <div className=\"lockin-confirm-content\">\n          <h3 id=\"confirm-dialog-title\" className=\"lockin-confirm-title\">\n            {title}\n          </h3>\n          <p id=\"confirm-dialog-description\" className=\"lockin-confirm-description\">\n            {description}\n          </p>\n        </div>\n\n        <div className=\"lockin-confirm-actions\">\n          <button\n            ref={cancelButtonRef}\n            type=\"button\"\n            className=\"lockin-confirm-btn lockin-confirm-btn-cancel\"\n            onClick={onClose}\n            disabled={isLoading}\n          >\n            {cancelLabel}\n          </button>\n          <button\n            type=\"button\"\n            className={`lockin-confirm-btn ${\n              isDanger ? 'lockin-confirm-btn-danger' : 'lockin-confirm-btn-primary'\n            }`}\n            onClick={handleConfirm}\n            disabled={isLoading}\n          >\n            {isLoading ? (\n              <>\n                <span className=\"lockin-confirm-spinner\" aria-hidden=\"true\" />\n                <span>Deleting...</span>\n              </>\n            ) : (\n              confirmLabel\n            )}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\shared\\ui\\components\\Tabs.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'Tabs' has too many lines (71). Maximum allowed is 50.",
        "line": 24,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 100,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 24,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 24,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 30,
        "column": 42,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 30,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 43,
        "column": 88,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 43,
        "endColumn": 90
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 46,
        "column": 44,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 46,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 49,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 49,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1437, 1445], "text": "nextTab == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 94,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorOther",
        "endLine": 94,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Tabs Component\n *\n * Reusable tabbed interface component.\n * Uses Tailwind CSS for styling.\n */\n\nimport React from 'react';\n\nexport interface Tab {\n  id: string;\n  label: string;\n  icon?: React.ReactNode;\n}\n\nexport interface TabsProps {\n  tabs: Tab[];\n  activeTab: string;\n  onTabChange: (tabId: string) => void;\n  variant?: 'line' | 'pill';\n  ariaLabel?: string;\n}\n\nexport function Tabs({ tabs, activeTab, onTabChange, variant = 'line', ariaLabel }: TabsProps) {\n  const containerClasses =\n    variant === 'line'\n      ? 'flex gap-0 border-b border-gray-200'\n      : 'flex gap-2 bg-gray-100 p-1 rounded-lg';\n\n  const tabClasses = (isActive: boolean) =>\n    variant === 'line'\n      ? `px-4 py-2 text-sm font-medium transition-colors border-b-2 ${\n          isActive\n            ? 'border-blue-600 text-blue-600'\n            : 'border-transparent text-gray-600 hover:text-gray-900'\n        }`\n      : `px-4 py-2 text-sm font-medium transition-colors rounded-md ${\n          isActive ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-600 hover:text-gray-900'\n        }`;\n\n  const tabRefs = React.useRef<(HTMLButtonElement | null)[]>([]);\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLButtonElement>, index: number) => {\n    if (tabs.length === 0) return;\n\n    const focusTab = (targetIndex: number) => {\n      const nextIndex = (targetIndex + tabs.length) % tabs.length;\n      const nextTab = tabs[nextIndex];\n      if (!nextTab) return;\n      onTabChange(nextTab.id);\n      tabRefs.current[nextIndex]?.focus();\n    };\n\n    switch (event.key) {\n      case 'ArrowRight':\n      case 'ArrowDown':\n        event.preventDefault();\n        focusTab(index + 1);\n        break;\n      case 'ArrowLeft':\n      case 'ArrowUp':\n        event.preventDefault();\n        focusTab(index - 1);\n        break;\n      case 'Home':\n        event.preventDefault();\n        focusTab(0);\n        break;\n      case 'End':\n        event.preventDefault();\n        focusTab(tabs.length - 1);\n        break;\n      default:\n        break;\n    }\n  };\n\n  return (\n    <div className={containerClasses} role=\"tablist\" aria-label={ariaLabel}>\n      {tabs.map((tab, index) => (\n        <button\n          key={tab.id}\n          ref={(node) => {\n            tabRefs.current[index] = node;\n          }}\n          className={tabClasses(tab.id === activeTab)}\n          onClick={() => onTabChange(tab.id)}\n          onKeyDown={(event) => handleKeyDown(event, index)}\n          type=\"button\"\n          role=\"tab\"\n          aria-selected={tab.id === activeTab}\n          tabIndex={tab.id === activeTab ? 0 : -1}\n        >\n          {tab.icon && <span className=\"inline mr-1\">{tab.icon}</span>}\n          {tab.label}\n        </button>\n      ))}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\shared\\ui\\components\\TextInput.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 16,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 16,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 19,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 19,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [482, 487], "text": "(error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [482, 487], "text": "(error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [482, 487], "text": "(Boolean(error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 20,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 20,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [541, 551], "text": "(helperText != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [541, 551], "text": "(helperText ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [541, 551], "text": "(Boolean(helperText))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 20,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 20,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [555, 561], "text": "(error == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [556, 561], "text": "(error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [555, 561], "text": "(!Boolean(error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 24,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 24,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [658, 663], "text": "(label != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [658, 663], "text": "(label ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [658, 663], "text": "(Boolean(label))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 31,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 31,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [927, 932], "text": "(error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [927, 932], "text": "(error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [927, 932], "text": "(Boolean(error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 38,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 38,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1177, 1182], "text": "(error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1177, 1182], "text": "(error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1177, 1182], "text": "(Boolean(error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 43,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 43,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1299, 1309], "text": "(helperText != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1299, 1309], "text": "(helperText ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1299, 1309], "text": "(Boolean(helperText))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 43,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 43,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1313, 1319], "text": "(error == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1314, 1319], "text": "(error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1313, 1319], "text": "(!Boolean(error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * TextInput Component\n *\n * Reusable text input component.\n * Uses Tailwind CSS for styling.\n */\n\nimport React, { useId } from 'react';\n\nexport interface TextInputProps extends React.InputHTMLAttributes<HTMLInputElement> {\n  label?: string;\n  error?: string;\n  helperText?: string;\n}\n\nexport function TextInput({ label, error, helperText, className = '', ...props }: TextInputProps) {\n  const generatedId = useId();\n  const inputId = props.id ?? generatedId;\n  const errorId = error ? `${inputId}-error` : undefined;\n  const helperId = helperText && !error ? `${inputId}-helper` : undefined;\n\n  return (\n    <div className=\"flex flex-col gap-1\">\n      {label && (\n        <label htmlFor={inputId} className=\"text-sm font-medium text-gray-700\">\n          {label}\n        </label>\n      )}\n      <input\n        className={`px-3 py-2 border rounded-md text-base focus:outline-none focus:ring-2 transition-colors ${\n          error ? 'border-red-500 focus:ring-red-500' : 'border-gray-300 focus:ring-blue-500'\n        } ${className}`}\n        id={inputId}\n        aria-invalid={Boolean(error)}\n        aria-describedby={errorId ?? helperId}\n        {...props}\n      />\n      {error && (\n        <span id={errorId} className=\"text-sm text-red-600\">\n          {error}\n        </span>\n      )}\n      {helperText && !error && (\n        <span id={helperId} className=\"text-sm text-gray-500\">\n          {helperText}\n        </span>\n      )}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\shared\\ui\\components\\Toast.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 33,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 33,
        "endColumn": 22
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3000.",
        "line": 36,
        "column": 14,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 36,
        "endColumn": 18
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 48,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 48,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 54,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 54,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 56,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 56,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 88,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 88,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 95,
        "column": 65,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 95,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 99,
        "column": 24,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 99,
        "endColumn": 26
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useState } from 'react';\nimport { Star, Check, X, AlertCircle } from 'lucide-react';\n\nexport type ToastType = 'success' | 'error' | 'info' | 'star';\n\nexport interface ToastProps {\n  /** Toast message */\n  message: string;\n  /** Toast type for styling */\n  type?: ToastType;\n  /** Duration in ms before auto-dismiss (0 = no auto-dismiss) */\n  duration?: number;\n  /** Called when toast should be dismissed */\n  onDismiss: () => void;\n  /** Whether the toast is visible */\n  isVisible: boolean;\n}\n\nconst ICON_MAP = {\n  success: Check,\n  error: AlertCircle,\n  info: AlertCircle,\n  star: Star,\n};\n\n/**\n * A toast notification component following industry best practices:\n * - Accessible with proper ARIA attributes\n * - Auto-dismisses after configurable duration\n * - Smooth enter/exit animations\n * - Supports multiple types with appropriate icons\n */\nexport function Toast({\n  message,\n  type = 'info',\n  duration = 3000,\n  onDismiss,\n  isVisible,\n}: ToastProps) {\n  const [isLeaving, setIsLeaving] = useState(false);\n\n  useEffect(() => {\n    if (!isVisible || duration === 0) return;\n\n    const timer = setTimeout(() => {\n      setIsLeaving(true);\n      // Wait for exit animation before actually dismissing\n      setTimeout(onDismiss, 200);\n    }, duration);\n\n    return () => clearTimeout(timer);\n  }, [isVisible, duration, onDismiss]);\n\n  const handleDismiss = () => {\n    setIsLeaving(true);\n    setTimeout(onDismiss, 200);\n  };\n\n  if (!isVisible) return null;\n\n  const Icon = ICON_MAP[type];\n\n  return (\n    <div\n      className={`lockin-toast lockin-toast-${type} ${isLeaving ? 'is-leaving' : ''}`}\n      role=\"alert\"\n      aria-live=\"polite\"\n    >\n      <div className=\"lockin-toast-icon\">\n        <Icon size={16} strokeWidth={2.5} />\n      </div>\n      <span className=\"lockin-toast-message\">{message}</span>\n      <button\n        type=\"button\"\n        className=\"lockin-toast-dismiss\"\n        onClick={handleDismiss}\n        aria-label=\"Dismiss notification\"\n      >\n        <X size={14} strokeWidth={2} />\n      </button>\n    </div>\n  );\n}\n\n/**\n * Hook for managing toast state\n */\nexport function useToast() {\n  const [toast, setToast] = useState<{\n    message: string;\n    type: ToastType;\n    isVisible: boolean;\n  } | null>(null);\n\n  const showToast = (message: string, type: ToastType = 'info') => {\n    setToast({ message, type, isVisible: true });\n  };\n\n  const hideToast = () => {\n    setToast(null);\n  };\n\n  return {\n    toast,\n    showToast,\n    hideToast,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\shared\\ui\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\tailwind.config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\tools\\stubs\\react-markdown.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 9,
        "column": 16,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 9,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\n\ntype ReactMarkdownStubProps = {\n  children?: React.ReactNode;\n  className?: string;\n  [key: string]: unknown;\n};\n\nexport default function ReactMarkdownStub({ children }: ReactMarkdownStubProps) {\n  return <>{children}</>;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\tools\\stubs\\react-syntax-highlighter-prism.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\tools\\stubs\\react-syntax-highlighter.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 9,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 9,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\n\ntype SyntaxHighlighterStubProps = {\n  children?: React.ReactNode;\n  className?: string;\n  [key: string]: unknown;\n};\n\nexport function Prism({ children, ...props }: SyntaxHighlighterStubProps) {\n  return (\n    <pre {...props}>\n      <code>{children}</code>\n    </pre>\n  );\n}\n\nexport default Prism;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\tools\\stubs\\remark-gfm.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 1,
        "column": 16,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 1,
        "endColumn": 38
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "export default function remarkGfmStub() {\n  return null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\types\\optional-deps.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\LockInSidebar.tsx",
    "messages": [
      {
        "ruleId": "no-restricted-imports",
        "severity": 1,
        "message": "'../../integrations/adapters/baseAdapter' import is restricted from being used by a pattern. UI cannot import backend/extension/integrations code.",
        "line": 36,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "messageId": "patternWithCustomMessage",
        "endLine": 36,
        "endColumn": 76
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'LockInSidebarContent' has too many lines (150). Maximum allowed is 50.",
        "line": 49,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 210,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 49,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 49,
        "endColumn": 30
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Function 'LockInSidebarContent' has a complexity of 18. Maximum allowed is 15.",
        "line": 49,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 49,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 68,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 68,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2307, 2324], "text": "activeTabExternal != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2307, 2324], "text": "activeTabExternal ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2307, 2324], "text": "Boolean(activeTabExternal)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 71,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 71,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2401, 2408], "text": "storage != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 85,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 85,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2707, 2716], "text": "(apiClient != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 107,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 107,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3201, 3208], "text": "storage != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 112,
        "column": 22,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 112,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [3333, 3370],
              "text": "((pageContext?.courseContext.courseCode) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": {
              "range": [3333, 3370],
              "text": "((pageContext?.courseContext.courseCode) ?? \"\")"
            },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [3333, 3370],
              "text": "(Boolean((pageContext?.courseContext.courseCode)))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 113,
        "column": 19,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 113,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3398, 3414], "text": "((pageContext?.url) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3398, 3414], "text": "((pageContext?.url) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3398, 3414], "text": "(Boolean((pageContext?.url)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 116,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 116,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3508, 3520], "text": "activeToolId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3508, 3520], "text": "activeToolId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3508, 3520], "text": "Boolean(activeToolId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 123,
        "column": 7,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 123,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [3664, 3664], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [3664, 3664], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 155,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 155,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4657, 4664], "text": "(storage != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 160,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 160,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4877, 4891], "text": "(onClearPrefill != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 1,
        "message": "Promise-returning function provided to attribute where a void return was expected.",
        "line": 171,
        "column": 30,
        "nodeType": "JSXExpressionContainer",
        "messageId": "voidReturnAttribute",
        "endLine": 171,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 212,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 212,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * LockInSidebar\n *\n * Main sidebar orchestrator for the Lock-in extension.\n */\nimport { useEffect, useMemo, useState } from 'react';\nimport type { PageContext, StudyMode } from '../../core/domain/types';\nimport type { ApiClient } from '../../api/client';\nimport { createNotesService } from '../../core/services/notesService.ts';\nimport type { NotesService } from '../../core/services/notesService.ts';\nimport { useNotesList } from '../hooks/useNotesList';\nimport { NotesPanel } from './notes/NotesPanel';\nimport { ToolProvider, useToolContext } from './tools';\nimport { NoteSaveProvider } from './contexts/NoteSaveContext';\nimport { TranscriptCacheProvider } from './contexts/TranscriptCacheContext';\nimport { ChatQueryProvider } from './chat';\nimport { FeedbackModal } from './feedback';\nimport { PrivacyNotice } from './sidebar/PrivacyNotice';\nimport { SidebarLayout } from './sidebar/SidebarLayout';\nimport { SidebarTabs } from './sidebar/SidebarTabs';\nimport { ChatSection } from './sidebar/ChatSection';\nimport { SidebarHeaderActions } from './sidebar/SidebarHeaderActions';\nimport { ToolSection } from './sidebar/ToolSection';\nimport { useResize } from './sidebar/useResize';\nimport {\n  CHAT_TAB_ID,\n  NOTES_TAB_ID,\n  TOOL_TAB_ID,\n  SIDEBAR_WIDTH_KEY,\n  SIDEBAR_MIN_WIDTH,\n  SIDEBAR_MAX_WIDTH,\n  SIDEBAR_MAX_VW,\n} from './sidebar/constants';\nimport type { StorageAdapter } from './sidebar/types';\nimport { useSidebarState } from './sidebar/useSidebarState';\nimport type { BaseAdapter } from '../../integrations/adapters/baseAdapter';\nexport interface LockInSidebarProps {\n  apiClient: ApiClient | null;\n  isOpen: boolean;\n  onToggle: () => void;\n  currentMode: StudyMode;\n  pendingPrefill?: string;\n  onClearPrefill?: () => void;\n  pageContext?: PageContext;\n  adapter?: BaseAdapter;\n  storage?: StorageAdapter;\n  activeTabExternal?: string;\n}\nfunction LockInSidebarContent({\n  apiClient,\n  isOpen,\n  onToggle,\n  currentMode,\n  pendingPrefill,\n  onClearPrefill,\n  pageContext,\n  storage,\n  activeTabExternal,\n}: LockInSidebarProps) {\n  const { activeToolId, activeToolTitle, closeTool } = useToolContext();\n  const [isFeedbackOpen, setIsFeedbackOpen] = useState(false);\n\n  const sidebarStateOptions: Parameters<typeof useSidebarState>[0] = {\n    currentMode,\n    isOpen,\n    onToggle,\n  };\n  if (activeTabExternal) {\n    sidebarStateOptions.activeTabExternal = activeTabExternal;\n  }\n  if (storage) {\n    sidebarStateOptions.storage = storage;\n  }\n  const {\n    activeTab,\n    setActiveTab,\n    handleTabChange,\n    mode,\n    selectedNoteId,\n    setSelectedNoteId,\n    setIsNoteEditing,\n  } = useSidebarState(sidebarStateOptions);\n\n  const notesService: NotesService | null = useMemo(\n    () => (apiClient ? createNotesService(apiClient) : null),\n    [apiClient],\n  );\n\n  const {\n    notes,\n    isLoading: notesLoading,\n    refresh: refreshNotes,\n    upsertNote,\n    deleteNote: deleteNoteFromList,\n    toggleStar: toggleNoteStar,\n  } = useNotesList({\n    notesService,\n    limit: 50,\n  });\n\n  const resizeOptions: Parameters<typeof useResize>[0] = {\n    minWidth: SIDEBAR_MIN_WIDTH,\n    maxWidth: SIDEBAR_MAX_WIDTH,\n    maxVw: SIDEBAR_MAX_VW,\n    storageKey: SIDEBAR_WIDTH_KEY,\n  };\n  if (storage) {\n    resizeOptions.storage = storage;\n  }\n  const { handleResizeStart } = useResize(resizeOptions);\n\n  const courseCode = pageContext?.courseContext.courseCode || null;\n  const pageUrl = pageContext?.url || (typeof window !== 'undefined' ? window.location.href : '');\n\n  useEffect(() => {\n    if (activeToolId) {\n      setActiveTab(TOOL_TAB_ID);\n    }\n  }, [activeToolId, setActiveTab]);\n\n  useEffect(() => {\n    if (activeTab === NOTES_TAB_ID) {\n      refreshNotes();\n    }\n  }, [activeTab, refreshNotes]);\n\n  return (\n    <TranscriptCacheProvider apiClient={apiClient}>\n      <NoteSaveProvider\n        notesService={notesService}\n        pageUrl={pageUrl}\n        courseCode={courseCode}\n        upsertNote={upsertNote}\n        setSelectedNoteId={setSelectedNoteId}\n        setActiveTab={setActiveTab}\n      >\n        <SidebarLayout\n          isOpen={isOpen}\n          onToggle={onToggle}\n          onResizeStart={handleResizeStart}\n          headerLeft={\n            <SidebarTabs\n              activeTab={activeTab}\n              onTabChange={handleTabChange}\n              activeToolId={activeToolId}\n              activeToolTitle={activeToolTitle}\n              onCloseTool={closeTool}\n            />\n          }\n          headerRight={<SidebarHeaderActions onOpenFeedback={() => setIsFeedbackOpen(true)} />}\n        >\n          {activeTab === CHAT_TAB_ID && (\n            <ChatSection\n              apiClient={apiClient}\n              {...(storage ? { storage } : {})}\n              mode={mode}\n              pageUrl={pageUrl}\n              courseCode={courseCode}\n              {...(pendingPrefill !== undefined ? { pendingPrefill } : {})}\n              {...(onClearPrefill ? { onClearPrefill } : {})}\n              isOpen={isOpen}\n              isActive={activeTab === CHAT_TAB_ID}\n            />\n          )}\n\n          {activeTab === NOTES_TAB_ID && (\n            <NotesPanel\n              notesService={notesService}\n              notes={notes}\n              notesLoading={notesLoading}\n              onRefreshNotes={refreshNotes}\n              onNoteSaved={(note) => {\n                upsertNote(note);\n                setSelectedNoteId(note.id);\n              }}\n              onDeleteNote={async (noteId) => {\n                await deleteNoteFromList(noteId);\n                if (selectedNoteId === noteId) {\n                  setSelectedNoteId(null);\n                }\n              }}\n              onToggleStar={toggleNoteStar}\n              activeNoteId={selectedNoteId}\n              onSelectNote={(noteId) => setSelectedNoteId(noteId)}\n              courseCode={courseCode}\n              pageUrl={pageUrl}\n              currentWeek={pageContext?.courseContext?.week ?? null}\n              onNoteEditingChange={setIsNoteEditing}\n            />\n          )}\n\n          {activeTab === TOOL_TAB_ID && (\n            <ToolSection activeToolId={activeToolId} onClose={closeTool} />\n          )}\n\n          {/* Privacy disclosure notice - shown on first use */}\n          <PrivacyNotice />\n        </SidebarLayout>\n\n        <FeedbackModal\n          isOpen={isFeedbackOpen}\n          onClose={() => setIsFeedbackOpen(false)}\n          apiClient={apiClient}\n          pageUrl={pageUrl}\n          courseCode={courseCode}\n        />\n      </NoteSaveProvider>\n    </TranscriptCacheProvider>\n  );\n}\n\nexport function LockInSidebar(props: LockInSidebarProps) {\n  return (\n    <ToolProvider>\n      <ChatQueryProvider>\n        <LockInSidebarContent {...props} />\n      </ChatQueryProvider>\n    </ToolProvider>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\__tests__\\chatHistory.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 25,
        "column": 49,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 25,
        "endColumn": 51,
        "fix": { "range": [999, 999], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 28,
        "column": 43,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 28,
        "endColumn": 45,
        "fix": { "range": [1182, 1182], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 34,
        "column": 19,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 34,
        "endColumn": 21,
        "fix": { "range": [1307, 1307], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 36,
        "column": 24,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 36,
        "endColumn": 26,
        "fix": { "range": [1367, 1367], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 63,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 63,
        "endColumn": 29
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (229). Maximum allowed is 50.",
        "line": 69,
        "column": 40,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 315,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async arrow function has too many lines (65). Maximum allowed is 50.",
        "line": 132,
        "column": 51,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 200,
        "endColumn": 4
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async arrow function has too many lines (65). Maximum allowed is 50.",
        "line": 202,
        "column": 56,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 270,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 308,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 308,
        "endColumn": 28
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 4,
    "source": "import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';\nimport { act } from 'react';\nimport { createRoot, type Root } from 'react-dom/client';\nimport type { ApiClient } from '@api/client';\nimport chatLimits from '@core/config/chatLimits.json';\nimport { LockInSidebar } from '../LockInSidebar';\n\nconst actEnvironment = globalThis as typeof globalThis & {\n  IS_REACT_ACT_ENVIRONMENT?: boolean;\n};\nactEnvironment.IS_REACT_ACT_ENVIRONMENT = true;\n\ntype StorageStub = {\n  get: <T = unknown>(key: string) => Promise<T | null>;\n  set: (key: string, value: unknown) => Promise<void>;\n  getLocal: <T = unknown>(key: string) => Promise<T | null>;\n  setLocal: (key: string, value: unknown) => Promise<void>;\n};\n\nconst ACTIVE_CHAT_ID_KEY = 'lockin_sidebar_activeChatId';\nconst SIDEBAR_ACTIVE_TAB_KEY = 'lockin_sidebar_activeTab';\nconst SELECTED_NOTE_ID_KEY = 'lockin_sidebar_selectedNoteId';\n\nfunction createStorageStub(values: Record<string, unknown> = {}): StorageStub {\n  const get = vi.fn(<T = unknown,>(key: string) =>\n    Promise.resolve(Object.prototype.hasOwnProperty.call(values, key) ? (values[key] as T) : null),\n  ) as StorageStub['get'];\n  const getLocal = vi.fn(<T = unknown,>() =>\n    Promise.resolve<T | null>(null),\n  ) as StorageStub['getLocal'];\n\n  return {\n    get,\n    set: vi.fn(() => Promise.resolve()),\n    getLocal,\n    setLocal: vi.fn(() => Promise.resolve()),\n  };\n}\n\nfunction createApiClientStub(overrides: Partial<ApiClient> = {}): ApiClient {\n  return {\n    processText: vi.fn(),\n    createChat: vi.fn(),\n    getRecentChats: vi.fn(),\n    getChatMessages: vi.fn(),\n    deleteChat: vi.fn(),\n    generateChatTitle: vi.fn(),\n    createNote: vi.fn(),\n    updateNote: vi.fn(),\n    deleteNote: vi.fn(),\n    toggleNoteStar: vi.fn(),\n    setNoteStar: vi.fn(),\n    listNotes: vi.fn(),\n    searchNotes: vi.fn(),\n    chatWithNotes: vi.fn(),\n    uploadNoteAsset: vi.fn(),\n    listNoteAssets: vi.fn(),\n    deleteNoteAsset: vi.fn(),\n    ...overrides,\n  } as ApiClient;\n}\n\nasync function flushPromises(cycles = 1) {\n  for (let i = 0; i < cycles; i += 1) {\n    await new Promise((resolve) => setTimeout(resolve, 0));\n  }\n}\n\ndescribe('LockInSidebar chat history', () => {\n  let container: HTMLDivElement;\n  let root: Root;\n\n  beforeEach(() => {\n    container = document.createElement('div');\n    document.body.appendChild(container);\n    root = createRoot(container);\n  });\n\n  afterEach(() => {\n    act(() => {\n      root.unmount();\n    });\n    container.remove();\n    document.body.innerHTML = '';\n    vi.restoreAllMocks();\n  });\n\n  it('loads chat history entries from the API', async () => {\n    const apiClient = createApiClientStub({\n      getRecentChats: vi.fn().mockResolvedValue({\n        chats: [\n          {\n            id: 'chat-1',\n            title: 'Arrays and stacks overview',\n            updated_at: '2025-01-01T00:00:00.000Z',\n          },\n        ],\n        pagination: {\n          hasMore: false,\n          nextCursor: null,\n        },\n      }),\n    });\n    const storage = createStorageStub({\n      [SIDEBAR_ACTIVE_TAB_KEY]: null,\n      [SELECTED_NOTE_ID_KEY]: null,\n      [ACTIVE_CHAT_ID_KEY]: null,\n    });\n\n    await act(async () => {\n      root.render(\n        <LockInSidebar\n          apiClient={apiClient}\n          isOpen={true}\n          onToggle={vi.fn()}\n          currentMode=\"explain\"\n          storage={storage}\n        />,\n      );\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    expect(apiClient.getRecentChats).toHaveBeenCalledWith(\n      expect.objectContaining({ limit: chatLimits.DEFAULT_CHAT_LIST_LIMIT }),\n    );\n    const title = document.querySelector('.lockin-history-title');\n    expect(title?.textContent).toBe('Arrays and stacks overview');\n  });\n\n  it('loads more chat history entries on demand', async () => {\n    const apiClient = createApiClientStub({\n      getRecentChats: vi\n        .fn()\n        .mockResolvedValueOnce({\n          chats: [\n            {\n              id: 'chat-1',\n              title: 'First page chat',\n              updated_at: '2025-01-02T00:00:00.000Z',\n            },\n          ],\n          pagination: {\n            hasMore: true,\n            nextCursor: '2025-01-01T00:00:00.000Z',\n          },\n        })\n        .mockResolvedValueOnce({\n          chats: [\n            {\n              id: 'chat-2',\n              title: 'Second page chat',\n              updated_at: '2024-12-31T00:00:00.000Z',\n            },\n          ],\n          pagination: {\n            hasMore: false,\n            nextCursor: null,\n          },\n        }),\n    });\n    const storage = createStorageStub();\n\n    await act(async () => {\n      root.render(\n        <LockInSidebar\n          apiClient={apiClient}\n          isOpen={true}\n          onToggle={vi.fn()}\n          currentMode=\"explain\"\n          storage={storage}\n        />,\n      );\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const loadMoreButton = document.querySelector(\n      '.lockin-history-load-more',\n    ) as HTMLButtonElement | null;\n    expect(loadMoreButton).not.toBeNull();\n\n    await act(async () => {\n      loadMoreButton?.click();\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    expect(apiClient.getRecentChats).toHaveBeenNthCalledWith(\n      2,\n      expect.objectContaining({ cursor: '2025-01-01T00:00:00.000Z' }),\n    );\n    const titles = Array.from(document.querySelectorAll('.lockin-history-title')).map(\n      (node) => node.textContent,\n    );\n    expect(titles).toContain('Second page chat');\n  });\n\n  it('loads messages when a history item is selected', async () => {\n    const apiClient = createApiClientStub({\n      getRecentChats: vi.fn().mockResolvedValue({\n        chats: [\n          {\n            id: 'chat-2',\n            title: 'Graph theory basics',\n            updated_at: '2025-01-02T00:00:00.000Z',\n          },\n        ],\n        pagination: {\n          hasMore: false,\n          nextCursor: null,\n        },\n      }),\n      getChatMessages: vi.fn().mockResolvedValue([\n        {\n          id: 'msg-1',\n          role: 'user',\n          input_text: 'What is a graph?',\n          output_text: null,\n          created_at: '2025-01-02T00:00:01.000Z',\n        },\n        {\n          id: 'msg-2',\n          role: 'assistant',\n          input_text: null,\n          output_text: 'A graph models nodes and edges.',\n          created_at: '2025-01-02T00:00:02.000Z',\n        },\n      ]),\n    });\n    const storage = createStorageStub();\n\n    await act(async () => {\n      root.render(\n        <LockInSidebar\n          apiClient={apiClient}\n          isOpen={true}\n          onToggle={vi.fn()}\n          currentMode=\"explain\"\n          storage={storage}\n        />,\n      );\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const historyButton = document.querySelector(\n      '.lockin-history-item',\n    ) as HTMLButtonElement | null;\n    expect(historyButton).not.toBeNull();\n\n    await act(async () => {\n      historyButton?.click();\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    expect(apiClient.getChatMessages).toHaveBeenCalledWith('chat-2');\n    const bubbles = Array.from(document.querySelectorAll('.lockin-chat-bubble')).map(\n      (node) => node.textContent,\n    );\n    expect(bubbles).toContain('What is a graph?');\n    expect(bubbles).toContain('A graph models nodes and edges.');\n    expect(historyButton?.classList.contains('active')).toBe(true);\n  });\n\n  it('restores the last active chat from storage', async () => {\n    const storedChatId = '11111111-1111-1111-8111-111111111111';\n    const apiClient = createApiClientStub({\n      getRecentChats: vi.fn().mockResolvedValue({\n        chats: [],\n        pagination: {\n          hasMore: false,\n          nextCursor: null,\n        },\n      }),\n      getChatMessages: vi.fn().mockResolvedValue([\n        {\n          id: 'msg-3',\n          role: 'assistant',\n          input_text: null,\n          output_text: 'Restored message content.',\n          created_at: '2025-01-03T00:00:00.000Z',\n        },\n      ]),\n    });\n    const storage = createStorageStub({\n      [ACTIVE_CHAT_ID_KEY]: storedChatId,\n    });\n\n    await act(async () => {\n      root.render(\n        <LockInSidebar\n          apiClient={apiClient}\n          isOpen={true}\n          onToggle={vi.fn()}\n          currentMode=\"explain\"\n          storage={storage}\n        />,\n      );\n    });\n    await act(async () => {\n      await flushPromises(3);\n    });\n\n    expect(apiClient.getChatMessages).toHaveBeenCalledWith(storedChatId);\n    const bubble = document.querySelector('.lockin-chat-bubble');\n    expect(bubble?.textContent).toBe('Restored message content.');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\__tests__\\chatSend.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 21,
        "column": 49,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 21,
        "endColumn": 51,
        "fix": { "range": [811, 811], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 24,
        "column": 43,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 24,
        "endColumn": 45,
        "fix": { "range": [994, 994], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 30,
        "column": 19,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 30,
        "endColumn": 21,
        "fix": { "range": [1119, 1119], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 32,
        "column": 24,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 32,
        "endColumn": 26,
        "fix": { "range": [1179, 1179], "text": "async " }
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 65,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 65,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 71,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 71,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 73,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 73,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2300, 2306], "text": "setter != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (207). Maximum allowed is 50.",
        "line": 82,
        "column": 49,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 319,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async arrow function has too many lines (52). Maximum allowed is 50.",
        "line": 101,
        "column": 41,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 158,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 137,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 137,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3918, 3926], "text": "textarea != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 154,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 154,
        "endColumn": 28
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async arrow function has too many lines (51). Maximum allowed is 50.",
        "line": 204,
        "column": 63,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 260,
        "endColumn": 4
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3000.",
        "line": 206,
        "column": 79,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 206,
        "endColumn": 83
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 235,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 235,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6509, 6517], "text": "textarea != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 251,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 251,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 256,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 256,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [7136, 7152], "text": "(node.textContent.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [7136, 7152], "text": "(node.textContent !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7136, 7152], "text": "(Boolean(node.textContent))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 258,
        "column": 27,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 258,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7193, 7217], "text": "((errorBanner?.textContent) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7193, 7217], "text": "((errorBanner?.textContent) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7193, 7217], "text": "(Boolean((errorBanner?.textContent)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 293,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 293,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8233, 8241], "text": "textarea != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 308,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 308,
        "endColumn": 28
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 4,
    "source": "import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';\nimport { act } from 'react';\nimport { createRoot, type Root } from 'react-dom/client';\nimport type { ApiClient } from '@api/client';\nimport { RateLimitError } from '@core/errors';\nimport { LockInSidebar } from '../LockInSidebar';\n\nconst actEnvironment = globalThis as typeof globalThis & {\n  IS_REACT_ACT_ENVIRONMENT?: boolean;\n};\nactEnvironment.IS_REACT_ACT_ENVIRONMENT = true;\n\ntype StorageStub = {\n  get: <T = unknown>(key: string) => Promise<T | null>;\n  set: (key: string, value: unknown) => Promise<void>;\n  getLocal: <T = unknown>(key: string) => Promise<T | null>;\n  setLocal: (key: string, value: unknown) => Promise<void>;\n};\n\nfunction createStorageStub(values: Record<string, unknown> = {}): StorageStub {\n  const get = vi.fn(<T = unknown,>(key: string) =>\n    Promise.resolve(Object.prototype.hasOwnProperty.call(values, key) ? (values[key] as T) : null),\n  ) as StorageStub['get'];\n  const getLocal = vi.fn(<T = unknown,>() =>\n    Promise.resolve<T | null>(null),\n  ) as StorageStub['getLocal'];\n\n  return {\n    get,\n    set: vi.fn(() => Promise.resolve()),\n    getLocal,\n    setLocal: vi.fn(() => Promise.resolve()),\n  };\n}\n\nfunction createApiClientStub(overrides: Partial<ApiClient> = {}): ApiClient {\n  return {\n    processText: vi.fn(),\n    createChat: vi.fn(),\n    getRecentChats: vi.fn(),\n    getChatMessages: vi.fn(),\n    deleteChat: vi.fn(),\n    generateChatTitle: vi.fn(),\n    createNote: vi.fn(),\n    updateNote: vi.fn(),\n    deleteNote: vi.fn(),\n    toggleNoteStar: vi.fn(),\n    setNoteStar: vi.fn(),\n    listNotes: vi.fn(),\n    searchNotes: vi.fn(),\n    chatWithNotes: vi.fn(),\n    uploadNoteAsset: vi.fn(),\n    listNoteAssets: vi.fn(),\n    deleteNoteAsset: vi.fn(),\n    uploadChatAsset: vi.fn(),\n    listChatAssets: vi.fn(),\n    deleteChatAsset: vi.fn(),\n    submitFeedback: vi.fn(),\n    listFeedback: vi.fn(),\n    getFeedback: vi.fn(),\n    ...overrides,\n  } as ApiClient;\n}\n\nasync function flushPromises(cycles = 1) {\n  for (let i = 0; i < cycles; i += 1) {\n    await new Promise((resolve) => setTimeout(resolve, 0));\n  }\n}\n\nfunction setTextareaValue(element: HTMLTextAreaElement, value: string) {\n  const setter = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'value')?.set;\n  if (setter) {\n    setter.call(element, value);\n  } else {\n    element.value = value;\n  }\n  element.dispatchEvent(new Event('input', { bubbles: true }));\n  element.dispatchEvent(new Event('change', { bubbles: true }));\n}\n\ndescribe('LockInSidebar chat send reliability', () => {\n  let container: HTMLDivElement;\n  let root: Root;\n\n  beforeEach(() => {\n    container = document.createElement('div');\n    document.body.appendChild(container);\n    root = createRoot(container);\n  });\n\n  afterEach(() => {\n    act(() => {\n      root.unmount();\n    });\n    container.remove();\n    document.body.innerHTML = '';\n    vi.restoreAllMocks();\n  });\n\n  it('deduplicates rapid send actions', async () => {\n    const processText = vi.fn().mockResolvedValue({\n      data: { explanation: 'Reply' },\n      chatId: '11111111-1111-4111-8111-111111111111',\n      chatTitle: 'Title',\n    });\n    const apiClient = createApiClientStub({\n      processText,\n      getRecentChats: vi.fn().mockResolvedValue({\n        chats: [],\n        pagination: { hasMore: false, nextCursor: null },\n      }),\n    });\n    const storage = createStorageStub();\n\n    await act(async () => {\n      root.render(\n        <LockInSidebar\n          apiClient={apiClient}\n          isOpen={true}\n          onToggle={vi.fn()}\n          currentMode=\"explain\"\n          storage={storage}\n        />,\n      );\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const textarea = document.querySelector(\n      '.lockin-chat-input-field',\n    ) as HTMLTextAreaElement | null;\n    expect(textarea).not.toBeNull();\n\n    await act(async () => {\n      if (textarea) {\n        setTextareaValue(textarea, 'Hello');\n      }\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const sendButton = document.querySelector('.lockin-send-btn') as HTMLButtonElement | null;\n    expect(sendButton).not.toBeNull();\n    expect(sendButton?.disabled).toBe(false);\n\n    await act(async () => {\n      sendButton?.click();\n      sendButton?.click();\n    });\n    await act(async () => {\n      await flushPromises(3);\n    });\n\n    expect(processText).toHaveBeenCalledTimes(1);\n  });\n\n  it('does not send when input is empty', async () => {\n    const processText = vi.fn().mockResolvedValue({\n      data: { explanation: 'Reply' },\n      chatId: '11111111-1111-4111-8111-111111111111',\n      chatTitle: 'Title',\n    });\n    const apiClient = createApiClientStub({\n      processText,\n      getRecentChats: vi.fn().mockResolvedValue({\n        chats: [],\n        pagination: { hasMore: false, nextCursor: null },\n      }),\n    });\n    const storage = createStorageStub();\n\n    await act(async () => {\n      root.render(\n        <LockInSidebar\n          apiClient={apiClient}\n          isOpen={true}\n          onToggle={vi.fn()}\n          currentMode=\"explain\"\n          storage={storage}\n        />,\n      );\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const sendButton = document.querySelector('.lockin-send-btn') as HTMLButtonElement | null;\n    expect(sendButton).not.toBeNull();\n    expect(sendButton?.disabled).toBe(true);\n\n    await act(async () => {\n      sendButton?.click();\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    expect(processText).not.toHaveBeenCalled();\n  });\n\n  it('shows rate limit feedback when requests are throttled', async () => {\n    const apiClient = createApiClientStub({\n      processText: vi.fn().mockRejectedValue(new RateLimitError('Rate limit', 3000)),\n      getRecentChats: vi.fn().mockResolvedValue({\n        chats: [],\n        pagination: { hasMore: false, nextCursor: null },\n      }),\n    });\n    const storage = createStorageStub();\n\n    await act(async () => {\n      root.render(\n        <LockInSidebar\n          apiClient={apiClient}\n          isOpen={true}\n          onToggle={vi.fn()}\n          currentMode=\"explain\"\n          storage={storage}\n        />,\n      );\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const textarea = document.querySelector(\n      '.lockin-chat-input-field',\n    ) as HTMLTextAreaElement | null;\n    expect(textarea).not.toBeNull();\n\n    await act(async () => {\n      if (textarea) {\n        setTextareaValue(textarea, 'Hello');\n      }\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const sendButton = document.querySelector('.lockin-send-btn') as HTMLButtonElement | null;\n    expect(sendButton).not.toBeNull();\n    expect(sendButton?.disabled).toBe(false);\n\n    await act(async () => {\n      sendButton?.click();\n    });\n    await act(async () => {\n      await flushPromises(4);\n    });\n\n    const errorBanner = document.querySelector('.lockin-chat-error');\n    const bubbleTexts = Array.from(document.querySelectorAll('.lockin-chat-bubble')).map(\n      (node) => node.textContent || '',\n    );\n    const combinedText = [errorBanner?.textContent || '', ...bubbleTexts].join(' ');\n    expect(combinedText).toContain(\"You're sending too fast - try again in 3s.\");\n  });\n\n  it('does not show save note button on error messages', async () => {\n    const apiClient = createApiClientStub({\n      processText: vi.fn().mockRejectedValue(new Error('Please sign in to continue')),\n      getRecentChats: vi.fn().mockResolvedValue({\n        chats: [],\n        pagination: { hasMore: false, nextCursor: null },\n      }),\n    });\n    const storage = createStorageStub();\n\n    await act(async () => {\n      root.render(\n        <LockInSidebar\n          apiClient={apiClient}\n          isOpen={true}\n          onToggle={vi.fn()}\n          currentMode=\"explain\"\n          storage={storage}\n        />,\n      );\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const textarea = document.querySelector(\n      '.lockin-chat-input-field',\n    ) as HTMLTextAreaElement | null;\n    expect(textarea).not.toBeNull();\n\n    await act(async () => {\n      if (textarea) {\n        setTextareaValue(textarea, 'Hello');\n      }\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const sendButton = document.querySelector('.lockin-send-btn') as HTMLButtonElement | null;\n    expect(sendButton).not.toBeNull();\n\n    await act(async () => {\n      sendButton?.click();\n    });\n    await act(async () => {\n      await flushPromises(4);\n    });\n\n    // Verify error message is shown in a bubble with error styling\n    const errorBubbles = document.querySelectorAll('.lockin-chat-msg-error');\n    expect(errorBubbles.length).toBeGreaterThan(0);\n\n    // Verify NO save note button is present for error messages\n    const saveNoteButtons = document.querySelectorAll('.lockin-chat-save-note-btn');\n    expect(saveNoteButtons.length).toBe(0);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\__tests__\\uiSurface.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 9,
        "column": 25,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 9,
        "endColumn": 65
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 15000.",
        "line": 42,
        "column": 6,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 42,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { beforeEach, describe, expect, it, vi } from 'vitest';\nimport type { SidebarInstance } from '../index';\nimport type { LockInSidebarProps } from '../LockInSidebar';\n\ntype LockInSidebarFactory = (props: LockInSidebarProps) => SidebarInstance;\n\ntype LockInUISurface = {\n  createLockInSidebar: LockInSidebarFactory;\n  LockInSidebar: typeof import('../LockInSidebar').LockInSidebar;\n};\n\ntype TestWindow = typeof window & {\n  LockInUI?: LockInUISurface;\n  LockInSentry?: {\n    initSentry?: (surface: string) => Promise<boolean>;\n  };\n};\n\ndescribe('LockInUI global surface', () => {\n  let testWindow: TestWindow;\n\n  beforeEach(() => {\n    vi.resetModules();\n    testWindow = window as TestWindow;\n    delete testWindow.LockInUI;\n    testWindow.LockInSentry = {\n      initSentry: vi.fn().mockResolvedValue(false),\n    };\n    document.body.innerHTML = '';\n  });\n\n  it('attaches a stable LockInUI object on window with exact keys', async () => {\n    await import('../index');\n\n    const lockInUI = testWindow.LockInUI;\n    expect(lockInUI).toBeDefined();\n    expect(Object.keys(lockInUI ?? {}).sort()).toEqual(\n      ['LockInSidebar', 'createLockInSidebar'].sort(),\n    );\n    expect(typeof lockInUI?.createLockInSidebar).toBe('function');\n    expect(typeof lockInUI?.LockInSidebar).toBe('function');\n  }, 15000);\n\n  it('exposes a callable sidebar factory that returns the expected instance contract', async () => {\n    await import('../index');\n    const { createLockInSidebar } = testWindow.LockInUI ?? {};\n\n    expect(createLockInSidebar).toBeDefined();\n\n    const instance = createLockInSidebar?.({\n      apiClient: null,\n      isOpen: false,\n      onToggle: vi.fn(),\n      currentMode: 'explain',\n    });\n\n    expect(instance).toBeDefined();\n    expect(typeof instance?.unmount).toBe('function');\n    expect(typeof instance?.updateProps).toBe('function');\n    expect(instance?.root).toBeDefined();\n\n    expect(() => instance?.updateProps({ isOpen: true })).not.toThrow();\n    instance?.unmount();\n\n    expect(document.getElementById('lockin-root')).toBeNull();\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\ChatQueryProvider.tsx",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 25,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 25,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 25,
        "column": 24,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 25,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 30.",
        "line": 26,
        "column": 17,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 26,
        "endColumn": 19
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 26,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 26,
        "endColumn": 24
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 28,
        "column": 48,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 28,
        "endColumn": 51
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5000.",
        "line": 28,
        "column": 73,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 28,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 44,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 44,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Chat Query Provider\n *\n * Provides QueryClient for TanStack Query with configuration\n * optimized for chat functionality.\n */\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { useMemo, type ReactNode } from 'react';\n\ninterface ChatQueryProviderProps {\n  children: ReactNode;\n}\n\n/**\n * Creates a QueryClient with chat-optimized defaults.\n * - Retry: 2 attempts with exponential backoff\n * - Stale time: 5 minutes (chats don't change frequently)\n * - GC time: 30 minutes (keep cache for session)\n */\nfunction createChatQueryClient(): QueryClient {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 5 * 60 * 1000, // 5 minutes\n        gcTime: 30 * 60 * 1000, // 30 minutes (formerly cacheTime)\n        retry: 2,\n        retryDelay: (attemptIndex) => Math.min(500 * 2 ** attemptIndex, 5000),\n        refetchOnWindowFocus: false,\n        refetchOnReconnect: true,\n      },\n      mutations: {\n        retry: 1,\n        retryDelay: 500,\n      },\n    },\n  });\n}\n\n/**\n * Provider component that wraps children with QueryClientProvider.\n * Creates a stable QueryClient instance per component lifecycle.\n */\nexport function ChatQueryProvider({ children }: ChatQueryProviderProps) {\n  const queryClient = useMemo(() => createChatQueryClient(), []);\n\n  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;\n}\n\n// Export for direct access when needed\nexport { QueryClient, QueryClientProvider };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\components\\AttachmentButton.tsx",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 38,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 38,
        "endColumn": 25
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 38,
        "column": 28,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 38,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 38,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 38,
        "endColumn": 39
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'AttachmentButton' has too many lines (71). Maximum allowed is 50.",
        "line": 53,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 133,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 53,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 53,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 56,
        "column": 14,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 56,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 69,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 69,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1665, 1674], "text": "(fileList == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 88,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 88,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2232, 2248], "text": "inputRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * AttachmentButton Component\n *\n * A button that triggers file selection for chat attachments.\n * Supports images, documents, and code files.\n */\n\nimport React, { useRef, useCallback } from 'react';\n\n/** Supported MIME types for chat attachments */\nconst ACCEPTED_TYPES = [\n  // Images (vision-compatible)\n  'image/png',\n  'image/jpeg',\n  'image/gif',\n  'image/webp',\n  // Documents\n  'application/pdf',\n  'text/plain',\n  'text/markdown',\n  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  // Code files\n  'text/javascript',\n  'application/javascript',\n  'text/typescript',\n  'text/x-python',\n  'text/x-java',\n  'text/x-c',\n  'text/x-c++',\n  'text/css',\n  'text/html',\n  'application/json',\n  'text/x-rust',\n  'text/x-go',\n].join(',');\n\n/** Maximum file size in bytes (10MB) */\nconst MAX_FILE_SIZE = 10 * 1024 * 1024;\n\nexport interface AttachmentButtonProps {\n  /** Callback when files are selected */\n  onFilesSelected: (files: File[]) => void;\n  /** Whether the button is disabled */\n  disabled?: boolean;\n  /** Maximum number of files allowed */\n  maxFiles?: number;\n  /** Current number of attached files */\n  currentFileCount?: number;\n  /** Custom class name */\n  className?: string;\n}\n\nexport function AttachmentButton({\n  onFilesSelected,\n  disabled = false,\n  maxFiles = 5,\n  currentFileCount = 0,\n  className = '',\n}: AttachmentButtonProps) {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const handleClick = useCallback(() => {\n    inputRef.current?.click();\n  }, []);\n\n  const handleChange = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      const fileList = event.target.files;\n      if (!fileList || fileList.length === 0) return;\n\n      const files = Array.from(fileList);\n      const remaining = maxFiles - currentFileCount;\n\n      // Limit to remaining slots\n      const validFiles = files.slice(0, remaining).filter((file) => {\n        if (file.size > MAX_FILE_SIZE) {\n          console.warn(`File ${file.name} exceeds size limit`);\n          return false;\n        }\n        return true;\n      });\n\n      if (validFiles.length > 0) {\n        onFilesSelected(validFiles);\n      }\n\n      // Reset input so the same file can be selected again\n      if (inputRef.current) {\n        inputRef.current.value = '';\n      }\n    },\n    [onFilesSelected, maxFiles, currentFileCount],\n  );\n\n  const isAtLimit = currentFileCount >= maxFiles;\n\n  return (\n    <>\n      <button\n        type=\"button\"\n        onClick={handleClick}\n        disabled={disabled || isAtLimit}\n        className={`lockin-chat-attach-btn ${className}`}\n        title={isAtLimit ? `Maximum ${maxFiles} files` : 'Attach file'}\n        aria-label=\"Attach file\"\n      >\n        {/* Paperclip icon */}\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          width=\"18\"\n          height=\"18\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n        >\n          <path d=\"M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48\" />\n        </svg>\n      </button>\n      <input\n        ref={inputRef}\n        type=\"file\"\n        accept={ACCEPTED_TYPES}\n        multiple\n        onChange={handleChange}\n        className=\"hidden\"\n        aria-hidden=\"true\"\n      />\n    </>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\components\\AttachmentPreview.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 53,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 53,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1568, 1572], "text": "(last != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1568, 1572], "text": "(last ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1568, 1572], "text": "(Boolean(last))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 58,
        "column": 15,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 58,
        "endColumn": 19
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 59,
        "column": 15,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 59,
        "endColumn": 19
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 59,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 59,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 59,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 59,
        "endColumn": 51
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 60,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 60,
        "endColumn": 27
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1024.",
        "line": 60,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 60,
        "endColumn": 34
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'AttachmentItem' has too many lines (91). Maximum allowed is 50.",
        "line": 63,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 157,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 63,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 63,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 83,
        "column": 34,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 83,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2509, 2530], "text": "(attachment.previewUrl != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2509, 2530], "text": "(attachment.previewUrl ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2509, 2530], "text": "(Boolean(attachment.previewUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 104,
        "column": 63,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 104,
        "endColumn": 72,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3255, 3264], "text": "(extension.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3255, 3264], "text": "(extension !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3255, 3264], "text": "(Boolean(extension))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 118,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 118,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3759, 3775], "text": "(attachment.error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3759, 3775], "text": "(attachment.error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3759, 3775], "text": "(Boolean(attachment.error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 130,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 130,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [4030, 4038], "text": "(disabled ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [4030, 4038], "text": "(disabled === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 159,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 159,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 14,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * AttachmentPreview Component\n *\n * Displays a preview of pending attachments before sending a message.\n * Shows thumbnails for images, icons for documents/code.\n */\n\nimport { useMemo } from 'react';\n\nexport interface PendingAttachment {\n  /** Unique identifier for the attachment */\n  id: string;\n  /** The file object */\n  file: File;\n  /** Preview URL for images (created with URL.createObjectURL) */\n  previewUrl?: string;\n  /** Upload status */\n  status: 'pending' | 'uploading' | 'uploaded' | 'error';\n  /** Uploaded asset ID (after upload) */\n  assetId?: string;\n  /** Error message if upload failed */\n  error?: string;\n}\n\nexport interface AttachmentPreviewProps {\n  /** List of pending attachments */\n  attachments: PendingAttachment[];\n  /** Callback to remove an attachment */\n  onRemove: (id: string) => void;\n  /** Whether removing is disabled (e.g., during upload) */\n  disabled?: boolean;\n}\n\n/** Get file type category from MIME type */\nfunction getFileType(mimeType: string): 'image' | 'document' | 'code' | 'other' {\n  if (mimeType.startsWith('image/')) return 'image';\n  if (mimeType === 'application/pdf' || mimeType.includes('document')) return 'document';\n  if (\n    mimeType.startsWith('text/') ||\n    mimeType === 'application/json' ||\n    mimeType === 'application/javascript'\n  ) {\n    return 'code';\n  }\n  return 'other';\n}\n\n/** Get file extension from filename */\nfunction getExtension(filename: string): string {\n  const parts = filename.split('.');\n  if (parts.length <= 1) return '';\n  const last = parts[parts.length - 1];\n  return last ? last.toUpperCase() : '';\n}\n\n/** Format file size for display */\nfunction formatFileSize(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n}\n\nfunction AttachmentItem({\n  attachment,\n  onRemove,\n  disabled,\n}: {\n  attachment: PendingAttachment;\n  onRemove: () => void;\n  disabled?: boolean;\n}) {\n  const fileType = useMemo(() => getFileType(attachment.file.type), [attachment.file.type]);\n  const extension = useMemo(() => getExtension(attachment.file.name), [attachment.file.name]);\n\n  return (\n    <div\n      className={`lockin-chat-attachment-item ${\n        attachment.status === 'error' ? 'is-error' : ''\n      } ${attachment.status === 'uploading' ? 'is-uploading' : ''}`}\n    >\n      {/* Preview/Icon */}\n      <div className=\"lockin-chat-attachment-thumb\">\n        {fileType === 'image' && attachment.previewUrl ? (\n          <img\n            src={attachment.previewUrl}\n            alt={attachment.file.name}\n            className=\"lockin-chat-attachment-thumb-img\"\n          />\n        ) : fileType === 'document' ? (\n          <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width=\"20\"\n            height=\"20\"\n            viewBox=\"0 0 24 24\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            className=\"lockin-chat-attachment-doc-icon\"\n          >\n            <path d=\"M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z\" />\n            <polyline points=\"14,2 14,8 20,8\" />\n          </svg>\n        ) : (\n          <span className=\"lockin-chat-attachment-extension\">{extension || '?'}</span>\n        )}\n      </div>\n\n      {/* File info */}\n      <div className=\"lockin-chat-attachment-meta\">\n        <p className=\"lockin-chat-attachment-name\" title={attachment.file.name}>\n          {attachment.file.name}\n        </p>\n        <p className=\"lockin-chat-attachment-size\">\n          {attachment.status === 'uploading' ? (\n            'Uploading...'\n          ) : attachment.status === 'error' ? (\n            <span className=\"lockin-chat-attachment-error\">\n              {attachment.error || 'Upload failed'}\n            </span>\n          ) : (\n            formatFileSize(attachment.file.size)\n          )}\n        </p>\n      </div>\n\n      {/* Remove button */}\n      <button\n        type=\"button\"\n        onClick={onRemove}\n        disabled={disabled || attachment.status === 'uploading'}\n        className=\"lockin-chat-attachment-remove\"\n        title=\"Remove attachment\"\n        aria-label={`Remove ${attachment.file.name}`}\n      >\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          width=\"16\"\n          height=\"16\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth=\"2\"\n        >\n          <line x1=\"18\" y1=\"6\" x2=\"6\" y2=\"18\" />\n          <line x1=\"6\" y1=\"6\" x2=\"18\" y2=\"18\" />\n        </svg>\n      </button>\n\n      {/* Upload spinner overlay */}\n      {attachment.status === 'uploading' && (\n        <div className=\"lockin-chat-attachment-overlay\">\n          <span className=\"lockin-inline-spinner\" />\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport function AttachmentPreview({\n  attachments,\n  onRemove,\n  disabled = false,\n}: AttachmentPreviewProps) {\n  if (attachments.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"lockin-chat-attachment-preview\">\n      {attachments.map((attachment) => (\n        <AttachmentItem\n          key={attachment.id}\n          attachment={attachment}\n          onRemove={() => onRemove(attachment.id)}\n          disabled={disabled}\n        />\n      ))}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\components\\ChatMessage.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 24,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 24,
        "endColumn": 27
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'ChatMessage' has too many lines (67). Maximum allowed is 50.",
        "line": 37,
        "column": 33,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 114,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 47,
        "column": 57,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 47,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 48,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 48,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1514, 1528], "text": "(attachment.url != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1514, 1528], "text": "(attachment.url ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1514, 1528], "text": "(Boolean(attachment.url))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 49,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 49,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1591, 1594], "text": "(src != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1591, 1594], "text": "(src ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1591, 1594], "text": "(Boolean(src))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 77,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 77,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [2324, 2333], "text": "(isPending ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [2324, 2333], "text": "(isPending === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 78,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 78,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [2377, 2384], "text": "(isError ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [2377, 2384], "text": "(isError === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 82,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 82,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [2506, 2515], "text": "(isPending ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [2506, 2515], "text": "(isPending === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 104,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 104,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 104,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 104,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [3259, 3268], "text": "(isPending ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareFalse",
            "fix": { "range": [3258, 3268], "text": "(isPending === false)" },
            "desc": "Change condition to check if false (`value === false`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * ChatMessage Component\n *\n * Renders a single chat message with markdown support.\n * Handles both user and assistant messages with appropriate styling.\n */\n\nimport React, { memo } from 'react';\nimport { MarkdownRenderer } from './MarkdownRenderer';\nimport type { ChatAttachment, ChatMessage as ChatMessageType } from '../types';\n\ninterface ChatMessageProps {\n  /** The message to render */\n  message: ChatMessageType;\n  /** Optional action component to display (e.g., save to notes) */\n  action?: React.ReactNode;\n  /** Whether to show the thinking animation */\n  isThinking?: boolean;\n}\n\n/**\n * Thinking animation dots\n */\nfunction ThinkingIndicator() {\n  return (\n    <div className=\"lockin-chat-thinking\">\n      <span className=\"lockin-chat-thinking-text\">Thinking</span>\n      <span className=\"lockin-chat-thinking-dots\">\n        <span className=\"lockin-chat-thinking-dot\" style={{ animationDelay: '0ms' }} />\n        <span className=\"lockin-chat-thinking-dot\" style={{ animationDelay: '150ms' }} />\n        <span className=\"lockin-chat-thinking-dot\" style={{ animationDelay: '300ms' }} />\n      </span>\n    </div>\n  );\n}\n\nexport const ChatMessage = memo(function ChatMessage({\n  message,\n  action,\n  isThinking = false,\n}: ChatMessageProps) {\n  const isUser = message.role === 'user';\n  const isPending = message.isPending;\n  const isError = message.isError;\n  const attachments = message.attachments?.filter(Boolean) ?? [];\n\n  const renderAttachment = (attachment: ChatAttachment) => {\n    const src = attachment.url || attachment.dataUrl;\n    if (attachment.kind === 'image' && src) {\n      return (\n        <div className=\"lockin-chat-attachment-thumb\">\n          <img\n            src={src}\n            alt={attachment.name}\n            className=\"lockin-chat-attachment-thumb-img\"\n            loading=\"lazy\"\n          />\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"lockin-chat-attachment-file\">\n        <span className=\"lockin-chat-attachment-file-icon\" aria-hidden=\"true\">\n          \n        </span>\n        <span className=\"lockin-chat-attachment-file-name\" title={attachment.name}>\n          {attachment.name}\n        </span>\n      </div>\n    );\n  };\n\n  return (\n    <div\n      className={`lockin-chat-msg ${isUser ? 'lockin-chat-msg-user' : 'lockin-chat-msg-assistant'} ${\n        isPending ? 'lockin-chat-msg-pending' : ''\n      } ${isError ? 'lockin-chat-msg-error' : ''}`}\n    >\n      {/* Message bubble */}\n      <div className=\"lockin-chat-bubble\">\n        {isPending || isThinking ? (\n          <ThinkingIndicator />\n        ) : isUser ? (\n          // User messages are plain text\n          <p>{message.content}</p>\n        ) : (\n          // Assistant messages get markdown rendering\n          <MarkdownRenderer content={message.content} />\n        )}\n      </div>\n\n      {isUser && attachments.length > 0 && (\n        <div className=\"lockin-chat-attachments\" aria-label=\"Message attachments\">\n          {attachments.map((attachment, index) => (\n            <div className=\"lockin-chat-attachment\" key={`${message.id}-attach-${index}`}>\n              {renderAttachment(attachment)}\n            </div>\n          ))}\n        </div>\n      )}\n\n      {/* Action button (e.g., save to notes) */}\n      {action && !isPending && !isUser && action}\n\n      {/* Timestamp - optional, hidden by default */}\n      {/* {message.timestamp && (\n        <span className=\"text-xs text-gray-400 px-2\">\n          {new Date(message.timestamp).toLocaleTimeString()}\n        </span>\n      )} */}\n    </div>\n  );\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\components\\MarkdownRenderer.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 33,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 33,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1049, 1058], "text": "(className != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1049, 1058], "text": "(className ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1049, 1058], "text": "(Boolean(className))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 34,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 34,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1086, 1091], "text": "(match != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 38,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 38,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1191, 1197], "text": "inline ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1191, 1197], "text": "inline === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 52,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 52,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1513, 1521], "text": "(language != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1513, 1521], "text": "(language ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1513, 1521], "text": "(Boolean(language))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 59,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 59,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1747, 1755], "text": "(language != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1747, 1755], "text": "(language ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1747, 1755], "text": "(Boolean(language))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 159,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 159,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [4769, 4777], "text": "content.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [4769, 4777], "text": "content === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4769, 4777], "text": "!Boolean(content)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * MarkdownRenderer Component\n *\n * Renders markdown content with syntax highlighting for code blocks.\n * Uses react-markdown with remark-gfm for GitHub Flavored Markdown.\n */\n\nimport React, { memo } from 'react';\nimport ReactMarkdown from 'react-markdown';\nimport remarkGfm from 'remark-gfm';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';\n\ninterface MarkdownRendererProps {\n  /** Markdown content to render */\n  content: string;\n  /** Additional CSS classes */\n  className?: string;\n}\n\n/**\n * Custom code block component with syntax highlighting\n */\ntype CodeProps = Omit<React.HTMLAttributes<HTMLElement>, 'style'> & {\n  inline?: boolean;\n  node?: unknown;\n};\n\nconst syntaxStyle = oneDark as unknown as Record<string, React.CSSProperties>;\n\nconst CodeBlock = memo(function CodeBlock({ inline, className, children, ...props }: CodeProps) {\n  // Extract language from className (e.g., \"language-javascript\")\n  const match = /language-(\\w+)/.exec(className || '');\n  const language = match ? match[1] : '';\n  const codeString = String(children).replace(/\\n$/, '');\n\n  // Inline code\n  if (inline) {\n    return (\n      <code\n        className=\"px-1.5 py-0.5 mx-0.5 rounded bg-gray-100 text-gray-800 font-mono text-sm\"\n        {...props}\n      >\n        {children}\n      </code>\n    );\n  }\n\n  // Code block with syntax highlighting\n  return (\n    <div className=\"relative my-3 rounded-lg overflow-hidden\">\n      {language && (\n        <div className=\"absolute top-0 right-0 px-2 py-1 text-xs text-gray-400 bg-gray-800 rounded-bl\">\n          {language}\n        </div>\n      )}\n      <SyntaxHighlighter\n        style={syntaxStyle}\n        language={language || 'text'}\n        PreTag=\"div\"\n        customStyle={{\n          margin: 0,\n          padding: '1rem',\n          fontSize: '0.875rem',\n          borderRadius: '0.5rem',\n        }}\n        {...props}\n      >\n        {codeString}\n      </SyntaxHighlighter>\n    </div>\n  );\n});\n\n/**\n * Custom components for markdown elements\n */\ntype MarkdownComponents = Record<string, React.ComponentType<Record<string, unknown>>>;\n\nconst markdownComponents: MarkdownComponents = {\n  // Code blocks with syntax highlighting\n  code: CodeBlock,\n\n  // Paragraphs with proper spacing\n  p: ({ children }: { children?: React.ReactNode }) => (\n    <p className=\"mb-3 last:mb-0 leading-relaxed\">{children}</p>\n  ),\n\n  // Headings\n  h1: ({ children }: { children?: React.ReactNode }) => (\n    <h1 className=\"text-xl font-bold mb-3 mt-4 first:mt-0\">{children}</h1>\n  ),\n  h2: ({ children }: { children?: React.ReactNode }) => (\n    <h2 className=\"text-lg font-bold mb-2 mt-3 first:mt-0\">{children}</h2>\n  ),\n  h3: ({ children }: { children?: React.ReactNode }) => (\n    <h3 className=\"text-base font-semibold mb-2 mt-3 first:mt-0\">{children}</h3>\n  ),\n\n  // Lists\n  ul: ({ children }: { children?: React.ReactNode }) => (\n    <ul className=\"list-disc list-inside mb-3 space-y-1\">{children}</ul>\n  ),\n  ol: ({ children }: { children?: React.ReactNode }) => (\n    <ol className=\"list-decimal list-inside mb-3 space-y-1\">{children}</ol>\n  ),\n  li: ({ children }: { children?: React.ReactNode }) => (\n    <li className=\"leading-relaxed\">{children}</li>\n  ),\n\n  // Links\n  a: ({ href, children }: { href?: string; children?: React.ReactNode }) => (\n    <a\n      href={href}\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n      className=\"text-blue-600 hover:text-blue-800 underline\"\n    >\n      {children}\n    </a>\n  ),\n\n  // Blockquotes\n  blockquote: ({ children }: { children?: React.ReactNode }) => (\n    <blockquote className=\"border-l-4 border-gray-300 pl-4 py-1 my-3 italic text-gray-700\">\n      {children}\n    </blockquote>\n  ),\n\n  // Tables\n  table: ({ children }: { children?: React.ReactNode }) => (\n    <div className=\"overflow-x-auto my-3\">\n      <table className=\"min-w-full border-collapse border border-gray-300\">{children}</table>\n    </div>\n  ),\n  th: ({ children }: { children?: React.ReactNode }) => (\n    <th className=\"border border-gray-300 px-3 py-2 bg-gray-100 font-semibold text-left\">\n      {children}\n    </th>\n  ),\n  td: ({ children }: { children?: React.ReactNode }) => (\n    <td className=\"border border-gray-300 px-3 py-2\">{children}</td>\n  ),\n\n  // Horizontal rule\n  hr: () => <hr className=\"my-4 border-t border-gray-300\" />,\n\n  // Strong and emphasis\n  strong: ({ children }: { children?: React.ReactNode }) => (\n    <strong className=\"font-semibold\">{children}</strong>\n  ),\n  em: ({ children }: { children?: React.ReactNode }) => <em className=\"italic\">{children}</em>,\n};\n\nexport const MarkdownRenderer = memo(function MarkdownRenderer({\n  content,\n  className = '',\n}: MarkdownRendererProps) {\n  if (!content) return null;\n\n  return (\n    <div className={`markdown-content text-gray-900 ${className}`}>\n      <ReactMarkdown remarkPlugins={[remarkGfm]} components={markdownComponents}>\n        {content}\n      </ReactMarkdown>\n    </div>\n  );\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\chatHistoryUtils.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 28,
        "column": 11,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 28,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [744, 767], "text": "(getString(record['id']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [744, 767], "text": "(getString(record['id']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [744, 767], "text": "(Boolean(getString(record['id'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 28,
        "column": 69,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 28,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 31,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 31,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [922, 953], "text": "(getString(record['updated_at']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [922, 953], "text": "(getString(record['updated_at']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [922, 953], "text": "(Boolean(getString(record['updated_at'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 32,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 32,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [965, 995], "text": "(getString(record['updatedAt']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [965, 995], "text": "(getString(record['updatedAt']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [965, 995], "text": "(Boolean(getString(record['updatedAt'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 34,
        "column": 20,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 34,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1052, 1084], "text": "(getString(record['lastMessage']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1052, 1084], "text": "(getString(record['lastMessage']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1052, 1084], "text": "(Boolean(getString(record['lastMessage'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 69,
        "column": 32,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 69,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [2124, 2156],
              "text": "((existingPages[index]?.pagination) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { ChatHistoryItem } from '../types';\nimport { coerceChatTitle, FALLBACK_CHAT_TITLE } from '../types';\n\nexport type ChatHistoryPage = {\n  chats: ChatHistoryItem[];\n  pagination: {\n    hasMore: boolean;\n    nextCursor?: string | null;\n  };\n};\n\ntype RecordValue = Record<string, unknown>;\n\nfunction isRecord(value: unknown): value is RecordValue {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction getString(value: unknown): string | undefined {\n  return typeof value === 'string' ? value : undefined;\n}\n\nfunction normalizeHistory(response: unknown): ChatHistoryItem[] {\n  if (!Array.isArray(response)) return [];\n\n  return response.map((item) => {\n    const record = isRecord(item) ? item : {};\n    return {\n      id: getString(record['id']) || `chat-${Math.random().toString(16).slice(2)}`,\n      title: coerceChatTitle(getString(record['title']), FALLBACK_CHAT_TITLE),\n      updatedAt:\n        getString(record['updated_at']) ||\n        getString(record['updatedAt']) ||\n        new Date().toISOString(),\n      lastMessage: getString(record['lastMessage']) || '',\n    };\n  });\n}\n\nexport function normalizeHistoryPage(response: unknown): ChatHistoryPage {\n  if (Array.isArray(response)) {\n    return {\n      chats: normalizeHistory(response),\n      pagination: { hasMore: false, nextCursor: null },\n    };\n  }\n\n  const record = isRecord(response) ? response : {};\n  const pagination = isRecord(record['pagination']) ? record['pagination'] : {};\n  return {\n    chats: normalizeHistory(record['chats']),\n    pagination: {\n      hasMore: Boolean(pagination?.['hasMore']),\n      nextCursor: typeof pagination?.['nextCursor'] === 'string' ? pagination['nextCursor'] : null,\n    },\n  };\n}\n\nexport function buildPages(\n  items: ChatHistoryItem[],\n  pageSize: number,\n  existingPages: ChatHistoryPage[] = [],\n): ChatHistoryPage[] {\n  const pageCount = Math.max(existingPages.length, 1);\n  const pages: ChatHistoryPage[] = [];\n\n  for (let index = 0; index < pageCount; index += 1) {\n    const start = index * pageSize;\n    const chats = items.slice(start, start + pageSize);\n    const existingPagination = existingPages[index]?.pagination || {\n      hasMore: false,\n      nextCursor: null,\n    };\n    pages.push({ chats, pagination: existingPagination });\n  }\n\n  return pages;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\chatHookTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\chatSendOptions.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 16,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 16,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { ChatAttachment } from '../types';\nimport type { TranscriptCacheInput } from '../../transcripts/hooks/useTranscriptCache';\n\nexport interface SendChatMessageOptions {\n  source?: 'selection' | 'followup';\n  attachments?: ChatAttachment[];\n  attachmentIds?: string[];\n  selectionOverride?: string;\n  userMessageOverride?: string;\n  transcriptContext?: TranscriptCacheInput;\n}\n\nexport type SendChatOptionsInput = 'selection' | 'followup' | SendChatMessageOptions;\n\nexport function coerceSendOptions(options?: SendChatOptionsInput): SendChatMessageOptions {\n  if (!options) return {};\n  if (typeof options === 'string') {\n    return { source: options };\n  }\n  return options;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\createSelectChat.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 21,
        "column": 10,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 21,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [740, 772], "text": "(deps.apiClient?.getChatMessages) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { ChatHistoryItem, ChatMessage, UseChatOptions } from '../types';\nimport { normalizeChatMessage } from '../types';\nimport type { StudyMode } from '@core/domain/types';\nimport type { Dispatch, SetStateAction } from 'react';\n\ntype SetActiveId = Dispatch<SetStateAction<string | null>>;\ntype SetError = Dispatch<SetStateAction<Error | null>>;\ntype SetMessages = (chatId: string, messages: ChatMessage[]) => void;\n\ninterface SelectChatDeps {\n  apiClient: UseChatOptions['apiClient'];\n  mode: StudyMode;\n  setActiveChatId: SetActiveId;\n  setActiveHistoryId: SetActiveId;\n  setError: SetError;\n  setMessages: SetMessages;\n}\n\nexport function createSelectChat(deps: SelectChatDeps) {\n  return async (item: ChatHistoryItem) => {\n    if (!deps.apiClient?.getChatMessages) return;\n\n    deps.setError(null);\n    deps.setActiveHistoryId(item.id);\n    deps.setActiveChatId(item.id);\n\n    try {\n      const response = await deps.apiClient.getChatMessages(item.id);\n      if (Array.isArray(response)) {\n        const normalized: ChatMessage[] = response.map((msg) =>\n          normalizeChatMessage(msg, deps.mode),\n        );\n        deps.setMessages(item.id, normalized);\n      }\n    } catch (err: unknown) {\n      const error = err instanceof Error ? err : new Error('Failed to load chat messages');\n      deps.setError(error);\n    }\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\createSendMessage.ts",
    "messages": [
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Function 'buildUserMessage' has too many parameters (5). Maximum allowed is 4.",
        "line": 42,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 42,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 57,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 57,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1809, 1820], "text": "(attachments != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Function 'buildSendPayload' has too many parameters (6). Maximum allowed is 4.",
        "line": 63,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 63,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 85,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 85,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2471, 2486], "text": "deps.courseCode != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2471, 2486], "text": "deps.courseCode ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2471, 2486], "text": "Boolean(deps.courseCode)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 88,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 88,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2542, 2563], "text": "(options.attachmentIds != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 97,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 97,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2894, 2919], "text": "options.transcriptContext != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createSendMessage' has too many lines (72). Maximum allowed is 50.",
        "line": 103,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 185,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (70). Maximum allowed is 50.",
        "line": 104,
        "column": 10,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 184,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (34). Maximum allowed is 20.",
        "line": 104,
        "column": 10,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 184,
        "endColumn": 4
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Arrow function has a complexity of 16. Maximum allowed is 15.",
        "line": 104,
        "column": 57,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 104,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 106,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 106,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3168, 3176], "text": "trimmed.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3168, 3176], "text": "trimmed === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3168, 3176], "text": "!Boolean(trimmed)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 108,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorOther",
        "endLine": 108,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 120,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 120,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3801, 3814], "text": "(attachmentIds != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 129,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 129,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4121, 4138], "text": "transcriptContext != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 133,
        "column": 36,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 133,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4239, 4256], "text": "(deps.activeChatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4239, 4256], "text": "(deps.activeChatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4239, 4256], "text": "(Boolean(deps.activeChatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 144,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 144,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4563, 4583], "text": "(deps.activeHistoryId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4563, 4583], "text": "(deps.activeHistoryId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4563, 4583], "text": "(Boolean(deps.activeHistoryId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 153,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 155,
        "endColumn": 8,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [4841, 4965],
              "text": "(deps.queryClient.getQueryData<ChatMessage[]>(\n        chatMessagesKeys.byId(deps.activeChatId || provisionalChatId),\n      ) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 154,
        "column": 31,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 154,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4917, 4934], "text": "(deps.activeChatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4917, 4934], "text": "(deps.activeChatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4917, 4934], "text": "(Boolean(deps.activeChatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 159,
        "column": 29,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 159,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5108, 5125], "text": "(deps.activeChatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5108, 5125], "text": "(deps.activeChatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5108, 5125], "text": "(Boolean(deps.activeChatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { ChatMessage, ChatHistoryItem, HistoryTitleSource } from '../types';\nimport { buildInitialChatTitle, isValidUUID } from '../types';\nimport type { SendChatOptionsInput } from './chatSendOptions';\nimport { coerceSendOptions } from './chatSendOptions';\nimport type { SendMessageMutationParams } from './sendMessageUtils';\nimport { chatMessagesKeys } from './useChatMessages';\nimport type { TranscriptCacheInput } from '../../transcripts/hooks/useTranscriptCache';\nimport type { StudyMode } from '@core/domain/types';\nimport type { QueryClient } from '@tanstack/react-query';\nimport type { Dispatch, SetStateAction } from 'react';\n\ntype UpsertHistory = (\n  item: ChatHistoryItem,\n  previousId?: string | null,\n  titleSource?: HistoryTitleSource,\n) => void;\n\ntype SendMessage = (params: SendMessageMutationParams) => void;\n\ntype SetActiveId = Dispatch<SetStateAction<string | null>>;\ntype SetError = Dispatch<SetStateAction<Error | null>>;\ntype SetHistoryOpen = Dispatch<SetStateAction<boolean>>;\n\ntype StartNewChat = (text: string, options?: SendChatOptionsInput) => void;\n\ninterface SendMessageDeps {\n  activeChatId: string | null;\n  activeHistoryId: string | null;\n  messages: ChatMessage[];\n  mode: StudyMode;\n  pageUrl: string;\n  courseCode: string | null;\n  queryClient: QueryClient;\n  upsertHistory: UpsertHistory;\n  sendMessage: SendMessage;\n  startNewChat: StartNewChat;\n  setActiveHistoryId: SetActiveId;\n  setIsHistoryOpen: SetHistoryOpen;\n  setError: SetError;\n}\n\nfunction buildUserMessage(\n  content: string,\n  mode: StudyMode,\n  source: 'selection' | 'followup',\n  timestamp: string,\n  attachments?: ChatMessage['attachments'],\n): ChatMessage {\n  const message: ChatMessage = {\n    id: `user-${Date.now()}`,\n    role: 'user',\n    content,\n    timestamp,\n    mode,\n    source,\n  };\n  if (attachments && attachments.length > 0) {\n    message.attachments = attachments;\n  }\n  return message;\n}\n\nfunction buildSendPayload(\n  deps: SendMessageDeps,\n  message: string,\n  source: 'selection' | 'followup',\n  currentMessages: ChatMessage[],\n  activeChatId: string,\n  options: {\n    attachmentIds?: string[];\n    selectionOverride?: string;\n    userMessageOverride?: string;\n    transcriptContext?: TranscriptCacheInput;\n  },\n): SendMessageMutationParams {\n  const payload: SendMessageMutationParams = {\n    message,\n    mode: deps.mode,\n    source,\n    pageUrl: deps.pageUrl,\n    chatId: deps.activeChatId,\n    currentMessages,\n    activeChatId,\n  };\n  if (deps.courseCode) {\n    payload.courseCode = deps.courseCode;\n  }\n  if (options.attachmentIds && options.attachmentIds.length > 0) {\n    payload.attachmentIds = options.attachmentIds;\n  }\n  if (options.selectionOverride !== undefined) {\n    payload.selectionOverride = options.selectionOverride;\n  }\n  if (options.userMessageOverride !== undefined) {\n    payload.userMessageOverride = options.userMessageOverride;\n  }\n  if (options.transcriptContext) {\n    payload.transcriptContext = options.transcriptContext;\n  }\n  return payload;\n}\n\nexport function createSendMessage(deps: SendMessageDeps) {\n  return (text: string, options?: SendChatOptionsInput) => {\n    const trimmed = text.trim();\n    if (!trimmed) return;\n    const resolvedOptions = coerceSendOptions(options);\n    const source = resolvedOptions.source || 'followup';\n    const attachments = resolvedOptions.attachments;\n    const attachmentIds = resolvedOptions.attachmentIds;\n    const selectionOverride = resolvedOptions.selectionOverride;\n    const userMessageOverride = resolvedOptions.userMessageOverride;\n    const transcriptContext = resolvedOptions.transcriptContext;\n    const overrides: {\n      attachmentIds?: string[];\n      selectionOverride?: string;\n      userMessageOverride?: string;\n      transcriptContext?: TranscriptCacheInput;\n    } = {};\n    if (attachmentIds && attachmentIds.length > 0) {\n      overrides.attachmentIds = attachmentIds;\n    }\n    if (selectionOverride !== undefined) {\n      overrides.selectionOverride = selectionOverride;\n    }\n    if (userMessageOverride !== undefined) {\n      overrides.userMessageOverride = userMessageOverride;\n    }\n    if (transcriptContext) {\n      overrides.transcriptContext = transcriptContext;\n    }\n\n    const hasChatContext = Boolean(deps.activeChatId || deps.activeHistoryId);\n\n    if (deps.messages.length === 0 && !hasChatContext) {\n      deps.startNewChat(trimmed, resolvedOptions);\n      return;\n    }\n\n    const now = new Date().toISOString();\n\n    const provisionalChatId = isValidUUID(deps.activeChatId)\n      ? (deps.activeChatId as string)\n      : deps.activeHistoryId || `chat-${Date.now()}`;\n\n    const userMessage = buildUserMessage(trimmed, deps.mode, source, now, attachments);\n\n    deps.setIsHistoryOpen(false);\n    deps.setError(null);\n    deps.setActiveHistoryId(provisionalChatId);\n\n    const currentMessages =\n      deps.queryClient.getQueryData<ChatMessage[]>(\n        chatMessagesKeys.byId(deps.activeChatId || provisionalChatId),\n      ) || deps.messages;\n    const nextMessages = [...currentMessages, userMessage];\n\n    deps.queryClient.setQueryData(\n      chatMessagesKeys.byId(deps.activeChatId || provisionalChatId),\n      nextMessages,\n    );\n\n    deps.upsertHistory(\n      {\n        id: provisionalChatId,\n        title: buildInitialChatTitle(trimmed),\n        updatedAt: now,\n        lastMessage: trimmed,\n      },\n      undefined,\n      'local',\n    );\n\n    const payload = buildSendPayload(\n      deps,\n      trimmed,\n      source,\n      nextMessages,\n      provisionalChatId,\n      overrides,\n    );\n\n    deps.sendMessage(payload);\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\createSendSuccessHandler.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 29,
        "column": 28,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 29,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1012, 1040], "text": "(deps.activeChatIdRef.current != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1012, 1040], "text": "(deps.activeChatIdRef.current ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1012, 1040], "text": "(Boolean(deps.activeChatIdRef.current))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 30,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 30,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1085, 1099], "text": "(previousChatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1085, 1099], "text": "(previousChatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1085, 1099], "text": "(Boolean(previousChatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 34,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 34,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1281, 1295], "text": "(cachedMessages != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 38,
        "column": 79,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 38,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 40,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 40,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1590, 1601], "text": "(serverTitle != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1590, 1601], "text": "(serverTitle ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1590, 1601], "text": "(Boolean(serverTitle))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 41,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 41,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1709, 1720], "text": "(serverTitle != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1709, 1720], "text": "(serverTitle ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1709, 1720], "text": "(Boolean(serverTitle))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Dispatch, SetStateAction, MutableRefObject } from 'react';\nimport type { QueryClient } from '@tanstack/react-query';\nimport type { ChatApiResponse, ChatHistoryItem, ChatMessage, HistoryTitleSource } from '../types';\nimport { buildInitialChatTitle, coerceChatTitle } from '../types';\nimport { chatMessagesKeys } from './useChatMessages';\n\ntype UpsertHistory = (\n  item: ChatHistoryItem,\n  previousId?: string | null,\n  titleSource?: HistoryTitleSource,\n) => void;\n\ntype SetActiveId = Dispatch<SetStateAction<string | null>>;\n\ntype ChatIdRef = MutableRefObject<string | null>;\n\ninterface SendSuccessDeps {\n  queryClient: QueryClient;\n  activeChatIdRef: ChatIdRef;\n  activeHistoryIdRef: ChatIdRef;\n  setActiveChatId: SetActiveId;\n  setActiveHistoryId: SetActiveId;\n  upsertHistory: UpsertHistory;\n}\n\nexport function createSendSuccessHandler(deps: SendSuccessDeps) {\n  return (response: ChatApiResponse, resolvedChatId: string) => {\n    const now = new Date().toISOString();\n    const previousChatId = deps.activeChatIdRef.current || deps.activeHistoryIdRef.current;\n    if (previousChatId && previousChatId !== resolvedChatId) {\n      const cachedMessages = deps.queryClient.getQueryData<ChatMessage[]>(\n        chatMessagesKeys.byId(previousChatId),\n      );\n      if (cachedMessages && cachedMessages.length > 0) {\n        deps.queryClient.setQueryData(chatMessagesKeys.byId(resolvedChatId), cachedMessages);\n      }\n    }\n    const fallbackTitle = buildInitialChatTitle(response.explanation.slice(0, 50));\n    const serverTitle = response.chatTitle;\n    const resolvedTitle = serverTitle ? coerceChatTitle(serverTitle, fallbackTitle) : fallbackTitle;\n    const titleSource: HistoryTitleSource = serverTitle ? 'server' : 'local';\n\n    deps.setActiveChatId(resolvedChatId);\n    deps.setActiveHistoryId(resolvedChatId);\n\n    deps.upsertHistory(\n      {\n        id: resolvedChatId,\n        title: resolvedTitle,\n        updatedAt: now,\n        lastMessage: response.explanation,\n      },\n      deps.activeHistoryIdRef.current !== resolvedChatId\n        ? deps.activeHistoryIdRef.current\n        : undefined,\n      titleSource,\n    );\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\createStartBlankChat.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\createStartNewChat.ts",
    "messages": [
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Function 'buildUserMessage' has too many parameters (6). Maximum allowed is 4.",
        "line": 35,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 35,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 51,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 51,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1585, 1596], "text": "(attachments != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Function 'buildSendPayload' has too many parameters (6). Maximum allowed is 4.",
        "line": 57,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 57,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 79,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 79,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2242, 2257], "text": "deps.courseCode != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2242, 2257], "text": "deps.courseCode ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2242, 2257], "text": "Boolean(deps.courseCode)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 82,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 82,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2313, 2334], "text": "(options.attachmentIds != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 91,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 91,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2665, 2690], "text": "options.transcriptContext != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createStartNewChat' has too many lines (66). Maximum allowed is 50.",
        "line": 97,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 170,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (64). Maximum allowed is 50.",
        "line": 98,
        "column": 10,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 169,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (30). Maximum allowed is 20.",
        "line": 98,
        "column": 10,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 169,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 100,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 100,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2941, 2949], "text": "trimmed.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2941, 2949], "text": "trimmed === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2941, 2949], "text": "!Boolean(trimmed)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 102,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorOther",
        "endLine": 102,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 114,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 114,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3575, 3588], "text": "(attachmentIds != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 123,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 123,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3895, 3912], "text": "transcriptContext != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { ChatAttachment, ChatHistoryItem, ChatMessage, HistoryTitleSource } from '../types';\nimport { buildInitialChatTitle } from '../types';\nimport type { SendChatOptionsInput } from './chatSendOptions';\nimport { coerceSendOptions } from './chatSendOptions';\nimport type { SendMessageMutationParams } from './sendMessageUtils';\nimport type { TranscriptCacheInput } from '../../transcripts/hooks/useTranscriptCache';\nimport type { StudyMode } from '@core/domain/types';\nimport type { Dispatch, SetStateAction } from 'react';\n\ntype SetMessages = (chatId: string, messages: ChatMessage[]) => void;\ntype UpsertHistory = (\n  item: ChatHistoryItem,\n  previousId?: string | null,\n  titleSource?: HistoryTitleSource,\n) => void;\ntype SendMessage = (params: SendMessageMutationParams) => void;\n\ntype SetActiveId = Dispatch<SetStateAction<string | null>>;\ntype SetError = Dispatch<SetStateAction<Error | null>>;\ntype SetHistoryOpen = Dispatch<SetStateAction<boolean>>;\n\ninterface StartNewChatDeps {\n  mode: StudyMode;\n  pageUrl: string;\n  courseCode: string | null;\n  setMessages: SetMessages;\n  upsertHistory: UpsertHistory;\n  sendMessage: SendMessage;\n  setActiveChatId: SetActiveId;\n  setActiveHistoryId: SetActiveId;\n  setIsHistoryOpen: SetHistoryOpen;\n  setError: SetError;\n}\n\nfunction buildUserMessage(\n  id: string,\n  content: string,\n  mode: StudyMode,\n  source: 'selection' | 'followup',\n  timestamp: string,\n  attachments?: ChatAttachment[],\n): ChatMessage {\n  const message: ChatMessage = {\n    id,\n    role: 'user',\n    content,\n    timestamp,\n    mode,\n    source,\n  };\n  if (attachments && attachments.length > 0) {\n    message.attachments = attachments;\n  }\n  return message;\n}\n\nfunction buildSendPayload(\n  deps: StartNewChatDeps,\n  message: string,\n  source: 'selection' | 'followup',\n  currentMessages: ChatMessage[],\n  activeChatId: string | null,\n  options: {\n    attachmentIds?: string[];\n    selectionOverride?: string;\n    userMessageOverride?: string;\n    transcriptContext?: TranscriptCacheInput;\n  },\n): SendMessageMutationParams {\n  const payload: SendMessageMutationParams = {\n    message,\n    mode: deps.mode,\n    source,\n    pageUrl: deps.pageUrl,\n    chatId: null,\n    currentMessages,\n    activeChatId,\n  };\n  if (deps.courseCode) {\n    payload.courseCode = deps.courseCode;\n  }\n  if (options.attachmentIds && options.attachmentIds.length > 0) {\n    payload.attachmentIds = options.attachmentIds;\n  }\n  if (options.selectionOverride !== undefined) {\n    payload.selectionOverride = options.selectionOverride;\n  }\n  if (options.userMessageOverride !== undefined) {\n    payload.userMessageOverride = options.userMessageOverride;\n  }\n  if (options.transcriptContext) {\n    payload.transcriptContext = options.transcriptContext;\n  }\n  return payload;\n}\n\nexport function createStartNewChat(deps: StartNewChatDeps) {\n  return (text: string, options?: SendChatOptionsInput) => {\n    const trimmed = text.trim();\n    if (!trimmed) return;\n    const resolvedOptions = coerceSendOptions(options);\n    const source = resolvedOptions.source || 'selection';\n    const attachments = resolvedOptions.attachments;\n    const attachmentIds = resolvedOptions.attachmentIds;\n    const selectionOverride = resolvedOptions.selectionOverride;\n    const userMessageOverride = resolvedOptions.userMessageOverride;\n    const transcriptContext = resolvedOptions.transcriptContext;\n    const overrides: {\n      attachmentIds?: string[];\n      selectionOverride?: string;\n      userMessageOverride?: string;\n      transcriptContext?: TranscriptCacheInput;\n    } = {};\n    if (attachmentIds && attachmentIds.length > 0) {\n      overrides.attachmentIds = attachmentIds;\n    }\n    if (selectionOverride !== undefined) {\n      overrides.selectionOverride = selectionOverride;\n    }\n    if (userMessageOverride !== undefined) {\n      overrides.userMessageOverride = userMessageOverride;\n    }\n    if (transcriptContext) {\n      overrides.transcriptContext = transcriptContext;\n    }\n\n    const now = new Date().toISOString();\n    const provisionalChatId = `chat-${Date.now()}`;\n\n    const userMessage = buildUserMessage(\n      `${provisionalChatId}-user`,\n      trimmed,\n      deps.mode,\n      source,\n      now,\n      attachments,\n    );\n\n    deps.setIsHistoryOpen(false);\n    deps.setError(null);\n    deps.setActiveChatId(null);\n    deps.setActiveHistoryId(provisionalChatId);\n\n    deps.setMessages(provisionalChatId, [userMessage]);\n\n    deps.upsertHistory(\n      {\n        id: provisionalChatId,\n        title: buildInitialChatTitle(trimmed),\n        updatedAt: now,\n        lastMessage: trimmed,\n      },\n      undefined,\n      'local',\n    );\n\n    deps.setActiveChatId(provisionalChatId);\n\n    const payload = buildSendPayload(\n      deps,\n      trimmed,\n      source,\n      [userMessage],\n      provisionalChatId,\n      overrides,\n    );\n\n    deps.sendMessage(payload);\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\sendMessageHandlers.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'createSendMessageHandlers' has too many lines (69). Maximum allowed is 50.",
        "line": 18,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 97,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 18,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 18,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 21,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 21,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [775, 781], "text": "chatId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [775, 781], "text": "chatId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [775, 781], "text": "Boolean(chatId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 25,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 25,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [910, 916], "text": "(chatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [910, 916], "text": "(chatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [910, 916], "text": "(Boolean(chatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 26,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 26,
        "endColumn": 84,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [925, 1000],
              "text": "(deps.queryClient.getQueryData<ChatMessage[]>(chatMessagesKeys.byId(chatId)) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 30,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 30,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1126, 1132], "text": "(chatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1126, 1132], "text": "(chatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1126, 1132], "text": "(Boolean(chatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 43,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 43,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1465, 1471], "text": "chatId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1465, 1471], "text": "chatId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1465, 1471], "text": "Boolean(chatId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 54,
        "column": 96,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 54,
        "endColumn": 98
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 56,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 56,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1833, 1840], "text": "context != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 58,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 58,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1896, 1902], "text": "chatId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1896, 1902], "text": "chatId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1896, 1902], "text": "Boolean(chatId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 80,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 80,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 81,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 81,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2552, 2559], "text": "context != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 82,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 82,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2584, 2603], "text": "(params.activeChatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2584, 2603], "text": "(params.activeChatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2584, 2603], "text": "(Boolean(params.activeChatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { QueryClient } from '@tanstack/react-query';\nimport type { ChatApiResponse, ChatMessage } from '../types';\nimport { chatMessagesKeys } from './useChatMessages';\nimport { formatSendError, type SendMessageMutationParams } from './sendMessageUtils';\n\nexport interface MutationContext {\n  previousMessages: ChatMessage[];\n  pendingMessageId: string;\n  provisionalChatId: string;\n}\n\nexport interface MutationHandlerDeps {\n  queryClient: QueryClient;\n  onSuccess?: (response: ChatApiResponse, chatId: string) => void;\n  onError?: (error: Error) => void;\n}\n\nexport function createSendMessageHandlers(deps: MutationHandlerDeps) {\n  const onMutate = async (params: SendMessageMutationParams): Promise<MutationContext> => {\n    const chatId = params.activeChatId;\n    if (chatId) {\n      await deps.queryClient.cancelQueries({ queryKey: chatMessagesKeys.byId(chatId) });\n    }\n\n    const previousMessages = chatId\n      ? deps.queryClient.getQueryData<ChatMessage[]>(chatMessagesKeys.byId(chatId)) || []\n      : params.currentMessages;\n\n    const pendingMessageId = `assistant-${Date.now()}`;\n    const provisionalChatId = chatId || `chat-${Date.now()}`;\n\n    const pendingMessage: ChatMessage = {\n      id: pendingMessageId,\n      role: 'assistant',\n      content: 'Thinking...',\n      timestamp: new Date().toISOString(),\n      mode: params.mode,\n      isPending: true,\n    };\n\n    const updatedMessages = [...params.currentMessages, pendingMessage];\n\n    if (chatId) {\n      deps.queryClient.setQueryData<ChatMessage[]>(chatMessagesKeys.byId(chatId), updatedMessages);\n    }\n\n    return {\n      previousMessages,\n      pendingMessageId,\n      provisionalChatId,\n    };\n  };\n\n  const onError = (error: Error, params: SendMessageMutationParams, context?: MutationContext) => {\n    const message = formatSendError(error);\n    if (context) {\n      const chatId = params.activeChatId;\n      if (chatId) {\n        deps.queryClient.setQueryData<ChatMessage[]>(chatMessagesKeys.byId(chatId), (old = []) =>\n          old.map((msg) =>\n            msg.id === context.pendingMessageId\n              ? {\n                  ...msg,\n                  content: message,\n                  isPending: false,\n                  isError: true,\n                }\n              : msg,\n          ),\n        );\n      }\n    }\n    deps.onError?.(message === error.message ? error : new Error(message));\n  };\n\n  const onSuccess = (\n    data: ChatApiResponse & { resolvedChatId: string },\n    params: SendMessageMutationParams,\n    context?: MutationContext,\n  ) => {\n    if (context) {\n      const chatId = params.activeChatId || data.resolvedChatId;\n\n      deps.queryClient.setQueryData<ChatMessage[]>(chatMessagesKeys.byId(chatId), (old = []) =>\n        old.map((msg) =>\n          msg.id === context.pendingMessageId\n            ? { ...msg, content: data.explanation, isPending: false }\n            : msg,\n        ),\n      );\n\n      deps.onSuccess?.(data, data.resolvedChatId);\n    }\n  };\n\n  return { onMutate, onError, onSuccess };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\sendMessageMutation.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'sendMessageMutation' has too many lines (64). Maximum allowed is 50.",
        "line": 15,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 86,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'sendMessageMutation' has too many statements (36). Maximum allowed is 20.",
        "line": 15,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 86,
        "endColumn": 2
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async function 'sendMessageMutation' has a complexity of 24. Maximum allowed is 15.",
        "line": 15,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 15,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 27,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 27,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1013, 1039], "text": "abortControllerRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 32,
        "column": 8,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 32,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1148, 1171], "text": "(apiClient?.processText) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 52,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 52,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1826, 1835], "text": "apiChatId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1826, 1835], "text": "apiChatId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1826, 1835], "text": "Boolean(apiChatId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 55,
        "column": 27,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 55,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1908, 1922], "text": "(params.pageUrl != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1908, 1922], "text": "(params.pageUrl ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1908, 1922], "text": "(Boolean(params.pageUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 56,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 56,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1941, 1956], "text": "resolvedPageUrl != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1941, 1956], "text": "resolvedPageUrl ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1941, 1956], "text": "Boolean(resolvedPageUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 60,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 60,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2086, 2104], "text": "resolvedCourseCode != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2086, 2104], "text": "resolvedCourseCode ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2086, 2104], "text": "Boolean(resolvedCourseCode)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 63,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 63,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2170, 2190], "text": "(params.attachmentIds != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 66,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 66,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2294, 2308], "text": "idempotencyKey.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2294, 2308], "text": "idempotencyKey !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2294, 2308], "text": "Boolean(idempotencyKey)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 72,
        "column": 23,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 72,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2456, 2483], "text": "((response?.data?.explanation) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2456, 2483], "text": "((response?.data?.explanation) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2456, 2483], "text": "(Boolean((response?.data?.explanation)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 73,
        "column": 26,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 73,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2550, 2566], "text": "((response?.chatId) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2550, 2566], "text": "((response?.chatId) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2550, 2566], "text": "(Boolean((response?.chatId)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 73,
        "column": 46,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 73,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2570, 2583], "text": "(params.chatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2570, 2583], "text": "(params.chatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2570, 2583], "text": "(Boolean(params.chatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 79,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 79,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2723, 2739], "text": "(response?.chatId) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2723, 2739], "text": "(response?.chatId) ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2723, 2739], "text": "Boolean((response?.chatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 82,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 82,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2790, 2809], "text": "(response?.chatTitle) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2790, 2809], "text": "(response?.chatTitle) ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2790, 2809], "text": "Boolean((response?.chatTitle))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { MutableRefObject } from 'react';\nimport type { UseSendMessageOptions, ChatApiResponse } from '../types';\nimport type { TranscriptCacheInput } from '../../transcripts/hooks/useTranscriptCache';\nimport type { ProcessTextParams } from '@api/resources/lockinClient';\nimport {\n  buildChatHistory,\n  cacheTranscriptIfNeeded,\n  resolveApiChatId,\n  resolveIdempotencyKey,\n  resolveSelectionPayload,\n  resolveUserMessagePayload,\n  type SendMessageMutationParams,\n} from './sendMessageUtils';\n\nexport async function sendMessageMutation(\n  params: SendMessageMutationParams,\n  deps: {\n    apiClient: UseSendMessageOptions['apiClient'];\n    pageUrl?: string;\n    courseCode?: string | null;\n    cacheTranscript: (input: TranscriptCacheInput) => Promise<{ fingerprint: string } | null>;\n    abortControllerRef: MutableRefObject<AbortController | null>;\n  },\n): Promise<ChatApiResponse & { resolvedChatId: string }> {\n  const { apiClient, pageUrl, courseCode, cacheTranscript, abortControllerRef } = deps;\n\n  if (abortControllerRef.current) {\n    abortControllerRef.current.abort();\n  }\n  abortControllerRef.current = new AbortController();\n\n  if (!apiClient?.processText) {\n    throw new Error('API client not available');\n  }\n\n  await cacheTranscriptIfNeeded(cacheTranscript, params.transcriptContext);\n\n  const baseHistory = buildChatHistory(params);\n  const apiChatId = resolveApiChatId(params);\n  const selectionPayload = resolveSelectionPayload(params);\n  const userMessagePayload = resolveUserMessagePayload(params);\n  const idempotencyKey = resolveIdempotencyKey(params);\n\n  const requestPayload: ProcessTextParams = {\n    selection: selectionPayload,\n    mode: params.mode,\n    chatHistory: baseHistory,\n  };\n  if (userMessagePayload !== undefined) {\n    requestPayload.newUserMessage = userMessagePayload;\n  }\n  if (apiChatId) {\n    requestPayload.chatId = apiChatId;\n  }\n  const resolvedPageUrl = params.pageUrl || pageUrl;\n  if (resolvedPageUrl) {\n    requestPayload.pageUrl = resolvedPageUrl;\n  }\n  const resolvedCourseCode = params.courseCode ?? courseCode ?? null;\n  if (resolvedCourseCode) {\n    requestPayload.courseCode = resolvedCourseCode;\n  }\n  if (params.attachmentIds && params.attachmentIds.length > 0) {\n    requestPayload.attachments = params.attachmentIds;\n  }\n  if (idempotencyKey) {\n    requestPayload.idempotencyKey = idempotencyKey;\n  }\n\n  const response = await apiClient.processText(requestPayload);\n\n  const explanation = response?.data?.explanation || `(${params.mode}) ${params.message}`;\n  const resolvedChatId = response?.chatId || params.chatId || `chat-${Date.now()}`;\n\n  const result: ChatApiResponse & { resolvedChatId: string } = {\n    explanation,\n    resolvedChatId,\n  };\n  if (response?.chatId) {\n    result.chatId = response.chatId;\n  }\n  if (response?.chatTitle) {\n    result.chatTitle = response.chatTitle;\n  }\n  return result;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\sendMessageUtils.ts",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 32,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 32,
        "endColumn": 22
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 36.",
        "line": 35,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 35,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 40,
        "column": 26,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 40,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1451, 1471], "text": "(params.attachmentIds != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 41,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 41,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1508, 1521], "text": "(params.chatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1508, 1521], "text": "(params.chatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1508, 1521], "text": "(Boolean(params.chatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 50,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 50,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1856, 1868], "text": "(retryAfterMs != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [1856, 1868], "text": "(retryAfterMs ?? 0)" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1856, 1868], "text": "(Boolean(retryAfterMs))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 56,
        "column": 10,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorString",
        "endLine": 56,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2109, 2123], "text": "((error?.message).length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2109, 2123], "text": "((error?.message) !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2109, 2123], "text": "(Boolean((error?.message)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 82,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 82,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3171, 3192], "text": "(params.idempotencyKey != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3171, 3192], "text": "(params.idempotencyKey ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3171, 3192], "text": "(Boolean(params.idempotencyKey))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 85,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 85,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 89,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 89,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3422, 3440], "text": "transcriptContext == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { RateLimitError } from '@core/errors';\nimport type { ChatMessage, SendMessageParams } from '../types';\nimport { isValidUUID } from '../types';\nimport type { TranscriptCacheInput } from '../../transcripts/hooks/useTranscriptCache';\n\nconst IDEMPOTENCY_BUCKET_MS = 5000;\n\n/** Extended params that include attachments */\nexport interface SendMessageWithAttachmentsParams extends SendMessageParams {\n  /** Array of uploaded asset IDs to include */\n  attachmentIds?: string[];\n  /** Override selection payload sent to the API */\n  selectionOverride?: string;\n  /** Override user message payload sent to the API */\n  userMessageOverride?: string;\n  /** Idempotency key for de-duplication */\n  idempotencyKey?: string;\n  /** Optional transcript context to cache before sending */\n  transcriptContext?: TranscriptCacheInput;\n}\n\nexport type SendMessageMutationParams = SendMessageWithAttachmentsParams & {\n  currentMessages: ChatMessage[];\n  activeChatId: string | null;\n};\n\nexport type ChatHistoryEntry = { role: ChatMessage['role']; content: string };\n\nfunction hashString(value: string): string {\n  let hash = 0;\n  for (let i = 0; i < value.length; i += 1) {\n    hash = (hash << 5) - hash + value.charCodeAt(i);\n    hash |= 0;\n  }\n  return Math.abs(hash).toString(36);\n}\n\nexport function buildIdempotencyKey(params: SendMessageWithAttachmentsParams): string {\n  const bucket = Math.floor(Date.now() / IDEMPOTENCY_BUCKET_MS);\n  const attachmentKey = (params.attachmentIds || []).join(',');\n  const chatKey = params.chatId || '';\n  const payloadKey = params.selectionOverride ?? params.message;\n  const seed = `${chatKey}|${payloadKey}|${attachmentKey}|${bucket}`;\n  return `lockin-${hashString(seed)}`;\n}\n\nexport function formatSendError(error: Error): string {\n  if (error instanceof RateLimitError) {\n    const retryAfterMs = error.retryAfterMs;\n    if (retryAfterMs && retryAfterMs > 0) {\n      const seconds = Math.max(1, Math.ceil(retryAfterMs / 1000));\n      return `You're sending too fast - try again in ${seconds}s.`;\n    }\n    return \"You're sending too fast - try again in a moment.\";\n  }\n  return error?.message || 'We could not process this request. Try again in a moment.';\n}\n\nexport function buildChatHistory(params: SendMessageMutationParams): ChatHistoryEntry[] {\n  const baseHistorySource = params.chatHistory ?? params.currentMessages;\n  return baseHistorySource.map((msg) => ({\n    role: msg.role === 'assistant' ? 'assistant' : 'user',\n    content: msg.content,\n  }));\n}\n\nexport function resolveApiChatId(params: SendMessageMutationParams): string | undefined {\n  return typeof params.chatId === 'string' && isValidUUID(params.chatId)\n    ? params.chatId\n    : undefined;\n}\n\nexport function resolveSelectionPayload(params: SendMessageMutationParams): string {\n  return params.selectionOverride !== undefined ? params.selectionOverride : params.message;\n}\n\nexport function resolveUserMessagePayload(params: SendMessageMutationParams): string | undefined {\n  return params.source === 'followup' ? (params.userMessageOverride ?? params.message) : undefined;\n}\n\nexport function resolveIdempotencyKey(params: SendMessageMutationParams): string {\n  return params.idempotencyKey || buildIdempotencyKey(params);\n}\n\nexport async function cacheTranscriptIfNeeded(\n  cacheTranscript: (input: TranscriptCacheInput) => Promise<{ fingerprint: string } | null>,\n  transcriptContext?: TranscriptCacheInput,\n) {\n  if (!transcriptContext) return;\n  cacheTranscript(transcriptContext).catch((error) => {\n    console.warn('[Lock-in] Failed to cache transcript for chat:', error);\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\useChat.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useChat' has too many lines (119). Maximum allowed is 50.",
        "line": 29,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 157,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useChat Hook\n *\n * Main orchestration hook that combines all chat functionality.\n * Provides a unified API for the sidebar component.\n */\n\nimport { useQueryClient } from '@tanstack/react-query';\nimport type { UseChatOptions } from '../types';\nimport { useChatMessages } from './useChatMessages';\nimport { useChatHistory } from './useChatHistory';\nimport { useSendMessage } from './useSendMessage';\nimport { createSendMessage } from './createSendMessage';\nimport { createSendSuccessHandler } from './createSendSuccessHandler';\nimport { createSelectChat } from './createSelectChat';\nimport { createStartBlankChat } from './createStartBlankChat';\nimport { createStartNewChat } from './createStartNewChat';\nimport type { UseChatReturn } from './chatHookTypes';\nimport { useChatSessionState } from './useChatSessionState';\n\n/**\n * Main chat hook that orchestrates all chat functionality.\n *\n * Features:\n * - Manages active chat session state\n * - Coordinates message sending with history updates\n * - Handles storage persistence for active chat ID\n */\nexport function useChat(options: UseChatOptions): UseChatReturn {\n  const { apiClient, storage, mode, pageUrl, courseCode } = options;\n  const queryClient = useQueryClient();\n\n  const {\n    activeChatId,\n    setActiveChatId,\n    activeHistoryId,\n    setActiveHistoryId,\n    activeChatIdRef,\n    activeHistoryIdRef,\n    isHistoryOpen,\n    setIsHistoryOpen,\n    error,\n    setError,\n    clearError,\n    ensureChatId,\n  } = useChatSessionState({ apiClient, storage });\n\n  const {\n    messages,\n    isLoading: isLoadingMessages,\n    setMessages,\n  } = useChatMessages({\n    apiClient,\n    chatId: activeChatId,\n    mode,\n  });\n\n  const {\n    recentChats,\n    isLoading: isLoadingHistory,\n    hasMore: hasMoreHistory,\n    loadMore: loadMoreHistory,\n    isFetchingNextPage: isLoadingMoreHistory,\n    upsertHistory,\n  } = useChatHistory({\n    apiClient,\n  });\n\n  const handleSendSuccess = createSendSuccessHandler({\n    queryClient,\n    activeChatIdRef,\n    activeHistoryIdRef,\n    setActiveChatId,\n    setActiveHistoryId,\n    upsertHistory,\n  });\n\n  const { sendMessage: sendMessageMutation, isSending } = useSendMessage({\n    apiClient,\n    mode,\n    pageUrl,\n    courseCode,\n    onSuccess: handleSendSuccess,\n    onError: (err) => {\n      setError(err);\n    },\n  });\n\n  const startNewChat = createStartNewChat({\n    mode,\n    pageUrl,\n    courseCode,\n    setMessages,\n    upsertHistory,\n    sendMessage: sendMessageMutation,\n    setActiveChatId,\n    setActiveHistoryId,\n    setIsHistoryOpen,\n    setError,\n  });\n\n  const sendMessage = createSendMessage({\n    activeChatId,\n    activeHistoryId,\n    messages,\n    mode,\n    pageUrl,\n    courseCode,\n    queryClient,\n    upsertHistory,\n    sendMessage: sendMessageMutation,\n    startNewChat,\n    setActiveHistoryId,\n    setIsHistoryOpen,\n    setError,\n  });\n\n  const startBlankChat = createStartBlankChat({\n    setMessages,\n    upsertHistory,\n    setActiveChatId,\n    setActiveHistoryId,\n    setIsHistoryOpen,\n    setError,\n  });\n\n  const selectChat = createSelectChat({\n    apiClient,\n    mode,\n    setActiveChatId,\n    setActiveHistoryId,\n    setError,\n    setMessages,\n  });\n\n  return {\n    activeChatId,\n    activeHistoryId,\n    messages,\n    isLoadingMessages,\n    recentChats,\n    isLoadingHistory,\n    hasMoreHistory,\n    isLoadingMoreHistory,\n    loadMoreHistory,\n    sendMessage,\n    startNewChat,\n    startBlankChat,\n    selectChat,\n    ensureChatId,\n    isSending,\n    error,\n    clearError,\n    isHistoryOpen,\n    setIsHistoryOpen,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\useChatAttachments.ts",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 36.",
        "line": 42,
        "column": 57,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 42,
        "endColumn": 59
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 9.",
        "line": 42,
        "column": 70,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 42,
        "endColumn": 71
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useChatAttachments' has too many lines (99). Maximum allowed is 50.",
        "line": 45,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 162,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 48,
        "column": 28,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 48,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 82,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 82,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2523, 2533], "text": "previewUrl != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2523, 2533], "text": "previewUrl ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2523, 2533], "text": "Boolean(previewUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 99,
        "column": 11,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 99,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2913, 2935], "text": "(attachment?.previewUrl) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2913, 2935], "text": "(attachment?.previewUrl) ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2913, 2935], "text": "Boolean((attachment?.previewUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 112,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 112,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3288, 3309], "text": "attachment.previewUrl != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3288, 3309], "text": "attachment.previewUrl ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3288, 3309], "text": "Boolean(attachment.previewUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 127,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 127,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3789, 3796], "text": "assetId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3789, 3796], "text": "assetId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3789, 3796], "text": "Boolean(assetId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 131,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 131,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3901, 3906], "text": "error.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3901, 3906], "text": "error !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3901, 3906], "text": "Boolean(error)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 134,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 134,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4001, 4011], "text": "(next.error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4001, 4011], "text": "(next.error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4001, 4011], "text": "(Boolean(next.error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 146,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "conditionErrorOther",
        "endLine": 146,
        "endColumn": 74,
        "suggestions": [
          {
            "messageId": "explicitBooleanReturnType",
            "fix": { "range": [4265, 4265], "text": ": boolean" },
            "desc": "Add an explicit `boolean` return type annotation."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useChatAttachments Hook\n *\n * Manages attachment state for chat messages.\n * Handles file selection, preview URLs, upload tracking, and cleanup.\n */\n\nimport { useState, useCallback, useEffect, useRef } from 'react';\nimport type { PendingAttachment } from '../components/AttachmentPreview';\n\ninterface UseChatAttachmentsOptions {\n  /** Maximum number of attachments allowed */\n  maxAttachments?: number;\n}\n\ninterface UseChatAttachmentsReturn {\n  /** List of pending attachments */\n  attachments: PendingAttachment[];\n  /** Add files to the attachment list */\n  addFiles: (files: File[]) => void;\n  /** Remove an attachment by ID */\n  removeAttachment: (id: string) => void;\n  /** Clear all attachments */\n  clearAttachments: () => void;\n  /** Update attachment status after upload */\n  setAttachmentStatus: (\n    id: string,\n    status: PendingAttachment['status'],\n    assetId?: string,\n    error?: string,\n  ) => void;\n  /** Get asset IDs for uploaded attachments */\n  getUploadedAssetIds: () => string[];\n  /** Whether any attachments are currently uploading */\n  isUploading: boolean;\n  /** Whether max attachments reached */\n  isAtLimit: boolean;\n}\n\n/** Generate a unique ID for attachments */\nfunction generateId(): string {\n  return `attach-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;\n}\n\nexport function useChatAttachments(\n  options: UseChatAttachmentsOptions = {},\n): UseChatAttachmentsReturn {\n  const { maxAttachments = 5 } = options;\n  const [attachments, setAttachments] = useState<PendingAttachment[]>([]);\n\n  // Track preview URLs for cleanup\n  const previewUrlsRef = useRef<Set<string>>(new Set());\n\n  // Cleanup preview URLs on unmount\n  useEffect(() => {\n    return () => {\n      previewUrlsRef.current.forEach((url) => {\n        URL.revokeObjectURL(url);\n      });\n    };\n  }, []);\n\n  const addFiles = useCallback(\n    (files: File[]) => {\n      setAttachments((prev) => {\n        const remaining = maxAttachments - prev.length;\n        if (remaining <= 0) return prev;\n\n        const newAttachments: PendingAttachment[] = files.slice(0, remaining).map((file) => {\n          // Create preview URL for images\n          let previewUrl: string | undefined;\n          if (file.type.startsWith('image/')) {\n            previewUrl = URL.createObjectURL(file);\n            previewUrlsRef.current.add(previewUrl);\n          }\n\n          const attachment: PendingAttachment = {\n            id: generateId(),\n            file,\n            status: 'pending' as const,\n          };\n          if (previewUrl) {\n            attachment.previewUrl = previewUrl;\n          }\n          return attachment;\n        });\n\n        return [...prev, ...newAttachments];\n      });\n    },\n    [maxAttachments],\n  );\n\n  const removeAttachment = useCallback((id: string) => {\n    setAttachments((prev) => {\n      const attachment = prev.find((a) => a.id === id);\n\n      // Cleanup preview URL\n      if (attachment?.previewUrl) {\n        URL.revokeObjectURL(attachment.previewUrl);\n        previewUrlsRef.current.delete(attachment.previewUrl);\n      }\n\n      return prev.filter((a) => a.id !== id);\n    });\n  }, []);\n\n  const clearAttachments = useCallback(() => {\n    setAttachments((prev) => {\n      // Cleanup all preview URLs\n      prev.forEach((attachment) => {\n        if (attachment.previewUrl) {\n          URL.revokeObjectURL(attachment.previewUrl);\n          previewUrlsRef.current.delete(attachment.previewUrl);\n        }\n      });\n      return [];\n    });\n  }, []);\n\n  const setAttachmentStatus = useCallback(\n    (id: string, status: PendingAttachment['status'], assetId?: string, error?: string) => {\n      setAttachments((prev) =>\n        prev.map((a) => {\n          if (a.id !== id) return a;\n          let next: PendingAttachment = { ...a, status };\n          if (assetId) {\n            next.assetId = assetId;\n          }\n          if (error !== undefined) {\n            if (error) {\n              next.error = error;\n            }\n          } else if (status !== 'error' && next.error) {\n            const { error: _removed, ...rest } = next;\n            next = rest;\n          }\n          return next;\n        }),\n      );\n    },\n    [],\n  );\n\n  const getUploadedAssetIds = useCallback((): string[] => {\n    return attachments.filter((a) => a.status === 'uploaded' && a.assetId).map((a) => a.assetId!);\n  }, [attachments]);\n\n  const isUploading = attachments.some((a) => a.status === 'uploading');\n  const isAtLimit = attachments.length >= maxAttachments;\n\n  return {\n    attachments,\n    addFiles,\n    removeAttachment,\n    clearAttachments,\n    setAttachmentStatus,\n    getUploadedAssetIds,\n    isUploading,\n    isAtLimit,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\useChatHistory.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useChatHistory' has too many lines (127). Maximum allowed is 50.",
        "line": 13,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 153,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 13,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 13,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 16,
        "column": 24,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 16,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "conditionFixCompareZero",
            "fix": {
              "range": [771, 813],
              "text": "(Number(chatLimits.DEFAULT_CHAT_LIST_LIMIT) !== 0)"
            },
            "desc": "Change condition to check for 0 (`value !== 0`)"
          },
          {
            "messageId": "conditionFixCompareNaN",
            "fix": {
              "range": [771, 813],
              "text": "(!Number.isNaN(Number(chatLimits.DEFAULT_CHAT_LIST_LIMIT)))"
            },
            "desc": "Change condition to check for NaN (`!Number.isNaN(value)`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [771, 813],
              "text": "(Boolean(Number(chatLimits.DEFAULT_CHAT_LIST_LIMIT)))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 16,
        "column": 70,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 16,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 17,
        "column": 20,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 17,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "conditionFixCompareZero",
            "fix": {
              "range": [840, 878],
              "text": "(Number(chatLimits.MAX_CHAT_LIST_LIMIT) !== 0)"
            },
            "desc": "Change condition to check for 0 (`value !== 0`)"
          },
          {
            "messageId": "conditionFixCompareNaN",
            "fix": {
              "range": [840, 878],
              "text": "(!Number.isNaN(Number(chatLimits.MAX_CHAT_LIST_LIMIT)))"
            },
            "desc": "Change condition to check for NaN (`!Number.isNaN(value)`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [840, 878],
              "text": "(Boolean(Number(chatLimits.MAX_CHAT_LIST_LIMIT)))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 31,
        "column": 12,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 31,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1352, 1378], "text": "(apiClient?.getRecentChats) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 40,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 40,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1697, 1703], "text": "cursor != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1697, 1703], "text": "cursor ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1697, 1703], "text": "Boolean(cursor)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 48,
        "column": 39,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 48,
        "endColumn": 69,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1999, 2029], "text": "(lastPage.pagination.nextCursor != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1999, 2029], "text": "(lastPage.pagination.nextCursor ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1999, 2029], "text": "(Boolean(lastPage.pagination.nextCursor))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 52,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 57,
        "column": 12,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 57,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2243, 2260], "text": "((query.data?.pages) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 70,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 70,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2655, 2660], "text": "prev == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 84,
        "column": 13,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "conditionErrorOther",
        "endLine": 84,
        "endColumn": 93,
        "suggestions": [
          {
            "messageId": "explicitBooleanReturnType",
            "fix": { "range": [3064, 3064], "text": ": boolean" },
            "desc": "Add an explicit `boolean` return type annotation."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 84,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 84,
        "endColumn": 63,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3095, 3105], "text": "(previousId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3095, 3105], "text": "(previousId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3095, 3105], "text": "(Boolean(previousId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 87,
        "column": 33,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 87,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3183, 3198], "text": "((existing?.title) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3183, 3198], "text": "((existing?.title) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3183, 3198], "text": "(Boolean((existing?.title)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 88,
        "column": 61,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 88,
        "endColumn": 74,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3266, 3279], "text": "(existingTitle.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3266, 3279], "text": "(existingTitle !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3266, 3279], "text": "(Boolean(existingTitle))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 97,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 97,
        "endColumn": 71,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3732, 3745], "text": "(existingTitle.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3732, 3745], "text": "(existingTitle !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3732, 3745], "text": "(Boolean(existingTitle))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 101,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 101,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3881, 3892], "text": "(previousId == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3882, 3892], "text": "(previousId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3881, 3892], "text": "(!Boolean(previousId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 122,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 122,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4501, 4506], "text": "prev == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 136,
        "column": 37,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 136,
        "endColumn": 39,
        "fix": { "range": [4880, 4880], "text": "async " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useInfiniteQuery, useQueryClient, type InfiniteData } from '@tanstack/react-query';\nimport { useCallback, useMemo } from 'react';\nimport type { ChatHistoryItem, UseChatHistoryOptions, HistoryTitleSource } from '../types';\nimport { coerceChatTitle, clampChatTitle, FALLBACK_CHAT_TITLE } from '../types';\nimport { buildPages, normalizeHistoryPage, type ChatHistoryPage } from './chatHistoryUtils';\nimport chatLimits from '@core/config/chatLimits.json';\n\nexport const chatHistoryKeys = {\n  all: ['chatHistory'] as const,\n  recent: (limit: number) => ['chatHistory', 'recent', limit] as const,\n};\n\nexport function useChatHistory(options: UseChatHistoryOptions) {\n  const { apiClient, limit } = options;\n  const queryClient = useQueryClient();\n  const defaultLimit = Number(chatLimits.DEFAULT_CHAT_LIST_LIMIT) || 20;\n  const maxLimit = Number(chatLimits.MAX_CHAT_LIST_LIMIT) || 100;\n  const safeLimit =\n    typeof limit === 'number' && Number.isFinite(limit) && limit > 0 ? limit : defaultLimit;\n  const pageSize = Math.min(safeLimit, maxLimit);\n\n  const query = useInfiniteQuery<\n    ChatHistoryPage,\n    Error,\n    InfiniteData<ChatHistoryPage>,\n    ReturnType<typeof chatHistoryKeys.recent>,\n    string | undefined\n  >({\n    queryKey: chatHistoryKeys.recent(pageSize),\n    queryFn: async ({ pageParam }): Promise<ChatHistoryPage> => {\n      if (!apiClient?.getRecentChats) {\n        return {\n          chats: [],\n          pagination: { hasMore: false, nextCursor: null },\n        };\n      }\n\n      const cursor = typeof pageParam === 'string' && pageParam.length > 0 ? pageParam : null;\n      const requestParams: { limit: number; cursor?: string | null } = { limit: pageSize };\n      if (cursor) {\n        requestParams.cursor = cursor;\n      }\n      const response = await apiClient.getRecentChats(requestParams);\n      return normalizeHistoryPage(response);\n    },\n    enabled: Boolean(apiClient?.getRecentChats),\n    getNextPageParam: (lastPage) =>\n      lastPage.pagination?.hasMore && lastPage.pagination.nextCursor\n        ? lastPage.pagination.nextCursor\n        : undefined,\n    initialPageParam: undefined,\n    staleTime: 2 * 60 * 1000, // 2 minutes\n    refetchOnMount: true,\n  });\n\n  const recentChats = useMemo(\n    () => (query.data?.pages || []).flatMap((page) => page.chats),\n    [query.data?.pages],\n  );\n\n  const upsertHistory = useCallback(\n    (\n      item: ChatHistoryItem,\n      previousId?: string | null,\n      titleSource: HistoryTitleSource = 'local',\n    ) => {\n      queryClient.setQueryData<InfiniteData<ChatHistoryPage, string | undefined>>(\n        chatHistoryKeys.recent(pageSize),\n        (prev) => {\n          if (!prev) {\n            return {\n              pages: [\n                {\n                  chats: [item],\n                  pagination: { hasMore: false, nextCursor: null },\n                },\n              ],\n              pageParams: [undefined],\n            };\n          }\n\n          const flattened = prev.pages.flatMap((page) => page.chats);\n          const existing = flattened.find(\n            (history) => history.id === item.id || (previousId && history.id === previousId),\n          );\n\n          const existingTitle = existing?.title || '';\n          const incomingTitle = coerceChatTitle(item.title, existingTitle || FALLBACK_CHAT_TITLE);\n          const normalizedExisting = clampChatTitle(existingTitle);\n          const hasMeaningfulTitle =\n            Boolean(normalizedExisting) && normalizedExisting !== FALLBACK_CHAT_TITLE;\n          const shouldOverrideTitle = titleSource === 'server' || !hasMeaningfulTitle;\n\n          const merged: ChatHistoryItem = {\n            ...existing,\n            ...item,\n            title: shouldOverrideTitle ? incomingTitle : existingTitle || FALLBACK_CHAT_TITLE,\n          };\n\n          const filtered = flattened.filter(\n            (history) => history.id !== item.id && (!previousId || history.id !== previousId),\n          );\n\n          const maxItems = Math.min(maxLimit, pageSize * prev.pages.length);\n          const nextItems = [merged, ...filtered].slice(0, maxItems);\n\n          return {\n            ...prev,\n            pages: buildPages(nextItems, pageSize, prev.pages),\n          };\n        },\n      );\n    },\n    [maxLimit, pageSize, queryClient],\n  );\n\n  const removeFromHistory = useCallback(\n    (chatId: string) => {\n      queryClient.setQueryData<InfiniteData<ChatHistoryPage, string | undefined>>(\n        chatHistoryKeys.recent(pageSize),\n        (prev) => {\n          if (!prev) return prev;\n          const flattened = prev.pages.flatMap((page) => page.chats);\n          const nextItems = flattened.filter((item) => item.id !== chatId);\n\n          return {\n            ...prev,\n            pages: buildPages(nextItems, pageSize, prev.pages),\n          };\n        },\n      );\n    },\n    [pageSize, queryClient],\n  );\n\n  const invalidate = useCallback(() => {\n    return queryClient.invalidateQueries({ queryKey: chatHistoryKeys.all });\n  }, [queryClient]);\n\n  return {\n    recentChats,\n    isLoading: query.isLoading,\n    isFetchingNextPage: query.isFetchingNextPage,\n    hasMore: Boolean(query.hasNextPage),\n    loadMore: query.fetchNextPage,\n    isError: query.isError,\n    error: query.error,\n    refetch: query.refetch,\n    upsertHistory,\n    removeFromHistory,\n    invalidate,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\useChatInput.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useChatInput' has too many lines (76). Maximum allowed is 50.",
        "line": 49,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 156,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 61,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 61,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2007, 2013], "text": "input == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 68,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNumber",
        "endLine": 68,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareZero",
            "fix": { "range": [2267, 2277], "text": "(maxHeight === 0)" },
            "desc": "Change condition to check for 0 (`value !== 0`)"
          },
          {
            "messageId": "conditionFixCompareNaN",
            "fix": { "range": [2267, 2277], "text": "(Number.isNaN(maxHeight))" },
            "desc": "Change condition to check for NaN (`!Number.isNaN(value)`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2267, 2277], "text": "(!Boolean(maxHeight))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useChatInput Hook\n *\n * Manages chat input state and textarea behavior.\n * Extracted to keep input logic isolated and reusable.\n */\n\nimport { useCallback, useRef, useState, useLayoutEffect } from 'react';\n\ninterface UseChatInputOptions {\n  /** Called when user submits input (Enter key or send button) */\n  onSend?: (value: string) => boolean | void | Promise<boolean | void>;\n  /** Whether sending is in progress (disables input) */\n  isSending?: boolean;\n  /** Whether the input should be focused */\n  shouldFocus?: boolean;\n  /** Whether sending is allowed even with empty input */\n  canSend?: boolean;\n}\n\ninterface UseChatInputReturn {\n  /** Current input value */\n  value: string;\n  /** Set input value */\n  setValue: (value: string) => void;\n  /** Clear input */\n  clear: () => void;\n  /** Ref for textarea element */\n  inputRef: React.RefObject<HTMLTextAreaElement>;\n  /** Handle input change with auto-resize */\n  handleChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;\n  /** Handle keyboard events */\n  handleKeyDown: (event: React.KeyboardEvent<HTMLTextAreaElement>) => void;\n  /** Trigger send action */\n  handleSend: () => void;\n  /** Sync textarea height to content */\n  syncHeight: (target?: HTMLTextAreaElement | null) => void;\n}\n\n/**\n * Hook for managing chat input state and behavior.\n *\n * Features:\n * - Auto-resize textarea to content\n * - Enter to send (Shift+Enter for newline)\n * - Clear on send\n * - Focus management\n */\nexport function useChatInput(options: UseChatInputOptions = {}): UseChatInputReturn {\n  const { onSend, isSending = false, shouldFocus = false, canSend = false } = options;\n  const [value, setValue] = useState('');\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n\n  /**\n   * Sync textarea height to its content.\n   * Respects max-height CSS property.\n   */\n  const syncHeight = useCallback((target?: HTMLTextAreaElement | null) => {\n    if (typeof window === 'undefined') return;\n    const input = target ?? inputRef.current;\n    if (!input) return;\n\n    input.style.height = 'auto';\n    const maxHeightValue = window.getComputedStyle(input).maxHeight;\n    const maxHeight = maxHeightValue === 'none' ? 0 : Number.parseFloat(maxHeightValue);\n    const nextHeight = input.scrollHeight;\n\n    if (!maxHeight || Number.isNaN(maxHeight)) {\n      input.style.height = `${nextHeight}px`;\n      input.style.overflowY = 'hidden';\n      return;\n    }\n\n    input.style.height = `${Math.min(nextHeight, maxHeight)}px`;\n    input.style.overflowY = nextHeight > maxHeight ? 'auto' : 'hidden';\n  }, []);\n\n  /**\n   * Handle input change with auto-resize.\n   */\n  const handleChange = useCallback(\n    (event: React.ChangeEvent<HTMLTextAreaElement>) => {\n      setValue(event.target.value);\n      syncHeight(event.currentTarget);\n    },\n    [syncHeight],\n  );\n\n  /**\n   * Handle keyboard events.\n   * Enter to send, Shift+Enter for newline.\n   */\n  const triggerSend = useCallback(async () => {\n    const trimmed = value.trim();\n    const shouldSend = trimmed.length > 0 || canSend;\n    if (!shouldSend || isSending) return;\n    try {\n      const shouldClear = await onSend?.(trimmed);\n      if (shouldClear === false) return;\n      setValue('');\n      requestAnimationFrame(() => syncHeight());\n    } catch {\n      // Swallow errors so the UI stays responsive\n    }\n  }, [value, isSending, canSend, onSend, syncHeight]);\n\n  const handleKeyDown = useCallback(\n    (event: React.KeyboardEvent<HTMLTextAreaElement>) => {\n      if (event.key === 'Enter' && !event.shiftKey) {\n        event.preventDefault();\n        void triggerSend();\n      }\n    },\n    [triggerSend],\n  );\n\n  /**\n   * Trigger send action programmatically.\n   */\n  const handleSend = useCallback(() => {\n    void triggerSend();\n  }, [triggerSend]);\n\n  /**\n   * Clear input value.\n   */\n  const clear = useCallback(() => {\n    setValue('');\n    requestAnimationFrame(() => syncHeight());\n  }, [syncHeight]);\n\n  // Auto-resize on value change\n  useLayoutEffect(() => {\n    syncHeight();\n  }, [value, syncHeight]);\n\n  // Focus management\n  useLayoutEffect(() => {\n    if (shouldFocus) {\n      requestAnimationFrame(() => {\n        inputRef.current?.focus();\n      });\n    }\n  }, [shouldFocus]);\n\n  return {\n    value,\n    setValue,\n    clear,\n    inputRef,\n    handleChange,\n    handleKeyDown,\n    handleSend,\n    syncHeight,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\useChatMessages.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useChatMessages' has too many lines (59). Maximum allowed is 50.",
        "line": 38,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 120,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 38,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 38,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 45,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 45,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1388, 1395], "text": "(chatId == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1389, 1395], "text": "(chatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1388, 1395], "text": "(!Boolean(chatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 45,
        "column": 23,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 45,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1399, 1426], "text": "((apiClient?.getChatMessages) == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 53,
        "column": 16,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 53,
        "endColumn": 17
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 53,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 53,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 62,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 62,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1917, 1924], "text": "chatId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1918, 1924], "text": "(chatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1917, 1924], "text": "!Boolean(chatId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 78,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 78,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2335, 2342], "text": "chatId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2336, 2342], "text": "(chatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2335, 2342], "text": "!Boolean(chatId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 103,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 103,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3036, 3048], "text": "(targetChatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3036, 3048], "text": "(targetChatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3036, 3048], "text": "(Boolean(targetChatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useChatMessages Hook\n *\n * TanStack Query-based hook for fetching and caching chat messages.\n * Provides automatic caching, refetching, and loading states.\n */\n\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\nimport { useCallback } from 'react';\nimport type { ChatMessage, UseChatMessagesOptions } from '../types';\nimport { isValidUUID, normalizeChatMessage } from '../types';\n\n/**\n * Normalizes API response to ChatMessage array.\n */\nfunction normalizeMessages(response: unknown, mode: UseChatMessagesOptions['mode']): ChatMessage[] {\n  if (!Array.isArray(response)) return [];\n  return response.map((message) => normalizeChatMessage(message, mode));\n}\n\n/**\n * Query key factory for chat messages.\n */\nexport const chatMessagesKeys = {\n  all: ['chatMessages'] as const,\n  byId: (chatId: string | null) => ['chatMessages', chatId] as const,\n};\n\n/**\n * Hook for fetching chat messages with TanStack Query.\n *\n * Features:\n * - Automatic caching and deduplication\n * - Loading/error states managed by query\n * - Stale-while-revalidate pattern\n * - Suspense-ready if needed\n */\nexport function useChatMessages(options: UseChatMessagesOptions) {\n  const { apiClient, chatId, mode } = options;\n  const queryClient = useQueryClient();\n\n  const query = useQuery({\n    queryKey: chatMessagesKeys.byId(chatId),\n    queryFn: async (): Promise<ChatMessage[]> => {\n      if (!chatId || !apiClient?.getChatMessages) {\n        return [];\n      }\n\n      const response = await apiClient.getChatMessages(chatId);\n      return normalizeMessages(response, mode);\n    },\n    enabled: Boolean(chatId) && Boolean(apiClient?.getChatMessages) && isValidUUID(chatId),\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n\n  /**\n   * Optimistically add a message to the cache.\n   * Used when sending a new message or receiving a response.\n   */\n  const addMessage = useCallback(\n    (message: ChatMessage) => {\n      if (!chatId) return;\n\n      queryClient.setQueryData<ChatMessage[]>(chatMessagesKeys.byId(chatId), (old = []) => [\n        ...old,\n        message,\n      ]);\n    },\n    [chatId, queryClient],\n  );\n\n  /**\n   * Update a specific message in the cache.\n   * Used for updating pending messages after API response.\n   */\n  const updateMessage = useCallback(\n    (messageId: string, updates: Partial<ChatMessage>) => {\n      if (!chatId) return;\n\n      queryClient.setQueryData<ChatMessage[]>(chatMessagesKeys.byId(chatId), (old = []) =>\n        old.map((msg) => (msg.id === messageId ? { ...msg, ...updates } : msg)),\n      );\n    },\n    [chatId, queryClient],\n  );\n\n  /**\n   * Set all messages for a chat.\n   * Used when starting a new chat or loading from history.\n   */\n  const setMessages = useCallback(\n    (targetChatId: string, messages: ChatMessage[]) => {\n      queryClient.setQueryData<ChatMessage[]>(chatMessagesKeys.byId(targetChatId), messages);\n    },\n    [queryClient],\n  );\n\n  /**\n   * Clear messages cache for a chat.\n   */\n  const clearMessages = useCallback(\n    (targetChatId?: string) => {\n      const key = targetChatId ? chatMessagesKeys.byId(targetChatId) : chatMessagesKeys.all;\n      queryClient.removeQueries({ queryKey: key });\n    },\n    [queryClient],\n  );\n\n  return {\n    messages: query.data ?? [],\n    isLoading: query.isLoading,\n    isError: query.isError,\n    error: query.error,\n    refetch: query.refetch,\n    addMessage,\n    updateMessage,\n    setMessages,\n    clearMessages,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\useChatSessionState.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useChatSessionState' has too many lines (70). Maximum allowed is 50.",
        "line": 10,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 93,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 10,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 10,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 28,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 28,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1002, 1010], "text": "storage == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 44,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 44,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1401, 1409], "text": "storage == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 45,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 45,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1427, 1439], "text": "(activeChatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1427, 1439], "text": "(activeChatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1427, 1439], "text": "(Boolean(activeChatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 55,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 55,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1772, 1786], "text": "(existingChatId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1772, 1786], "text": "(existingChatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1772, 1786], "text": "(Boolean(existingChatId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 58,
        "column": 12,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 58,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1870, 1892], "text": "(apiClient?.createChat) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 62,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 62,
        "endColumn": 65,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2013, 2027], "text": "(initialMessage != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2013, 2027], "text": "(initialMessage ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2013, 2027], "text": "(Boolean(initialMessage))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 65,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 65,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2194, 2201], "text": "chatId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2195, 2201], "text": "(chatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2194, 2201], "text": "!Boolean(chatId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useEffect, useRef, useState } from 'react';\nimport type { UseChatOptions } from '../types';\nimport { ACTIVE_CHAT_ID_KEY, buildInitialChatTitle, isValidUUID } from '../types';\n\ninterface ChatSessionStateOptions {\n  apiClient: UseChatOptions['apiClient'];\n  storage?: UseChatOptions['storage'];\n}\n\nexport function useChatSessionState({ apiClient, storage }: ChatSessionStateOptions) {\n  const [activeChatId, setActiveChatId] = useState<string | null>(null);\n  const [activeHistoryId, setActiveHistoryId] = useState<string | null>(null);\n  const [isHistoryOpen, setIsHistoryOpen] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const activeChatIdRef = useRef<string | null>(null);\n  const activeHistoryIdRef = useRef<string | null>(null);\n\n  useEffect(() => {\n    activeChatIdRef.current = activeChatId;\n  }, [activeChatId]);\n\n  useEffect(() => {\n    activeHistoryIdRef.current = activeHistoryId;\n  }, [activeHistoryId]);\n\n  useEffect(() => {\n    if (!storage) return;\n\n    storage\n      .get<string>(ACTIVE_CHAT_ID_KEY)\n      .then(async (storedChatId) => {\n        if (typeof storedChatId === 'string' && isValidUUID(storedChatId)) {\n          setActiveChatId(storedChatId);\n          setActiveHistoryId(storedChatId);\n        }\n      })\n      .catch(() => {\n        // Ignore storage errors\n      });\n  }, [storage]);\n\n  useEffect(() => {\n    if (!storage) return;\n    if (activeChatId && isValidUUID(activeChatId)) {\n      storage.set(ACTIVE_CHAT_ID_KEY, activeChatId).catch(() => {\n        /* ignore */\n      });\n    }\n  }, [activeChatId, storage]);\n\n  const ensureChatId = useCallback(\n    async (initialMessage?: string): Promise<string | null> => {\n      const existingChatId = activeChatIdRef.current;\n      if (existingChatId && isValidUUID(existingChatId)) {\n        return existingChatId;\n      }\n      if (!apiClient?.createChat) {\n        throw new Error('Chat session is not available');\n      }\n\n      const fallbackTitle = buildInitialChatTitle(initialMessage || '');\n      const chat = await apiClient.createChat({ title: fallbackTitle });\n      const chatId = typeof chat?.['id'] === 'string' ? chat['id'] : null;\n      if (!chatId) {\n        throw new Error('Failed to create chat session');\n      }\n\n      setActiveChatId(chatId);\n      setActiveHistoryId(chatId);\n\n      return chatId;\n    },\n    [apiClient],\n  );\n\n  const clearError = useCallback(() => setError(null), []);\n\n  return {\n    activeChatId,\n    setActiveChatId,\n    activeHistoryId,\n    setActiveHistoryId,\n    isHistoryOpen,\n    setIsHistoryOpen,\n    error,\n    setError,\n    clearError,\n    activeChatIdRef,\n    activeHistoryIdRef,\n    ensureChatId,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\hooks\\useSendMessage.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useSendMessage' has too many lines (85). Maximum allowed is 50.",
        "line": 32,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 128,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 32,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 32,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 47,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 47,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1594, 1603], "text": "onSuccess != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 50,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 50,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1656, 1663], "text": "onError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 91,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 91,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2546, 2572], "text": "abortControllerRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 102,
        "column": 32,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 102,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2863, 2884], "text": "(params.idempotencyKey != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2863, 2884], "text": "(params.idempotencyKey ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2863, 2884], "text": "(Boolean(params.idempotencyKey))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 113,
        "column": 32,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 113,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3266, 3287], "text": "(params.idempotencyKey != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3266, 3287], "text": "(params.idempotencyKey ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3266, 3287], "text": "(Boolean(params.idempotencyKey))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useSendMessage Hook\n *\n * Mutation hook for sending chat messages with:\n * - Request cancellation via AbortController\n * - Optimistic UI updates\n * - Automatic rollback on error\n * - Retry logic for transient failures\n */\n\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useCallback, useEffect, useRef } from 'react';\nimport { useTranscriptCache } from '../../transcripts/hooks/useTranscriptCache';\nimport type { ChatApiResponse, UseSendMessageOptions } from '../types';\nimport { buildIdempotencyKey, type SendMessageMutationParams } from './sendMessageUtils';\nimport { sendMessageMutation } from './sendMessageMutation';\nimport {\n  createSendMessageHandlers,\n  type MutationContext,\n  type MutationHandlerDeps,\n} from './sendMessageHandlers';\n\n/**\n * Hook for sending messages with cancellation and optimistic updates.\n *\n * Key features:\n * - Cancels previous request if new one is sent\n * - Optimistic \"Thinking...\" message\n * - Rollback on error\n * - Returns chatId and chatTitle from response\n */\nexport function useSendMessage(options: UseSendMessageOptions) {\n  const { apiClient, pageUrl, courseCode, onSuccess, onError } = options;\n  const queryClient = useQueryClient();\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const pendingSendKeyRef = useRef<string | null>(null);\n  const { cacheTranscript } = useTranscriptCache(apiClient);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      abortControllerRef.current?.abort();\n    };\n  }, []);\n\n  const handlerDeps: MutationHandlerDeps = { queryClient };\n  if (onSuccess) {\n    handlerDeps.onSuccess = onSuccess;\n  }\n  if (onError) {\n    handlerDeps.onError = onError;\n  }\n\n  const {\n    onMutate,\n    onError: handleError,\n    onSuccess: handleSuccess,\n  } = createSendMessageHandlers(handlerDeps);\n\n  const mutation = useMutation<\n    ChatApiResponse & { resolvedChatId: string },\n    Error,\n    SendMessageMutationParams,\n    MutationContext\n  >({\n    retry: false,\n    mutationFn: async (params) => {\n      return sendMessageMutation(params, {\n        apiClient,\n        pageUrl,\n        courseCode,\n        cacheTranscript,\n        abortControllerRef,\n      });\n    },\n    onMutate,\n    onError: handleError,\n    onSuccess: handleSuccess,\n\n    onSettled: () => {\n      abortControllerRef.current = null;\n      pendingSendKeyRef.current = null;\n    },\n  });\n\n  /**\n   * Cancel any pending request.\n   * Useful when user navigates away or closes chat.\n   */\n  const cancelPending = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n    pendingSendKeyRef.current = null;\n    mutation.reset();\n  }, [mutation]);\n\n  return {\n    sendMessage: useCallback(\n      (params: SendMessageMutationParams) => {\n        const idempotencyKey = params.idempotencyKey || buildIdempotencyKey(params);\n        if (pendingSendKeyRef.current === idempotencyKey) {\n          return;\n        }\n        pendingSendKeyRef.current = idempotencyKey;\n        mutation.mutate({ ...params, idempotencyKey });\n      },\n      [mutation],\n    ),\n    sendMessageAsync: useCallback(\n      async (params: SendMessageMutationParams) => {\n        const idempotencyKey = params.idempotencyKey || buildIdempotencyKey(params);\n        if (pendingSendKeyRef.current === idempotencyKey) {\n          return undefined;\n        }\n        pendingSendKeyRef.current = idempotencyKey;\n        return mutation.mutateAsync({ ...params, idempotencyKey });\n      },\n      [mutation],\n    ),\n    isSending: mutation.isPending,\n    isError: mutation.isError,\n    error: mutation.error,\n    reset: mutation.reset,\n    cancelPending,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\chat\\types.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 133,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 133,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3772, 3778], "text": "value == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3773, 3778], "text": "(value ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3772, 3778], "text": "!Boolean(value)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 143,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 143,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [4100, 4111], "text": "normalized.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [4100, 4111], "text": "normalized === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4100, 4111], "text": "!Boolean(normalized)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 155,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 155,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4502, 4511], "text": "(candidate != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4502, 4511], "text": "(candidate ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4502, 4511], "text": "(Boolean(candidate))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 156,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 156,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [4526, 4545], "text": "normalizedCandidate.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [4526, 4545], "text": "normalizedCandidate !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4526, 4545], "text": "Boolean(normalizedCandidate)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 158,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 158,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4620, 4628], "text": "(fallback != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4620, 4628], "text": "(fallback ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4620, 4628], "text": "(Boolean(fallback))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 159,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 159,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [4646, 4664], "text": "(normalizedFallback.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [4646, 4664], "text": "(normalizedFallback !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4646, 4664], "text": "(Boolean(normalizedFallback))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 177,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 177,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5168, 5172], "text": "iso == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5169, 5172], "text": "(iso ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5168, 5172], "text": "!Boolean(iso)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60000.",
        "line": 181,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 181,
        "endColumn": 43
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 183,
        "column": 17,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 183,
        "endColumn": 19
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 184,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 184,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 24.",
        "line": 185,
        "column": 15,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 185,
        "endColumn": 17
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 24.",
        "line": 186,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 186,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 193,
        "column": 21,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 193,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5739, 5761], "text": "(getString(raw['kind']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5739, 5761], "text": "(getString(raw['kind']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5739, 5761], "text": "(Boolean(getString(raw['kind'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 193,
        "column": 47,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 193,
        "endColumn": 69,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5765, 5787], "text": "(getString(raw['type']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5765, 5787], "text": "(getString(raw['type']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5765, 5787], "text": "(Boolean(getString(raw['type'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 198,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 198,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5948, 5970], "text": "(getString(raw['mime']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5948, 5970], "text": "(getString(raw['mime']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5948, 5970], "text": "(Boolean(getString(raw['mime'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 198,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 198,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5974, 6000], "text": "(getString(raw['mimeType']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5974, 6000], "text": "(getString(raw['mimeType']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5974, 6000], "text": "(Boolean(getString(raw['mimeType'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 198,
        "column": 61,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 198,
        "endColumn": 88,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6004, 6031], "text": "(getString(raw['mime_type']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6004, 6031], "text": "(getString(raw['mime_type']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6004, 6031], "text": "(Boolean(getString(raw['mime_type'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 200,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 200,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6058, 6080], "text": "(getString(raw['name']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6058, 6080], "text": "(getString(raw['name']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6058, 6080], "text": "(Boolean(getString(raw['name'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 201,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 201,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6088, 6114], "text": "(getString(raw['fileName']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6088, 6114], "text": "(getString(raw['fileName']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6088, 6114], "text": "(Boolean(getString(raw['fileName'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 202,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 202,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6122, 6149], "text": "(getString(raw['file_name']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6122, 6149], "text": "(getString(raw['file_name']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6122, 6149], "text": "(Boolean(getString(raw['file_name'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 212,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 212,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6334, 6341], "text": "dataUrl != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6334, 6341], "text": "dataUrl ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6334, 6341], "text": "Boolean(dataUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 215,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 215,
        "endColumn": 10,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6389, 6392], "text": "url != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6389, 6392], "text": "url ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6389, 6392], "text": "Boolean(url)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 235,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 235,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7002, 7025], "text": "(getString(record['id']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7002, 7025], "text": "(getString(record['id']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7002, 7025], "text": "(Boolean(getString(record['id'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 235,
        "column": 66,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 235,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 238,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 238,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7159, 7187], "text": "(getString(record['content']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7159, 7187], "text": "(getString(record['content']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7159, 7187], "text": "(Boolean(getString(record['content'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 239,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 239,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7197, 7229], "text": "(getString(record['output_text']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7197, 7229], "text": "(getString(record['output_text']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7197, 7229], "text": "(Boolean(getString(record['output_text'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 240,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 240,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7239, 7270], "text": "(getString(record['input_text']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7239, 7270], "text": "(getString(record['input_text']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7239, 7270], "text": "(Boolean(getString(record['input_text'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 242,
        "column": 16,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 242,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7306, 7337], "text": "(getString(record['created_at']) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7306, 7337], "text": "(getString(record['created_at']) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7306, 7337], "text": "(Boolean(getString(record['created_at'])))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 243,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 243,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 245,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 245,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7407, 7418], "text": "(attachments != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 30,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Chat Domain Types\n *\n * Shared type definitions for the chat feature.\n * Used by hooks, components, and API layer.\n */\n\nimport type { StudyMode } from '@core/domain/types';\nimport type { ApiClient } from '@api/client';\n\n// =============================================================================\n// Message Types\n// =============================================================================\n\nexport type ChatMessageRole = 'user' | 'assistant';\n\nexport type ChatAttachmentKind = 'image' | 'document' | 'code' | 'other';\n\nexport interface ChatAttachment {\n  kind: ChatAttachmentKind;\n  mime: string;\n  name: string;\n  dataUrl?: string;\n  url?: string;\n}\n\nexport interface ChatMessage {\n  id: string;\n  role: ChatMessageRole;\n  content: string;\n  timestamp: string;\n  mode?: StudyMode;\n  source?: 'selection' | 'followup';\n  isPending?: boolean;\n  isError?: boolean;\n  attachments?: ChatAttachment[];\n}\n\n// =============================================================================\n// Chat Session Types\n// =============================================================================\n\nexport interface ChatHistoryItem {\n  id: string;\n  title: string;\n  updatedAt: string;\n  lastMessage?: string;\n}\n\nexport type HistoryTitleSource = 'local' | 'server';\n\n// =============================================================================\n// API Parameter Types\n// =============================================================================\n\nexport interface SendMessageParams {\n  /** The message content to send */\n  message: string;\n  /** Current study mode */\n  mode: StudyMode;\n  /** Source of the message */\n  source: 'selection' | 'followup';\n  /** Current page URL for context */\n  pageUrl?: string;\n  /** Course code if available */\n  courseCode?: string;\n  /** Existing chat ID if continuing conversation */\n  chatId?: string | null;\n  /** Chat history for context */\n  chatHistory?: Array<{ role: ChatMessageRole; content: string }>;\n}\n\nexport interface ChatApiResponse {\n  explanation: string;\n  chatId?: string;\n  chatTitle?: string;\n}\n\n// =============================================================================\n// Hook Option Types\n// =============================================================================\n\nexport interface UseChatOptions {\n  /** API client for backend calls */\n  apiClient: ApiClient | null;\n  /** Storage adapter for persistence */\n  storage?: {\n    get: <T = unknown>(key: string) => Promise<T | null>;\n    set: (key: string, value: unknown) => Promise<void>;\n  };\n  /** Current study mode */\n  mode: StudyMode;\n  /** Current page URL */\n  pageUrl: string;\n  /** Course code if available */\n  courseCode: string | null;\n}\n\nexport interface UseChatMessagesOptions {\n  apiClient: ApiClient | null;\n  chatId: string | null;\n  mode: StudyMode;\n}\n\nexport interface UseChatHistoryOptions {\n  apiClient: ApiClient | null;\n  limit?: number;\n}\n\nexport interface UseSendMessageOptions {\n  apiClient: ApiClient | null;\n  mode: StudyMode;\n  pageUrl: string;\n  courseCode: string | null;\n  onSuccess?: (response: ChatApiResponse, chatId: string) => void;\n  onError?: (error: Error) => void;\n}\n\n// =============================================================================\n// Constants\n// =============================================================================\n\nexport const CHAT_TITLE_MAX_WORDS = 6;\nexport const CHAT_TITLE_MAX_LENGTH = 80;\nexport const FALLBACK_CHAT_TITLE = 'New chat';\nexport const ACTIVE_CHAT_ID_KEY = 'lockin_sidebar_activeChatId';\n\n// =============================================================================\n// Utility Functions\n// =============================================================================\n\nexport function isValidUUID(value: string | null | undefined): boolean {\n  if (!value) return false;\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);\n}\n\nexport function normalizeSpaces(text: string): string {\n  return text.replace(/\\s+/g, ' ').trim();\n}\n\nexport function clampChatTitle(text = ''): string {\n  const normalized = normalizeSpaces(text);\n  if (!normalized) return '';\n\n  const limitedWords = normalized.split(' ').slice(0, CHAT_TITLE_MAX_WORDS).join(' ').trim();\n\n  if (limitedWords.length <= CHAT_TITLE_MAX_LENGTH) {\n    return limitedWords;\n  }\n\n  return limitedWords.slice(0, CHAT_TITLE_MAX_LENGTH).trim();\n}\n\nexport function coerceChatTitle(candidate?: string | null, fallback?: string): string {\n  const normalizedCandidate = clampChatTitle(candidate || '');\n  if (normalizedCandidate) return normalizedCandidate;\n\n  const normalizedFallback = clampChatTitle(fallback || '');\n  return normalizedFallback || FALLBACK_CHAT_TITLE;\n}\n\nexport function buildInitialChatTitle(text: string): string {\n  return coerceChatTitle(text, FALLBACK_CHAT_TITLE);\n}\n\ntype RecordValue = Record<string, unknown>;\n\nfunction isRecord(value: unknown): value is RecordValue {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction getString(value: unknown): string | undefined {\n  return typeof value === 'string' ? value : undefined;\n}\n\nexport function relativeTimeLabel(iso: string | null | undefined): string {\n  if (!iso) return 'just now';\n  const date = new Date(iso);\n  if (Number.isNaN(date.getTime())) return 'just now';\n  const delta = Date.now() - date.getTime();\n  const minutes = Math.round(delta / 60000);\n  if (minutes <= 1) return 'just now';\n  if (minutes < 60) return `${minutes}m ago`;\n  const hours = Math.round(minutes / 60);\n  if (hours < 24) return `${hours}h ago`;\n  const days = Math.round(hours / 24);\n  return `${days}d ago`;\n}\n\nexport function normalizeChatAttachment(raw: unknown): ChatAttachment | null {\n  if (!isRecord(raw)) return null;\n\n  const kindValue = getString(raw['kind']) || getString(raw['type']) || 'other';\n  const kind = (\n    ['image', 'document', 'code', 'other'].includes(kindValue) ? kindValue : 'other'\n  ) as ChatAttachmentKind;\n  const mime =\n    getString(raw['mime']) || getString(raw['mimeType']) || getString(raw['mime_type']) || '';\n  const name =\n    getString(raw['name']) ||\n    getString(raw['fileName']) ||\n    getString(raw['file_name']) ||\n    'Attachment';\n  const dataUrl = getString(raw['dataUrl']);\n  const url = getString(raw['url']);\n\n  const attachment: ChatAttachment = {\n    kind,\n    mime,\n    name,\n  };\n  if (dataUrl) {\n    attachment.dataUrl = dataUrl;\n  }\n  if (url) {\n    attachment.url = url;\n  }\n  return attachment;\n}\n\nexport function normalizeChatMessage(raw: unknown, mode: StudyMode): ChatMessage {\n  const record = isRecord(raw) ? raw : {};\n  const attachments = Array.isArray(record['attachments'])\n    ? record['attachments']\n        .map(normalizeChatAttachment)\n        .filter((attachment: ChatAttachment | null): attachment is ChatAttachment =>\n          Boolean(attachment),\n        )\n    : undefined;\n\n  const modeValue =\n    record['mode'] === 'explain' || record['mode'] === 'general' ? record['mode'] : undefined;\n\n  const message: ChatMessage = {\n    id: getString(record['id']) || `msg-${Math.random().toString(16).slice(2)}`,\n    role: record['role'] === 'assistant' ? 'assistant' : 'user',\n    content:\n      getString(record['content']) ||\n      getString(record['output_text']) ||\n      getString(record['input_text']) ||\n      'Message',\n    timestamp: getString(record['created_at']) || new Date().toISOString(),\n    mode: modeValue || mode,\n  };\n  if (attachments && attachments.length > 0) {\n    message.attachments = attachments;\n  }\n  return message;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\contexts\\NoteSaveContext.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 43,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 43,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 79,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 79,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2412, 2420], "text": "context == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Note Save Context\n *\n * Provides universal access to note saving functionality across the extension.\n * Follows the ToolContext.tsx pattern for consistency.\n */\n\nimport { createContext, useContext, useMemo, type ReactNode } from 'react';\nimport type { Note } from '@core/domain/Note';\nimport type { NotesService } from '@core/services/notesService';\nimport { useNoteSave, type SaveNoteOptions } from '../../hooks/useNoteSave';\nimport type { SidebarTabId } from '../sidebar/types';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\ninterface NoteSaveContextValue {\n  /** Save content as a note with optional configuration */\n  saveNote: (options: SaveNoteOptions) => Promise<Note | null>;\n}\n\n// -----------------------------------------------------------------------------\n// Context\n// -----------------------------------------------------------------------------\n\nconst NoteSaveContext = createContext<NoteSaveContextValue | null>(null);\n\n// -----------------------------------------------------------------------------\n// Provider\n// -----------------------------------------------------------------------------\n\ninterface NoteSaveProviderProps {\n  notesService: NotesService | null;\n  pageUrl: string | null;\n  courseCode: string | null;\n  upsertNote: (note: Note) => void;\n  setSelectedNoteId: (id: string | null) => void;\n  setActiveTab: (tab: SidebarTabId) => void;\n  children: ReactNode;\n}\n\nexport function NoteSaveProvider({\n  notesService,\n  pageUrl,\n  courseCode,\n  upsertNote,\n  setSelectedNoteId,\n  setActiveTab,\n  children,\n}: NoteSaveProviderProps) {\n  // Use the hook internally\n  const { saveNote } = useNoteSave({\n    notesService,\n    pageUrl,\n    courseCode,\n    upsertNote,\n    setSelectedNoteId,\n    setActiveTab,\n  });\n\n  // Memoize context value to avoid unnecessary rerenders\n  const value = useMemo<NoteSaveContextValue>(\n    () => ({\n      saveNote,\n    }),\n    [saveNote],\n  );\n\n  return <NoteSaveContext.Provider value={value}>{children}</NoteSaveContext.Provider>;\n}\n\n// -----------------------------------------------------------------------------\n// Hook\n// -----------------------------------------------------------------------------\n\nexport function useNoteSaveContext(): NoteSaveContextValue {\n  const context = useContext(NoteSaveContext);\n  if (!context) {\n    throw new Error('useNoteSaveContext must be used within a NoteSaveProvider');\n  }\n  return context;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\contexts\\TranscriptCacheContext.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 29,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 29,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 49,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 49,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1502, 1510], "text": "context == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Transcript Cache Context\n *\n * Provides access to transcript caching from anywhere in the extension UI.\n */\n\nimport { createContext, useContext, useMemo, type ReactNode } from 'react';\nimport type { ApiClient } from '@api/client';\nimport {\n  useTranscriptCache,\n  type TranscriptCacheInput,\n  type TranscriptCacheState,\n} from '../transcripts/hooks/useTranscriptCache';\n\ninterface TranscriptCacheContextValue {\n  cacheTranscript: (input: TranscriptCacheInput) => Promise<{ fingerprint: string } | null>;\n  status: TranscriptCacheState['status'];\n  error: string | null;\n  lastFingerprint: string | null;\n}\n\nconst TranscriptCacheContext = createContext<TranscriptCacheContextValue | null>(null);\n\ninterface TranscriptCacheProviderProps {\n  apiClient: ApiClient | null;\n  children: ReactNode;\n}\n\nexport function TranscriptCacheProvider({ apiClient, children }: TranscriptCacheProviderProps) {\n  const cache = useTranscriptCache(apiClient);\n\n  const value = useMemo<TranscriptCacheContextValue>(\n    () => ({\n      cacheTranscript: cache.cacheTranscript,\n      status: cache.status,\n      error: cache.error,\n      lastFingerprint: cache.lastFingerprint,\n    }),\n    [cache.cacheTranscript, cache.error, cache.lastFingerprint, cache.status],\n  );\n\n  return (\n    <TranscriptCacheContext.Provider value={value}>{children}</TranscriptCacheContext.Provider>\n  );\n}\n\nexport function useTranscriptCacheContext(): TranscriptCacheContextValue {\n  const context = useContext(TranscriptCacheContext);\n  if (!context) {\n    throw new Error('useTranscriptCacheContext must be used within a TranscriptCacheProvider');\n  }\n  return context;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\feedback\\FeedbackModal.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 48,
        "column": 12,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorString",
        "endLine": 48,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": {
              "range": [1641, 1689],
              "text": "((chromeRuntime?.runtime?.getManifest?.()?.version).length > 0)"
            },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": {
              "range": [1641, 1689],
              "text": "((chromeRuntime?.runtime?.getManifest?.()?.version) !== \"\")"
            },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1641, 1689],
              "text": "(Boolean((chromeRuntime?.runtime?.getManifest?.()?.version)))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 62,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 62,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1962, 1967], "text": "(match != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 66,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 66,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2104, 2109], "text": "(match != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 70,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 70,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2247, 2252], "text": "(match != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'FeedbackModal' has too many lines (225). Maximum allowed is 50.",
        "line": 78,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 323,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 78,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 78,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 2000.",
        "line": 104,
        "column": 10,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 104,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 110,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 110,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2983, 3002], "text": "(textareaRef.current != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 126,
        "column": 46,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 126,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 139,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 139,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3771, 3778], "text": "(pageUrl != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3771, 3778], "text": "(pageUrl ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3771, 3778], "text": "(Boolean(pageUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 143,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 143,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3900, 3910], "text": "courseCode != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3900, 3910], "text": "courseCode ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3900, 3910], "text": "Boolean(courseCode)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 146,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 146,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3967, 3981], "text": "document.title.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3967, 3981], "text": "document.title !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3967, 3981], "text": "Boolean(document.title)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 234,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 234,
        "endColumn": 73,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7108, 7123], "text": "(validationError != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7108, 7123], "text": "(validationError ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7108, 7123], "text": "(Boolean(validationError))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 249,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 249,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7819, 7834], "text": "(validationError != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7819, 7834], "text": "(validationError ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7819, 7834], "text": "(Boolean(validationError))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 268,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 268,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8729, 8736], "text": "(pageUrl != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [8729, 8736], "text": "(pageUrl ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [8729, 8736], "text": "(Boolean(pageUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 271,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 271,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8834, 8844], "text": "(courseCode != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [8834, 8844], "text": "(courseCode ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [8834, 8844], "text": "(Boolean(courseCode))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 289,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 289,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9770, 9775], "text": "(error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 1,
        "message": "Promise-returning function provided to attribute where a void return was expected.",
        "line": 305,
        "column": 25,
        "nodeType": "JSXExpressionContainer",
        "messageId": "voidReturnAttribute",
        "endLine": 305,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 306,
        "column": 44,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 306,
        "endColumn": 68,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [10424, 10449], "text": "(formState.message.trim().length === 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [10424, 10449], "text": "(formState.message.trim() === \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [10424, 10449], "text": "(!Boolean(formState.message.trim()))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * FeedbackModal Component\n *\n * Modal dialog for submitting user feedback (bug reports, feature requests, questions).\n * Auto-captures context (URL, course code, extension version, browser).\n */\n\nimport { useEffect, useRef, useCallback } from 'react';\nimport { useFeedbackForm } from './hooks/useFeedbackForm';\nimport type { ApiClient } from '@api/client';\nimport type { FeedbackType, FeedbackContext } from '@api/resources/feedbackClient';\nimport { sanitizeUrl } from '@core/utils/urlSanitizer';\n\nexport interface FeedbackModalProps {\n  /** Whether the modal is open */\n  isOpen: boolean;\n  /** Called when modal should close */\n  onClose: () => void;\n  /** API client for submitting feedback */\n  apiClient: ApiClient | null;\n  /** Current page URL */\n  pageUrl?: string;\n  /** Course code (if detected) */\n  courseCode?: string | null;\n}\n\nconst FEEDBACK_TYPES: { value: FeedbackType; label: string; description: string }[] = [\n  { value: 'bug', label: ' Bug Report', description: 'Something is broken or not working' },\n  {\n    value: 'feature',\n    label: ' Feature Request',\n    description: 'Suggest a new feature or improvement',\n  },\n  { value: 'question', label: ' Question', description: 'Ask a question about using Lock-in' },\n  { value: 'other', label: ' Other', description: 'General feedback or comments' },\n];\n\ntype ChromeRuntimeLike = {\n  runtime?: { getManifest?: () => { version?: string } };\n};\n\n/**\n * Get extension version from Chrome runtime\n */\nfunction getExtensionVersion(): string {\n  try {\n    const chromeRuntime = (globalThis as typeof globalThis & { chrome?: ChromeRuntimeLike }).chrome;\n    return chromeRuntime?.runtime?.getManifest?.()?.version || 'unknown';\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Get browser info from user agent\n */\nfunction getBrowserInfo(): string {\n  try {\n    const ua = navigator.userAgent;\n    if (ua.includes('Chrome')) {\n      const match = ua.match(/Chrome\\/(\\d+)/);\n      return match ? `Chrome ${match[1]}` : 'Chrome';\n    }\n    if (ua.includes('Firefox')) {\n      const match = ua.match(/Firefox\\/(\\d+)/);\n      return match ? `Firefox ${match[1]}` : 'Firefox';\n    }\n    if (ua.includes('Safari')) {\n      const match = ua.match(/Version\\/(\\d+)/);\n      return match ? `Safari ${match[1]}` : 'Safari';\n    }\n    return 'Unknown browser';\n  } catch {\n    return 'Unknown browser';\n  }\n}\n\nexport function FeedbackModal({\n  isOpen,\n  onClose,\n  apiClient,\n  pageUrl,\n  courseCode,\n}: FeedbackModalProps) {\n  const textareaRef = useRef<HTMLTextAreaElement>(null);\n\n  const {\n    formState,\n    setType,\n    setMessage,\n    isSubmitting,\n    error,\n    isSuccess,\n    submit,\n    reset,\n    validationError,\n  } = useFeedbackForm({\n    apiClient,\n    onSuccess: () => {\n      // Keep modal open to show success message, then auto-close\n      setTimeout(() => {\n        onClose();\n        reset();\n      }, 2000);\n    },\n  });\n\n  // Focus textarea when modal opens\n  useEffect(() => {\n    if (isOpen && textareaRef.current) {\n      setTimeout(() => textareaRef.current?.focus(), 100);\n    }\n  }, [isOpen]);\n\n  // Reset form when modal closes\n  useEffect(() => {\n    if (!isOpen) {\n      reset();\n    }\n  }, [isOpen, reset]);\n\n  // Handle Escape key\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape' && !isSubmitting) {\n        onClose();\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [isOpen, isSubmitting, onClose]);\n\n  const handleSubmit = useCallback(async () => {\n    // Sanitize URL to remove sensitive query parameters (sesskey, tokens, etc.)\n    const context: FeedbackContext = {\n      url: sanitizeUrl(pageUrl || window.location.href),\n      extensionVersion: getExtensionVersion(),\n      browser: getBrowserInfo(),\n    };\n    if (courseCode) {\n      context.courseCode = courseCode;\n    }\n    if (document.title) {\n      context.page = document.title;\n    }\n\n    await submit(context);\n  }, [pageUrl, courseCode, submit]);\n\n  const handleBackdropClick = useCallback(\n    (e: React.MouseEvent) => {\n      if (e.target === e.currentTarget && !isSubmitting) {\n        onClose();\n      }\n    },\n    [isSubmitting, onClose],\n  );\n\n  if (!isOpen) return null;\n\n  return (\n    <div className=\"lockin-feedback-backdrop\" onClick={handleBackdropClick}>\n      <div\n        className=\"lockin-feedback-modal\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-labelledby=\"feedback-title\"\n      >\n        {/* Header */}\n        <div className=\"lockin-feedback-header\">\n          <h2 id=\"feedback-title\" className=\"lockin-feedback-title\">\n            Send Feedback\n          </h2>\n          <button\n            className=\"lockin-feedback-close\"\n            onClick={onClose}\n            disabled={isSubmitting}\n            aria-label=\"Close feedback form\"\n          >\n            \n          </button>\n        </div>\n\n        {/* Success State */}\n        {isSuccess ? (\n          <div className=\"lockin-feedback-success\">\n            <div className=\"lockin-feedback-success-icon\"></div>\n            <p className=\"lockin-feedback-success-text\">\n              Thank you for your feedback!\n              <br />\n              <span className=\"lockin-feedback-success-subtext\">We'll review it soon.</span>\n            </p>\n          </div>\n        ) : (\n          <>\n            {/* Body */}\n            <div className=\"lockin-feedback-body\">\n              {/* Type Selection */}\n              <div className=\"lockin-feedback-field\">\n                <label className=\"lockin-feedback-label\">What type of feedback?</label>\n                <div className=\"lockin-feedback-type-grid\">\n                  {FEEDBACK_TYPES.map((type) => (\n                    <button\n                      key={type.value}\n                      type=\"button\"\n                      className={`lockin-feedback-type-btn ${formState.type === type.value ? 'is-selected' : ''}`}\n                      onClick={() => setType(type.value)}\n                      disabled={isSubmitting}\n                    >\n                      <span className=\"lockin-feedback-type-label\">{type.label}</span>\n                      <span className=\"lockin-feedback-type-desc\">{type.description}</span>\n                    </button>\n                  ))}\n                </div>\n              </div>\n\n              {/* Message */}\n              <div className=\"lockin-feedback-field\">\n                <label htmlFor=\"feedback-message\" className=\"lockin-feedback-label\">\n                  {formState.type === 'bug'\n                    ? 'Describe what happened'\n                    : formState.type === 'feature'\n                      ? 'Describe your idea'\n                      : formState.type === 'question'\n                        ? 'What would you like to know?'\n                        : 'Your feedback'}\n                </label>\n                <textarea\n                  id=\"feedback-message\"\n                  ref={textareaRef}\n                  className={`lockin-feedback-textarea ${validationError ? 'has-error' : ''}`}\n                  placeholder={\n                    formState.type === 'bug'\n                      ? 'What were you trying to do? What happened instead?'\n                      : formState.type === 'feature'\n                        ? 'What feature would help you? How would you use it?'\n                        : 'Type your message here...'\n                  }\n                  value={formState.message}\n                  onChange={(e) => setMessage(e.target.value)}\n                  disabled={isSubmitting}\n                  rows={5}\n                  maxLength={5000}\n                />\n                <div className=\"lockin-feedback-textarea-meta\">\n                  {validationError ? (\n                    <span className=\"lockin-feedback-error\">{validationError}</span>\n                  ) : (\n                    <span className=\"lockin-feedback-char-count\">\n                      {formState.message.length} / 5000\n                    </span>\n                  )}\n                </div>\n              </div>\n\n              {/* Context Info (Collapsed) */}\n              <details className=\"lockin-feedback-context\">\n                <summary className=\"lockin-feedback-context-summary\">\n                  Auto-captured context (click to expand)\n                </summary>\n                <div className=\"lockin-feedback-context-details\">\n                  <div className=\"lockin-feedback-context-row\">\n                    <span className=\"lockin-feedback-context-label\">Page:</span>\n                    <span className=\"lockin-feedback-context-value\">\n                      {pageUrl || window.location.href}\n                    </span>\n                  </div>\n                  {courseCode && (\n                    <div className=\"lockin-feedback-context-row\">\n                      <span className=\"lockin-feedback-context-label\">Course:</span>\n                      <span className=\"lockin-feedback-context-value\">{courseCode}</span>\n                    </div>\n                  )}\n                  <div className=\"lockin-feedback-context-row\">\n                    <span className=\"lockin-feedback-context-label\">Version:</span>\n                    <span className=\"lockin-feedback-context-value\">{getExtensionVersion()}</span>\n                  </div>\n                  <div className=\"lockin-feedback-context-row\">\n                    <span className=\"lockin-feedback-context-label\">Browser:</span>\n                    <span className=\"lockin-feedback-context-value\">{getBrowserInfo()}</span>\n                  </div>\n                </div>\n              </details>\n\n              {/* Error */}\n              {error && <div className=\"lockin-feedback-error-banner\">{error.message}</div>}\n            </div>\n\n            {/* Footer */}\n            <div className=\"lockin-feedback-footer\">\n              <button\n                type=\"button\"\n                className=\"lockin-feedback-btn lockin-feedback-btn-secondary\"\n                onClick={onClose}\n                disabled={isSubmitting}\n              >\n                Cancel\n              </button>\n              <button\n                type=\"button\"\n                className=\"lockin-feedback-btn lockin-feedback-btn-primary\"\n                onClick={handleSubmit}\n                disabled={isSubmitting || !formState.message.trim()}\n              >\n                {isSubmitting ? (\n                  <>\n                    <span className=\"lockin-feedback-spinner\" />\n                    Sending...\n                  </>\n                ) : (\n                  'Send Feedback'\n                )}\n              </button>\n            </div>\n          </>\n        )}\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\feedback\\hooks\\useFeedbackForm.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useFeedbackForm' has too many lines (84). Maximum allowed is 50.",
        "line": 54,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 148,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 78,
        "column": 10,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 78,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2289, 2314], "text": "formState.message.trim().length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2289, 2314], "text": "formState.message.trim() === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2289, 2314], "text": "!Boolean(formState.message.trim())" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 82,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 82,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 92,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 92,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2728, 2738], "text": "apiClient == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 109,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 109,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3173, 3180], "text": "context != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useFeedbackForm Hook\n *\n * Manages feedback form state, validation, and submission.\n * Uses the API client to submit feedback to the backend.\n */\n\nimport { useState, useCallback } from 'react';\nimport type { ApiClient } from '@api/client';\nimport type { FeedbackType, FeedbackContext } from '@api/resources/feedbackClient';\n\nexport interface UseFeedbackFormOptions {\n  apiClient: ApiClient | null;\n  onSuccess?: () => void;\n  onError?: (error: Error) => void;\n}\n\nexport interface FeedbackFormState {\n  type: FeedbackType;\n  message: string;\n}\n\nexport interface UseFeedbackFormResult {\n  /** Current form state */\n  formState: FeedbackFormState;\n  /** Set feedback type */\n  setType: (type: FeedbackType) => void;\n  /** Set feedback message */\n  setMessage: (message: string) => void;\n  /** Whether form is currently submitting */\n  isSubmitting: boolean;\n  /** Submission error (if any) */\n  error: Error | null;\n  /** Whether form was successfully submitted */\n  isSuccess: boolean;\n  /** Submit the feedback */\n  submit: (context?: FeedbackContext) => Promise<boolean>;\n  /** Reset form to initial state */\n  reset: () => void;\n  /** Validation error message (if any) */\n  validationError: string | null;\n}\n\nconst INITIAL_STATE: FeedbackFormState = {\n  type: 'bug',\n  message: '',\n};\n\nconst MAX_MESSAGE_LENGTH = 5000;\n\n/**\n * Hook for managing feedback form state and submission\n */\nexport function useFeedbackForm({\n  apiClient,\n  onSuccess,\n  onError,\n}: UseFeedbackFormOptions): UseFeedbackFormResult {\n  const [formState, setFormState] = useState<FeedbackFormState>(INITIAL_STATE);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [isSuccess, setIsSuccess] = useState(false);\n  const [validationError, setValidationError] = useState<string | null>(null);\n\n  const setType = useCallback((type: FeedbackType) => {\n    setFormState((prev) => ({ ...prev, type }));\n    setValidationError(null);\n  }, []);\n\n  const setMessage = useCallback((message: string) => {\n    // Enforce max length\n    const trimmed = message.slice(0, MAX_MESSAGE_LENGTH);\n    setFormState((prev) => ({ ...prev, message: trimmed }));\n    setValidationError(null);\n  }, []);\n\n  const validate = useCallback((): boolean => {\n    if (!formState.message.trim()) {\n      setValidationError('Please describe your feedback');\n      return false;\n    }\n    if (formState.message.length < 10) {\n      setValidationError('Please provide more details (at least 10 characters)');\n      return false;\n    }\n    setValidationError(null);\n    return true;\n  }, [formState.message]);\n\n  const submit = useCallback(\n    async (context?: FeedbackContext): Promise<boolean> => {\n      if (!apiClient) {\n        setError(new Error('Not authenticated. Please sign in to submit feedback.'));\n        return false;\n      }\n\n      if (!validate()) {\n        return false;\n      }\n\n      setIsSubmitting(true);\n      setError(null);\n\n      try {\n        const payload: { type: FeedbackType; message: string; context?: FeedbackContext } = {\n          type: formState.type,\n          message: formState.message.trim(),\n        };\n        if (context) {\n          payload.context = context;\n        }\n        await apiClient.submitFeedback(payload);\n\n        setIsSuccess(true);\n        onSuccess?.();\n        return true;\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error('Failed to submit feedback');\n        setError(error);\n        onError?.(error);\n        return false;\n      } finally {\n        setIsSubmitting(false);\n      }\n    },\n    [apiClient, formState, validate, onSuccess, onError],\n  );\n\n  const reset = useCallback(() => {\n    setFormState(INITIAL_STATE);\n    setIsSubmitting(false);\n    setError(null);\n    setIsSuccess(false);\n    setValidationError(null);\n  }, []);\n\n  return {\n    formState,\n    setType,\n    setMessage,\n    isSubmitting,\n    error,\n    isSuccess,\n    submit,\n    reset,\n    validationError,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\feedback\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\index.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "Imports \"Root\" are only used as type.",
        "line": 8,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "messageId": "someImportsAreOnlyTypes",
        "endLine": 8,
        "endColumn": 53,
        "fix": {
          "range": [186, 211],
          "text": "import type { Root } from 'react-dom/client';\nimport { createRoot"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 15,
        "column": 3,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 15,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [513, 513], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [513, 513], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 38,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 38,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1100, 1110], "text": "container == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 47,
        "column": 21,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 47,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 48,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 48,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1376, 1388], "text": "currentProps != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 63,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 63,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1670, 1682], "text": "currentProps != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "/**\n * Lock-in Extension UI Entry Point\n *\n * Exposes the React sidebar component + factory as `window.LockInUI`.\n * The actual sidebar implementation lives in `LockInSidebar.tsx`.\n */\n\nimport { createRoot, Root } from 'react-dom/client';\nimport { LockInSidebar } from './LockInSidebar';\nimport type { LockInSidebarProps } from './LockInSidebar';\n\n// Initialize Sentry for error tracking (sidebar surface)\n// This runs early before the React app renders to catch all errors\nif (typeof window !== 'undefined') {\n  window.LockInSentry?.initSentry?.('sidebar');\n}\n\nexport interface SidebarInstance {\n  root: Root;\n  unmount: () => void;\n  updateProps: (newProps: Partial<LockInSidebarProps>) => void;\n}\n\ndeclare global {\n  interface Window {\n    LockInSentry?: {\n      initSentry?: (surface: string) => Promise<boolean>;\n    };\n    LockInUI?: {\n      createLockInSidebar: typeof createLockInSidebar;\n      LockInSidebar: typeof LockInSidebar;\n    };\n  }\n}\n\nexport function createLockInSidebar(props: LockInSidebarProps): SidebarInstance {\n  let container = document.getElementById('lockin-root');\n  if (!container) {\n    container = document.createElement('div');\n    container.id = 'lockin-root';\n    document.body.appendChild(container);\n  }\n\n  let currentProps: LockInSidebarProps | null = { ...props };\n  const root = createRoot(container);\n\n  const render = () => {\n    if (currentProps) {\n      root.render(<LockInSidebar {...currentProps} />);\n    }\n  };\n\n  render();\n\n  return {\n    root,\n    unmount: () => {\n      root.unmount();\n      container?.remove();\n      currentProps = null;\n    },\n    updateProps: (newProps: Partial<LockInSidebarProps>) => {\n      if (currentProps) {\n        currentProps = { ...currentProps, ...newProps };\n        render();\n      }\n    },\n  };\n}\n\nif (typeof window !== 'undefined') {\n  window.LockInUI = {\n    createLockInSidebar,\n    LockInSidebar,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\NoteEditor.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'NoteEditorShell' has too many lines (157). Maximum allowed is 50.",
        "line": 44,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 213,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 44,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 44,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 66,
        "column": 10,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 66,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2908, 2922], "text": "(note?.content) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 67,
        "column": 50,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 67,
        "endColumn": 74,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2986, 3010], "text": "(Boolean(note.content.editorState))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 70,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 70,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 102,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 102,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3871, 3889], "text": "initialEditorState != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3871, 3889], "text": "initialEditorState ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3871, 3889], "text": "Boolean(initialEditorState)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 121,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 121,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4435, 4445], "text": "(assetError != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4435, 4445], "text": "(assetError ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4435, 4445], "text": "(Boolean(assetError))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 151,
        "column": 31,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 151,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5378, 5387], "text": "((note?.id) == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5379, 5387], "text": "((note?.id) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5378, 5387], "text": "(!Boolean((note?.id)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 151,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 151,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5391, 5404], "text": "(onUploadFile == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 153,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 153,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5471, 5483], "text": "(onUploadFile != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 177,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 177,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6387, 6396], "text": "(onSaveNow != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 181,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 181,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6534, 6546], "text": "(onUploadFile != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 186,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 186,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6691, 6704], "text": "(onDeleteAsset != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 190,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 190,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6776, 6786], "text": "(assetError != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6776, 6786], "text": "(assetError ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6776, 6786], "text": "(Boolean(assetError))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 199,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 199,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7069, 7073], "text": "(file != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 199,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 199,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7077, 7089], "text": "(onUploadFile != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 199,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 199,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7093, 7107], "text": "(composerEditor != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 201,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 201,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7183, 7188], "text": "asset != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 206,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 206,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7312, 7332], "text": "fileInputRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useMemo, useRef, useState } from 'react';\nimport { CodeHighlightNode, CodeNode } from '@lexical/code';\nimport { LinkNode } from '@lexical/link';\nimport { ListItemNode, ListNode } from '@lexical/list';\nimport { LexicalComposer } from '@lexical/react/LexicalComposer';\nimport type { InitialConfigType } from '@lexical/react/LexicalComposer';\nimport { ContentEditable } from '@lexical/react/LexicalContentEditable';\nimport { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';\nimport { ListPlugin } from '@lexical/react/LexicalListPlugin';\nimport { LinkPlugin as ReactLinkPlugin } from '@lexical/react/LexicalLinkPlugin';\nimport { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';\nimport { LexicalErrorBoundary } from '@lexical/react/LexicalErrorBoundary';\nimport { AutoFocusPlugin } from '@lexical/react/LexicalAutoFocusPlugin';\nimport { HeadingNode, QuoteNode } from '@lexical/rich-text';\nimport type { LexicalEditor } from 'lexical';\nimport type { Note, NoteAsset, NoteContent, NoteStatus } from '@core/domain/Note';\nimport { AttachmentNode } from './nodes/AttachmentNode';\nimport { ImageNode } from './nodes/ImageNode';\nimport { buildStatusLabel } from './editor/buildStatusLabel';\nimport { noteEditorTheme } from './editor/noteEditorTheme';\nimport { insertAssetIntoEditor } from './editor/insertAssetIntoEditor';\nimport { NoteToolbar } from './editor/NoteToolbar';\nimport { AssetCleanupPlugin } from './editor/plugins/AssetCleanupPlugin';\nimport { CaretScrollPlugin } from './editor/plugins/CaretScrollPlugin';\nimport { NoteChangePlugin } from './editor/plugins/NoteChangePlugin';\nimport { NoteContentLoader } from './editor/plugins/NoteContentLoader';\nimport { ShortcutsPlugin } from './editor/plugins/ShortcutsPlugin';\nimport { UploadPlugin } from './editor/plugins/UploadPlugin';\n\ninterface NoteEditorShellProps {\n  note: Note | null;\n  status: NoteStatus;\n  title: string;\n  onTitleChange: (next: string) => void;\n  onContentChange: (content: NoteContent) => void;\n  onSaveNow?: () => void;\n  onUploadFile?: (file: File) => Promise<NoteAsset | null>;\n  onDeleteAsset?: (assetId: string) => Promise<boolean>;\n  isAssetUploading?: boolean;\n  assetError?: string | null;\n  editorError?: string | null;\n}\n\nexport function NoteEditorShell({\n  note,\n  status,\n  title,\n  onTitleChange,\n  onContentChange,\n  onSaveNow,\n  onUploadFile,\n  onDeleteAsset,\n  isAssetUploading,\n  assetError,\n  editorError,\n}: NoteEditorShellProps) {\n  const fileInputRef = useRef<HTMLInputElement | null>(null);\n  const [composerEditor, setComposerEditor] = useState<LexicalEditor | null>(null);\n  const [isHydrating, setIsHydrating] = useState(false);\n\n  // Use note.id for existing notes, or a stable \"new\" key for drafts\n  // This forces LexicalComposer to remount when switching notes\n  const composerKey = note?.id ?? 'new-note';\n\n  const initialEditorState = useMemo(() => {\n    if (!note?.content) return null;\n    if (note.content.version === 'lexical_v1' && note.content.editorState) {\n      const state = note.content.editorState;\n      if (typeof state === 'string') return state;\n      if (state && typeof state === 'object') {\n        try {\n          return JSON.stringify(state);\n        } catch {\n          return null;\n        }\n      }\n      return null;\n    }\n    return null;\n  }, [note?.id, note?.content?.editorState]);\n\n  const initialConfig: InitialConfigType = useMemo(() => {\n    const baseConfig: InitialConfigType = {\n      namespace: 'LockInNoteEditor',\n      theme: noteEditorTheme,\n      editable: true,\n      onError(error: Error) {\n        console.error('Lexical editor error', error);\n      },\n      nodes: [\n        HeadingNode,\n        ListNode,\n        ListItemNode,\n        LinkNode,\n        QuoteNode,\n        CodeNode,\n        CodeHighlightNode,\n        ImageNode,\n        AttachmentNode,\n      ],\n    };\n    if (initialEditorState) {\n      return { ...baseConfig, editorState: initialEditorState };\n    }\n    return baseConfig;\n  }, [initialEditorState]);\n\n  const statusMeta = (() => {\n    const metaOptions: {\n      status: NoteStatus;\n      updatedAt?: string | null;\n      isAssetUploading?: boolean;\n      error?: string | null;\n    } = { status };\n    if (note?.updatedAt !== undefined) {\n      metaOptions.updatedAt = note.updatedAt;\n    }\n    if (isAssetUploading !== undefined) {\n      metaOptions.isAssetUploading = isAssetUploading;\n    }\n    const combinedError = assetError || editorError;\n    if (combinedError !== undefined) {\n      metaOptions.error = combinedError;\n    }\n    return buildStatusLabel(metaOptions);\n  })();\n\n  const handleUploadClick = useCallback(() => {\n    fileInputRef.current?.click();\n  }, []);\n\n  return (\n    <div className=\"lockin-note-shell-card\">\n      <div className=\"lockin-note-shell-head\">\n        <input\n          className=\"lockin-note-title-input\"\n          value={title}\n          placeholder=\"Note title...\"\n          onChange={(e) => onTitleChange(e.target.value)}\n        />\n        <div className={`lockin-note-status is-${statusMeta.tone}`}>\n          {statusMeta.spinner ? (\n            <span className=\"lockin-inline-spinner\" aria-hidden=\"true\" />\n          ) : null}\n          <span>{statusMeta.label}</span>\n        </div>\n      </div>\n\n      <LexicalComposer key={composerKey} initialConfig={initialConfig}>\n        <NoteToolbar\n          disableAttachment={!note?.id || !onUploadFile}\n          isUploading={Boolean(isAssetUploading)}\n          {...(onUploadFile ? { onOpenFilePicker: handleUploadClick } : {})}\n        />\n\n        <div className=\"lockin-note-editor-surface\">\n          <div className=\"lockin-note-editor-scroll\">\n            <RichTextPlugin\n              contentEditable={\n                <ContentEditable\n                  className=\"lockin-note-editor-area\"\n                  data-placeholder=\"Write your note here...\"\n                />\n              }\n              placeholder={<div className=\"lockin-note-placeholder\">Write your note here...</div>}\n              ErrorBoundary={LexicalErrorBoundary}\n            />\n          </div>\n        </div>\n\n        <HistoryPlugin />\n        <ListPlugin />\n        <ReactLinkPlugin />\n        <AutoFocusPlugin />\n        <NoteContentLoader note={note} onHydrationChange={setIsHydrating} />\n        <NoteChangePlugin onChange={onContentChange} isHydrating={isHydrating} />\n        <ShortcutsPlugin {...(onSaveNow ? { onSaveNow } : {})} />\n        <CaretScrollPlugin />\n        <UploadPlugin\n          onEditorReady={setComposerEditor}\n          {...(onUploadFile ? { onUploadFile } : {})}\n        />\n        <AssetCleanupPlugin\n          noteId={note?.id}\n          isHydrating={isHydrating}\n          {...(onDeleteAsset ? { onDeleteAsset } : {})}\n        />\n      </LexicalComposer>\n\n      {assetError ? <div className=\"lockin-note-inline-error\">{assetError}</div> : null}\n\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        accept=\"*/*\"\n        style={{ display: 'none' }}\n        onChange={(event) => {\n          const file = event.target.files?.[0];\n          if (file && onUploadFile && composerEditor) {\n            void onUploadFile(file).then((asset) => {\n              if (asset) {\n                insertAssetIntoEditor(composerEditor, asset);\n              }\n            });\n          }\n          if (fileInputRef.current) {\n            fileInputRef.current.value = '';\n          }\n        }}\n      />\n    </div>\n  );\n}\n\nexport const NoteEditor = NoteEditorShell;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\NotesPanel.tsx",
    "messages": [
      {
        "ruleId": "eqeqeq",
        "severity": 1,
        "message": "Expected '!==' and instead saw '!='.",
        "line": 30,
        "column": 12,
        "nodeType": "BinaryExpression",
        "messageId": "unexpected",
        "endLine": 30,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "replaceOperator",
            "data": { "expectedOperator": "!==", "actualOperator": "!=" },
            "fix": { "range": [1246, 1248], "text": "!==" },
            "desc": "Use '!==' instead of '!='."
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'NotesPanel' has too many lines (197). Maximum allowed is 50.",
        "line": 36,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 249,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'NotesPanel' has too many statements (21). Maximum allowed is 20.",
        "line": 36,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 249,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 36,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 36,
        "endColumn": 27
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Function 'NotesPanel' has a complexity of 20. Maximum allowed is 15.",
        "line": 36,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 36,
        "endColumn": 27
      },
      {
        "ruleId": "eqeqeq",
        "severity": 1,
        "message": "Expected '!==' and instead saw '!='.",
        "line": 55,
        "column": 36,
        "nodeType": "BinaryExpression",
        "messageId": "unexpected",
        "endLine": 55,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "replaceOperator",
            "data": { "expectedOperator": "!==", "actualOperator": "!=" },
            "fix": { "range": [1849, 1851], "text": "!==" },
            "desc": "Use '!==' instead of '!='."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 87,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 87,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2674, 2678], "text": "(note != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3000.",
        "line": 101,
        "column": 8,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 101,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 114,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 114,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3307, 3322], "text": "editorActiveId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3308, 3322], "text": "(editorActiveId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3307, 3322], "text": "!Boolean(editorActiveId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 115,
        "column": 12,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 115,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [3348, 3390],
              "text": "(notes.find((n) => n.id === editorActiveId) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 145,
        "column": 16,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 145,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4063, 4074], "text": "((note?.title) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4063, 4074], "text": "((note?.title) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4063, 4074], "text": "(Boolean((note?.title)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 156,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 156,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4279, 4288], "text": "(weekLabel != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4279, 4288], "text": "(weekLabel ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4279, 4288], "text": "(Boolean(weekLabel))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 156,
        "column": 36,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 156,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4291, 4306], "text": "((note?.sourceUrl) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4291, 4306], "text": "((note?.sourceUrl) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4291, 4306], "text": "(Boolean((note?.sourceUrl)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 157,
        "column": 47,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 157,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4371, 4386], "text": "(editorActiveId == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4372, 4386], "text": "(editorActiveId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4371, 4386], "text": "(!Boolean(editorActiveId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 159,
        "column": 45,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 159,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 182,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 182,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5062, 5073], "text": "(deleteError != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5062, 5073], "text": "(deleteError ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5062, 5073], "text": "(Boolean(deleteError))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 196,
        "column": 20,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 196,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5475, 5486], "text": "((note?.title) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5475, 5486], "text": "((note?.title) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5475, 5486], "text": "(Boolean((note?.title)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 1,
        "message": "Promise-returning function provided to attribute where a void return was expected.",
        "line": 199,
        "column": 23,
        "nodeType": "JSXExpressionContainer",
        "messageId": "voidReturnAttribute",
        "endLine": 199,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 1,
        "message": "Promise-returning function provided to attribute where a void return was expected.",
        "line": 219,
        "column": 26,
        "nodeType": "JSXExpressionContainer",
        "messageId": "voidReturnAttribute",
        "endLine": 219,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 1,
        "message": "Promise-returning function provided to attribute where a void return was expected.",
        "line": 230,
        "column": 19,
        "nodeType": "JSXExpressionContainer",
        "messageId": "voidReturnAttribute",
        "endLine": 230,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 239,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 239,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6880, 6885], "text": "(toast != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 21,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useMemo, useRef, useState } from 'react';\nimport type { Note } from '@core/domain/Note';\nimport type { NotesService } from '@core/services/notesService';\nimport { ConfirmDialog, Toast, useToast } from '@shared/ui/components';\nimport { useNoteAssets } from '../../hooks/useNoteAssets';\nimport { useNoteEditor } from '../../hooks/useNoteEditor';\nimport { NoteEditor } from './NoteEditor';\nimport { NotesListView } from './panel/NotesListView';\nimport { NotesPanelHeader } from './panel/NotesPanelHeader';\nimport { filterNotes } from './panel/noteFilters';\nimport { useNotesPanelActions } from './panel/useNotesPanelActions';\n\ninterface NotesPanelProps {\n  notesService: NotesService | null | undefined;\n  notes: Note[];\n  notesLoading: boolean;\n  onRefreshNotes: () => void;\n  onNoteSaved: (note: Note) => void;\n  onDeleteNote: (noteId: string) => Promise<void>;\n  onToggleStar: (noteId: string) => Promise<Note | undefined>;\n  activeNoteId: string | null;\n  onSelectNote: (noteId: string | null) => void;\n  courseCode: string | null;\n  pageUrl: string;\n  currentWeek?: number | null;\n  onNoteEditingChange?: (editing: boolean) => void;\n}\n\nfunction formatLinkedLabel(week: number | null | undefined): string | null {\n  if (week != null && week > 0) {\n    return `Week ${week}`;\n  }\n  return null;\n}\n\nexport function NotesPanel({\n  notesService,\n  notes,\n  notesLoading,\n  onRefreshNotes,\n  onNoteSaved,\n  onDeleteNote,\n  onToggleStar,\n  activeNoteId,\n  onSelectNote,\n  courseCode,\n  pageUrl,\n  currentWeek,\n  onNoteEditingChange,\n}: NotesPanelProps) {\n  const [view, setView] = useState<'current' | 'all'>('current');\n  const [filter, setFilter] = useState<'course' | 'all' | 'starred'>('course');\n  const [search, setSearch] = useState('');\n  const { toast, showToast, hideToast } = useToast();\n  const hasValidWeek = currentWeek != null && currentWeek > 0;\n  const effectiveSourceUrl = hasValidWeek ? pageUrl : null;\n\n  const {\n    note,\n    status,\n    error: editorError,\n    activeNoteId: editorActiveId,\n    handleContentChange,\n    handleTitleChange,\n    saveNow,\n    resetToNew,\n  } = useNoteEditor({\n    noteId: activeNoteId,\n    notesService,\n    defaultCourseCode: courseCode,\n    defaultSourceUrl: effectiveSourceUrl,\n  });\n\n  const prevEditorActiveIdRef = useRef(editorActiveId);\n  useEffect(() => {\n    if (\n      editorActiveId !== prevEditorActiveIdRef.current &&\n      editorActiveId !== activeNoteId &&\n      editorActiveId !== null\n    ) {\n      onSelectNote(editorActiveId);\n    }\n    prevEditorActiveIdRef.current = editorActiveId;\n  }, [editorActiveId, activeNoteId, onSelectNote]);\n\n  useEffect(() => {\n    if (status === 'saved' && note) {\n      onNoteSaved(note);\n    }\n  }, [note, onNoteSaved, status]);\n\n  useEffect(() => {\n    const isEditing = status === 'editing' || status === 'saving';\n    if (isEditing) {\n      onNoteEditingChange?.(true);\n      return;\n    }\n\n    const timeout = window.setTimeout(() => {\n      onNoteEditingChange?.(false);\n    }, 3000);\n\n    return () => window.clearTimeout(timeout);\n  }, [onNoteEditingChange, status]);\n\n  const {\n    isUploading: isAssetUploading,\n    error: noteAssetError,\n    uploadAsset,\n    deleteAsset,\n  } = useNoteAssets(editorActiveId, notesService);\n\n  const currentNoteFromList = useMemo(() => {\n    if (!editorActiveId) return null;\n    return notes.find((n) => n.id === editorActiveId) || null;\n  }, [editorActiveId, notes]);\n\n  const isCurrentNoteStarred = currentNoteFromList?.isStarred ?? note?.isStarred ?? false;\n  const filteredNotes = useMemo(\n    () =>\n      filterNotes({\n        notes,\n        courseCode,\n        filter,\n        search,\n      }),\n    [courseCode, filter, notes, search],\n  );\n  const {\n    deleteConfirmId,\n    noteToDeleteTitle,\n    deleteError,\n    isDeleting,\n    openDeleteConfirm,\n    closeDeleteConfirm,\n    executeDelete,\n    handleToggleStar,\n    handleHeaderToggleStar,\n    handleHeaderDelete,\n    handleNewNote,\n    handleSelectNote,\n    clearDeleteError,\n  } = useNotesPanelActions({\n    editorActiveId,\n    noteTitle: note?.title || '',\n    onDeleteNote,\n    onToggleStar,\n    onNoteSaved,\n    onSelectNote,\n    resetToNew,\n    showToast,\n    setView,\n  });\n\n  const weekLabel = formatLinkedLabel(currentWeek);\n  const linkedTarget = weekLabel ? note?.sourceUrl || pageUrl : null;\n  const showActions = view === 'current' && !!editorActiveId;\n\n  const handleExportError = (error: string) => {\n    showToast(error, 'error');\n  };\n\n  return (\n    <div className=\"lockin-notes-panel\">\n      <NotesPanelHeader\n        courseCode={courseCode}\n        weekLabel={weekLabel}\n        linkedTarget={linkedTarget}\n        view={view}\n        onViewChange={setView}\n        showActions={showActions}\n        isStarred={isCurrentNoteStarred}\n        isDeleting={isDeleting === editorActiveId}\n        onToggleStar={handleHeaderToggleStar}\n        onDeleteNote={handleHeaderDelete}\n        onNewNote={handleNewNote}\n        note={note}\n        week={currentWeek ?? null}\n        onExportError={handleExportError}\n      />\n\n      {deleteError && (\n        <div className=\"lockin-notes-error\">\n          {deleteError}\n          <button type=\"button\" className=\"lockin-notes-error-dismiss\" onClick={clearDeleteError}>\n            A-\n          </button>\n        </div>\n      )}\n\n      <div className=\"lockin-notes-body\">\n        {view === 'current' && (\n          <NoteEditor\n            note={note}\n            status={status}\n            title={note?.title || ''}\n            onTitleChange={handleTitleChange}\n            onContentChange={handleContentChange}\n            onSaveNow={saveNow}\n            onUploadFile={uploadAsset}\n            onDeleteAsset={deleteAsset}\n            isAssetUploading={isAssetUploading}\n            assetError={noteAssetError}\n            editorError={editorError}\n          />\n        )}\n\n        {view === 'all' && (\n          <NotesListView\n            notesLoading={notesLoading}\n            filter={filter}\n            onFilterChange={setFilter}\n            search={search}\n            onSearchChange={setSearch}\n            onRefreshNotes={onRefreshNotes}\n            filteredNotes={filteredNotes}\n            activeNoteId={editorActiveId}\n            onSelectNote={handleSelectNote}\n            onToggleStar={handleToggleStar}\n            onDeleteNote={openDeleteConfirm}\n            isDeleting={isDeleting}\n            onCreateNote={() => setView('current')}\n          />\n        )}\n      </div>\n\n      <ConfirmDialog\n        isOpen={deleteConfirmId !== null}\n        onClose={closeDeleteConfirm}\n        onConfirm={executeDelete}\n        title=\"Delete Note\"\n        description={`Are you sure you want to delete \"${noteToDeleteTitle}\"? This action cannot be undone.`}\n        confirmLabel=\"Delete\"\n        cancelLabel=\"Cancel\"\n        variant=\"danger\"\n        isLoading={isDeleting !== null}\n      />\n\n      {toast && (\n        <Toast\n          message={toast.message}\n          type={toast.type}\n          isVisible={toast.isVisible}\n          onDismiss={hideToast}\n        />\n      )}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\content.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 4,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 4,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [152, 156], "text": "(text.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [152, 156], "text": "(text !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [152, 156], "text": "(Boolean(text))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 5,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 5,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [183, 193], "text": "(normalized.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [183, 193], "text": "(normalized !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [183, 193], "text": "(Boolean(normalized))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { NoteContent } from '@core/domain/Note';\n\nexport function createNoteContentFromPlainText(text: string): NoteContent {\n  const normalized = text || '';\n  const textNode = normalized\n    ? [\n        {\n          detail: 0,\n          format: 0,\n          mode: 'normal',\n          style: '',\n          text: normalized,\n          type: 'text',\n          version: 1,\n        },\n      ]\n    : [];\n\n  return {\n    version: 'lexical_v1',\n    editorState: {\n      root: {\n        children: [\n          {\n            children: textNode,\n            direction: 'ltr',\n            format: '',\n            indent: 0,\n            type: 'paragraph',\n            version: 1,\n          },\n        ],\n        direction: 'ltr',\n        format: '',\n        indent: 0,\n        type: 'root',\n        version: 1,\n      },\n    },\n    legacyHtml: null,\n    plainText: normalized,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\editor\\NoteToolbar.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "Imports \"EditorState\" are only used as type.",
        "line": 31,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "messageId": "someImportsAreOnlyTypes",
        "endLine": 43,
        "endColumn": 18,
        "fix": {
          "range": [757, 883],
          "text": "import type {\n  EditorState} from 'lexical';\nimport {\n  $createParagraphNode,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  COMMAND_PRIORITY_LOW"
        }
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 57,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 57,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 68,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 68,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 87,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 87,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [2123, 2129], "text": "(active ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [2123, 2129], "text": "(active === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 93,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 93,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 94,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 94,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2309, 2320], "text": "(swatchColor != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2309, 2320], "text": "(swatchColor ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2309, 2320], "text": "(Boolean(swatchColor))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 110,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 110,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 133,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 133,
        "endColumn": 20
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'NoteToolbar' has too many lines (250). Maximum allowed is 50.",
        "line": 158,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 429,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 158,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 158,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 203,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 203,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [5645, 5655], "text": "(formatType.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [5645, 5655], "text": "(formatType !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5645, 5655], "text": "(Boolean(formatType))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 238,
        "column": 47,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 238,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 254,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 254,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6945, 6948], "text": "url != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6945, 6948], "text": "url ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6945, 6948], "text": "Boolean(url)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (399). Maximum allowed is 300.",
        "line": 323,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 430,
        "endColumn": 1
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 410,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 410,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [12166, 12182], "text": "(onOpenFilePicker != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 414,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 414,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [12318, 12329], "text": "(isUploading ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [12318, 12329], "text": "(isUploading === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useCallback, useEffect, useState } from 'react';\nimport { TOGGLE_LINK_COMMAND } from '@lexical/link';\nimport {\n  AlignCenter,\n  AlignLeft,\n  AlignRight,\n  Bold,\n  Braces,\n  Code,\n  Highlighter,\n  Italic,\n  Link,\n  List,\n  ListOrdered,\n  Palette,\n  Paperclip,\n  Redo2,\n  Underline,\n  Undo2,\n} from 'lucide-react';\nimport {\n  INSERT_ORDERED_LIST_COMMAND,\n  INSERT_UNORDERED_LIST_COMMAND,\n  $isListNode,\n} from '@lexical/list';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { $createHeadingNode, $isHeadingNode } from '@lexical/rich-text';\nimport { $createCodeNode } from '@lexical/code';\nimport { $patchStyleText, $setBlocksType } from '@lexical/selection';\nimport { mergeRegister } from '@lexical/utils';\nimport {\n  $createParagraphNode,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  COMMAND_PRIORITY_LOW,\n  EditorState,\n  FORMAT_ELEMENT_COMMAND,\n  FORMAT_TEXT_COMMAND,\n  REDO_COMMAND,\n  SELECTION_CHANGE_COMMAND,\n  UNDO_COMMAND,\n} from 'lexical';\n\ntype BlockType = 'paragraph' | 'h1' | 'h2' | 'h3';\n\nconst BLOCK_OPTIONS: Array<{ value: BlockType; label: string }> = [\n  { value: 'paragraph', label: 'Paragraph' },\n  { value: 'h1', label: 'Heading 1' },\n  { value: 'h2', label: 'Heading 2' },\n  { value: 'h3', label: 'Heading 3' },\n];\n\nconst TEXT_COLORS = ['#111827', '#334155', '#2563eb', '#7c3aed', '#dc2626', '#059669', '#f59e0b'];\nconst HIGHLIGHT_COLORS = ['#fef3c7', '#e0f2fe', '#f3e8ff', '#dcfce7', '#fee2e2', 'transparent'];\n\nfunction Tooltip({ text, children }: { text: string; children: React.ReactNode }) {\n  return (\n    <span className=\"lockin-tooltip-wrapper\">\n      {children}\n      <span className=\"lockin-tooltip\" role=\"tooltip\">\n        {text}\n      </span>\n    </span>\n  );\n}\n\nfunction ToolbarButton({\n  label,\n  onClick,\n  active,\n  disabled,\n  children,\n  swatchColor,\n}: {\n  label: string;\n  onClick?: () => void;\n  active?: boolean;\n  disabled?: boolean;\n  children?: React.ReactNode;\n  swatchColor?: string | null;\n}) {\n  return (\n    <Tooltip text={label}>\n      <button\n        type=\"button\"\n        className={`lockin-note-tool-btn${active ? ' is-active' : ''}`}\n        aria-pressed={active}\n        aria-label={label}\n        disabled={disabled}\n        onClick={onClick}\n      >\n        {children || label}\n        {swatchColor && (\n          <span\n            className=\"lockin-tool-swatch\"\n            style={{\n              background:\n                swatchColor === 'transparent'\n                  ? 'linear-gradient(135deg, #fff 45%, #f00 50%, #fff 55%)'\n                  : swatchColor,\n            }}\n          />\n        )}\n      </button>\n    </Tooltip>\n  );\n}\n\nfunction BlockTypeSelect({\n  value,\n  onChange,\n}: {\n  value: BlockType;\n  onChange: (next: BlockType) => void;\n}) {\n  return (\n    <select\n      className=\"lockin-note-block-select\"\n      value={value}\n      onChange={(event) => onChange(event.target.value as BlockType)}\n      aria-label=\"Block type\"\n    >\n      {BLOCK_OPTIONS.map((option) => (\n        <option key={option.value} value={option.value}>\n          {option.label}\n        </option>\n      ))}\n    </select>\n  );\n}\n\nfunction SwatchMenu({\n  swatches,\n  onSelect,\n  label,\n}: {\n  swatches: string[];\n  onSelect: (color: string) => void;\n  label: string;\n}) {\n  return (\n    <div className=\"lockin-note-color-menu\" role=\"listbox\" aria-label={label}>\n      {swatches.map((color) => (\n        <button\n          key={color}\n          type=\"button\"\n          className=\"lockin-color-swatch\"\n          style={{ background: color === 'transparent' ? 'white' : color }}\n          onClick={() => onSelect(color)}\n          aria-label={`${label} ${color}`}\n        />\n      ))}\n    </div>\n  );\n}\n\nexport function NoteToolbar({\n  onOpenFilePicker,\n  disableAttachment,\n  isUploading,\n}: {\n  onOpenFilePicker?: () => void;\n  disableAttachment?: boolean;\n  isUploading?: boolean;\n}) {\n  const [editor] = useLexicalComposerContext();\n  const [blockType, setBlockTypeState] = useState<BlockType>('paragraph');\n  const [selectionFormats, setSelectionFormats] = useState<Set<string>>(new Set());\n  const [alignment, setAlignment] = useState<string>('left');\n  const [showColor, setShowColor] = useState(false);\n  const [showHighlight, setShowHighlight] = useState(false);\n  const [currentTextColor, setCurrentTextColor] = useState<string>(TEXT_COLORS[0] ?? '#111827');\n  const [currentHighlight, setCurrentHighlight] = useState<string>('transparent');\n\n  const updateToolbar = useCallback(() => {\n    editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return;\n      const anchorNode = selection.anchor.getNode();\n      const element =\n        anchorNode.getKey() === 'root' ? anchorNode : anchorNode.getTopLevelElementOrThrow();\n\n      const formats = new Set<string>();\n      if (selection.hasFormat('bold')) formats.add('bold');\n      if (selection.hasFormat('italic')) formats.add('italic');\n      if (selection.hasFormat('underline')) formats.add('underline');\n      if (selection.hasFormat('code')) formats.add('code');\n      setSelectionFormats(formats);\n\n      if ($isHeadingNode(element)) {\n        setBlockTypeState(element.getTag() as BlockType);\n      } else if ($isListNode(element)) {\n        setBlockTypeState('paragraph');\n      } else {\n        const type = element.getType();\n        setBlockTypeState(type === 'paragraph' ? 'paragraph' : 'paragraph');\n      }\n\n      // Check format type for alignment - only ElementNode has getFormatType\n      if ($isElementNode(element)) {\n        const formatType = element.getFormatType();\n        setAlignment(formatType || 'left');\n      } else {\n        setAlignment('left');\n      }\n    });\n  }, [editor]);\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerUpdateListener(({ editorState }: { editorState: EditorState }) => {\n        editorState.read(() => updateToolbar());\n      }),\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        () => {\n          updateToolbar();\n          return false;\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    );\n  }, [editor, updateToolbar]);\n\n  const applyStyle = useCallback(\n    (style: Record<string, string>) => {\n      editor.update(() => {\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          $patchStyleText(selection, style);\n        }\n      });\n    },\n    [editor],\n  );\n\n  const handleBlockChange = (next: BlockType) => {\n    setBlockTypeState(next);\n    editor.update(() => {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        if (next === 'paragraph') {\n          $setBlocksType(selection, () => $createParagraphNode());\n        } else {\n          $setBlocksType(selection, () => $createHeadingNode(next));\n        }\n      }\n    });\n  };\n\n  const toggleLink = useCallback(() => {\n    const url = window.prompt('Enter URL');\n    if (url) {\n      editor.dispatchCommand(TOGGLE_LINK_COMMAND, url);\n    } else {\n      editor.dispatchCommand(TOGGLE_LINK_COMMAND, null);\n    }\n  }, [editor]);\n\n  return (\n    <div className=\"lockin-note-toolbar\">\n      <div className=\"lockin-note-toolbar-group\">\n        <BlockTypeSelect value={blockType} onChange={handleBlockChange} />\n      </div>\n\n      <div className=\"lockin-note-toolbar-divider\" />\n\n      <div className=\"lockin-note-toolbar-group\">\n        <ToolbarButton\n          label=\"Bold\"\n          active={selectionFormats.has('bold')}\n          onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'bold')}\n        >\n          <Bold size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        <ToolbarButton\n          label=\"Italic\"\n          active={selectionFormats.has('italic')}\n          onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'italic')}\n        >\n          <Italic size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        <ToolbarButton\n          label=\"Underline\"\n          active={selectionFormats.has('underline')}\n          onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'underline')}\n        >\n          <Underline size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        <ToolbarButton\n          label=\"Inline code\"\n          active={selectionFormats.has('code')}\n          onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'code')}\n        >\n          <Code size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        <ToolbarButton label=\"Link\" onClick={toggleLink}>\n          <Link size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n      </div>\n\n      <div className=\"lockin-note-toolbar-divider\" />\n\n      <div className=\"lockin-note-toolbar-group lockin-note-toolbar-menu\">\n        <ToolbarButton\n          label=\"Text color\"\n          onClick={() => setShowColor((v) => !v)}\n          swatchColor={currentTextColor}\n        >\n          <Palette size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        {showColor ? (\n          <SwatchMenu\n            label=\"Text color\"\n            swatches={TEXT_COLORS}\n            onSelect={(color) => {\n              applyStyle({ color });\n              setCurrentTextColor(color);\n              setShowColor(false);\n            }}\n          />\n        ) : null}\n        <ToolbarButton\n          label=\"Highlight\"\n          onClick={() => setShowHighlight((v) => !v)}\n          swatchColor={currentHighlight}\n        >\n          <Highlighter size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        {showHighlight ? (\n          <SwatchMenu\n            label=\"Highlight\"\n            swatches={HIGHLIGHT_COLORS}\n            onSelect={(color) => {\n              if (color === 'transparent') {\n                applyStyle({ 'background-color': 'transparent' });\n              } else {\n                applyStyle({ 'background-color': color });\n              }\n              setCurrentHighlight(color);\n              setShowHighlight(false);\n            }}\n          />\n        ) : null}\n      </div>\n\n      <div className=\"lockin-note-toolbar-divider\" />\n\n      <div className=\"lockin-note-toolbar-group\">\n        <ToolbarButton\n          label=\"Bulleted list\"\n          onClick={() => editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined)}\n        >\n          <List size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        <ToolbarButton\n          label=\"Numbered list\"\n          onClick={() => editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined)}\n        >\n          <ListOrdered size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        <ToolbarButton\n          label=\"Code block\"\n          onClick={() => {\n            editor.update(() => {\n              const selection = $getSelection();\n              if ($isRangeSelection(selection)) {\n                $setBlocksType(selection, () => $createCodeNode());\n              }\n            });\n          }}\n        >\n          <Braces size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n      </div>\n\n      <div className=\"lockin-note-toolbar-divider\" />\n\n      <div className=\"lockin-note-toolbar-group\">\n        <ToolbarButton\n          label=\"Align left\"\n          active={alignment === 'left' || alignment === 'start'}\n          onClick={() => editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, 'left')}\n        >\n          <AlignLeft size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        <ToolbarButton\n          label=\"Align center\"\n          active={alignment === 'center'}\n          onClick={() => editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, 'center')}\n        >\n          <AlignCenter size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        <ToolbarButton\n          label=\"Align right\"\n          active={alignment === 'right' || alignment === 'end'}\n          onClick={() => editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, 'right')}\n        >\n          <AlignRight size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n      </div>\n\n      <div className=\"lockin-note-toolbar-divider\" />\n\n      <div className=\"lockin-note-toolbar-group\">\n        <ToolbarButton\n          label=\"Attach file\"\n          disabled={Boolean(disableAttachment)}\n          {...(onOpenFilePicker ? { onClick: onOpenFilePicker } : {})}\n        >\n          <Paperclip size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        {isUploading ? <span className=\"lockin-inline-spinner\" aria-label=\"Uploading\" /> : null}\n      </div>\n\n      <div className=\"lockin-note-toolbar-divider\" />\n\n      <div className=\"lockin-note-toolbar-group\">\n        <ToolbarButton label=\"Undo\" onClick={() => editor.dispatchCommand(UNDO_COMMAND, undefined)}>\n          <Undo2 size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n        <ToolbarButton label=\"Redo\" onClick={() => editor.dispatchCommand(REDO_COMMAND, undefined)}>\n          <Redo2 size={16} strokeWidth={2.5} />\n        </ToolbarButton>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\editor\\buildStatusLabel.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 4,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 4,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 15,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 15,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [318, 323], "text": "error != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [318, 323], "text": "error ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [318, 323], "text": "Boolean(error)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 17,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 17,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [353, 358], "text": "(error.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [353, 358], "text": "(error !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [353, 358], "text": "(Boolean(error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 32,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 32,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [713, 729], "text": "isAssetUploading ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [713, 729], "text": "isAssetUploading === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { NoteStatus } from '@core/domain/Note';\nimport { relativeLabel } from '../utils/relativeTime';\n\nexport function buildStatusLabel({\n  status,\n  updatedAt,\n  isAssetUploading,\n  error,\n}: {\n  status: NoteStatus;\n  updatedAt?: string | null;\n  isAssetUploading?: boolean;\n  error?: string | null;\n}) {\n  if (error) {\n    return {\n      label: error || 'Error saving - retry soon',\n      tone: 'error' as const,\n      spinner: false,\n    };\n  }\n  if (status === 'error') {\n    return {\n      label: 'Error saving - retry soon',\n      tone: 'error' as const,\n      spinner: false,\n    };\n  }\n  if (status === 'saving') {\n    return { label: 'Saving...', tone: 'muted' as const, spinner: true };\n  }\n  if (isAssetUploading) {\n    return {\n      label: 'Uploading attachment...',\n      tone: 'muted' as const,\n      spinner: true,\n    };\n  }\n  if (status === 'saved') {\n    return {\n      label: `Saved ${relativeLabel(updatedAt)}`,\n      tone: 'success' as const,\n      spinner: false,\n    };\n  }\n  if (status === 'editing') {\n    return { label: 'Editing...', tone: 'muted' as const, spinner: false };\n  }\n  return { label: 'Idle', tone: 'muted' as const, spinner: false };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\editor\\insertAssetIntoEditor.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 13,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 13,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 19,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 19,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [559, 569], "text": "(selection == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 33,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 33,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1098, 1112], "text": "(containerWidth != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [1098, 1112], "text": "(containerWidth ?? 0)" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1098, 1112], "text": "(Boolean(containerWidth))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 220.",
        "line": 33,
        "column": 52,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 33,
        "endColumn": 55
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 24.",
        "line": 33,
        "column": 83,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 33,
        "endColumn": 85
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 640.",
        "line": 33,
        "column": 87,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 33,
        "endColumn": 90
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 38,
        "column": 14,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 38,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1323, 1337], "text": "(asset.fileName != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1323, 1337], "text": "(asset.fileName ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1323, 1337], "text": "(Boolean(asset.fileName))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 38,
        "column": 32,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 38,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1341, 1355], "text": "(asset.mimeType.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1341, 1355], "text": "(asset.mimeType !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1341, 1355], "text": "(Boolean(asset.mimeType))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 47,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 47,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1588, 1602], "text": "(asset.fileName != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1588, 1602], "text": "(asset.fileName ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1588, 1602], "text": "(Boolean(asset.fileName))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\n  $createParagraphNode,\n  $getRoot,\n  $getSelection,\n  $insertNodes,\n  $isRangeSelection,\n  type LexicalEditor,\n} from 'lexical';\nimport type { NoteAsset } from '@core/domain/Note';\nimport { $createAttachmentNode } from '../nodes/AttachmentNode';\nimport { $createImageNode } from '../nodes/ImageNode';\n\nexport function insertAssetIntoEditor(editor: LexicalEditor, asset: NoteAsset) {\n  editor.update(() => {\n    const selection = $getSelection();\n    const root = $getRoot();\n\n    // Ensure we have a valid selection, even in an empty editor\n    if (!selection || !$isRangeSelection(selection)) {\n      root.selectEnd();\n    }\n\n    // If root is empty, ensure we have at least one paragraph for the image to be inserted into\n    const rootChildren = root.getChildren();\n    if (rootChildren.length === 0) {\n      const paragraph = $createParagraphNode();\n      root.append(paragraph);\n      paragraph.selectEnd();\n    }\n\n    const rootElement = editor.getRootElement();\n    const containerWidth = rootElement?.parentElement?.getBoundingClientRect().width ?? null;\n    const defaultWidth = containerWidth ? Math.max(220, Math.min(containerWidth - 24, 640)) : null;\n\n    if (asset.mimeType?.startsWith('image/') || asset.type === 'image') {\n      const node = $createImageNode({\n        src: asset.url,\n        alt: asset.fileName || asset.mimeType || 'image',\n        assetId: asset.id,\n        width: defaultWidth,\n      });\n      $insertNodes([node]);\n    } else {\n      const node = $createAttachmentNode({\n        assetId: asset.id,\n        href: asset.url,\n        fileName: asset.fileName || 'attachment',\n        mimeType: asset.mimeType,\n      });\n      $insertNodes([node]);\n    }\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\editor\\noteEditorTheme.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\editor\\plugins\\AssetCleanupPlugin.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'AssetCleanupPlugin' has too many lines (66). Maximum allowed is 50.",
        "line": 8,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 79,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 8,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 8,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 22,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 22,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [760, 774], "text": "(onDeleteAsset == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 27,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 27,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [957, 964], "text": "assetId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [957, 964], "text": "assetId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [957, 964], "text": "Boolean(assetId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 33,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 33,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1176, 1183], "text": "assetId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1176, 1183], "text": "assetId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1176, 1183], "text": "Boolean(assetId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 41,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 41,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1358, 1372], "text": "onDeleteAsset == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 43,
        "column": 91,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 43,
        "endColumn": 93
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 49,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 49,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1708, 1713], "text": "node == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 52,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 52,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1828, 1835], "text": "assetId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1828, 1835], "text": "assetId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1828, 1835], "text": "Boolean(assetId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 57,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 57,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2034, 2041], "text": "assetId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2034, 2041], "text": "assetId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2034, 2041], "text": "Boolean(assetId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 64,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 64,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2275, 2282], "text": "assetId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2275, 2282], "text": "assetId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2275, 2282], "text": "Boolean(assetId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useRef } from 'react';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { mergeRegister } from '@lexical/utils';\nimport { $getNodeByKey, $nodesOfType } from 'lexical';\nimport { AttachmentNode, $isAttachmentNode } from '../../nodes/AttachmentNode';\nimport { ImageNode, $isImageNode } from '../../nodes/ImageNode';\n\nexport function AssetCleanupPlugin({\n  noteId,\n  onDeleteAsset,\n  isHydrating,\n}: {\n  noteId: string | null | undefined;\n  onDeleteAsset?: (assetId: string) => Promise<boolean>;\n  isHydrating: boolean;\n}) {\n  const [editor] = useLexicalComposerContext();\n  const assetKeyMapRef = useRef<Map<string, string>>(new Map());\n\n  useEffect(() => {\n    assetKeyMapRef.current.clear();\n    if (!onDeleteAsset || isHydrating) return;\n\n    editor.getEditorState().read(() => {\n      $nodesOfType(ImageNode).forEach((node: ImageNode) => {\n        const assetId = node.getAssetId();\n        if (assetId) {\n          assetKeyMapRef.current.set(node.getKey(), assetId);\n        }\n      });\n      $nodesOfType(AttachmentNode).forEach((node: AttachmentNode) => {\n        const assetId = node.getAssetId();\n        if (assetId) {\n          assetKeyMapRef.current.set(node.getKey(), assetId);\n        }\n      });\n    });\n  }, [editor, isHydrating, noteId, onDeleteAsset]);\n\n  useEffect(() => {\n    if (!onDeleteAsset) return;\n\n    const handleMutations = (mutations: Map<string, 'created' | 'destroyed' | 'updated'>) => {\n      if (isHydrating) return;\n      mutations.forEach((mutation, nodeKey) => {\n        if (mutation === 'created') {\n          editor.getEditorState().read(() => {\n            const node = $getNodeByKey(nodeKey);\n            if (!node) return;\n            if ($isImageNode(node)) {\n              const assetId = node.getAssetId();\n              if (assetId) {\n                assetKeyMapRef.current.set(nodeKey, assetId);\n              }\n            } else if ($isAttachmentNode(node)) {\n              const assetId = node.getAssetId();\n              if (assetId) {\n                assetKeyMapRef.current.set(nodeKey, assetId);\n              }\n            }\n          });\n        } else if (mutation === 'destroyed') {\n          const assetId = assetKeyMapRef.current.get(nodeKey);\n          if (assetId) {\n            assetKeyMapRef.current.delete(nodeKey);\n            void onDeleteAsset(assetId);\n          }\n        }\n      });\n    };\n\n    return mergeRegister(\n      editor.registerMutationListener(ImageNode, handleMutations),\n      editor.registerMutationListener(AttachmentNode, handleMutations),\n    );\n  }, [editor, isHydrating, onDeleteAsset]);\n\n  return null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\editor\\plugins\\CaretScrollPlugin.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'CaretScrollPlugin' has too many lines (96). Maximum allowed is 50.",
        "line": 15,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 157,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 15,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 15,
        "endColumn": 34
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.15.",
        "line": 16,
        "column": 14,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 16,
        "endColumn": 18
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.85.",
        "line": 17,
        "column": 17,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 17,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 24.",
        "line": 18,
        "column": 19,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 18,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 150.",
        "line": 19,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 19,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 38,
        "column": 46,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 38,
        "endColumn": 48
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (71). Maximum allowed is 50.",
        "line": 45,
        "column": 13,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 154,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (28). Maximum allowed is 20.",
        "line": 46,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 114,
        "endColumn": 6
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 46,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 46,
        "endColumn": 32
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Arrow function has a complexity of 16. Maximum allowed is 15.",
        "line": 46,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 46,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 48,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 48,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1861, 1873], "text": "rootElement == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 54,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 54,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2049, 2065], "text": "scrollContainer == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 57,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 57,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2133, 2143], "text": "(selection == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 97,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 97,
        "endColumn": 36
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 101,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 101,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 118,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 118,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 17,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useRef } from 'react';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { COMMAND_PRIORITY_LOW, KEY_DOWN_COMMAND, SELECTION_CHANGE_COMMAND } from 'lexical';\n\n/**\n * CaretScrollPlugin: Smart scrolling that keeps the caret within a \"comfort band\"\n *\n * UX principles:\n * - Wide comfort band (15%-85%) so scrolling is rare during normal editing\n * - When scrolling IS needed, scroll minimally (just bring caret slightly inside the band)\n * - Use 'auto' for small/medium moves to avoid laggy feel; 'smooth' only for big jumps\n * - Respects prefers-reduced-motion\n * - Debounced with RAF to prevent jitter\n */\nexport function CaretScrollPlugin({\n  topRatio = 0.15,\n  bottomRatio = 0.85,\n  scrollCushion = 24,\n  smoothThreshold = 150,\n}: {\n  /** Top boundary of comfort band (0-1, default 0.15 = 15% from top) */\n  topRatio?: number;\n  /** Bottom boundary of comfort band (0-1, default 0.85 = 85% from top) */\n  bottomRatio?: number;\n  /** Extra pixels to scroll past the band edge for breathing room */\n  scrollCushion?: number;\n  /** Scroll distance threshold above which to use smooth scrolling */\n  smoothThreshold?: number;\n}) {\n  const [editor] = useLexicalComposerContext();\n  const prefersReducedMotion = useRef(false);\n  const lastScrollTime = useRef(0);\n\n  // Check reduced motion preference\n  useEffect(() => {\n    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    prefersReducedMotion.current = mediaQuery.matches;\n    const handler = (e: MediaQueryListEvent) => {\n      prefersReducedMotion.current = e.matches;\n    };\n    mediaQuery.addEventListener('change', handler);\n    return () => mediaQuery.removeEventListener('change', handler);\n  }, []);\n\n  useEffect(() => {\n    const scrollToCaret = () => {\n      const rootElement = editor.getRootElement();\n      if (!rootElement) return;\n\n      // Find the scroll container\n      const scrollContainer = rootElement.closest(\n        '.lockin-note-editor-scroll',\n      ) as HTMLElement | null;\n      if (!scrollContainer) return;\n\n      const selection = window.getSelection();\n      if (!selection || selection.rangeCount === 0) return;\n\n      const range = selection.getRangeAt(0);\n      if (!range.collapsed) return; // Only scroll for caret, not text selections\n\n      // Get caret position relative to viewport\n      const caretRect = range.getBoundingClientRect();\n      const containerRect = scrollContainer.getBoundingClientRect();\n\n      // Skip if caret rect is invalid (can happen during DOM updates)\n      if (caretRect.height === 0 && caretRect.width === 0) return;\n\n      // Calculate the comfort band boundaries (in viewport coordinates)\n      const containerHeight = containerRect.height;\n      const topBand = containerRect.top + containerHeight * topRatio;\n      const bottomBand = containerRect.top + containerHeight * bottomRatio;\n\n      const caretY = caretRect.top;\n      const caretBottom = caretRect.bottom;\n\n      // Check if caret is within the comfort band\n      if (caretY >= topBand && caretBottom <= bottomBand) {\n        return; // Caret is comfortable, no scroll needed\n      }\n\n      // Calculate minimal scroll to bring caret just inside the band\n      // We add a small cushion so user sees some context\n      let scrollDelta = 0;\n\n      if (caretY < topBand) {\n        // Caret is above the band - scroll up\n        // Scroll just enough to put caret at topBand + cushion\n        scrollDelta = caretY - topBand - scrollCushion;\n      } else if (caretBottom > bottomBand) {\n        // Caret is below the band - scroll down\n        // Scroll just enough to put caret bottom at bottomBand - cushion\n        scrollDelta = caretBottom - bottomBand + scrollCushion;\n      }\n\n      // Ignore tiny scroll amounts (prevents micro-jitter)\n      if (Math.abs(scrollDelta) < 4) return;\n\n      // Throttle scrolls slightly to prevent rapid-fire during fast typing\n      const now = Date.now();\n      if (now - lastScrollTime.current < 50) return;\n      lastScrollTime.current = now;\n\n      // Determine scroll behavior:\n      // - Always 'auto' if user prefers reduced motion\n      // - 'auto' for small moves (feels snappier)\n      // - 'smooth' only for larger jumps (feels intentional)\n      const useSmooth = !prefersReducedMotion.current && Math.abs(scrollDelta) > smoothThreshold;\n\n      scrollContainer.scrollBy({\n        top: scrollDelta,\n        behavior: useSmooth ? 'smooth' : 'auto',\n      });\n    };\n\n    // Debounce with RAF to batch updates within a frame\n    let rafId: number | null = null;\n    const debouncedScroll = () => {\n      if (rafId !== null) return; // Already scheduled\n      rafId = requestAnimationFrame(() => {\n        rafId = null;\n        scrollToCaret();\n      });\n    };\n\n    // Listen for selection changes (clicks, arrow keys, etc.)\n    const unregister = editor.registerCommand(\n      SELECTION_CHANGE_COMMAND,\n      () => {\n        debouncedScroll();\n        return false;\n      },\n      COMMAND_PRIORITY_LOW,\n    );\n\n    // Handle keyboard input - check scroll after keystroke is processed\n    const unregisterKey = editor.registerCommand(\n      KEY_DOWN_COMMAND,\n      () => {\n        // Use setTimeout to check after the DOM update from the keystroke\n        window.setTimeout(debouncedScroll, 0);\n        return false;\n      },\n      COMMAND_PRIORITY_LOW,\n    );\n\n    return () => {\n      unregister();\n      unregisterKey();\n      if (rafId !== null) {\n        cancelAnimationFrame(rafId);\n      }\n    };\n  }, [editor, topRatio, bottomRatio, scrollCushion, smoothThreshold]);\n\n  return null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\editor\\plugins\\NoteChangePlugin.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 6,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 6,
        "endColumn": 33
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useRef } from 'react';\nimport { OnChangePlugin } from '@lexical/react/LexicalOnChangePlugin';\nimport { $getRoot, type EditorState } from 'lexical';\nimport type { NoteContent } from '@core/domain/Note';\n\nexport function NoteChangePlugin({\n  onChange,\n  isHydrating,\n}: {\n  onChange: (content: NoteContent) => void;\n  isHydrating: boolean;\n}) {\n  const isFirstChangeRef = useRef(true);\n\n  // Reset on mount (when editor remounts for a new note)\n  useEffect(() => {\n    isFirstChangeRef.current = true;\n  }, []);\n\n  return (\n    <OnChangePlugin\n      ignoreSelectionChange={true}\n      onChange={(editorState: EditorState) => {\n        // Skip the initial change event that fires when the editor first loads\n        // and skip changes during hydration to prevent save loops\n        if (isFirstChangeRef.current) {\n          isFirstChangeRef.current = false;\n          if (isHydrating) {\n            return;\n          }\n        }\n        if (isHydrating) {\n          return;\n        }\n        const plainText = editorState.read(() => $getRoot().getTextContent());\n        onChange({\n          version: 'lexical_v1',\n          editorState: editorState.toJSON(),\n          plainText,\n        });\n      }}\n    />\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\editor\\plugins\\NoteContentLoader.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 16,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 16,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 28,
        "column": 23,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 28,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 34,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 34,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1147, 1152], "text": "(note == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 34,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 34,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 42,
        "column": 45,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorAny",
        "endLine": 42,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1337, 1356], "text": "(Boolean(content.editorState))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 48,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 48,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1474, 1492], "text": "content.legacyHtml != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1474, 1492], "text": "content.legacyHtml ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1474, 1492], "text": "Boolean(content.legacyHtml)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect } from 'react';\nimport { $generateNodesFromDOM } from '@lexical/html';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { $getRoot } from 'lexical';\nimport type { Note } from '@core/domain/Note';\n\n/**\n * NoteContentLoader handles:\n * 1. Initial hydration signaling (for asset cleanup timing)\n * 2. Legacy HTML migration for old notes that don't have lexical state\n *\n * Since LexicalComposer uses a `key` based on note.id, it remounts when\n * switching notes. The initialConfig.editorState handles loading the\n * Lexical state. This plugin only needs to handle the legacy HTML case.\n */\nexport function NoteContentLoader({\n  note,\n  onHydrationChange,\n}: {\n  note: Note | null;\n  onHydrationChange?: (hydrating: boolean) => void;\n}) {\n  const [editor] = useLexicalComposerContext();\n\n  useEffect(() => {\n    onHydrationChange?.(true);\n\n    const finish = () => {\n      window.setTimeout(() => onHydrationChange?.(false), 0);\n    };\n\n    // If we have Lexical state in initialConfig, it's already loaded by LexicalComposer\n    // We only need to handle legacy HTML migration here\n    if (!note || !note.content) {\n      finish();\n      return;\n    }\n\n    const { content } = note;\n\n    // Already loaded via initialConfig.editorState\n    if (content.version === 'lexical_v1' && content.editorState) {\n      finish();\n      return;\n    }\n\n    // Legacy HTML migration: convert old HTML-only notes to Lexical\n    if (content.legacyHtml) {\n      try {\n        const parser = new DOMParser();\n        const dom = parser.parseFromString(content.legacyHtml, 'text/html');\n        const nodes = $generateNodesFromDOM(editor, dom);\n        editor.update(() => {\n          const root = $getRoot();\n          root.clear();\n          root.append(...nodes);\n        });\n      } catch {\n        // On error, just leave editor with default paragraph from initialConfig\n      }\n    }\n\n    finish();\n  }, [editor, note, onHydrationChange]);\n\n  return null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\editor\\plugins\\ShortcutsPlugin.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 5,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 5,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect } from 'react';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { COMMAND_PRIORITY_LOW, KEY_DOWN_COMMAND } from 'lexical';\n\nexport function ShortcutsPlugin({ onSaveNow }: { onSaveNow?: () => void }) {\n  const [editor] = useLexicalComposerContext();\n\n  useEffect(() => {\n    return editor.registerCommand<KeyboardEvent>(\n      KEY_DOWN_COMMAND,\n      (event: KeyboardEvent) => {\n        if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 's') {\n          event.preventDefault();\n          onSaveNow?.();\n          return true;\n        }\n        return false;\n      },\n      COMMAND_PRIORITY_LOW,\n    );\n  }, [editor, onSaveNow]);\n\n  return null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\editor\\plugins\\UploadPlugin.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 7,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 7,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 22,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 22,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [696, 709], "text": "(onUploadFile == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 22,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 22,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [713, 719], "text": "(files == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 24,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 24,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [795, 800], "text": "file == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 26,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 26,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [866, 872], "text": "asset == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 33,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 33,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [995, 1008], "text": "onUploadFile == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 34,
        "column": 58,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 34,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 41,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 41,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1288, 1294], "text": "(files == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 47,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 47,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1452, 1464], "text": "rootElement == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useEffect } from 'react';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport type { NoteAsset } from '@core/domain/Note';\nimport type { LexicalEditor } from 'lexical';\nimport { insertAssetIntoEditor } from '../insertAssetIntoEditor';\n\nexport function UploadPlugin({\n  onUploadFile,\n  onEditorReady,\n}: {\n  onUploadFile?: (file: File) => Promise<NoteAsset | null>;\n  onEditorReady?: (editor: LexicalEditor) => void;\n}) {\n  const [editor] = useLexicalComposerContext();\n\n  useEffect(() => {\n    onEditorReady?.(editor);\n  }, [editor, onEditorReady]);\n\n  const handleFiles = useCallback(\n    async (files: FileList | null) => {\n      if (!onUploadFile || !files || files.length === 0) return;\n      const file = files.item(0);\n      if (!file) return;\n      const asset = await onUploadFile(file);\n      if (!asset) return;\n      insertAssetIntoEditor(editor, asset);\n    },\n    [editor, onUploadFile],\n  );\n\n  useEffect(() => {\n    if (!onUploadFile) return;\n    const listener = (event: ClipboardEvent | DragEvent) => {\n      const files =\n        event instanceof ClipboardEvent\n          ? event.clipboardData?.files\n          : event instanceof DragEvent\n            ? event.dataTransfer?.files\n            : null;\n      if (!files || files.length === 0) return;\n      event.preventDefault();\n      void handleFiles(files);\n    };\n\n    const rootElement = editor.getRootElement();\n    if (!rootElement) return;\n    rootElement.addEventListener('paste', listener);\n    rootElement.addEventListener('drop', listener);\n    return () => {\n      rootElement.removeEventListener('paste', listener);\n      rootElement.removeEventListener('drop', listener);\n    };\n  }, [editor, handleFiles, onUploadFile]);\n\n  return null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\ExportDropdown.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 27,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 27,
        "endColumn": 23
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'ExportDropdown' has too many lines (129). Maximum allowed is 50.",
        "line": 40,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 184,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 40,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 40,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 53,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 53,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1469, 1473], "text": "(note != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 59,
        "column": 48,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 59,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 61,
        "column": 12,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 61,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [1739, 1781],
              "text": "target.closest('.lockin-export-dropdown') == null"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 74,
        "column": 45,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 74,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 87,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 87,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [2428, 2437], "text": "canExport ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [2428, 2437], "text": "canExport === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 96,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 96,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2599, 2604], "text": "(note == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 108,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 108,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2880, 2890], "text": "(note.title.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2880, 2890], "text": "(note.title !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2880, 2890], "text": "(Boolean(note.title))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 135,
        "column": 79,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 135,
        "endColumn": 88,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [3736, 3745], "text": "(canExport ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareFalse",
            "fix": { "range": [3735, 3745], "text": "(canExport === false)" },
            "desc": "Change condition to check if false (`value === false`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 137,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 137,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [3820, 3829], "text": "(canExport ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareFalse",
            "fix": { "range": [3819, 3829], "text": "canExport === false" },
            "desc": "Change condition to check if false (`value === false`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 141,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 141,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3920, 3925], "text": "(note == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 1,
        "message": "Promise-returning function provided to attribute where a void return was expected.",
        "line": 171,
        "column": 23,
        "nodeType": "JSXExpressionContainer",
        "messageId": "voidReturnAttribute",
        "endLine": 171,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 171,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 171,
        "endColumn": 29,
        "fix": { "range": [4831, 4831], "text": "async " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 15,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "/**\n * Export Dropdown Component\n *\n * A dropdown menu for selecting note export format.\n * Shows available formats with icons and triggers export on selection.\n */\n\nimport { useCallback, useEffect, useState } from 'react';\nimport { Download, FileText, FileType } from 'lucide-react';\nimport type { Note } from '@core/domain/Note';\nimport type { ExportFormat } from './types';\nimport { ExportError } from './types';\nimport { exportAndDownload, getFormatDisplayInfo, hasExportableContent } from './ExportManager';\n\ninterface ExportDropdownProps {\n  note: Note | null;\n  week: number | null;\n  disabled?: boolean;\n  onExportStart?: () => void;\n  onExportComplete?: () => void;\n  onExportError?: (error: string) => void;\n}\n\n/**\n * Returns the icon component for a given format.\n */\nfunction getFormatIcon(format: ExportFormat) {\n  switch (format) {\n    case 'pdf':\n      return <FileText size={14} />;\n    case 'markdown':\n      return <FileType size={14} />;\n    case 'text':\n      return <FileText size={14} />;\n    default:\n      return <FileText size={14} />;\n  }\n}\n\nexport function ExportDropdown({\n  note,\n  week,\n  disabled = false,\n  onExportStart,\n  onExportComplete,\n  onExportError,\n}: ExportDropdownProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [isExporting, setIsExporting] = useState(false);\n  const [exportingFormat, setExportingFormat] = useState<ExportFormat | null>(null);\n\n  const formats = getFormatDisplayInfo();\n  const canExport = note && hasExportableContent(note.content) && !disabled && !isExporting;\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleClickOutside = (e: MouseEvent) => {\n      const target = e.target as HTMLElement;\n      if (!target.closest('.lockin-export-dropdown')) {\n        setIsOpen(false);\n      }\n    };\n\n    document.addEventListener('click', handleClickOutside);\n    return () => document.removeEventListener('click', handleClickOutside);\n  }, [isOpen]);\n\n  // Close dropdown on escape\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleEscape = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        setIsOpen(false);\n      }\n    };\n\n    document.addEventListener('keydown', handleEscape);\n    return () => document.removeEventListener('keydown', handleEscape);\n  }, [isOpen]);\n\n  const handleToggle = useCallback(\n    (e: React.MouseEvent) => {\n      e.stopPropagation();\n      if (canExport) {\n        setIsOpen((prev) => !prev);\n      }\n    },\n    [canExport],\n  );\n\n  const handleExport = useCallback(\n    async (format: ExportFormat) => {\n      if (!note || isExporting) return;\n\n      setIsOpen(false);\n      setIsExporting(true);\n      setExportingFormat(format);\n      onExportStart?.();\n\n      try {\n        await exportAndDownload({\n          content: note.content,\n          format,\n          metadata: {\n            title: note.title || 'Untitled Note',\n            courseCode: note.courseCode,\n            week,\n          },\n        });\n        onExportComplete?.();\n      } catch (error) {\n        // Use user-friendly message from ExportError, or fallback to generic message\n        const message =\n          error instanceof ExportError\n            ? error.userMessage\n            : error instanceof Error\n              ? error.message\n              : 'Export failed. Please try again.';\n        onExportError?.(message);\n      } finally {\n        setIsExporting(false);\n        setExportingFormat(null);\n      }\n    },\n    [note, week, isExporting, onExportStart, onExportComplete, onExportError],\n  );\n\n  return (\n    <div className=\"lockin-export-dropdown\">\n      <button\n        type=\"button\"\n        className={`lockin-export-btn ${isExporting ? 'is-exporting' : ''} ${!canExport ? 'is-disabled' : ''}`}\n        onClick={handleToggle}\n        disabled={!canExport}\n        aria-haspopup=\"listbox\"\n        aria-expanded={isOpen}\n        title={\n          !note\n            ? 'No note to export'\n            : !hasExportableContent(note.content)\n              ? 'Note is empty'\n              : 'Export note'\n        }\n      >\n        {isExporting ? (\n          <>\n            <span className=\"lockin-inline-spinner\" aria-hidden=\"true\" />\n            <span>Exporting...</span>\n          </>\n        ) : (\n          <>\n            <Download size={14} />\n            <span>Export</span>\n            <span className=\"lockin-export-chevron\" aria-hidden=\"true\">\n              {'\\u25BC'}\n            </span>\n          </>\n        )}\n      </button>\n\n      {isOpen && (\n        <div className=\"lockin-export-menu\" role=\"listbox\">\n          {formats.map((format) => (\n            <button\n              key={format.format}\n              type=\"button\"\n              className={`lockin-export-item ${exportingFormat === format.format ? 'is-active' : ''}`}\n              onClick={() => handleExport(format.format)}\n              role=\"option\"\n              aria-selected={exportingFormat === format.format}\n            >\n              {getFormatIcon(format.format)}\n              <span className=\"lockin-export-item-label\">{format.label}</span>\n              <span className=\"lockin-export-item-ext\">.{format.extension}</span>\n            </button>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\ExportManager.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 117,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 117,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3649, 3668], "text": "metadata.courseCode != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3649, 3668], "text": "metadata.courseCode ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3649, 3668], "text": "Boolean(metadata.courseCode)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 121,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 121,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3729, 3742], "text": "metadata.week != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [3729, 3742], "text": "metadata.week ?? 0" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3729, 3742], "text": "Boolean(metadata.week)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 125,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 125,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3797, 3811], "text": "metadata.title.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3797, 3811], "text": "metadata.title !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3797, 3811], "text": "Boolean(metadata.title)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 128,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 128,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 129,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 129,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3959, 3973], "text": "truncatedTitle.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3959, 3973], "text": "truncatedTitle !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3959, 3973], "text": "Boolean(truncatedTitle)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 195,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 195,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 247,
        "column": 8,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorAny",
        "endLine": 247,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7323, 7343], "text": "(Boolean((content?.editorState)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Export Manager\n *\n * Coordinates the export process: normalizes note content, selects the\n * appropriate exporter based on format, and triggers the browser download.\n *\n * Design notes:\n * - Uses strategy pattern for format selection\n * - Decoupled from editor implementation via normalizer\n * - Easy to extend with new formats (e.g., DOCX)\n */\n\nimport type { NoteContent } from '@core/domain/Note';\nimport type {\n  Exporter,\n  ExportFormat,\n  ExportMetadata,\n  ExportResult,\n  NormalizedDocument,\n} from './types';\nimport { ExportError } from './types';\nimport { documentHasContent, normalizeEditorState } from './normalizer';\nimport { MarkdownExporter, PdfExporter, TextExporter } from './exporters';\n\n// ============================================================================\n// Exporter Registry\n// ============================================================================\n\n/**\n * Registry of available exporters by format.\n * To add a new format:\n * 1. Create a new exporter class implementing the Exporter interface\n * 2. Register it here\n */\nconst exporterRegistry: Record<ExportFormat, Exporter> = {\n  pdf: new PdfExporter(),\n  markdown: new MarkdownExporter(),\n  text: new TextExporter(),\n};\n\n/**\n * Returns display info for export formats.\n */\nexport function getFormatDisplayInfo(): Array<{\n  format: ExportFormat;\n  label: string;\n  extension: string;\n}> {\n  return [\n    { format: 'pdf', label: 'PDF Document', extension: 'pdf' },\n    { format: 'markdown', label: 'Markdown', extension: 'md' },\n    { format: 'text', label: 'Plain Text', extension: 'txt' },\n  ];\n}\n\n// ============================================================================\n// Filename Generation\n// ============================================================================\n\n/**\n * Characters that are illegal in filenames across Windows, macOS, and Linux.\n * Also includes control characters and other problematic characters.\n */\nconst ILLEGAL_FILENAME_CHARS = /[<>:\"/\\\\|?*\\x00-\\x1f]/g;\n\n/**\n * Emoji and other Unicode symbols that may cause issues in filenames.\n * Matches emoji, dingbats, symbols, and other non-letter/number Unicode.\n */\nconst EMOJI_AND_SYMBOLS =\n  /[\\u{1F000}-\\u{1FFFF}]|[\\u{2600}-\\u{26FF}]|[\\u{2700}-\\u{27BF}]|[\\u{FE00}-\\u{FE0F}]|[\\u{1F900}-\\u{1F9FF}]/gu;\n\n/**\n * Slugifies a string for use in filenames.\n * - Removes emoji and special symbols\n * - Removes illegal filename characters\n * - Converts to lowercase ASCII\n * - Replaces spaces with dashes\n * - Collapses consecutive dashes\n *\n * @param text - The text to slugify\n * @returns A filesystem-safe slug\n */\nfunction slugify(text: string): string {\n  return (\n    text\n      // Normalize Unicode to decomposed form (separate base chars from diacritics)\n      .normalize('NFD')\n      // Remove diacritical marks (accents)\n      .replace(/[\\u0300-\\u036f]/g, '')\n      // Remove emoji and symbols\n      .replace(EMOJI_AND_SYMBOLS, '')\n      // Remove illegal filename characters\n      .replace(ILLEGAL_FILENAME_CHARS, '')\n      // Convert to lowercase\n      .toLowerCase()\n      // Trim whitespace\n      .trim()\n      // Replace spaces and underscores with dashes\n      .replace(/[\\s_]+/g, '-')\n      // Remove any remaining non-alphanumeric except dashes\n      .replace(/[^a-z0-9-]/g, '')\n      // Collapse multiple dashes\n      .replace(/-+/g, '-')\n      // Trim leading/trailing dashes\n      .replace(/^-+|-+$/g, '')\n  );\n}\n\n/**\n * Generates a meaningful filename for the export.\n * Format: lock-in_<course>_<week>_<title>.<ext>\n */\nexport function generateFilename(metadata: ExportMetadata, extension: string): string {\n  const parts: string[] = ['lock-in'];\n\n  if (metadata.courseCode) {\n    parts.push(slugify(metadata.courseCode));\n  }\n\n  if (metadata.week) {\n    parts.push(`week${metadata.week}`);\n  }\n\n  if (metadata.title) {\n    const titleSlug = slugify(metadata.title);\n    // Limit title length in filename\n    const truncatedTitle = titleSlug.slice(0, 50);\n    if (truncatedTitle) {\n      parts.push(truncatedTitle);\n    }\n  }\n\n  // Fallback if no meaningful parts\n  if (parts.length === 1) {\n    parts.push('note');\n    parts.push(Date.now().toString());\n  }\n\n  return `${parts.join('_')}.${extension}`;\n}\n\n// ============================================================================\n// Download Helper\n// ============================================================================\n\n/**\n * Triggers a browser download for a blob.\n * Creates a temporary anchor element and clicks it.\n */\nexport function downloadBlob(blob: Blob, filename: string): void {\n  const url = URL.createObjectURL(blob);\n\n  try {\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = filename;\n    link.style.display = 'none';\n\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  } finally {\n    // Clean up the object URL after a short delay\n    // to ensure the download has started\n    setTimeout(() => URL.revokeObjectURL(url), 1000);\n  }\n}\n\n// ============================================================================\n// Export Manager\n// ============================================================================\n\nexport interface ExportNoteOptions {\n  content: NoteContent;\n  format: ExportFormat;\n  metadata: ExportMetadata;\n}\n\nexport interface ExportDocumentOptions {\n  document: NormalizedDocument;\n  format: ExportFormat;\n  metadata: ExportMetadata;\n}\n\n/**\n * Exports a normalized document to the specified format and returns the result.\n *\n * @throws {ExportError} If content is empty, format is unsupported, or generation fails\n */\nexport async function exportDocument(options: ExportDocumentOptions): Promise<ExportResult> {\n  const { document, format, metadata } = options;\n\n  const exporter = exporterRegistry[format];\n  if (!exporter) {\n    throw ExportError.unsupportedFormat(format);\n  }\n\n  if (!documentHasContent(document)) {\n    throw ExportError.empty();\n  }\n\n  let blob: Blob;\n  try {\n    blob = await exporter.export(document, metadata);\n  } catch (error) {\n    throw ExportError.generationFailed(format, error);\n  }\n\n  const filename = generateFilename(metadata, exporter.extension);\n\n  return {\n    blob,\n    filename,\n    mimeType: exporter.mimeType,\n  };\n}\n\n/**\n * Exports a note to the specified format and returns the result.\n * Does not trigger download - use downloadBlob for that.\n *\n * @throws {ExportError} If content is empty, format is unsupported, or generation fails\n */\nexport async function exportNote(options: ExportNoteOptions): Promise<ExportResult> {\n  const { content, format, metadata } = options;\n\n  // Normalize the editor state to intermediate AST\n  const normalizedDocument = normalizeEditorState(content.editorState);\n  return exportDocument({ document: normalizedDocument, format, metadata });\n}\n\n/**\n * Exports a note and triggers browser download.\n * This is the main entry point for the export feature.\n */\nexport async function exportAndDownload(options: ExportNoteOptions): Promise<void> {\n  const result = await exportNote(options);\n  downloadBlob(result.blob, result.filename);\n}\n\n/**\n * Checks if a note has exportable content.\n * This is a lightweight check used by the UI to enable/disable export buttons.\n */\nexport function hasExportableContent(content: NoteContent | null | undefined): boolean {\n  if (!content?.editorState) return false;\n\n  const normalizedDocument = normalizeEditorState(content.editorState);\n  return documentHasContent(normalizedDocument);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\__tests__\\ExportManager.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (90). Maximum allowed is 50.",
        "line": 10,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 127,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 70,
        "column": 50,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 70,
        "endColumn": 52
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (70). Maximum allowed is 50.",
        "line": 129,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 209,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Tests for ExportManager\n */\n\nimport { describe, expect, it } from 'vitest';\nimport { generateFilename, hasExportableContent } from '../ExportManager';\nimport type { ExportMetadata } from '../types';\nimport type { NoteContent } from '@core/domain/Note';\n\ndescribe('generateFilename', () => {\n  it('generates filename with all metadata', () => {\n    const metadata: ExportMetadata = {\n      title: 'My Note Title',\n      courseCode: 'FIT1045',\n      week: 5,\n    };\n\n    const filename = generateFilename(metadata, 'pdf');\n\n    expect(filename).toBe('lock-in_fit1045_week5_my-note-title.pdf');\n  });\n\n  it('handles missing course code', () => {\n    const metadata: ExportMetadata = {\n      title: 'Test Note',\n      courseCode: null,\n      week: 3,\n    };\n\n    const filename = generateFilename(metadata, 'md');\n\n    expect(filename).toBe('lock-in_week3_test-note.md');\n  });\n\n  it('handles missing week', () => {\n    const metadata: ExportMetadata = {\n      title: 'Test Note',\n      courseCode: 'ABC123',\n      week: null,\n    };\n\n    const filename = generateFilename(metadata, 'txt');\n\n    expect(filename).toBe('lock-in_abc123_test-note.txt');\n  });\n\n  it('handles empty metadata with timestamp fallback', () => {\n    const metadata: ExportMetadata = {\n      title: '',\n      courseCode: null,\n      week: null,\n    };\n\n    const filename = generateFilename(metadata, 'pdf');\n\n    // Should have fallback format: lock-in_note_<timestamp>.pdf\n    expect(filename).toMatch(/^lock-in_note_\\d+\\.pdf$/);\n  });\n\n  it('truncates long titles to 50 characters', () => {\n    const metadata: ExportMetadata = {\n      title: 'This is a very long note title that exceeds fifty characters and should be truncated',\n      courseCode: null,\n      week: null,\n    };\n\n    const filename = generateFilename(metadata, 'md');\n    const titlePart = filename.replace('lock-in_', '').replace('.md', '');\n\n    expect(titlePart.length).toBeLessThanOrEqual(50);\n  });\n\n  it('removes emoji from titles', () => {\n    const metadata: ExportMetadata = {\n      title: ' Study Notes ',\n      courseCode: null,\n      week: null,\n    };\n\n    const filename = generateFilename(metadata, 'pdf');\n\n    expect(filename).not.toContain('');\n    expect(filename).not.toContain('');\n    expect(filename).toContain('study-notes');\n  });\n\n  it('handles unicode accented characters', () => {\n    const metadata: ExportMetadata = {\n      title: 'Caf rsum nave',\n      courseCode: null,\n      week: null,\n    };\n\n    const filename = generateFilename(metadata, 'txt');\n\n    // Should normalize to ASCII\n    expect(filename).toContain('cafe-resume-naive');\n  });\n\n  it('removes illegal filename characters', () => {\n    const metadata: ExportMetadata = {\n      title: 'Note: \"Important\" <stuff>',\n      courseCode: null,\n      week: null,\n    };\n\n    const filename = generateFilename(metadata, 'pdf');\n\n    expect(filename).not.toContain(':');\n    expect(filename).not.toContain('\"');\n    expect(filename).not.toContain('<');\n    expect(filename).not.toContain('>');\n  });\n\n  it('collapses multiple spaces and dashes', () => {\n    const metadata: ExportMetadata = {\n      title: 'Note   with    spaces',\n      courseCode: null,\n      week: null,\n    };\n\n    const filename = generateFilename(metadata, 'pdf');\n\n    expect(filename).not.toContain('--');\n    expect(filename).toContain('note-with-spaces');\n  });\n});\n\ndescribe('hasExportableContent', () => {\n  it('returns false for null content', () => {\n    expect(hasExportableContent(null)).toBe(false);\n  });\n\n  it('returns false for undefined content', () => {\n    expect(hasExportableContent(undefined)).toBe(false);\n  });\n\n  it('returns false for content with null editorState', () => {\n    const content: NoteContent = {\n      version: 'lexical_v1',\n      editorState: null,\n    };\n\n    expect(hasExportableContent(content)).toBe(false);\n  });\n\n  it('returns false for empty editor state', () => {\n    const content: NoteContent = {\n      version: 'lexical_v1',\n      editorState: { root: { children: [] } },\n    };\n\n    expect(hasExportableContent(content)).toBe(false);\n  });\n\n  it('returns true for content with text', () => {\n    const content: NoteContent = {\n      version: 'lexical_v1',\n      editorState: {\n        root: {\n          children: [\n            {\n              type: 'paragraph',\n              children: [{ type: 'text', text: 'Hello world', format: 0 }],\n            },\n          ],\n        },\n      },\n    };\n\n    expect(hasExportableContent(content)).toBe(true);\n  });\n\n  it('returns false for whitespace-only content', () => {\n    const content: NoteContent = {\n      version: 'lexical_v1',\n      editorState: {\n        root: {\n          children: [\n            {\n              type: 'paragraph',\n              children: [{ type: 'text', text: '   \\n  ', format: 0 }],\n            },\n          ],\n        },\n      },\n    };\n\n    expect(hasExportableContent(content)).toBe(false);\n  });\n\n  it('returns true for code blocks with content', () => {\n    const content: NoteContent = {\n      version: 'lexical_v1',\n      editorState: {\n        root: {\n          children: [\n            {\n              type: 'code',\n              children: [{ type: 'text', text: 'const x = 1;', format: 0 }],\n            },\n          ],\n        },\n      },\n    };\n\n    expect(hasExportableContent(content)).toBe(true);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\__tests__\\exporters.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (165). Maximum allowed is 50.",
        "line": 48,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 255,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (118). Maximum allowed is 50.",
        "line": 257,
        "column": 26,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 404,
        "endColumn": 2
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 402,
        "column": 39,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 402,
        "endColumn": 41
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Tests for Markdown and Text exporters\n */\n\nimport { describe, expect, it } from 'vitest';\nimport { MarkdownExporter } from '../exporters/MarkdownExporter';\nimport { TextExporter } from '../exporters/TextExporter';\nimport type { NormalizedDocument, ExportMetadata } from '../types';\nimport { AST_VERSION } from '../types';\n\n/**\n * Helper to read Blob content as text.\n * Works in both Node.js and browser environments.\n */\nasync function blobToText(blob: Blob): Promise<string> {\n  // Try the standard text() method first (browser)\n  if (typeof blob.text === 'function') {\n    return blob.text();\n  }\n  // Fallback for Node.js environments where Blob.text() might not exist\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.onerror = reject;\n    reader.readAsText(blob);\n  });\n}\n\n/**\n * Creates a NormalizedDocument with the correct version.\n */\nfunction makeDoc(blocks: NormalizedDocument['blocks']): NormalizedDocument {\n  return { version: AST_VERSION, blocks };\n}\n\nconst metadata: ExportMetadata = {\n  title: 'Test Note',\n  courseCode: 'FIT1045',\n  week: 3,\n};\n\nconst emptyMetadata: ExportMetadata = {\n  title: '',\n  courseCode: null,\n  week: null,\n};\n\ndescribe('MarkdownExporter', () => {\n  const exporter = new MarkdownExporter();\n\n  it('has correct format properties', () => {\n    expect(exporter.format).toBe('markdown');\n    expect(exporter.extension).toBe('md');\n    expect(exporter.mimeType).toBe('text/markdown');\n  });\n\n  it('exports a simple document with title and metadata', async () => {\n    const doc = makeDoc([\n      { type: 'paragraph', children: [{ type: 'text', text: 'Hello world', format: {} }] },\n    ]);\n\n    const blob = await exporter.export(doc, metadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('# Test Note');\n    expect(text).toContain('**Course:** FIT1045');\n    expect(text).toContain('**Week:** 3');\n    expect(text).toContain('Hello world');\n  });\n\n  it('exports headings with correct markdown syntax', async () => {\n    const doc = makeDoc([\n      { type: 'heading', level: 1, children: [{ type: 'text', text: 'Main Title', format: {} }] },\n      { type: 'heading', level: 2, children: [{ type: 'text', text: 'Subtitle', format: {} }] },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    // Level 1 heading becomes ## (offset by 1 since title uses #)\n    expect(text).toContain('## Main Title');\n    expect(text).toContain('### Subtitle');\n  });\n\n  it('exports formatted text with markdown syntax', async () => {\n    const doc = makeDoc([\n      {\n        type: 'paragraph',\n        children: [\n          { type: 'text', text: 'bold text', format: { bold: true } },\n          { type: 'text', text: ' ', format: {} },\n          { type: 'text', text: 'italic text', format: { italic: true } },\n          { type: 'text', text: ' ', format: {} },\n          { type: 'text', text: 'both', format: { bold: true, italic: true } },\n        ],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('**bold text**');\n    expect(text).toContain('*italic text*');\n    expect(text).toContain('***both***');\n  });\n\n  it('exports strikethrough text', async () => {\n    const doc = makeDoc([\n      {\n        type: 'paragraph',\n        children: [{ type: 'text', text: 'deleted', format: { strikethrough: true } }],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('~~deleted~~');\n  });\n\n  it('exports code inline with backticks', async () => {\n    const doc = makeDoc([\n      {\n        type: 'paragraph',\n        children: [\n          { type: 'text', text: 'Use ', format: {} },\n          { type: 'text', text: 'console.log()', format: { code: true } },\n          { type: 'text', text: ' to debug', format: {} },\n        ],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('`console.log()`');\n  });\n\n  it('exports unordered lists', async () => {\n    const doc = makeDoc([\n      {\n        type: 'list',\n        ordered: false,\n        children: [\n          { type: 'listItem', children: [{ type: 'text', text: 'First item', format: {} }] },\n          { type: 'listItem', children: [{ type: 'text', text: 'Second item', format: {} }] },\n        ],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('- First item');\n    expect(text).toContain('- Second item');\n  });\n\n  it('exports ordered lists', async () => {\n    const doc = makeDoc([\n      {\n        type: 'list',\n        ordered: true,\n        children: [\n          { type: 'listItem', children: [{ type: 'text', text: 'First', format: {} }] },\n          { type: 'listItem', children: [{ type: 'text', text: 'Second', format: {} }] },\n        ],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('1. First');\n    expect(text).toContain('2. Second');\n  });\n\n  it('exports blockquotes', async () => {\n    const doc = makeDoc([\n      { type: 'quote', children: [{ type: 'text', text: 'Famous quote', format: {} }] },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('> Famous quote');\n  });\n\n  it('exports code blocks with language', async () => {\n    const doc = makeDoc([{ type: 'code', language: 'python', code: 'print(\"hello\")' }]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('```python');\n    expect(text).toContain('print(\"hello\")');\n    expect(text).toContain('```');\n  });\n\n  it('exports code blocks without language', async () => {\n    const doc = makeDoc([{ type: 'code', code: 'some code' }]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('```\\n');\n    expect(text).toContain('some code');\n  });\n\n  it('exports links with markdown syntax', async () => {\n    const doc = makeDoc([\n      {\n        type: 'paragraph',\n        children: [\n          {\n            type: 'link',\n            url: 'https://example.com',\n            children: [{ type: 'text', text: 'Example', format: {} }],\n          },\n        ],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('[Example](https://example.com)');\n  });\n\n  it('escapes special markdown characters in text', async () => {\n    const doc = makeDoc([\n      {\n        type: 'paragraph',\n        children: [{ type: 'text', text: 'Use *asterisks* and [brackets]', format: {} }],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    // Should escape special characters\n    expect(text).toContain('\\\\*asterisks\\\\*');\n    expect(text).toContain('\\\\[brackets\\\\]');\n  });\n\n  it('handles empty document gracefully', async () => {\n    const doc = makeDoc([]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    // Should produce valid (minimal) output\n    expect(text).toBeDefined();\n    expect(text.length).toBeGreaterThanOrEqual(0);\n  });\n});\n\ndescribe('TextExporter', () => {\n  const exporter = new TextExporter();\n\n  it('has correct format properties', () => {\n    expect(exporter.format).toBe('text');\n    expect(exporter.extension).toBe('txt');\n    expect(exporter.mimeType).toBe('text/plain');\n  });\n\n  it('exports a simple document with title and metadata', async () => {\n    const doc = makeDoc([\n      { type: 'paragraph', children: [{ type: 'text', text: 'Hello world', format: {} }] },\n    ]);\n\n    const blob = await exporter.export(doc, metadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('Test Note');\n    expect(text).toContain('='); // Title underline\n    expect(text).toContain('Course: FIT1045');\n    expect(text).toContain('Week: 3');\n    expect(text).toContain('Hello world');\n  });\n\n  it('exports headings in uppercase with underline', async () => {\n    const doc = makeDoc([\n      {\n        type: 'heading',\n        level: 1,\n        children: [{ type: 'text', text: 'Section Title', format: {} }],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('SECTION TITLE');\n    expect(text).toContain('-'); // Heading underline\n  });\n\n  it('strips formatting from text', async () => {\n    const doc = makeDoc([\n      {\n        type: 'paragraph',\n        children: [\n          { type: 'text', text: 'bold', format: { bold: true } },\n          { type: 'text', text: ' and ', format: {} },\n          { type: 'text', text: 'italic', format: { italic: true } },\n        ],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    // Should not contain markdown formatting\n    expect(text).not.toContain('**');\n    expect(text).not.toContain('*');\n    expect(text).toContain('bold and italic');\n  });\n\n  it('exports lists with bullet points or numbers', async () => {\n    const doc = makeDoc([\n      {\n        type: 'list',\n        ordered: false,\n        children: [\n          { type: 'listItem', children: [{ type: 'text', text: 'Bullet item', format: {} }] },\n        ],\n      },\n      {\n        type: 'list',\n        ordered: true,\n        children: [\n          { type: 'listItem', children: [{ type: 'text', text: 'Numbered item', format: {} }] },\n        ],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('* Bullet item');\n    expect(text).toContain('1. Numbered item');\n  });\n\n  it('exports quotes with indentation', async () => {\n    const doc = makeDoc([\n      { type: 'quote', children: [{ type: 'text', text: 'Quoted text', format: {} }] },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('\"Quoted text\"');\n  });\n\n  it('exports code blocks with separators', async () => {\n    const doc = makeDoc([{ type: 'code', code: 'const x = 1;' }]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('---');\n    expect(text).toContain('const x = 1;');\n  });\n\n  it('includes link URLs in parentheses', async () => {\n    const doc = makeDoc([\n      {\n        type: 'paragraph',\n        children: [\n          {\n            type: 'link',\n            url: 'https://example.com',\n            children: [{ type: 'text', text: 'Example', format: {} }],\n          },\n        ],\n      },\n    ]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toContain('Example (https://example.com)');\n  });\n\n  it('handles empty document gracefully', async () => {\n    const doc = makeDoc([]);\n\n    const blob = await exporter.export(doc, emptyMetadata);\n    const text = await blobToText(blob);\n\n    expect(text).toBeDefined();\n  });\n\n  it('handles long titles with truncated underline', async () => {\n    const longTitle = 'This is a very long title that exceeds sixty characters in total length';\n    const doc = makeDoc([]);\n\n    const blob = await exporter.export(doc, { ...emptyMetadata, title: longTitle });\n    const text = await blobToText(blob);\n\n    expect(text).toContain(longTitle);\n    // Underline should be capped at 60 characters\n    expect(text).toContain('='.repeat(60));\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\__tests__\\normalizer.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (494). Maximum allowed is 50.",
        "line": 15,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 573,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (22). Maximum allowed is 20.",
        "line": 15,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 573,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 120,
        "column": 44,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 120,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 204,
        "column": 44,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 204,
        "endColumn": 70
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 223,
        "column": 40,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 223,
        "endColumn": 41
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 226,
        "column": 59,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 226,
        "endColumn": 60
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (54). Maximum allowed is 50.",
        "line": 260,
        "column": 87,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 318,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 305,
        "column": 38,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 305,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 349,
        "column": 38,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 349,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 394,
        "column": 38,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 394,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 426,
        "column": 39,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 426,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 460,
        "column": 38,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 460,
        "endColumn": 66
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (57). Maximum allowed is 50.",
        "line": 675,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 739,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Tests for the Lexical-to-AST normalizer\n */\n\nimport { describe, expect, it } from 'vitest';\nimport {\n  normalizeEditorState,\n  extractPlainText,\n  flattenInlineContent,\n  documentHasContent,\n} from '../normalizer';\nimport { AST_VERSION } from '../types';\nimport type { NormalizedDocument, InlineContent, ParagraphBlock, HeadingBlock } from '../types';\n\ndescribe('normalizeEditorState', () => {\n  it('returns empty document with version for null/undefined input', () => {\n    expect(normalizeEditorState(null)).toEqual({ version: AST_VERSION, blocks: [] });\n    expect(normalizeEditorState(undefined)).toEqual({ version: AST_VERSION, blocks: [] });\n  });\n\n  it('returns empty document for invalid JSON string', () => {\n    expect(normalizeEditorState('not valid json')).toEqual({ version: AST_VERSION, blocks: [] });\n  });\n\n  it('returns empty document for empty root', () => {\n    expect(normalizeEditorState({ root: { children: [] } })).toEqual({\n      version: AST_VERSION,\n      blocks: [],\n    });\n  });\n\n  it('includes version in output', () => {\n    const state = {\n      root: {\n        children: [{ type: 'paragraph', children: [{ type: 'text', text: 'Hello', format: 0 }] }],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n    expect(result.version).toBe(AST_VERSION);\n  });\n\n  it('normalizes a simple paragraph', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'paragraph',\n            children: [{ type: 'text', text: 'Hello world', format: 0 }],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n    const paragraph = result.blocks[0] as ParagraphBlock;\n\n    expect(result.blocks).toHaveLength(1);\n    expect(paragraph.type).toBe('paragraph');\n    expect(paragraph.children).toHaveLength(1);\n    expect(paragraph.children[0]).toEqual({\n      type: 'text',\n      text: 'Hello world',\n      format: {},\n    });\n  });\n\n  it('parses text formatting correctly', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'paragraph',\n            children: [\n              { type: 'text', text: 'bold', format: 1 },\n              { type: 'text', text: 'italic', format: 2 },\n              { type: 'text', text: 'bold+italic', format: 3 },\n              { type: 'text', text: 'underline', format: 8 },\n              { type: 'text', text: 'code', format: 16 },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n    const paragraph = result.blocks[0] as ParagraphBlock;\n    const children = paragraph.children;\n\n    expect(children[0]).toMatchObject({ type: 'text', format: { bold: true } });\n    expect(children[1]).toMatchObject({ type: 'text', format: { italic: true } });\n    expect(children[2]).toMatchObject({ type: 'text', format: { bold: true, italic: true } });\n    expect(children[3]).toMatchObject({ type: 'text', format: { underline: true } });\n    expect(children[4]).toMatchObject({ type: 'text', format: { code: true } });\n  });\n\n  it('parses text styles (colors) from style property', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'paragraph',\n            children: [\n              { type: 'text', text: 'red text', format: 0, style: 'color: #ff0000;' },\n              { type: 'text', text: 'highlighted', format: 0, style: 'background-color: yellow;' },\n              {\n                type: 'text',\n                text: 'both',\n                format: 0,\n                style: 'color: blue; background-color: #ffff00;',\n              },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n    const paragraph = result.blocks[0] as ParagraphBlock;\n    const children = paragraph.children as import('../types').TextRun[];\n\n    expect(children[0]?.styles).toEqual({ color: '#ff0000' });\n    expect(children[1]?.styles).toEqual({ backgroundColor: 'yellow' });\n    expect(children[2]?.styles).toEqual({ color: 'blue', backgroundColor: '#ffff00' });\n  });\n\n  it('parses text alignment on paragraphs', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'paragraph',\n            format: 2,\n            children: [{ type: 'text', text: 'centered', format: 0 }],\n          },\n          { type: 'paragraph', format: 3, children: [{ type: 'text', text: 'right', format: 0 }] },\n          {\n            type: 'paragraph',\n            format: 4,\n            children: [{ type: 'text', text: 'justified', format: 0 }],\n          },\n          {\n            type: 'paragraph',\n            format: 1,\n            children: [{ type: 'text', text: 'left (explicit)', format: 0 }],\n          },\n          { type: 'paragraph', children: [{ type: 'text', text: 'left (default)', format: 0 }] },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    expect((result.blocks[0] as ParagraphBlock).alignment).toBe('center');\n    expect((result.blocks[1] as ParagraphBlock).alignment).toBe('right');\n    expect((result.blocks[2] as ParagraphBlock).alignment).toBe('justify');\n    expect((result.blocks[3] as ParagraphBlock).alignment).toBeUndefined(); // left is default, not stored\n    expect((result.blocks[4] as ParagraphBlock).alignment).toBeUndefined();\n  });\n\n  it('parses text alignment on headings', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'heading',\n            tag: 'h1',\n            format: 2,\n            children: [{ type: 'text', text: 'Centered Title', format: 0 }],\n          },\n          {\n            type: 'heading',\n            tag: 'h2',\n            format: 3,\n            children: [{ type: 'text', text: 'Right Subtitle', format: 0 }],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    expect((result.blocks[0] as HeadingBlock).alignment).toBe('center');\n    expect((result.blocks[1] as HeadingBlock).alignment).toBe('right');\n  });\n\n  it('does not include styles property when no styles present', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'paragraph',\n            children: [\n              { type: 'text', text: 'no styles', format: 1 },\n              { type: 'text', text: 'empty style', format: 0, style: '' },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n    const paragraph = result.blocks[0] as ParagraphBlock;\n    const children = paragraph.children as import('../types').TextRun[];\n\n    expect(children[0]?.styles).toBeUndefined();\n    expect(children[1]?.styles).toBeUndefined();\n  });\n\n  it('normalizes headings with correct level', () => {\n    const state = {\n      root: {\n        children: [\n          { type: 'heading', tag: 'h1', children: [{ type: 'text', text: 'Title', format: 0 }] },\n          { type: 'heading', tag: 'h2', children: [{ type: 'text', text: 'Subtitle', format: 0 }] },\n          { type: 'heading', tag: 'h3', children: [{ type: 'text', text: 'Section', format: 0 }] },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    expect(result.blocks).toHaveLength(3);\n    expect((result.blocks[0] as HeadingBlock).level).toBe(1);\n    expect((result.blocks[1] as HeadingBlock).level).toBe(2);\n    expect((result.blocks[2] as HeadingBlock).level).toBe(3);\n  });\n\n  it('normalizes ordered and unordered lists', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'list',\n            listType: 'bullet',\n            children: [\n              { type: 'listitem', children: [{ type: 'text', text: 'Item 1', format: 0 }] },\n              { type: 'listitem', children: [{ type: 'text', text: 'Item 2', format: 0 }] },\n            ],\n          },\n          {\n            type: 'list',\n            listType: 'number',\n            children: [\n              { type: 'listitem', children: [{ type: 'text', text: 'First', format: 0 }] },\n              { type: 'listitem', children: [{ type: 'text', text: 'Second', format: 0 }] },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    expect(result.blocks).toHaveLength(2);\n    expect(result.blocks[0]).toMatchObject({ type: 'list', ordered: false });\n    expect(result.blocks[1]).toMatchObject({ type: 'list', ordered: true });\n  });\n\n  it('normalizes list items with nested paragraph children (real Lexical structure)', () => {\n    // This is the actual structure Lexical produces when list items contain\n    // formatted text or were created in certain ways\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'list',\n            listType: 'bullet',\n            children: [\n              {\n                type: 'listitem',\n                children: [\n                  {\n                    type: 'paragraph',\n                    children: [\n                      {\n                        type: 'text',\n                        text: 'Describe the building blocks of a computer system',\n                        format: 0,\n                      },\n                    ],\n                  },\n                ],\n              },\n              {\n                type: 'listitem',\n                children: [\n                  {\n                    type: 'paragraph',\n                    children: [\n                      { type: 'text', text: 'Understand various terminologies', format: 0 },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    expect(result.blocks).toHaveLength(1);\n    const list = result.blocks[0] as import('../types').ListBlock;\n    expect(list.type).toBe('list');\n    expect(list.children).toHaveLength(2);\n    // Should extract text from nested paragraph\n    expect(list.children[0]?.children).toHaveLength(1);\n    expect(list.children[0]?.children?.[0]).toMatchObject({\n      type: 'text',\n      text: 'Describe the building blocks of a computer system',\n    });\n    expect(list.children[1]?.children?.[0]).toMatchObject({\n      type: 'text',\n      text: 'Understand various terminologies',\n    });\n  });\n\n  it('normalizes deeply nested list item content', () => {\n    // Lexical can nest content several levels deep\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'list',\n            listType: 'bullet',\n            children: [\n              {\n                type: 'listitem',\n                children: [\n                  {\n                    type: 'paragraph',\n                    children: [\n                      { type: 'text', text: 'Bold ', format: 1 },\n                      { type: 'text', text: 'and normal text', format: 0 },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    const list = result.blocks[0] as import('../types').ListBlock;\n    expect(list.children[0]?.children).toHaveLength(2);\n    expect(list.children[0]?.children?.[0]).toMatchObject({\n      type: 'text',\n      text: 'Bold ',\n      format: { bold: true },\n    });\n    expect(list.children[0]?.children?.[1]).toMatchObject({\n      type: 'text',\n      text: 'and normal text',\n    });\n  });\n\n  it('normalizes list items with links inside paragraphs', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'list',\n            listType: 'bullet',\n            children: [\n              {\n                type: 'listitem',\n                children: [\n                  {\n                    type: 'paragraph',\n                    children: [\n                      { type: 'text', text: 'Check ', format: 0 },\n                      {\n                        type: 'link',\n                        url: 'https://example.com',\n                        children: [{ type: 'text', text: 'this link', format: 0 }],\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    const list = result.blocks[0] as import('../types').ListBlock;\n    expect(list.children[0]?.children).toHaveLength(2);\n    expect(list.children[0]?.children?.[0]).toMatchObject({\n      type: 'text',\n      text: 'Check ',\n    });\n    expect(list.children[0]?.children?.[1]).toMatchObject({\n      type: 'link',\n      url: 'https://example.com',\n    });\n  });\n\n  it('normalizes quote containing nested paragraph', () => {\n    // Quotes can also contain paragraph children\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'quote',\n            children: [\n              {\n                type: 'paragraph',\n                children: [{ type: 'text', text: 'Quoted text here', format: 0 }],\n              },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    const quote = result.blocks[0] as import('../types').QuoteBlock;\n    expect(quote.children).toHaveLength(1);\n    expect(quote.children[0]).toMatchObject({\n      type: 'text',\n      text: 'Quoted text here',\n    });\n  });\n\n  it('handles unknown wrapper nodes by extracting children', () => {\n    // Forward compatibility: unknown nodes with children should still extract text\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'list',\n            listType: 'bullet',\n            children: [\n              {\n                type: 'listitem',\n                children: [\n                  {\n                    type: 'unknown-future-node',\n                    children: [{ type: 'text', text: 'Future-proof text', format: 0 }],\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    const list = result.blocks[0] as import('../types').ListBlock;\n    expect(list.children[0]?.children).toHaveLength(1);\n    expect(list.children[0]?.children?.[0]).toMatchObject({\n      type: 'text',\n      text: 'Future-proof text',\n    });\n  });\n\n  it('normalizes links', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'paragraph',\n            children: [\n              { type: 'text', text: 'Check out ', format: 0 },\n              {\n                type: 'link',\n                url: 'https://example.com',\n                children: [{ type: 'text', text: 'this link', format: 0 }],\n              },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n    const paragraph = result.blocks[0] as ParagraphBlock;\n\n    expect(paragraph.children).toHaveLength(2);\n    expect(paragraph.children[1]).toMatchObject({\n      type: 'link',\n      url: 'https://example.com',\n    });\n  });\n\n  it('normalizes quotes', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'quote',\n            children: [{ type: 'text', text: 'Famous quote here', format: 0 }],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    expect(result.blocks).toHaveLength(1);\n    expect(result.blocks[0]).toMatchObject({ type: 'quote' });\n  });\n\n  it('normalizes code blocks', () => {\n    const state = {\n      root: {\n        children: [\n          {\n            type: 'code',\n            language: 'javascript',\n            children: [\n              { type: 'text', text: 'const x = 1;', format: 0 },\n              { type: 'text', text: 'console.log(x);', format: 0 },\n            ],\n          },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    expect(result.blocks).toHaveLength(1);\n    expect(result.blocks[0]).toMatchObject({\n      type: 'code',\n      language: 'javascript',\n    });\n  });\n\n  it('parses stringified JSON', () => {\n    const state = JSON.stringify({\n      root: {\n        children: [\n          { type: 'paragraph', children: [{ type: 'text', text: 'From string', format: 0 }] },\n        ],\n      },\n    });\n\n    const result = normalizeEditorState(state);\n    const paragraph = result.blocks[0] as ParagraphBlock;\n\n    expect(result.blocks).toHaveLength(1);\n    expect(paragraph.children[0]).toMatchObject({ type: 'text', text: 'From string' });\n  });\n\n  it('skips unknown node types gracefully', () => {\n    const state = {\n      root: {\n        children: [\n          { type: 'unknown-node', data: 'should be skipped' },\n          { type: 'paragraph', children: [{ type: 'text', text: 'Valid', format: 0 }] },\n          { type: 'another-unknown', nested: { deep: true } },\n        ],\n      },\n    };\n\n    const result = normalizeEditorState(state);\n\n    // Should only have the valid paragraph\n    expect(result.blocks).toHaveLength(1);\n    expect(result.blocks[0]?.type).toBe('paragraph');\n  });\n});\n\ndescribe('extractPlainText', () => {\n  const makeDoc = (blocks: NormalizedDocument['blocks']): NormalizedDocument => ({\n    version: AST_VERSION,\n    blocks,\n  });\n\n  it('extracts text from paragraphs', () => {\n    const doc = makeDoc([\n      { type: 'paragraph', children: [{ type: 'text', text: 'Hello', format: {} }] },\n      { type: 'paragraph', children: [{ type: 'text', text: 'World', format: {} }] },\n    ]);\n\n    const result = extractPlainText(doc);\n    expect(result).toBe('Hello\\nWorld');\n  });\n\n  it('extracts text from lists with prefixes', () => {\n    const doc = makeDoc([\n      {\n        type: 'list',\n        ordered: false,\n        children: [\n          { type: 'listItem', children: [{ type: 'text', text: 'Item 1', format: {} }] },\n          { type: 'listItem', children: [{ type: 'text', text: 'Item 2', format: {} }] },\n        ],\n      },\n    ]);\n\n    const result = extractPlainText(doc);\n    expect(result).toContain('- Item 1');\n    expect(result).toContain('- Item 2');\n  });\n\n  it('extracts text from ordered lists with numbers', () => {\n    const doc = makeDoc([\n      {\n        type: 'list',\n        ordered: true,\n        children: [\n          { type: 'listItem', children: [{ type: 'text', text: 'First', format: {} }] },\n          { type: 'listItem', children: [{ type: 'text', text: 'Second', format: {} }] },\n        ],\n      },\n    ]);\n\n    const result = extractPlainText(doc);\n    expect(result).toContain('1. First');\n    expect(result).toContain('2. Second');\n  });\n\n  it('extracts text from code blocks', () => {\n    const doc = makeDoc([{ type: 'code', code: 'const x = 1;' }]);\n\n    const result = extractPlainText(doc);\n    expect(result).toBe('const x = 1;');\n  });\n});\n\ndescribe('flattenInlineContent', () => {\n  it('flattens text nodes', () => {\n    const content: InlineContent[] = [\n      { type: 'text', text: 'Hello ', format: {} },\n      { type: 'text', text: 'world', format: { bold: true } },\n    ];\n\n    expect(flattenInlineContent(content)).toBe('Hello world');\n  });\n\n  it('flattens links without URLs by default', () => {\n    const content: InlineContent[] = [\n      { type: 'text', text: 'Visit ', format: {} },\n      {\n        type: 'link',\n        url: 'https://example.com',\n        children: [{ type: 'text', text: 'Example', format: {} }],\n      },\n    ];\n\n    expect(flattenInlineContent(content)).toBe('Visit Example');\n  });\n\n  it('includes URLs when option is set', () => {\n    const content: InlineContent[] = [\n      {\n        type: 'link',\n        url: 'https://example.com',\n        children: [{ type: 'text', text: 'Example', format: {} }],\n      },\n    ];\n\n    expect(flattenInlineContent(content, { includeLinkUrls: true })).toBe(\n      'Example (https://example.com)',\n    );\n  });\n\n  it('handles empty content', () => {\n    expect(flattenInlineContent([])).toBe('');\n  });\n});\n\ndescribe('documentHasContent', () => {\n  const makeDoc = (blocks: NormalizedDocument['blocks']): NormalizedDocument => ({\n    version: AST_VERSION,\n    blocks,\n  });\n\n  it('returns false for empty document', () => {\n    expect(documentHasContent(makeDoc([]))).toBe(false);\n  });\n\n  it('returns false for only linebreaks', () => {\n    expect(documentHasContent(makeDoc([{ type: 'linebreak' }]))).toBe(false);\n  });\n\n  it('returns false for empty paragraphs', () => {\n    const doc = makeDoc([\n      { type: 'paragraph', children: [{ type: 'text', text: '   ', format: {} }] },\n    ]);\n    expect(documentHasContent(doc)).toBe(false);\n  });\n\n  it('returns true for paragraph with content', () => {\n    const doc = makeDoc([\n      { type: 'paragraph', children: [{ type: 'text', text: 'Hello', format: {} }] },\n    ]);\n    expect(documentHasContent(doc)).toBe(true);\n  });\n\n  it('returns true for code block with content', () => {\n    const doc = makeDoc([{ type: 'code', code: 'x = 1' }]);\n    expect(documentHasContent(doc)).toBe(true);\n  });\n\n  it('returns false for empty code block', () => {\n    const doc = makeDoc([{ type: 'code', code: '   ' }]);\n    expect(documentHasContent(doc)).toBe(false);\n  });\n\n  it('returns true for list with content', () => {\n    const doc = makeDoc([\n      {\n        type: 'list',\n        ordered: false,\n        children: [{ type: 'listItem', children: [{ type: 'text', text: 'Item', format: {} }] }],\n      },\n    ]);\n    expect(documentHasContent(doc)).toBe(true);\n  });\n\n  it('returns true for link with content', () => {\n    const doc = makeDoc([\n      {\n        type: 'paragraph',\n        children: [\n          {\n            type: 'link',\n            url: 'https://example.com',\n            children: [{ type: 'text', text: 'Link', format: {} }],\n          },\n        ],\n      },\n    ]);\n    expect(documentHasContent(doc)).toBe(true);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\exporters\\MarkdownExporter.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 42,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 42,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1270, 1281], "text": "format.code ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1270, 1281], "text": "format.code === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 47,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 47,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1364, 1375], "text": "(format.bold ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1364, 1375], "text": "(format.bold === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 47,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 47,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1379, 1392], "text": "(format.italic ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1379, 1392], "text": "(format.italic === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 49,
        "column": 14,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 49,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1437, 1448], "text": "format.bold ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1437, 1448], "text": "format.bold === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 51,
        "column": 14,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 51,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1491, 1504], "text": "format.italic ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1491, 1504], "text": "format.italic === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 55,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 55,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1543, 1563], "text": "format.strikethrough ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1543, 1563], "text": "format.strikethrough === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'documentToMarkdown' has too many lines (65). Maximum allowed is 50.",
        "line": 85,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 163,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'documentToMarkdown' has too many statements (41). Maximum allowed is 20.",
        "line": 85,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 163,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 89,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 89,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2336, 2350], "text": "metadata.title.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2336, 2350], "text": "metadata.title !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2336, 2350], "text": "Boolean(metadata.title)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 107,
        "column": 13,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 107,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2882, 2893], "text": "text.trim().length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2882, 2893], "text": "text.trim() !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2882, 2893], "text": "Boolean(text.trim())" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 116,
        "column": 13,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 116,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3076, 3087], "text": "text.trim().length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3076, 3087], "text": "text.trim() !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3076, 3087], "text": "Boolean(text.trim())" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 118,
        "column": 51,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 118,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 137,
        "column": 13,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 137,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3687, 3698], "text": "text.trim().length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3687, 3698], "text": "text.trim() !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3687, 3698], "text": "Boolean(text.trim())" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 147,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 147,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3970, 3984], "text": "(block.language != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3970, 3984], "text": "(block.language ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3970, 3984], "text": "(Boolean(block.language))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 14,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Markdown Exporter\n *\n * Converts normalized documents to CommonMark-compliant Markdown.\n * Preserves formatting, links, and document structure.\n *\n * Note on formatting support:\n * - Supported: bold, italic, strikethrough, code, links\n * - Not supported (no native Markdown equivalent):\n *   - Text colors (would require HTML <span> tags)\n *   - Background/highlight colors (would require HTML)\n *   - Underline (would require HTML <u> tags)\n *   - Text alignment (would require HTML or non-standard extensions)\n */\n\nimport type {\n  Exporter,\n  ExportMetadata,\n  InlineContent,\n  NormalizedDocument,\n  TextRun,\n} from '../types';\nimport { buildMetadataFields } from '../metadata';\n\n/**\n * Escapes special Markdown characters in text.\n */\nfunction escapeMarkdown(text: string): string {\n  // Escape characters that have special meaning in Markdown\n  return text.replace(/([\\\\`*_{}[\\]()#+\\-.!])/g, '\\\\$1');\n}\n\n/**\n * Converts a text run to Markdown with formatting.\n */\nfunction textRunToMarkdown(run: TextRun, escapeText = true): string {\n  let text = escapeText ? escapeMarkdown(run.text) : run.text;\n  const { format } = run;\n\n  // Apply formatting in order: code, then bold/italic\n  // Code formatting takes precedence and shouldn't nest other formatting\n  if (format.code) {\n    // Don't escape inside code spans\n    return `\\`${run.text}\\``;\n  }\n\n  if (format.bold && format.italic) {\n    text = `***${text}***`;\n  } else if (format.bold) {\n    text = `**${text}**`;\n  } else if (format.italic) {\n    text = `*${text}*`;\n  }\n\n  if (format.strikethrough) {\n    text = `~~${text}~~`;\n  }\n\n  // Underline doesn't have native Markdown support, skip it\n\n  return text;\n}\n\n/**\n * Converts inline content to Markdown.\n */\nfunction inlineToMarkdown(content: InlineContent[]): string {\n  return content\n    .map((item) => {\n      if (item.type === 'text') {\n        return textRunToMarkdown(item);\n      }\n      if (item.type === 'link') {\n        const linkText = item.children.map((c) => textRunToMarkdown(c, false)).join('');\n        return `[${linkText}](${item.url})`;\n      }\n      return '';\n    })\n    .join('');\n}\n\n/**\n * Generates Markdown from a normalized document.\n */\nfunction documentToMarkdown(document: NormalizedDocument, metadata: ExportMetadata): string {\n  const lines: string[] = [];\n\n  // Add title as H1\n  if (metadata.title) {\n    lines.push(`# ${metadata.title}`);\n    lines.push('');\n  }\n\n  // Add metadata as blockquote\n  const metadataFields = buildMetadataFields(metadata);\n  if (metadataFields.length > 0) {\n    const metaParts = metadataFields.map(({ label, value }) => `**${label}:** ${value}`);\n    lines.push(`> ${metaParts.join(' | ')}`);\n    lines.push('');\n  }\n\n  // Process blocks\n  for (const block of document.blocks) {\n    switch (block.type) {\n      case 'paragraph': {\n        const text = inlineToMarkdown(block.children);\n        if (text.trim()) {\n          lines.push(text);\n          lines.push('');\n        }\n        break;\n      }\n\n      case 'heading': {\n        const text = inlineToMarkdown(block.children);\n        if (text.trim()) {\n          // Offset by 1 since title uses H1\n          const level = Math.min(block.level + 1, 6);\n          const prefix = '#'.repeat(level);\n          lines.push(`${prefix} ${text}`);\n          lines.push('');\n        }\n        break;\n      }\n\n      case 'list': {\n        block.children.forEach((item, index) => {\n          const prefix = block.ordered ? `${index + 1}. ` : '- ';\n          lines.push(prefix + inlineToMarkdown(item.children));\n        });\n        lines.push('');\n        break;\n      }\n\n      case 'quote': {\n        const text = inlineToMarkdown(block.children);\n        if (text.trim()) {\n          // Split into lines and prefix each with >\n          const quotedLines = text.split('\\n').map((line) => `> ${line}`);\n          lines.push(...quotedLines);\n          lines.push('');\n        }\n        break;\n      }\n\n      case 'code': {\n        const lang = block.language || '';\n        lines.push('```' + lang);\n        lines.push(block.code);\n        lines.push('```');\n        lines.push('');\n        break;\n      }\n\n      case 'linebreak': {\n        lines.push('');\n        break;\n      }\n    }\n  }\n\n  return lines.join('\\n').trim() + '\\n';\n}\n\n/**\n * Markdown exporter implementation.\n */\nexport class MarkdownExporter implements Exporter {\n  readonly format = 'markdown' as const;\n  readonly extension = 'md';\n  readonly mimeType = 'text/markdown';\n\n  async export(document: NormalizedDocument, metadata: ExportMetadata): Promise<Blob> {\n    const markdown = documentToMarkdown(document, metadata);\n    return new Blob([markdown], { type: this.mimeType });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\exporters\\PdfBuilder.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 66,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 66,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2099, 2107], "text": "hexMatch != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 68,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 68,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2146, 2150], "text": "hex == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2147, 2150], "text": "(hex ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2146, 2150], "text": "!Boolean(hex)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 71,
        "column": 24,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 71,
        "endColumn": 25
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 77,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 23
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 77,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 8.",
        "line": 77,
        "column": 40,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 41
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 77,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 77,
        "column": 56,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 81,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 81,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2471, 2479], "text": "rgbMatch != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 83,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 83,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2526, 2528], "text": "(r == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2527, 2528], "text": "(r ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2526, 2528], "text": "(!Boolean(r))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 83,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 83,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2532, 2534], "text": "(g == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2533, 2534], "text": "(g ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2532, 2534], "text": "(!Boolean(g))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 83,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 83,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2538, 2540], "text": "(b == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2539, 2540], "text": "(b ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2538, 2540], "text": "(!Boolean(b))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 89,
        "column": 13,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 89,
        "endColumn": 16
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 89,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 89,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 89,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 89,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 90,
        "column": 11,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 90,
        "endColumn": 14
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 128.",
        "line": 91,
        "column": 16,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 91,
        "endColumn": 19
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 92,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 92,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 93,
        "column": 14,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 93,
        "endColumn": 17
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 93,
        "column": 19,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 93,
        "endColumn": 22
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 94,
        "column": 14,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 94,
        "endColumn": 17
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 165.",
        "line": 94,
        "column": 19,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 94,
        "endColumn": 22
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 128.",
        "line": 95,
        "column": 14,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 95,
        "endColumn": 17
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 128.",
        "line": 95,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 95,
        "endColumn": 25
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 255.",
        "line": 96,
        "column": 12,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 96,
        "endColumn": 15
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 192.",
        "line": 96,
        "column": 17,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 96,
        "endColumn": 20
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 203.",
        "line": 96,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 96,
        "endColumn": 25
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 128.",
        "line": 97,
        "column": 12,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 97,
        "endColumn": 15
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 128.",
        "line": 97,
        "column": 17,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 97,
        "endColumn": 20
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 128.",
        "line": 97,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 97,
        "endColumn": 25
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 128.",
        "line": 98,
        "column": 12,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 98,
        "endColumn": 15
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 128.",
        "line": 98,
        "column": 17,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 98,
        "endColumn": 20
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 128.",
        "line": 98,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 98,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 104,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 104,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [3051, 3060], "text": "(span.bold ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [3051, 3060], "text": "(span.bold === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 104,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 104,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [3064, 3075], "text": "(span.italic ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [3064, 3075], "text": "(span.italic === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 105,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 105,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [3104, 3113], "text": "span.bold ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [3104, 3113], "text": "span.bold === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 106,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 106,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [3136, 3147], "text": "span.italic ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [3136, 3147], "text": "span.italic === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 111,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 111,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [3246, 3255], "text": "(span.code ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [3246, 3255], "text": "(span.code === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.352778.",
        "line": 146,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 146,
        "endColumn": 55
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Method 'inlineToSpans' has a complexity of 20. Maximum allowed is 15.",
        "line": 174,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "complex",
        "endLine": 174,
        "endColumn": 24
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Method 'inlineToSpans' has too many statements (22). Maximum allowed is 20.",
        "line": 174,
        "column": 24,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 203,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 179,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 179,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [5622, 5638], "text": "item.format.bold ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [5622, 5638], "text": "item.format.bold === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 180,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 180,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [5670, 5688], "text": "item.format.italic ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [5670, 5688], "text": "item.format.italic === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 181,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 181,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [5722, 5743], "text": "item.format.underline ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [5722, 5743], "text": "item.format.underline === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 182,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 182,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [5780, 5805], "text": "item.format.strikethrough ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [5780, 5805], "text": "item.format.strikethrough === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 183,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 183,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [5846, 5862], "text": "item.format.code ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [5846, 5862], "text": "item.format.code === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 184,
        "column": 23,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 184,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5904, 5922], "text": "((item.styles?.color) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5904, 5922], "text": "((item.styles?.color) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5904, 5922], "text": "(Boolean((item.styles?.color)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 185,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 185,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5975, 5980], "text": "color != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 186,
        "column": 33,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 186,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6034, 6062], "text": "((item.styles?.backgroundColor) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6034, 6062], "text": "((item.styles?.backgroundColor) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6034, 6062], "text": "(Boolean((item.styles?.backgroundColor)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 189,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 189,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6145, 6160], "text": "backgroundColor != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 238.",
        "line": 193,
        "column": 85,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 193,
        "endColumn": 88
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 194,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 194,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [6420, 6437], "text": "child.format.bold ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [6420, 6437], "text": "child.format.bold === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 195,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 195,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [6471, 6490], "text": "child.format.italic ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [6471, 6490], "text": "child.format.italic === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 196,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 196,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [6526, 6552], "text": "child.format.strikethrough ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [6526, 6552], "text": "child.format.strikethrough === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 197,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 197,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [6595, 6612], "text": "child.format.code ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [6595, 6612], "text": "child.format.code === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 214,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 214,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 215,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 215,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareArrayLengthNonzero",
            "fix": { "range": [7094, 7108], "text": "current.length > 0" },
            "desc": "Change condition to check array's length (`value.length > 0`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 225,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 225,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [7356, 7361], "text": "part.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [7356, 7361], "text": "part === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7356, 7361], "text": "!Boolean(part)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 230,
        "column": 47,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 230,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "conditionFixCompareArrayLengthNonzero",
            "fix": { "range": [7594, 7608], "text": "(current.length > 0)" },
            "desc": "Change condition to check array's length (`value.length > 0`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 231,
        "column": 15,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 231,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [7636, 7647], "text": "(word.trim().length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [7636, 7647], "text": "(word.trim() !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7636, 7647], "text": "(Boolean(word.trim()))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 231,
        "column": 30,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 231,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "conditionFixCompareArrayLengthNonzero",
            "fix": { "range": [7651, 7665], "text": "(current.length > 0)" },
            "desc": "Change condition to check array's length (`value.length > 0`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 250,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 250,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8216, 8236], "text": "span.backgroundColor != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.7.",
        "line": 252,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 252,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 255,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 255,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8391, 8401], "text": "(span.color != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 258,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 258,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [8478, 8492], "text": "span.underline ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [8478, 8492], "text": "span.underline === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 259,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 259,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8520, 8530], "text": "(span.color != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.2.",
        "line": 260,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 260,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.5.",
        "line": 261,
        "column": 33,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 261,
        "endColumn": 36
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.5.",
        "line": 261,
        "column": 62,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 261,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 263,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 263,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [8672, 8690], "text": "span.strikethrough ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [8672, 8690], "text": "span.strikethrough === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 264,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 264,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8718, 8728], "text": "(span.color != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.2.",
        "line": 265,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 265,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.3.",
        "line": 266,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 266,
        "endColumn": 49
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.3.",
        "line": 266,
        "column": 88,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 266,
        "endColumn": 91
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Method 'renderLines' has too many parameters (5). Maximum allowed is 4.",
        "line": 272,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 272,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 315,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 315,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareArrayLengthZero",
            "fix": { "range": [10310, 10323], "text": "parts.length === 0" },
            "desc": "Change condition to check array's length (`value.length === 0`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 346,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 346,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [11487, 11501], "text": "s.text.trim().length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [11487, 11501], "text": "s.text.trim() === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [11487, 11501], "text": "!Boolean(s.text.trim())" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Method 'addListItem' has too many statements (26). Maximum allowed is 20.",
        "line": 358,
        "column": 14,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 402,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 375,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 375,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareArrayLengthZero",
            "fix": { "range": [12512, 12525], "text": "lines.length === 0" },
            "desc": "Change condition to check array's length (`value.length === 0`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 383,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 383,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [12686, 12696], "text": "firstLine == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (379). Maximum allowed is 300.",
        "line": 393,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 490,
        "endColumn": 1
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 410,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 410,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [13394, 13408], "text": "s.text.trim().length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [13394, 13408], "text": "s.text.trim() === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [13394, 13408], "text": "!Boolean(s.text.trim())" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.5.",
        "line": 421,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 421,
        "endColumn": 30
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.3.",
        "line": 424,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 424,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.5.",
        "line": 426,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 426,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 432,
        "column": 14,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 432,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [14067, 14074], "text": "(s.color != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 448,
        "column": 10,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 448,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [14491, 14503], "text": "code.trim().length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [14491, 14503], "text": "code.trim() === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [14491, 14503], "text": "!Boolean(code.trim())" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 454,
        "column": 72,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 454,
        "endColumn": 76,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [14745, 14749], "text": "(line.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [14745, 14749], "text": "(line !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [14745, 14749], "text": "(Boolean(line))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.5.",
        "line": 463,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 463,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 89,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * PDF Builder\n *\n * Wraps jsPDF with layout logic for document generation.\n * Handles pagination, text wrapping, and consistent styling.\n * Supports rich text formatting including colors and highlighting.\n */\n\nimport type { InlineContent, TextAlignment } from '../types';\nimport { PDF_CONFIG } from './pdfConfig';\n\n// ============================================================================\n// jsPDF Type Declarations\n// ============================================================================\n\nexport interface JsPDFInstance {\n  setFont(fontName: string, fontStyle: string): void;\n  setFontSize(size: number): void;\n  setTextColor(r: number, g: number, b: number): void;\n  setFillColor(r: number, g: number, b: number): void;\n  setDrawColor(r: number, g: number, b: number): void;\n  setLineWidth(width: number): void;\n  text(text: string, x: number, y: number): void;\n  rect(x: number, y: number, w: number, h: number, style?: string): void;\n  line(x1: number, y1: number, x2: number, y2: number): void;\n  addPage(): void;\n  splitTextToSize(text: string, maxWidth: number): string[];\n  getTextWidth(text: string): number;\n  output(type: 'blob'): Blob;\n}\n\nexport interface JsPDFConstructor {\n  new (options: { orientation: string; unit: string; format: string }): JsPDFInstance;\n}\n\n// ============================================================================\n// Types\n// ============================================================================\n\ntype RGB = [number, number, number];\n\ninterface TextSpan {\n  text: string;\n  bold?: boolean;\n  italic?: boolean;\n  underline?: boolean;\n  strikethrough?: boolean;\n  code?: boolean;\n  color?: RGB;\n  backgroundColor?: RGB;\n}\n\ninterface WrappedLine {\n  spans: TextSpan[];\n  width: number;\n}\n\n// ============================================================================\n// Color Utilities\n// ============================================================================\n\nfunction parseColor(cssColor: string): RGB | null {\n  const trimmed = cssColor.trim().toLowerCase();\n\n  const hexMatch = trimmed.match(/^#([a-f0-9]{3,6})$/i);\n  if (hexMatch) {\n    let hex = hexMatch[1];\n    if (!hex) {\n      return null;\n    }\n    if (hex.length === 3)\n      hex = hex\n        .split('')\n        .map((c) => c + c)\n        .join('');\n    const num = parseInt(hex, 16);\n    return [(num >> 16) & 255, (num >> 8) & 255, num & 255];\n  }\n\n  const rgbMatch = trimmed.match(/^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)/);\n  if (rgbMatch) {\n    const [_, r, g, b] = rgbMatch;\n    if (!r || !g || !b) return null;\n    return [parseInt(r, 10), parseInt(g, 10), parseInt(b, 10)];\n  }\n\n  const namedColors: Record<string, RGB> = {\n    black: [0, 0, 0],\n    white: [255, 255, 255],\n    red: [255, 0, 0],\n    green: [0, 128, 0],\n    blue: [0, 0, 255],\n    yellow: [255, 255, 0],\n    orange: [255, 165, 0],\n    purple: [128, 0, 128],\n    pink: [255, 192, 203],\n    gray: [128, 128, 128],\n    grey: [128, 128, 128],\n  };\n  return namedColors[trimmed] ?? null;\n}\n\nfunction getFontStyle(span: TextSpan): string {\n  if (span.bold && span.italic) return 'bolditalic';\n  if (span.bold) return 'bold';\n  if (span.italic) return 'italic';\n  return 'normal';\n}\n\nfunction getFontFamily(span: TextSpan): string {\n  return span.code ? 'courier' : 'helvetica';\n}\n\n// ============================================================================\n// PDF Builder Class\n// ============================================================================\n\nexport class PdfBuilder {\n  private doc: JsPDFInstance;\n  private y: number;\n  private contentWidth: number;\n\n  constructor(JsPDFCtor: JsPDFConstructor) {\n    this.doc = new JsPDFCtor({ orientation: 'portrait', unit: 'mm', format: 'a4' });\n    this.y = PDF_CONFIG.marginTop;\n    this.contentWidth = PDF_CONFIG.pageWidth - PDF_CONFIG.marginLeft - PDF_CONFIG.marginRight;\n    this.doc.setFont('helvetica', 'normal');\n    this.doc.setFontSize(PDF_CONFIG.bodySize);\n    this.setColor(PDF_CONFIG.textColor);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Basic Helpers\n  // ---------------------------------------------------------------------------\n\n  private setColor(color: RGB): void {\n    this.doc.setTextColor(color[0], color[1], color[2]);\n  }\n  private setFillColor(color: RGB): void {\n    this.doc.setFillColor(color[0], color[1], color[2]);\n  }\n  private setDrawColor(color: RGB): void {\n    this.doc.setDrawColor(color[0], color[1], color[2]);\n  }\n  private getTextHeight(fontSize: number): number {\n    return fontSize * PDF_CONFIG.lineHeight * 0.352778;\n  }\n  private wrapText(text: string, maxWidth: number): string[] {\n    return this.doc.splitTextToSize(text, maxWidth);\n  }\n\n  private checkPageBreak(height: number): void {\n    if (this.y + height > PDF_CONFIG.pageHeight - PDF_CONFIG.marginBottom) {\n      this.doc.addPage();\n      this.y = PDF_CONFIG.marginTop;\n    }\n  }\n\n  private getAlignedX(\n    textWidth: number,\n    alignment: TextAlignment | undefined,\n    baseX: number,\n    maxWidth: number,\n  ): number {\n    if (alignment === 'center') return baseX + (maxWidth - textWidth) / 2;\n    if (alignment === 'right') return baseX + maxWidth - textWidth;\n    return baseX;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Span Conversion\n  // ---------------------------------------------------------------------------\n\n  private inlineToSpans(content: InlineContent[]): TextSpan[] {\n    const spans: TextSpan[] = [];\n    for (const item of content) {\n      if (item.type === 'text') {\n        const span: TextSpan = { text: item.text };\n        if (item.format.bold) span.bold = true;\n        if (item.format.italic) span.italic = true;\n        if (item.format.underline) span.underline = true;\n        if (item.format.strikethrough) span.strikethrough = true;\n        if (item.format.code) span.code = true;\n        const color = item.styles?.color ? parseColor(item.styles.color) : null;\n        if (color) span.color = color;\n        const backgroundColor = item.styles?.backgroundColor\n          ? parseColor(item.styles.backgroundColor)\n          : null;\n        if (backgroundColor) span.backgroundColor = backgroundColor;\n        spans.push(span);\n      } else if (item.type === 'link') {\n        for (const child of item.children) {\n          const span: TextSpan = { text: child.text, underline: true, color: [0, 0, 238] };\n          if (child.format.bold) span.bold = true;\n          if (child.format.italic) span.italic = true;\n          if (child.format.strikethrough) span.strikethrough = true;\n          if (child.format.code) span.code = true;\n          spans.push(span);\n        }\n      }\n    }\n    return spans;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Line Building\n  // ---------------------------------------------------------------------------\n\n  private buildLines(spans: TextSpan[], maxWidth: number): WrappedLine[] {\n    const lines: WrappedLine[] = [];\n    let current: TextSpan[] = [];\n    let width = 0;\n\n    const pushLine = () => {\n      if (current.length) {\n        lines.push({ spans: current, width });\n        current = [];\n        width = 0;\n      }\n    };\n\n    for (const span of spans) {\n      for (const [i, part] of span.text.split('\\n').entries()) {\n        if (i > 0) pushLine();\n        if (!part) continue;\n\n        this.doc.setFont(getFontFamily(span), getFontStyle(span));\n        for (const word of part.split(/(\\s+)/)) {\n          const wordWidth = this.doc.getTextWidth(word);\n          if (width + wordWidth > maxWidth && current.length) pushLine();\n          if (word.trim() || current.length) {\n            current.push({ ...span, text: word });\n            width += wordWidth;\n          }\n        }\n      }\n    }\n    pushLine();\n    return lines;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Span Rendering\n  // ---------------------------------------------------------------------------\n\n  private renderSpan(span: TextSpan, x: number, lineHeight: number): number {\n    this.doc.setFont(getFontFamily(span), getFontStyle(span));\n    const textWidth = this.doc.getTextWidth(span.text);\n\n    if (span.backgroundColor) {\n      this.setFillColor(span.backgroundColor);\n      this.doc.rect(x, this.y - lineHeight * 0.7, textWidth, lineHeight, 'F');\n    }\n\n    this.setColor(span.color || PDF_CONFIG.textColor);\n    this.doc.text(span.text, x, this.y);\n\n    if (span.underline) {\n      this.setDrawColor(span.color || PDF_CONFIG.textColor);\n      this.doc.setLineWidth(0.2);\n      this.doc.line(x, this.y + 0.5, x + textWidth, this.y + 0.5);\n    }\n    if (span.strikethrough) {\n      this.setDrawColor(span.color || PDF_CONFIG.textColor);\n      this.doc.setLineWidth(0.2);\n      this.doc.line(x, this.y - lineHeight * 0.3, x + textWidth, this.y - lineHeight * 0.3);\n    }\n\n    return textWidth;\n  }\n\n  private renderLines(\n    lines: WrappedLine[],\n    fontSize: number,\n    startX: number,\n    maxWidth: number,\n    alignment?: TextAlignment,\n  ): void {\n    const lineHeight = this.getTextHeight(fontSize);\n    this.doc.setFontSize(fontSize);\n\n    for (const line of lines) {\n      this.checkPageBreak(lineHeight);\n      let x = this.getAlignedX(line.width, alignment, startX, maxWidth);\n      for (const span of line.spans) x += this.renderSpan(span, x, lineHeight);\n      this.y += lineHeight;\n    }\n\n    this.doc.setFont('helvetica', 'normal');\n    this.setColor(PDF_CONFIG.textColor);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------------\n\n  addTitle(title: string): void {\n    this.doc.setFontSize(PDF_CONFIG.titleSize);\n    this.doc.setFont('helvetica', 'bold');\n    this.setColor(PDF_CONFIG.textColor);\n\n    const lineHeight = this.getTextHeight(PDF_CONFIG.titleSize);\n    for (const line of this.wrapText(title, this.contentWidth)) {\n      this.checkPageBreak(lineHeight);\n      this.doc.text(line, PDF_CONFIG.marginLeft, this.y);\n      this.y += lineHeight;\n    }\n\n    this.y += PDF_CONFIG.headingSpacing;\n    this.doc.setFont('helvetica', 'normal');\n    this.doc.setFontSize(PDF_CONFIG.bodySize);\n  }\n\n  addMetadata(parts: string[]): void {\n    if (!parts.length) return;\n    this.doc.setFontSize(PDF_CONFIG.metaSize);\n    this.setColor(PDF_CONFIG.metaColor);\n\n    const lineHeight = this.getTextHeight(PDF_CONFIG.metaSize);\n    this.checkPageBreak(lineHeight);\n    this.doc.text(parts.join(' | '), PDF_CONFIG.marginLeft, this.y);\n    this.y += lineHeight + PDF_CONFIG.paragraphSpacing;\n\n    this.doc.setFontSize(PDF_CONFIG.bodySize);\n    this.setColor(PDF_CONFIG.textColor);\n  }\n\n  addHeading(content: InlineContent[], level: number, alignment?: TextAlignment): void {\n    const headingIndex = Math.min(level - 1, PDF_CONFIG.headingSizes.length - 1);\n    const fontSize = PDF_CONFIG.headingSizes[headingIndex] ?? PDF_CONFIG.bodySize;\n    this.y += PDF_CONFIG.headingSpacing / 2;\n\n    const spans = this.inlineToSpans(content).map((s) => ({ ...s, bold: true }));\n    this.renderLines(\n      this.buildLines(spans, this.contentWidth),\n      fontSize,\n      PDF_CONFIG.marginLeft,\n      this.contentWidth,\n      alignment,\n    );\n    this.y += PDF_CONFIG.paragraphSpacing;\n  }\n\n  addParagraph(content: InlineContent[], alignment?: TextAlignment): void {\n    const spans = this.inlineToSpans(content);\n    if (spans.every((s) => !s.text.trim())) return;\n\n    this.renderLines(\n      this.buildLines(spans, this.contentWidth),\n      PDF_CONFIG.bodySize,\n      PDF_CONFIG.marginLeft,\n      this.contentWidth,\n      alignment,\n    );\n    this.y += PDF_CONFIG.paragraphSpacing;\n  }\n\n  addListItem(content: InlineContent[], index: number, ordered: boolean): void {\n    const prefix = ordered ? `${index + 1}. ` : '\\u2022 ';\n    const lineHeight = this.getTextHeight(PDF_CONFIG.bodySize);\n\n    this.checkPageBreak(lineHeight);\n    this.doc.setFontSize(PDF_CONFIG.bodySize);\n    this.doc.setFont('helvetica', 'normal');\n    this.setColor(PDF_CONFIG.textColor);\n    this.doc.text(prefix, PDF_CONFIG.marginLeft, this.y);\n\n    const prefixWidth = this.doc.getTextWidth(prefix);\n    const contentX = PDF_CONFIG.marginLeft + Math.max(prefixWidth, PDF_CONFIG.listIndent);\n    const contentWidth = this.contentWidth - PDF_CONFIG.listIndent;\n\n    const spans = this.inlineToSpans(content);\n    const lines = this.buildLines(spans, contentWidth - prefixWidth);\n\n    if (!lines.length) {\n      this.y += lineHeight;\n      return;\n    }\n\n    // First line rendered inline with prefix\n    let x = contentX;\n    const firstLine = lines[0];\n    if (!firstLine) {\n      this.y += lineHeight;\n      return;\n    }\n    for (const span of firstLine.spans) x += this.renderSpan(span, x, lineHeight);\n    this.y += lineHeight;\n\n    // Remaining lines at indent\n    if (lines.length > 1) {\n      this.renderLines(\n        lines.slice(1),\n        PDF_CONFIG.bodySize,\n        PDF_CONFIG.marginLeft + PDF_CONFIG.listIndent,\n        contentWidth,\n      );\n    }\n\n    this.doc.setFont('helvetica', 'normal');\n    this.setColor(PDF_CONFIG.textColor);\n  }\n\n  endList(): void {\n    this.y += PDF_CONFIG.paragraphSpacing;\n  }\n\n  addQuote(content: InlineContent[], alignment?: TextAlignment): void {\n    const spans = this.inlineToSpans(content);\n    if (spans.every((s) => !s.text.trim())) return;\n\n    const quoteWidth = this.contentWidth - PDF_CONFIG.quoteIndent;\n    const lineHeight = this.getTextHeight(PDF_CONFIG.bodySize);\n    const estimatedHeight =\n      this.wrapText(spans.map((s) => s.text).join(''), quoteWidth).length * lineHeight;\n\n    this.checkPageBreak(estimatedHeight);\n\n    // Left border\n    this.setDrawColor(PDF_CONFIG.quoteBorder);\n    this.doc.setLineWidth(0.5);\n    this.doc.line(\n      PDF_CONFIG.marginLeft,\n      this.y - lineHeight * 0.3,\n      PDF_CONFIG.marginLeft,\n      this.y + estimatedHeight - lineHeight * 0.5,\n    );\n\n    const quotedSpans = spans.map((s) => ({\n      ...s,\n      italic: true,\n      color: s.color || (PDF_CONFIG.metaColor as RGB),\n    }));\n    this.renderLines(\n      this.buildLines(quotedSpans, quoteWidth),\n      PDF_CONFIG.bodySize,\n      PDF_CONFIG.marginLeft + PDF_CONFIG.quoteIndent,\n      quoteWidth,\n      alignment,\n    );\n    this.y += PDF_CONFIG.paragraphSpacing;\n\n    this.doc.setFont('helvetica', 'normal');\n    this.setColor(PDF_CONFIG.textColor);\n  }\n\n  addCodeBlock(code: string): void {\n    if (!code.trim()) return;\n\n    this.doc.setFontSize(PDF_CONFIG.codeSize);\n    this.doc.setFont('courier', 'normal');\n\n    const codeWidth = this.contentWidth - PDF_CONFIG.codeIndent * 2;\n    const codeLines = code.split('\\n').flatMap((line) => this.wrapText(line || ' ', codeWidth));\n    const lineHeight = this.getTextHeight(PDF_CONFIG.codeSize);\n    const blockHeight = codeLines.length * lineHeight + PDF_CONFIG.codeIndent;\n\n    this.checkPageBreak(blockHeight);\n\n    this.setFillColor(PDF_CONFIG.codeBackground);\n    this.doc.rect(\n      PDF_CONFIG.marginLeft,\n      this.y - lineHeight * 0.5,\n      this.contentWidth,\n      blockHeight,\n      'F',\n    );\n\n    this.setColor(PDF_CONFIG.textColor);\n    const x = PDF_CONFIG.marginLeft + PDF_CONFIG.codeIndent;\n    this.y += PDF_CONFIG.codeIndent / 2;\n\n    for (const line of codeLines) {\n      this.doc.text(line, x, this.y);\n      this.y += lineHeight;\n    }\n\n    this.y += PDF_CONFIG.paragraphSpacing + PDF_CONFIG.codeIndent / 2;\n    this.doc.setFont('helvetica', 'normal');\n    this.doc.setFontSize(PDF_CONFIG.bodySize);\n  }\n\n  addLineBreak(): void {\n    this.y += PDF_CONFIG.paragraphSpacing;\n  }\n  toBlob(): Blob {\n    return this.doc.output('blob');\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\exporters\\PdfExporter.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "Imports \"JsPDFConstructor\" are only used as type.",
        "line": 11,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "messageId": "someImportsAreOnlyTypes",
        "endLine": 11,
        "endColumn": 61,
        "fix": {
          "range": [365, 391],
          "text": "import type { JsPDFConstructor} from './PdfBuilder';\nimport {"
        }
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 18,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorAny",
        "endLine": 18,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [692, 698], "text": "(Boolean(module))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'generatePdf' has too many statements (23). Maximum allowed is 20.",
        "line": 38,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 93,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 46,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 46,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1671, 1685], "text": "metadata.title.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1671, 1685], "text": "metadata.title !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1671, 1685], "text": "Boolean(metadata.title)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "/**\n * PDF Exporter\n *\n * Converts normalized documents to PDF format using jsPDF.\n * Produces clean, well-formatted documents with proper typography.\n * Supports rich text formatting including colors, highlighting, and alignment.\n */\n\nimport type { Exporter, ExportMetadata, NormalizedDocument } from '../types';\nimport { buildMetadataFields } from '../metadata';\nimport { JsPDFConstructor, PdfBuilder } from './PdfBuilder';\n\n// ============================================================================\n// jsPDF Module Resolution\n// ============================================================================\n\nfunction resolveJsPdfConstructor(module: unknown): JsPDFConstructor {\n  if (!module || typeof module !== 'object') {\n    throw new Error('jsPDF module did not load correctly.');\n  }\n\n  const candidate = (module as { jsPDF?: unknown }).jsPDF;\n  if (typeof candidate !== 'function') {\n    throw new Error('jsPDF constructor was not found in the module.');\n  }\n\n  return candidate as JsPDFConstructor;\n}\n\n// ============================================================================\n// PDF Generation\n// ============================================================================\n\n/**\n * Generates a PDF from the normalized document.\n * Preserves rich text formatting including colors, highlighting, and alignment.\n */\nasync function generatePdf(document: NormalizedDocument, metadata: ExportMetadata): Promise<Blob> {\n  // Dynamically import jsPDF to keep bundle size down when not exporting\n  const jspdfModule = await import('jspdf');\n  const JsPDF = resolveJsPdfConstructor(jspdfModule);\n\n  const builder = new PdfBuilder(JsPDF);\n\n  // Add title\n  if (metadata.title) {\n    builder.addTitle(metadata.title);\n  }\n\n  // Add metadata\n  const metadataFields = buildMetadataFields(metadata);\n  builder.addMetadata(metadataFields.map(({ label, value }) => `${label}: ${value}`));\n\n  // Process blocks with rich text support\n  for (const block of document.blocks) {\n    switch (block.type) {\n      case 'paragraph': {\n        builder.addParagraph(block.children, block.alignment);\n        break;\n      }\n\n      case 'heading': {\n        builder.addHeading(block.children, block.level, block.alignment);\n        break;\n      }\n\n      case 'list': {\n        block.children.forEach((item, index) => {\n          builder.addListItem(item.children, index, block.ordered);\n        });\n        builder.endList();\n        break;\n      }\n\n      case 'quote': {\n        builder.addQuote(block.children, block.alignment);\n        break;\n      }\n\n      case 'code': {\n        builder.addCodeBlock(block.code);\n        break;\n      }\n\n      case 'linebreak': {\n        builder.addLineBreak();\n        break;\n      }\n    }\n  }\n\n  return builder.toBlob();\n}\n\n// ============================================================================\n// Exporter Implementation\n// ============================================================================\n\n/**\n * PDF exporter implementation using jsPDF.\n * Follows Strategy pattern for extensibility.\n */\nexport class PdfExporter implements Exporter {\n  readonly format = 'pdf' as const;\n  readonly extension = 'pdf';\n  readonly mimeType = 'application/pdf';\n\n  async export(document: NormalizedDocument, metadata: ExportMetadata): Promise<Blob> {\n    return generatePdf(document, metadata);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\exporters\\TextExporter.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'documentToText' has too many lines (65). Maximum allowed is 50.",
        "line": 16,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 94,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'documentToText' has too many statements (41). Maximum allowed is 20.",
        "line": 16,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 94,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 20,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 20,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [586, 600], "text": "metadata.title.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [586, 600], "text": "metadata.title !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [586, 600], "text": "Boolean(metadata.title)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 22,
        "column": 59,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 22,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 40,
        "column": 13,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 40,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1253, 1264], "text": "text.trim().length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1253, 1264], "text": "text.trim() !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1253, 1264], "text": "Boolean(text.trim())" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 49,
        "column": 13,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 49,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1451, 1462], "text": "text.trim().length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1451, 1462], "text": "text.trim() !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1451, 1462], "text": "Boolean(text.trim())" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 40.",
        "line": 52,
        "column": 55,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 69,
        "column": 13,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 69,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2040, 2051], "text": "text.trim().length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2040, 2051], "text": "text.trim() !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2040, 2051], "text": "Boolean(text.trim())" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Plain Text Exporter\n *\n * Converts normalized documents to plain text format.\n * Strips all formatting while preserving document structure through\n * whitespace and simple markers.\n */\n\nimport type { Exporter, ExportMetadata, NormalizedDocument } from '../types';\nimport { buildMetadataFields } from '../metadata';\nimport { flattenInlineContent } from '../normalizer';\n\n/**\n * Generates plain text from a normalized document.\n */\nfunction documentToText(document: NormalizedDocument, metadata: ExportMetadata): string {\n  const lines: string[] = [];\n\n  // Add title header\n  if (metadata.title) {\n    lines.push(metadata.title);\n    lines.push('='.repeat(Math.min(metadata.title.length, 60)));\n    lines.push('');\n  }\n\n  // Add metadata\n  const metadataFields = buildMetadataFields(metadata);\n  if (metadataFields.length > 0) {\n    const metaParts = metadataFields.map(({ label, value }) => `${label}: ${value}`);\n    lines.push(metaParts.join(' | '));\n    lines.push('');\n  }\n\n  // Process blocks\n  for (const block of document.blocks) {\n    switch (block.type) {\n      case 'paragraph': {\n        // Include link URLs in plain text for reference\n        const text = flattenInlineContent(block.children, { includeLinkUrls: true });\n        if (text.trim()) {\n          lines.push(text);\n          lines.push('');\n        }\n        break;\n      }\n\n      case 'heading': {\n        const text = flattenInlineContent(block.children);\n        if (text.trim()) {\n          lines.push('');\n          lines.push(text.toUpperCase());\n          lines.push('-'.repeat(Math.min(text.length, 40)));\n          lines.push('');\n        }\n        break;\n      }\n\n      case 'list': {\n        block.children.forEach((item, index) => {\n          const prefix = block.ordered ? `${index + 1}. ` : '* ';\n          lines.push(prefix + flattenInlineContent(item.children, { includeLinkUrls: true }));\n        });\n        lines.push('');\n        break;\n      }\n\n      case 'quote': {\n        const text = flattenInlineContent(block.children);\n        if (text.trim()) {\n          // Indent quoted text\n          const quotedLines = text.split('\\n').map((line) => `  \"${line}\"`);\n          lines.push(...quotedLines);\n          lines.push('');\n        }\n        break;\n      }\n\n      case 'code': {\n        lines.push('---');\n        lines.push(block.code);\n        lines.push('---');\n        lines.push('');\n        break;\n      }\n\n      case 'linebreak': {\n        lines.push('');\n        break;\n      }\n    }\n  }\n\n  return lines.join('\\n').trim() + '\\n';\n}\n\n/**\n * Plain text exporter implementation.\n */\nexport class TextExporter implements Exporter {\n  readonly format = 'text' as const;\n  readonly extension = 'txt';\n  readonly mimeType = 'text/plain';\n\n  async export(document: NormalizedDocument, metadata: ExportMetadata): Promise<Blob> {\n    const text = documentToText(document, metadata);\n    return new Blob([text], { type: this.mimeType });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\exporters\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\exporters\\pdfConfig.ts",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 18,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 18,
        "endColumn": 20
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 14.",
        "line": 18,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 18,
        "endColumn": 24
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 13.",
        "line": 18,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 18,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 12.",
        "line": 18,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 18,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 11.",
        "line": 18,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 18,
        "endColumn": 36
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 18,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 18,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 33.",
        "line": 34,
        "column": 15,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 34,
        "endColumn": 17
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 33.",
        "line": 34,
        "column": 19,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 34,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 33.",
        "line": 34,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 34,
        "endColumn": 25
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 245.",
        "line": 36,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 36,
        "endColumn": 23
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 245.",
        "line": 36,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 36,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 245.",
        "line": 36,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 36,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 37,
        "column": 17,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 37,
        "endColumn": 20
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 37,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 37,
        "endColumn": 25
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 200.",
        "line": 37,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 37,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 15,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * PDF Configuration Constants\n *\n * Centralized configuration for PDF document generation.\n */\n\nexport const PDF_CONFIG = {\n  // Page settings (A4 in mm)\n  pageWidth: 210,\n  pageHeight: 297,\n  marginLeft: 20,\n  marginRight: 20,\n  marginTop: 25,\n  marginBottom: 25,\n\n  // Font sizes (in points)\n  titleSize: 18,\n  headingSizes: [16, 14, 13, 12, 11, 10] as const,\n  bodySize: 11,\n  metaSize: 9,\n  codeSize: 10,\n\n  // Line heights (multiplier of font size)\n  lineHeight: 1.4,\n  paragraphSpacing: 6,\n  headingSpacing: 10,\n\n  // Indentation (in mm)\n  listIndent: 8,\n  quoteIndent: 10,\n  codeIndent: 5,\n\n  // Colors [R, G, B]\n  textColor: [33, 33, 33] as [number, number, number],\n  metaColor: [100, 100, 100] as [number, number, number],\n  codeBackground: [245, 245, 245] as [number, number, number],\n  quoteBorder: [200, 200, 200] as [number, number, number],\n} as const;\n\nexport type PdfConfig = typeof PDF_CONFIG;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\inlineUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\lexicalTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\metadata.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 17,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 17,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [347, 366], "text": "metadata.courseCode != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [347, 366], "text": "metadata.courseCode ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [347, 366], "text": "Boolean(metadata.courseCode)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 21,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 21,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [447, 460], "text": "metadata.week != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [447, 460], "text": "metadata.week ?? 0" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [447, 460], "text": "Boolean(metadata.week)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Export Metadata Helpers\n *\n * Shared helpers for rendering note metadata across exporters.\n */\n\nimport type { ExportMetadata } from './types';\n\nexport interface MetadataField {\n  label: string;\n  value: string;\n}\n\nexport function buildMetadataFields(metadata: ExportMetadata): MetadataField[] {\n  const fields: MetadataField[] = [];\n\n  if (metadata.courseCode) {\n    fields.push({ label: 'Course', value: metadata.courseCode });\n  }\n\n  if (metadata.week) {\n    fields.push({ label: 'Week', value: String(metadata.week) });\n  }\n\n  return fields;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\normalizer.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 62,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 62,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1523, 1530], "text": "format == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [1524, 1530], "text": "(format ?? 0)" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1523, 1530], "text": "!Boolean(format)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 78,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 78,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2195, 2201], "text": "(style == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2196, 2201], "text": "(style ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2195, 2201], "text": "(!Boolean(style))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 84,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 84,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2379, 2394], "text": "(colorMatch?.[1]) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2379, 2394], "text": "(colorMatch?.[1]) ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2379, 2394], "text": "Boolean((colorMatch?.[1]))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 90,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 90,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2563, 2575], "text": "(bgMatch?.[1]) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2563, 2575], "text": "(bgMatch?.[1]) ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2563, 2575], "text": "Boolean((bgMatch?.[1]))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 102,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 102,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2936, 2943], "text": "(format == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [2937, 2943], "text": "(format ?? 0)" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2936, 2943], "text": "(!Boolean(format))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'extractInlineContent' has too many statements (24). Maximum allowed is 20.",
        "line": 135,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 193,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 136,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 136,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4363, 4372], "text": "(children == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 145,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 145,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4656, 4666], "text": "(child.text != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4656, 4666], "text": "(child.text ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4656, 4666], "text": "(Boolean(child.text))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 149,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 149,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4783, 4789], "text": "styles != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 160,
        "column": 14,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 160,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5042, 5051], "text": "(child.url != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5042, 5051], "text": "(child.url ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5042, 5051], "text": "(Boolean(child.url))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 186,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 186,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5821, 5835], "text": "(child.children != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 198,
        "column": 62,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 198,
        "endColumn": 63
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 198,
        "column": 66,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 198,
        "endColumn": 67
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 198,
        "column": 70,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 198,
        "endColumn": 71
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 198,
        "column": 74,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 198,
        "endColumn": 75
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 200,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 200,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6190, 6200], "text": "(match?.[1]) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6190, 6200], "text": "(match?.[1]) ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6190, 6200], "text": "Boolean((match?.[1]))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 202,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 202,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 203,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 203,
        "endColumn": 32
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 203,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 203,
        "endColumn": 36
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 203,
        "column": 39,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 203,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 203,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 203,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 215,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 215,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 228,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 228,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 237,
        "column": 23,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 237,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7103, 7116], "text": "(node.children != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 259,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 259,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 266,
        "column": 21,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 266,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7741, 7754], "text": "(node.children != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 266,
        "column": 57,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 266,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7777, 7787], "text": "(child.text != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7777, 7787], "text": "(child.text ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7777, 7787], "text": "(Boolean(child.text))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 272,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 272,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7886, 7899], "text": "node.language != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7886, 7899], "text": "node.language ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7886, 7899], "text": "Boolean(node.language)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 304,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorAny",
        "endLine": 304,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [8988, 8999], "text": "(Boolean(editorState))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 310,
        "column": 5,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 310,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 323,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 323,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9443, 9448], "text": "block != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 31,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Lexical Editor State Normalizer\n *\n * Converts Lexical's editor state JSON into a format-agnostic intermediate AST.\n * This decouples export logic from the editor implementation, making it easier\n * to test and extend with new export formats.\n */\n\nimport {\n  AST_VERSION,\n  type Block,\n  type CodeBlock,\n  type HeadingBlock,\n  type InlineContent,\n  type LineBreakBlock,\n  type ListBlock,\n  type ListItemBlock,\n  type NormalizedDocument,\n  type ParagraphBlock,\n  type QuoteBlock,\n  type TextAlignment,\n  type TextFormatting,\n  type TextRun,\n  type TextStyles,\n} from './types';\n\nimport {\n  ELEMENT_FORMAT_CENTER,\n  ELEMENT_FORMAT_JUSTIFY,\n  ELEMENT_FORMAT_LEFT,\n  ELEMENT_FORMAT_RIGHT,\n  FORMAT_BOLD,\n  FORMAT_CODE,\n  FORMAT_ITALIC,\n  FORMAT_STRIKETHROUGH,\n  FORMAT_UNDERLINE,\n  isCodeNode,\n  isHeadingNode,\n  isLineBreakNode,\n  isLinkNode,\n  isListItemNode,\n  isListNode,\n  isParagraphNode,\n  isQuoteNode,\n  isTextNode,\n  type LexicalEditorState,\n  type LexicalNode,\n} from './lexicalTypes';\n\n// Re-export utilities for backward compatibility\nexport { documentHasContent, extractPlainText, flattenInlineContent } from './inlineUtils';\nexport type { FlattenOptions } from './inlineUtils';\n\n// ============================================================================\n// Format Parsing\n// ============================================================================\n\n/**\n * Parses Lexical's format bitmask into explicit formatting flags.\n */\nfunction parseFormat(format: number | undefined): TextFormatting {\n  if (!format) return {};\n\n  const formatting: TextFormatting = {};\n  if ((format & FORMAT_BOLD) !== 0) formatting.bold = true;\n  if ((format & FORMAT_ITALIC) !== 0) formatting.italic = true;\n  if ((format & FORMAT_STRIKETHROUGH) !== 0) formatting.strikethrough = true;\n  if ((format & FORMAT_UNDERLINE) !== 0) formatting.underline = true;\n  if ((format & FORMAT_CODE) !== 0) formatting.code = true;\n  return formatting;\n}\n\n/**\n * Parses CSS style string to extract text styles (color, background-color).\n * Lexical stores styles as CSS strings like \"color: #ff0000; background-color: yellow;\"\n */\nfunction parseStyles(style: string | undefined): TextStyles | undefined {\n  if (!style || style.trim() === '') return undefined;\n\n  const styles: TextStyles = {};\n\n  // Parse color property\n  const colorMatch = style.match(/(?:^|;)\\s*color\\s*:\\s*([^;]+)/i);\n  if (colorMatch?.[1]) {\n    styles.color = colorMatch[1].trim();\n  }\n\n  // Parse background-color property\n  const bgMatch = style.match(/(?:^|;)\\s*background-color\\s*:\\s*([^;]+)/i);\n  if (bgMatch?.[1]) {\n    styles.backgroundColor = bgMatch[1].trim();\n  }\n\n  return Object.keys(styles).length > 0 ? styles : undefined;\n}\n\n/**\n * Parses Lexical element format to text alignment.\n * Lexical uses numeric format for element alignment (1=left, 2=center, 3=right, 4=justify)\n */\nfunction parseAlignment(format: number | undefined): TextAlignment | undefined {\n  if (!format || format === 0 || format === ELEMENT_FORMAT_LEFT) return undefined; // default is left, don't store\n  if (format === ELEMENT_FORMAT_CENTER) return 'center';\n  if (format === ELEMENT_FORMAT_RIGHT) return 'right';\n  if (format === ELEMENT_FORMAT_JUSTIFY) return 'justify';\n  return undefined;\n}\n\n// ============================================================================\n// Node Normalization\n// ============================================================================\n\n/**\n * Checks if a node is a container that holds inline content.\n * These nodes don't contribute content themselves but wrap inline children.\n */\nfunction isInlineContainerNode(node: LexicalNode): boolean {\n  return isParagraphNode(node) || isHeadingNode(node) || isQuoteNode(node);\n}\n\n/**\n * Recursively extracts inline content from a Lexical node tree.\n *\n * Lexical's structure can be deeply nested. For example, a list item might contain:\n * - Direct text nodes (simple case)\n * - Paragraph nodes containing text (common case from rich editing)\n * - Multiple paragraphs or mixed content\n *\n * This function handles all cases by recursively descending into container nodes\n * and collecting all inline content (text, links, linebreaks).\n *\n * @param children - Array of Lexical nodes to process\n * @returns Flattened array of inline content\n */\nfunction extractInlineContent(children: LexicalNode[] | undefined): InlineContent[] {\n  if (!children || children.length === 0) return [];\n\n  const result: InlineContent[] = [];\n\n  for (const child of children) {\n    // Case 1: Direct text node - extract text with formatting and styles\n    if (isTextNode(child)) {\n      const textRun: TextRun = {\n        type: 'text',\n        text: child.text || '',\n        format: parseFormat(child.format),\n      };\n      const styles = parseStyles(child.style);\n      if (styles) {\n        textRun.styles = styles;\n      }\n      result.push(textRun);\n      continue;\n    }\n\n    // Case 2: Link node - extract URL and recursively get text children\n    if (isLinkNode(child)) {\n      result.push({\n        type: 'link',\n        url: child.url || '',\n        children: extractInlineContent(child.children) as TextRun[],\n      });\n      continue;\n    }\n\n    // Case 3: Line break - convert to newline text\n    if (isLineBreakNode(child)) {\n      result.push({\n        type: 'text',\n        text: '\\n',\n        format: {},\n      });\n      continue;\n    }\n\n    // Case 4: Container nodes (paragraph, heading, quote inside list items)\n    // Recursively extract inline content from these containers\n    if (isInlineContainerNode(child)) {\n      const nestedContent = extractInlineContent(child.children);\n      result.push(...nestedContent);\n      continue;\n    }\n\n    // Case 5: Unknown nodes with children - attempt recursive extraction\n    // This provides forward compatibility for new Lexical node types\n    if (child.children && Array.isArray(child.children)) {\n      const nestedContent = extractInlineContent(child.children);\n      result.push(...nestedContent);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Extracts heading level from Lexical's tag property.\n */\nfunction parseHeadingLevel(tag: string | undefined): 1 | 2 | 3 | 4 | 5 | 6 {\n  const match = tag?.match(/h(\\d)/i);\n  if (match?.[1]) {\n    const level = parseInt(match[1], 10);\n    if (level >= 1 && level <= 6) {\n      return level as 1 | 2 | 3 | 4 | 5 | 6;\n    }\n  }\n  return 1;\n}\n\nfunction normalizeParagraph(node: LexicalNode): ParagraphBlock {\n  const block: ParagraphBlock = {\n    type: 'paragraph',\n    children: extractInlineContent(node.children),\n  };\n  const alignment = parseAlignment(node.format);\n  if (alignment) {\n    block.alignment = alignment;\n  }\n  return block;\n}\n\nfunction normalizeHeading(node: LexicalNode): HeadingBlock {\n  const block: HeadingBlock = {\n    type: 'heading',\n    level: parseHeadingLevel(node.tag),\n    children: extractInlineContent(node.children),\n  };\n  const alignment = parseAlignment(node.format);\n  if (alignment) {\n    block.alignment = alignment;\n  }\n  return block;\n}\n\nfunction normalizeList(node: LexicalNode): ListBlock {\n  const items: ListItemBlock[] = [];\n\n  for (const child of node.children || []) {\n    if (isListItemNode(child)) {\n      items.push({\n        type: 'listItem',\n        children: extractInlineContent(child.children),\n      });\n    }\n  }\n\n  return {\n    type: 'list',\n    ordered: node.listType === 'number',\n    children: items,\n  };\n}\n\nfunction normalizeQuote(node: LexicalNode): QuoteBlock {\n  const block: QuoteBlock = {\n    type: 'quote',\n    children: extractInlineContent(node.children),\n  };\n  const alignment = parseAlignment(node.format);\n  if (alignment) {\n    block.alignment = alignment;\n  }\n  return block;\n}\n\nfunction normalizeCode(node: LexicalNode): CodeBlock {\n  const codeText = (node.children || []).map((child) => child.text || '').join('\\n');\n\n  const block: CodeBlock = {\n    type: 'code',\n    code: codeText,\n  };\n  if (node.language) {\n    block.language = node.language;\n  }\n  return block;\n}\n\nfunction normalizeBlockNode(node: LexicalNode): Block | null {\n  if (isParagraphNode(node)) return normalizeParagraph(node);\n  if (isHeadingNode(node)) return normalizeHeading(node);\n  if (isListNode(node)) return normalizeList(node);\n  if (isQuoteNode(node)) return normalizeQuote(node);\n  if (isCodeNode(node)) return normalizeCode(node);\n  if (isLineBreakNode(node)) return { type: 'linebreak' } as LineBreakBlock;\n\n  return null;\n}\n\n// ============================================================================\n// Main Normalizer Function\n// ============================================================================\n\nfunction emptyDocument(): NormalizedDocument {\n  return { version: AST_VERSION, blocks: [] };\n}\n\n/**\n * Normalizes a Lexical editor state into the intermediate document format.\n *\n * @param editorState - The Lexical editor state (can be JSON object or string)\n * @returns NormalizedDocument ready for export\n */\nexport function normalizeEditorState(editorState: unknown): NormalizedDocument {\n  if (!editorState) {\n    return emptyDocument();\n  }\n\n  let state: LexicalEditorState;\n  try {\n    state = typeof editorState === 'string' ? JSON.parse(editorState) : editorState;\n  } catch {\n    return emptyDocument();\n  }\n\n  const rootChildren = state?.root?.children;\n  if (!Array.isArray(rootChildren)) {\n    return emptyDocument();\n  }\n\n  const blocks: Block[] = [];\n  for (const node of rootChildren) {\n    const block = normalizeBlockNode(node);\n    if (block) {\n      blocks.push(block);\n    }\n  }\n\n  return { version: AST_VERSION, blocks };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\export\\types.ts",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 89,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 89,
        "endColumn": 19
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 89,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 89,
        "endColumn": 23
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 89,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 89,
        "endColumn": 27
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 89,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 89,
        "endColumn": 31
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Export Types\n *\n * Defines the intermediate AST format used to decouple the Lexical editor\n * from export logic. This allows exporters to work with a normalized structure\n * independent of the editor implementation.\n */\n\n// ============================================================================\n// AST Version\n// ============================================================================\n\n/**\n * Current AST schema version. Increment when making breaking changes\n * to the normalized document structure.\n */\nexport const AST_VERSION = 2 as const;\n\n// ============================================================================\n// Intermediate AST Types\n// ============================================================================\n\n/**\n * Text alignment options for blocks.\n */\nexport type TextAlignment = 'left' | 'center' | 'right' | 'justify';\n\n/**\n * Text formatting flags that can be combined.\n * Mirrors Lexical's format bitmask but as explicit booleans for clarity.\n */\nexport interface TextFormatting {\n  bold?: boolean;\n  italic?: boolean;\n  underline?: boolean;\n  strikethrough?: boolean;\n  code?: boolean;\n}\n\n/**\n * Style properties for text (colors, etc).\n * Separated from formatting for clarity and extensibility.\n */\nexport interface TextStyles {\n  /** CSS color value (e.g., '#ff0000', 'rgb(255,0,0)') */\n  color?: string;\n  /** CSS background-color value for highlighting */\n  backgroundColor?: string;\n}\n\n/**\n * A run of text with consistent formatting and styling.\n */\nexport interface TextRun {\n  type: 'text';\n  text: string;\n  format: TextFormatting;\n  styles?: TextStyles;\n}\n\n/**\n * A link containing text runs.\n */\nexport interface LinkNode {\n  type: 'link';\n  url: string;\n  children: TextRun[];\n}\n\n/**\n * Inline content can be text runs or links.\n */\nexport type InlineContent = TextRun | LinkNode;\n\n/**\n * A paragraph containing inline content.\n */\nexport interface ParagraphBlock {\n  type: 'paragraph';\n  children: InlineContent[];\n  alignment?: TextAlignment;\n}\n\n/**\n * A heading with level 1-6.\n */\nexport interface HeadingBlock {\n  type: 'heading';\n  level: 1 | 2 | 3 | 4 | 5 | 6;\n  children: InlineContent[];\n  alignment?: TextAlignment;\n}\n\n/**\n * A list item containing inline content.\n */\nexport interface ListItemBlock {\n  type: 'listItem';\n  children: InlineContent[];\n}\n\n/**\n * A list (ordered or unordered) containing list items.\n */\nexport interface ListBlock {\n  type: 'list';\n  ordered: boolean;\n  children: ListItemBlock[];\n}\n\n/**\n * A block quote containing inline content.\n */\nexport interface QuoteBlock {\n  type: 'quote';\n  children: InlineContent[];\n  alignment?: TextAlignment;\n}\n\n/**\n * A code block with optional language.\n */\nexport interface CodeBlock {\n  type: 'code';\n  language?: string;\n  code: string;\n}\n\n/**\n * A line break (hard break within content).\n */\nexport interface LineBreakBlock {\n  type: 'linebreak';\n}\n\n/**\n * All possible block types in the intermediate AST.\n */\nexport type Block =\n  | ParagraphBlock\n  | HeadingBlock\n  | ListBlock\n  | QuoteBlock\n  | CodeBlock\n  | LineBreakBlock;\n\n/**\n * The normalized document structure.\n * Includes version for forward compatibility.\n */\nexport interface NormalizedDocument {\n  /** Schema version for migration support */\n  version: typeof AST_VERSION;\n  blocks: Block[];\n}\n\n// ============================================================================\n// Export Types\n// ============================================================================\n\n/**\n * Supported export formats.\n */\nexport type ExportFormat = 'pdf' | 'markdown' | 'text';\n\n/**\n * Metadata about the note being exported.\n */\nexport interface ExportMetadata {\n  title: string;\n  courseCode: string | null;\n  week: number | null;\n}\n\n/**\n * Result of an export operation.\n */\nexport interface ExportResult {\n  blob: Blob;\n  filename: string;\n  mimeType: string;\n}\n\n/**\n * Interface that all exporters must implement.\n * Uses strategy pattern for extensibility.\n */\nexport interface Exporter {\n  readonly format: ExportFormat;\n  readonly extension: string;\n  readonly mimeType: string;\n\n  /**\n   * Exports the normalized document to the target format.\n   */\n  export(document: NormalizedDocument, metadata: ExportMetadata): Promise<Blob>;\n}\n\n/**\n * Options for the export manager.\n */\nexport interface ExportOptions {\n  format: ExportFormat;\n  metadata: ExportMetadata;\n}\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\n/**\n * Error codes for export failures.\n * Enables programmatic error handling and user-friendly messages.\n */\nexport type ExportErrorCode =\n  | 'EMPTY_CONTENT'\n  | 'UNSUPPORTED_FORMAT'\n  | 'GENERATION_FAILED'\n  | 'INVALID_INPUT';\n\n/**\n * Structured export error with code and user-friendly message.\n */\nexport class ExportError extends Error {\n  readonly code: ExportErrorCode;\n  readonly userMessage: string;\n\n  constructor(code: ExportErrorCode, userMessage: string, technicalMessage?: string) {\n    super(technicalMessage ?? userMessage);\n    this.name = 'ExportError';\n    this.code = code;\n    this.userMessage = userMessage;\n  }\n\n  /** User-friendly error messages by code */\n  static readonly messages: Record<ExportErrorCode, string> = {\n    EMPTY_CONTENT: 'Cannot export an empty note. Add some content first.',\n    UNSUPPORTED_FORMAT: 'This export format is not supported.',\n    GENERATION_FAILED: 'Failed to generate the export file. Please try again.',\n    INVALID_INPUT: 'The note content is invalid or corrupted.',\n  };\n\n  static empty(): ExportError {\n    return new ExportError('EMPTY_CONTENT', this.messages.EMPTY_CONTENT);\n  }\n\n  static unsupportedFormat(format: string): ExportError {\n    return new ExportError(\n      'UNSUPPORTED_FORMAT',\n      `Export format \"${format}\" is not supported.`,\n      `Unsupported export format: ${format}`,\n    );\n  }\n\n  static generationFailed(format: string, cause?: unknown): ExportError {\n    const causeMessage = cause instanceof Error ? cause.message : String(cause);\n    return new ExportError(\n      'GENERATION_FAILED',\n      `Failed to generate ${format.toUpperCase()} file. Please try again.`,\n      `Export generation failed for ${format}: ${causeMessage}`,\n    );\n  }\n\n  static invalidInput(): ExportError {\n    return new ExportError('INVALID_INPUT', this.messages.INVALID_INPUT);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\nodes\\AttachmentNode.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "Imports \"LexicalNode\" and \"NodeKey\" are only used as type.",
        "line": 1,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "messageId": "someImportsAreOnlyTypes",
        "endLine": 1,
        "endColumn": 63,
        "fix": {
          "range": [0, 44],
          "text": "import type { LexicalNode, NodeKey } from 'lexical';\nimport { DecoratorNode"
        }
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 12,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 12,
        "endColumn": 23
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Constructor has too many parameters (5). Maximum allowed is 4.",
        "line": 56,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 56,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 106,
        "column": 56,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 106,
        "endColumn": 71,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2503, 2518], "text": "(this.__fileName.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2503, 2518], "text": "(this.__fileName !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2503, 2518], "text": "(Boolean(this.__fileName))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 107,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 107,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2552, 2567], "text": "(this.__mimeType != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2552, 2567], "text": "(this.__mimeType ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2552, 2567], "text": "(Boolean(this.__mimeType))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { DecoratorNode, LexicalNode, NodeKey } from 'lexical';\n\nexport type SerializedAttachmentNode = {\n  type: 'attachment';\n  version: 1;\n  href: string;\n  fileName: string;\n  mimeType?: string | null;\n  assetId?: string | null;\n};\n\nfunction PaperclipIcon() {\n  return (\n    <svg\n      aria-hidden=\"true\"\n      focusable=\"false\"\n      width=\"14\"\n      height=\"14\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <path d=\"M21.44 11.05l-9.19 9.19a5 5 0 0 1-7.07-7.07l9.19-9.19a3 3 0 0 1 4.24 4.24l-9.2 9.19\" />\n    </svg>\n  );\n}\n\nexport class AttachmentNode extends DecoratorNode<JSX.Element> {\n  __href: string;\n  __fileName: string;\n  __mimeType: string | null;\n  __assetId: string | null;\n\n  static override getType(): string {\n    return 'attachment';\n  }\n\n  static override clone(node: AttachmentNode): AttachmentNode {\n    return new AttachmentNode(\n      node.__href,\n      node.__fileName,\n      node.__mimeType,\n      node.__assetId,\n      node.getKey(),\n    );\n  }\n\n  static override importJSON(serializedNode: SerializedAttachmentNode): AttachmentNode {\n    const { href, fileName, mimeType, assetId } = serializedNode;\n    return new AttachmentNode(href, fileName, mimeType, assetId);\n  }\n\n  constructor(\n    href: string,\n    fileName: string,\n    mimeType?: string | null,\n    assetId?: string | null,\n    key?: NodeKey,\n  ) {\n    super(key);\n    this.__href = href;\n    this.__fileName = fileName;\n    this.__mimeType = mimeType ?? null;\n    this.__assetId = assetId ?? null;\n  }\n\n  getAssetId(): string | null {\n    return this.__assetId;\n  }\n\n  override exportJSON(): SerializedAttachmentNode {\n    return {\n      type: 'attachment',\n      version: 1,\n      href: this.__href,\n      fileName: this.__fileName,\n      mimeType: this.__mimeType,\n      assetId: this.__assetId,\n    };\n  }\n\n  override createDOM(): HTMLElement {\n    const container = document.createElement('span');\n    container.className = 'lockin-note-attachment-wrapper';\n    return container;\n  }\n\n  override updateDOM(): false {\n    return false;\n  }\n\n  override decorate(): JSX.Element {\n    return (\n      <a\n        href={this.__href}\n        target=\"_blank\"\n        rel=\"noreferrer\"\n        className=\"lockin-note-attachment-chip\"\n      >\n        <span className=\"lockin-note-attachment-chip-icon\">\n          <PaperclipIcon />\n        </span>\n        <span className=\"lockin-note-attachment-name\">{this.__fileName || 'Attachment'}</span>\n        {this.__mimeType ? (\n          <span className=\"lockin-note-attachment-meta\">{this.__mimeType}</span>\n        ) : null}\n      </a>\n    );\n  }\n}\n\nexport function $createAttachmentNode(params: {\n  href: string;\n  fileName: string;\n  mimeType?: string | null;\n  assetId?: string | null;\n}): AttachmentNode {\n  return new AttachmentNode(\n    params.href,\n    params.fileName,\n    params.mimeType ?? null,\n    params.assetId ?? null,\n  );\n}\n\nexport function $isAttachmentNode(node: LexicalNode | null | undefined): node is AttachmentNode {\n  return node instanceof AttachmentNode;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\nodes\\ImageNode.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "Imports \"LexicalEditor\", \"LexicalNode\" and \"NodeKey\" are only used as type.",
        "line": 3,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "messageId": "someImportsAreOnlyTypes",
        "endLine": 13,
        "endColumn": 18,
        "fix": {
          "range": [130, 303],
          "text": "import type {\n  LexicalEditor,\n  LexicalNode,\n  NodeKey} from 'lexical';\nimport {\n  $getNodeByKey,\n  CLICK_COMMAND,\n  COMMAND_PRIORITY_LOW,\n  DecoratorNode,\n  KEY_BACKSPACE_COMMAND,\n  KEY_DELETE_COMMAND"
        }
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 48.",
        "line": 43,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 43,
        "endColumn": 44
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'ResizableImage' has too many lines (291). Maximum allowed is 50.",
        "line": 50,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 380,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 50,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 50,
        "endColumn": 24
      },
      {
        "ruleId": "eqeqeq",
        "severity": 1,
        "message": "Expected '!==' and instead saw '!='.",
        "line": 90,
        "column": 15,
        "nodeType": "BinaryExpression",
        "messageId": "unexpected",
        "endLine": 90,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "replaceOperator",
            "data": { "expectedOperator": "!==", "actualOperator": "!=" },
            "fix": { "range": [2435, 2437], "text": "!==" },
            "desc": "Use '!==' instead of '!='."
          }
        ]
      },
      {
        "ruleId": "eqeqeq",
        "severity": 1,
        "message": "Expected '!==' and instead saw '!='.",
        "line": 90,
        "column": 33,
        "nodeType": "BinaryExpression",
        "messageId": "unexpected",
        "endLine": 90,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "replaceOperator",
            "data": { "expectedOperator": "!==", "actualOperator": "!=" },
            "fix": { "range": [2453, 2455], "text": "!==" },
            "desc": "Use '!==' instead of '!='."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 95,
        "column": 22,
        "nodeType": "BinaryExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 95,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCompareZero",
            "fix": { "range": [2566, 2580], "text": "((width / height) !== 0)" },
            "desc": "Change condition to check for 0 (`value !== 0`)"
          },
          {
            "messageId": "conditionFixCompareNaN",
            "fix": { "range": [2566, 2580], "text": "(!Number.isNaN((width / height)))" },
            "desc": "Change condition to check for NaN (`!Number.isNaN(value)`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2566, 2580], "text": "(Boolean((width / height)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 102,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 102,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 122,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 122,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3345, 3349], "text": "img == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 125,
        "column": 25,
        "nodeType": "BinaryExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 125,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "conditionFixCompareZero",
            "fix": { "range": [3433, 3461], "text": "((naturalWidth / naturalHeight) !== 0)" },
            "desc": "Change condition to check for 0 (`value !== 0`)"
          },
          {
            "messageId": "conditionFixCompareNaN",
            "fix": {
              "range": [3433, 3461],
              "text": "(!Number.isNaN((naturalWidth / naturalHeight)))"
            },
            "desc": "Change condition to check for NaN (`!Number.isNaN(value)`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3433, 3461], "text": "(Boolean((naturalWidth / naturalHeight)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "eqeqeq",
        "severity": 1,
        "message": "Expected '===' and instead saw '=='.",
        "line": 140,
        "column": 15,
        "nodeType": "BinaryExpression",
        "messageId": "unexpected",
        "endLine": 140,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "replaceOperator",
            "data": { "expectedOperator": "===", "actualOperator": "==" },
            "fix": { "range": [3896, 3898], "text": "===" },
            "desc": "Use '===' instead of '=='."
          }
        ]
      },
      {
        "ruleId": "eqeqeq",
        "severity": 1,
        "message": "Expected '===' and instead saw '=='.",
        "line": 140,
        "column": 33,
        "nodeType": "BinaryExpression",
        "messageId": "unexpected",
        "endLine": 140,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "replaceOperator",
            "data": { "expectedOperator": "===", "actualOperator": "==" },
            "fix": { "range": [3914, 3916], "text": "===" },
            "desc": "Use '===' instead of '=='."
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (66). Maximum allowed is 50.",
        "line": 167,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 246,
        "endColumn": 6
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 184,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 184,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 231,
        "column": 51,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 231,
        "endColumn": 53
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (52). Maximum allowed is 50.",
        "line": 251,
        "column": 13,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 303,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 256,
        "column": 15,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 256,
        "endColumn": 74,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": {
              "range": [7504, 7563],
              "text": "(containerRef.current?.contains(event.target as HTMLElement)) ?? false"
            },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": {
              "range": [7504, 7563],
              "text": "(containerRef.current?.contains(event.target as HTMLElement)) === true"
            },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 258,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 258,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7639, 7669], "text": "target.dataset['resizeHandle'] != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7639, 7669], "text": "target.dataset['resizeHandle'] ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7639, 7669], "text": "Boolean(target.dataset['resizeHandle'])" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 319,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 319,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [9173, 9176], "text": "(alt.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [9173, 9176], "text": "(alt !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [9173, 9176], "text": "(Boolean(alt))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (431). Maximum allowed is 300.",
        "line": 352,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 500,
        "endColumn": 1
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Constructor has too many parameters (6). Maximum allowed is 4.",
        "line": 411,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 411,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 21,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useCallback, useEffect, useRef, useState } from 'react';\nimport type { PointerEvent as ReactPointerEvent } from 'react';\nimport {\n  $getNodeByKey,\n  CLICK_COMMAND,\n  COMMAND_PRIORITY_LOW,\n  DecoratorNode,\n  KEY_BACKSPACE_COMMAND,\n  KEY_DELETE_COMMAND,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n} from 'lexical';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useLexicalNodeSelection } from '@lexical/react/useLexicalNodeSelection';\nimport { mergeRegister } from '@lexical/utils';\n\nexport type SerializedImageNode = {\n  type: 'image';\n  version: 1;\n  src: string;\n  alt: string;\n  assetId?: string | null;\n  width?: number | null;\n  height?: number | null;\n};\n\n// Constants\nconst DEFAULT_WIDTH = 320;\nconst MIN_WIDTH = 80;\nconst MAX_WIDTH = 960;\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max);\n}\n\nfunction getMaxWidth(editor: LexicalEditor): number {\n  const root = editor.getRootElement();\n  const scrollContainer = root?.closest('.lockin-note-editor-scroll') as HTMLElement | null;\n  const container = scrollContainer ?? root?.parentElement;\n  const measured = container?.getBoundingClientRect().width ?? 0;\n  // Account for padding: 24px left + 24px right\n  return measured > 0 ? clamp(measured - 48, MIN_WIDTH, MAX_WIDTH) : MAX_WIDTH;\n}\n\n/**\n * ResizableImage component for Lexical editor\n * Industry-standard resize behavior with corner handles only\n */\nfunction ResizableImage({\n  src,\n  alt,\n  nodeKey,\n  assetId,\n  width,\n  height,\n}: {\n  src: string;\n  alt: string;\n  nodeKey: NodeKey;\n  assetId?: string | null;\n  width?: number | null;\n  height?: number | null;\n}) {\n  const [editor] = useLexicalComposerContext();\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection(nodeKey);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const imageRef = useRef<HTMLImageElement>(null);\n\n  // Dimensions state\n  const [dimensions, setDimensions] = useState({\n    width: width ?? DEFAULT_WIDTH,\n    height: height ?? DEFAULT_WIDTH,\n    aspectRatio: 1,\n    maxWidth: MAX_WIDTH,\n  });\n  const [isResizing, setIsResizing] = useState(false);\n\n  // Ref for resize calculations (avoids stale closures)\n  const resizeRef = useRef({\n    startX: 0,\n    startY: 0,\n    startWidth: 0,\n    aspectRatio: 1,\n    maxWidth: MAX_WIDTH,\n  });\n\n  // Sync with prop changes\n  useEffect(() => {\n    if (width != null && height != null) {\n      setDimensions((prev) => ({\n        ...prev,\n        width,\n        height,\n        aspectRatio: width / height || 1,\n      }));\n    }\n  }, [width, height]);\n\n  // Recalculate max width on window resize\n  useEffect(() => {\n    const updateMaxWidth = () => {\n      const maxWidth = getMaxWidth(editor);\n      setDimensions((prev) => {\n        const newWidth = clamp(prev.width, MIN_WIDTH, maxWidth);\n        return {\n          ...prev,\n          maxWidth,\n          width: newWidth,\n          height: newWidth / prev.aspectRatio,\n        };\n      });\n    };\n    updateMaxWidth();\n    window.addEventListener('resize', updateMaxWidth);\n    return () => window.removeEventListener('resize', updateMaxWidth);\n  }, [editor]);\n\n  // Handle image load - set initial dimensions from natural size\n  const handleImageLoad = useCallback(() => {\n    const img = imageRef.current;\n    if (!img) return;\n\n    const { naturalWidth, naturalHeight } = img;\n    const aspectRatio = naturalWidth / naturalHeight || 1;\n    const maxWidth = getMaxWidth(editor);\n\n    // Use saved dimensions or calculate from natural size\n    const targetWidth = width ?? clamp(Math.min(naturalWidth, maxWidth), MIN_WIDTH, maxWidth);\n    const targetHeight = height ?? targetWidth / aspectRatio;\n\n    setDimensions({\n      width: targetWidth,\n      height: targetHeight,\n      aspectRatio,\n      maxWidth,\n    });\n\n    // Persist if not already saved\n    if (width == null || height == null) {\n      editor.update(() => {\n        const node = $getNodeByKey(nodeKey);\n        if ($isImageNode(node)) {\n          node.setWidth(targetWidth);\n          node.setHeight(targetHeight);\n        }\n      });\n    }\n  }, [editor, nodeKey, width, height]);\n\n  // Commit dimensions to Lexical node\n  const commitDimensions = useCallback(\n    (w: number, h: number) => {\n      editor.update(() => {\n        const node = $getNodeByKey(nodeKey);\n        if ($isImageNode(node)) {\n          node.setWidth(w);\n          node.setHeight(h);\n        }\n      });\n    },\n    [editor, nodeKey],\n  );\n\n  // Handle corner resize with pointer capture for smooth dragging\n  const handleResizeStart = useCallback(\n    (e: ReactPointerEvent, corner: string) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      const target = e.target as HTMLElement;\n      target.setPointerCapture(e.pointerId);\n\n      const maxWidth = getMaxWidth(editor);\n      resizeRef.current = {\n        startX: e.clientX,\n        startY: e.clientY,\n        startWidth: dimensions.width,\n        aspectRatio: dimensions.aspectRatio,\n        maxWidth,\n      };\n      setIsResizing(true);\n\n      const onPointerMove = (moveEvent: PointerEvent) => {\n        const { startX, startY, startWidth, aspectRatio, maxWidth } = resizeRef.current;\n        const deltaX = moveEvent.clientX - startX;\n        const deltaY = moveEvent.clientY - startY;\n\n        // Calculate new width based on handle being dragged\n        let widthDelta = 0;\n        switch (corner) {\n          // Corner handles (diagonal movement)\n          case 'se':\n            widthDelta = Math.max(deltaX, deltaY * aspectRatio);\n            break;\n          case 'sw':\n            widthDelta = Math.max(-deltaX, deltaY * aspectRatio);\n            break;\n          case 'ne':\n            widthDelta = Math.max(deltaX, -deltaY * aspectRatio);\n            break;\n          case 'nw':\n            widthDelta = Math.max(-deltaX, -deltaY * aspectRatio);\n            break;\n          // Horizontal edge handles\n          case 'e':\n            widthDelta = deltaX;\n            break;\n          case 'w':\n            widthDelta = -deltaX;\n            break;\n          // Vertical edge handles (convert Y to width via aspect ratio)\n          case 's':\n            widthDelta = deltaY * aspectRatio;\n            break;\n          case 'n':\n            widthDelta = -deltaY * aspectRatio;\n            break;\n        }\n\n        const newWidth = clamp(startWidth + widthDelta, MIN_WIDTH, maxWidth);\n        const newHeight = newWidth / aspectRatio;\n\n        setDimensions((prev) => ({\n          ...prev,\n          width: newWidth,\n          height: newHeight,\n        }));\n      };\n\n      const onPointerUp = (upEvent: PointerEvent) => {\n        target.releasePointerCapture(upEvent.pointerId);\n        document.removeEventListener('pointermove', onPointerMove);\n        document.removeEventListener('pointerup', onPointerUp);\n        setIsResizing(false);\n\n        // Get final dimensions from ref to avoid stale closure\n        setDimensions((current) => {\n          commitDimensions(current.width, current.height);\n          return current;\n        });\n      };\n\n      document.addEventListener('pointermove', onPointerMove);\n      document.addEventListener('pointerup', onPointerUp);\n    },\n    [editor, dimensions.width, dimensions.aspectRatio, commitDimensions],\n  );\n\n  // Lexical command handlers for click and keyboard\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        CLICK_COMMAND,\n        (event: MouseEvent) => {\n          if (containerRef.current?.contains(event.target as HTMLElement)) {\n            const target = event.target as HTMLElement;\n            if (target.dataset['resizeHandle']) return false;\n\n            if (event.shiftKey) {\n              setSelected(!isSelected);\n            } else {\n              clearSelection();\n              setSelected(true);\n            }\n            return true;\n          }\n          return false;\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        KEY_DELETE_COMMAND,\n        (e) => {\n          if (isSelected) {\n            e?.preventDefault();\n            editor.update(() => {\n              const node = $getNodeByKey(nodeKey);\n              if ($isImageNode(node)) node.remove();\n            });\n            return true;\n          }\n          return false;\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        KEY_BACKSPACE_COMMAND,\n        (e) => {\n          if (isSelected) {\n            e?.preventDefault();\n            editor.update(() => {\n              const node = $getNodeByKey(nodeKey);\n              if ($isImageNode(node)) node.remove();\n            });\n            return true;\n          }\n          return false;\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    );\n  }, [editor, isSelected, nodeKey, setSelected, clearSelection]);\n\n  const containerClass = [\n    'lockin-image-container',\n    isSelected && 'is-selected',\n    isResizing && 'is-resizing',\n  ]\n    .filter(Boolean)\n    .join(' ');\n\n  return (\n    <div\n      ref={containerRef}\n      className={containerClass}\n      style={{ width: dimensions.width }}\n      role=\"figure\"\n      aria-label={alt || 'Image'}\n      data-asset-id={assetId ?? undefined}\n    >\n      <img\n        ref={imageRef}\n        src={src}\n        alt={alt}\n        className=\"lockin-image\"\n        draggable={false}\n        onLoad={handleImageLoad}\n      />\n\n      {/* Resize handles - only show when selected */}\n      {isSelected && (\n        <>\n          {/* Corner handles */}\n          <div\n            className=\"lockin-resize-handle corner nw\"\n            data-resize-handle=\"nw\"\n            onPointerDown={(e) => handleResizeStart(e, 'nw')}\n          />\n          <div\n            className=\"lockin-resize-handle corner ne\"\n            data-resize-handle=\"ne\"\n            onPointerDown={(e) => handleResizeStart(e, 'ne')}\n          />\n          <div\n            className=\"lockin-resize-handle corner sw\"\n            data-resize-handle=\"sw\"\n            onPointerDown={(e) => handleResizeStart(e, 'sw')}\n          />\n          <div\n            className=\"lockin-resize-handle corner se\"\n            data-resize-handle=\"se\"\n            onPointerDown={(e) => handleResizeStart(e, 'se')}\n          />\n          {/* Edge handles */}\n          <div\n            className=\"lockin-resize-handle edge n\"\n            data-resize-handle=\"n\"\n            onPointerDown={(e) => handleResizeStart(e, 'n')}\n          />\n          <div\n            className=\"lockin-resize-handle edge s\"\n            data-resize-handle=\"s\"\n            onPointerDown={(e) => handleResizeStart(e, 's')}\n          />\n          <div\n            className=\"lockin-resize-handle edge e\"\n            data-resize-handle=\"e\"\n            onPointerDown={(e) => handleResizeStart(e, 'e')}\n          />\n          <div\n            className=\"lockin-resize-handle edge w\"\n            data-resize-handle=\"w\"\n            onPointerDown={(e) => handleResizeStart(e, 'w')}\n          />\n        </>\n      )}\n    </div>\n  );\n}\n\n// --- Lexical Node Class ---\n\nexport class ImageNode extends DecoratorNode<JSX.Element> {\n  __src: string;\n  __alt: string;\n  __assetId: string | null;\n  __width: number | null;\n  __height: number | null;\n\n  static override getType(): string {\n    return 'image';\n  }\n\n  static override clone(node: ImageNode): ImageNode {\n    return new ImageNode(\n      node.__src,\n      node.__alt,\n      node.__assetId,\n      node.__width,\n      node.__height,\n      node.getKey(),\n    );\n  }\n\n  static override importJSON(serializedNode: SerializedImageNode): ImageNode {\n    const { src, alt, assetId, width = null, height = null } = serializedNode;\n    return new ImageNode(src, alt, assetId, width, height);\n  }\n\n  constructor(\n    src: string,\n    alt = '',\n    assetId?: string | null,\n    width?: number | null,\n    height?: number | null,\n    key?: NodeKey,\n  ) {\n    super(key);\n    this.__src = src;\n    this.__alt = alt;\n    this.__assetId = assetId ?? null;\n    this.__width = width ?? null;\n    this.__height = height ?? null;\n  }\n\n  getAssetId(): string | null {\n    return this.__assetId;\n  }\n\n  getWidth(): number | null {\n    return this.__width ?? null;\n  }\n\n  setWidth(width: number | null): void {\n    const self = this.getWritable();\n    self.__width = width;\n  }\n\n  setHeight(height: number | null): void {\n    const self = this.getWritable();\n    self.__height = height;\n  }\n\n  override exportJSON(): SerializedImageNode {\n    return {\n      type: 'image',\n      version: 1,\n      src: this.__src,\n      alt: this.__alt,\n      assetId: this.__assetId,\n      width: this.__width ?? null,\n      height: this.__height ?? null,\n    };\n  }\n\n  override createDOM(): HTMLElement {\n    const span = document.createElement('span');\n    span.className = 'lockin-image-wrapper';\n    return span;\n  }\n\n  override updateDOM(): false {\n    return false;\n  }\n\n  override decorate(): JSX.Element {\n    return (\n      <ResizableImage\n        src={this.__src}\n        alt={this.__alt}\n        assetId={this.__assetId}\n        nodeKey={this.getKey()}\n        width={this.__width}\n        height={this.__height}\n      />\n    );\n  }\n}\n\nexport function $createImageNode(params: {\n  src: string;\n  alt?: string;\n  assetId?: string | null;\n  width?: number | null;\n  height?: number | null;\n}): ImageNode {\n  return new ImageNode(\n    params.src,\n    params.alt ?? '',\n    params.assetId ?? null,\n    params.width ?? null,\n    params.height ?? null,\n  );\n}\n\nexport function $isImageNode(node: LexicalNode | null | undefined): node is ImageNode {\n  return node instanceof ImageNode;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\panel\\NotesListItem.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'NotesListItem' has too many lines (82). Maximum allowed is 50.",
        "line": 5,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 86,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 5,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 5,
        "endColumn": 30
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Function 'NotesListItem' has a complexity of 16. Maximum allowed is 15.",
        "line": 5,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "complex",
        "endLine": 5,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 22,
        "column": 68,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 22,
        "endColumn": 82,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [539, 553], "text": "(note.isStarred ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [539, 553], "text": "(note.isStarred === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 34,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 34,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [877, 891], "text": "(note.isStarred ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [877, 891], "text": "(note.isStarred === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 43,
        "column": 52,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 43,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1170, 1180], "text": "(note.title.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1170, 1180], "text": "(note.title !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1170, 1180], "text": "(Boolean(note.title))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 46,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 46,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1279, 1286], "text": "(note.id != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1279, 1286], "text": "(note.id ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1279, 1286], "text": "(Boolean(note.id))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 51,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 51,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1451, 1465], "text": "(note.isStarred ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1451, 1465], "text": "(note.isStarred === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 54,
        "column": 24,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 54,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1569, 1583], "text": "(note.isStarred ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1569, 1583], "text": "(note.isStarred === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 55,
        "column": 29,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 55,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1643, 1657], "text": "(note.isStarred ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1643, 1657], "text": "(note.isStarred === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 57,
        "column": 55,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 57,
        "endColumn": 69,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1759, 1773], "text": "(note.isStarred ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1759, 1773], "text": "(note.isStarred === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 77,
        "column": 8,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 77,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2420, 2435], "text": "(note.courseCode != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2420, 2435], "text": "(note.courseCode ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2420, 2435], "text": "(Boolean(note.courseCode))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 79,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 79,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2559, 2575], "text": "(note.previewText != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2559, 2575], "text": "(note.previewText ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2559, 2575], "text": "(Boolean(note.previewText))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 79,
        "column": 30,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 79,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2579, 2602], "text": "((note.content?.plainText) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2579, 2602], "text": "((note.content?.plainText) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2579, 2602], "text": "(Boolean((note.content?.plainText)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 82,
        "column": 32,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 82,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2710, 2724], "text": "(note.updatedAt != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2710, 2724], "text": "(note.updatedAt ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2710, 2724], "text": "(Boolean(note.updatedAt))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 15,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Star, Trash2 } from 'lucide-react';\nimport type { Note } from '@core/domain/Note';\nimport { relativeLabel } from '../utils/relativeTime';\n\nexport function NotesListItem({\n  note,\n  isActive,\n  onSelect,\n  onToggleStar,\n  onDeleteNote,\n  isDeleting,\n}: {\n  note: Note;\n  isActive: boolean;\n  onSelect: () => void;\n  onToggleStar: (event: React.MouseEvent) => void;\n  onDeleteNote: (event: React.MouseEvent) => void;\n  isDeleting: boolean;\n}) {\n  return (\n    <div\n      className={`lockin-note-card${isActive ? ' is-active' : ''}${note.isStarred ? ' is-starred' : ''}`}\n      onClick={onSelect}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => {\n        if (e.key === 'Enter' || e.key === ' ') {\n          onSelect();\n        }\n      }}\n    >\n      <div className=\"lockin-note-card-header\">\n        <div className=\"lockin-note-card-title-row\">\n          {note.isStarred && (\n            <Star\n              className=\"lockin-note-star-indicator\"\n              size={14}\n              strokeWidth={2}\n              fill=\"currentColor\"\n              aria-label=\"Starred\"\n            />\n          )}\n          <div className=\"lockin-note-card-title\">{note.title || 'Untitled'}</div>\n        </div>\n        <div className=\"lockin-note-card-actions\">\n          {note.id && (\n            <>\n              <button\n                type=\"button\"\n                className={`lockin-note-action-btn lockin-note-star-btn${\n                  note.isStarred ? ' is-starred' : ''\n                }`}\n                onClick={onToggleStar}\n                title={note.isStarred ? 'Unstar note' : 'Star note'}\n                aria-label={note.isStarred ? 'Unstar note' : 'Star note'}\n              >\n                <Star size={14} strokeWidth={2} fill={note.isStarred ? 'currentColor' : 'none'} />\n              </button>\n              <button\n                type=\"button\"\n                className=\"lockin-note-action-btn lockin-note-delete-btn\"\n                onClick={onDeleteNote}\n                disabled={isDeleting}\n                title=\"Delete note\"\n                aria-label=\"Delete note\"\n              >\n                {isDeleting ? (\n                  <span className=\"lockin-inline-spinner\" aria-hidden=\"true\" />\n                ) : (\n                  <Trash2 size={14} strokeWidth={2} />\n                )}\n              </button>\n            </>\n          )}\n        </div>\n      </div>\n      {note.courseCode && <span className=\"lockin-note-badge\">{note.courseCode}</span>}\n      <div className=\"lockin-note-card-snippet\">\n        {note.previewText || note.content?.plainText || 'No content'}\n      </div>\n      <div className=\"lockin-note-card-meta\">\n        Updated {relativeLabel(note.updatedAt || note.createdAt)}\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\panel\\NotesListView.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'NotesListView' has too many lines (91). Maximum allowed is 50.",
        "line": 4,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 95,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 4,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 4,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 80,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 80,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2610, 2617], "text": "(item.id != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2610, 2617], "text": "(item.id ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2610, 2617], "text": "(Boolean(item.id))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 82,
        "column": 27,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 82,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2684, 2692], "text": "(item.id == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2685, 2692], "text": "(item.id ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2684, 2692], "text": "(!Boolean(item.id))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 84,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 84,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2815, 2822], "text": "(item.id != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2815, 2822], "text": "(item.id ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2815, 2822], "text": "(Boolean(item.id))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 85,
        "column": 40,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 85,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2872, 2879], "text": "(item.id != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2872, 2879], "text": "(item.id ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2872, 2879], "text": "(Boolean(item.id))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 87,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 87,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2968, 2975], "text": "(item.id != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2968, 2975], "text": "(item.id ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2968, 2975], "text": "(Boolean(item.id))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 87,
        "column": 50,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 87,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3001, 3011], "text": "(item.title.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3001, 3011], "text": "(item.title !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3001, 3011], "text": "(Boolean(item.title))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Note } from '@core/domain/Note';\nimport { NotesListItem } from './NotesListItem';\n\nexport function NotesListView({\n  notesLoading,\n  filter,\n  onFilterChange,\n  search,\n  onSearchChange,\n  onRefreshNotes,\n  filteredNotes,\n  activeNoteId,\n  onSelectNote,\n  onToggleStar,\n  onDeleteNote,\n  isDeleting,\n  onCreateNote,\n}: {\n  notesLoading: boolean;\n  filter: 'course' | 'all' | 'starred';\n  onFilterChange: (value: 'course' | 'all' | 'starred') => void;\n  search: string;\n  onSearchChange: (value: string) => void;\n  onRefreshNotes: () => void;\n  filteredNotes: Note[];\n  activeNoteId: string | null;\n  onSelectNote: (noteId: string | null) => void;\n  onToggleStar: (noteId: string, event: React.MouseEvent) => void;\n  onDeleteNote: (noteId: string, title: string, event: React.MouseEvent) => void;\n  isDeleting: string | null;\n  onCreateNote: () => void;\n}) {\n  return (\n    <div className=\"lockin-notes-list-container\">\n      <div className=\"lockin-notes-filter-bar\">\n        <div className=\"lockin-notes-filter-group\">\n          <span className=\"lockin-notes-filter-label\">Filter</span>\n          <select\n            className=\"lockin-notes-filter-select\"\n            value={filter}\n            onChange={(e) => onFilterChange(e.target.value as typeof filter)}\n          >\n            <option value=\"course\">This course</option>\n            <option value=\"all\">All notes</option>\n            <option value=\"starred\">Starred</option>\n          </select>\n        </div>\n        <input\n          type=\"text\"\n          className=\"lockin-notes-search-input\"\n          placeholder=\"Search notes\"\n          value={search}\n          onChange={(e) => onSearchChange(e.target.value)}\n        />\n        <button type=\"button\" className=\"lockin-btn-ghost\" onClick={onRefreshNotes}>\n          Refresh\n        </button>\n      </div>\n\n      <div className=\"lockin-notes-list\">\n        {notesLoading ? (\n          <div className=\"lockin-notes-empty\">Loading notes...</div>\n        ) : filteredNotes.length === 0 ? (\n          <div className=\"lockin-notes-empty\">\n            <div className=\"lockin-notes-empty-title\">No notes yet</div>\n            <div className=\"lockin-notes-empty-subtitle\">\n              Capture a note from the current page to see it here.\n            </div>\n            <button\n              type=\"button\"\n              className=\"lockin-btn-ghost lockin-notes-empty-btn\"\n              onClick={onCreateNote}\n            >\n              Create a note\n            </button>\n          </div>\n        ) : (\n          filteredNotes.map((item) => (\n            <NotesListItem\n              key={item.id || item.title}\n              note={item}\n              isActive={!!item.id && item.id === activeNoteId}\n              isDeleting={isDeleting === item.id}\n              onSelect={() => onSelectNote(item.id || null)}\n              onToggleStar={(event) => item.id && onToggleStar(item.id, event)}\n              onDeleteNote={(event) =>\n                item.id && onDeleteNote(item.id, item.title || 'Untitled', event)\n              }\n            />\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\panel\\NotesPanelHeader.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'NotesPanelHeader' has too many lines (108). Maximum allowed is 50.",
        "line": 5,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 114,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 5,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 5,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 41,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 41,
        "endColumn": 68,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1116, 1126], "text": "(courseCode != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1116, 1126], "text": "(courseCode ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1116, 1126], "text": "(Boolean(courseCode))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 43,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 43,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1171, 1180], "text": "(weekLabel != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1171, 1180], "text": "(weekLabel ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1171, 1180], "text": "(Boolean(weekLabel))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 47,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 47,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1338, 1350], "text": "(linkedTarget != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1338, 1350], "text": "(linkedTarget ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1338, 1350], "text": "(Boolean(linkedTarget))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 80,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 80,
        "endColumn": 71,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2355, 2368], "text": "(onExportError != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Star, Trash2 } from 'lucide-react';\nimport type { Note } from '@core/domain/Note';\nimport { ExportDropdown } from '../export';\n\nexport function NotesPanelHeader({\n  courseCode,\n  weekLabel,\n  linkedTarget,\n  view,\n  onViewChange,\n  showActions,\n  isStarred,\n  isDeleting,\n  onToggleStar,\n  onDeleteNote,\n  onNewNote,\n  note,\n  week,\n  onExportError,\n}: {\n  courseCode: string | null;\n  weekLabel: string | null;\n  linkedTarget: string | null;\n  view: 'current' | 'all';\n  onViewChange: (view: 'current' | 'all') => void;\n  showActions: boolean;\n  isStarred: boolean;\n  isDeleting: boolean;\n  onToggleStar: (event: React.MouseEvent) => void;\n  onDeleteNote: (event: React.MouseEvent) => void;\n  onNewNote: () => void;\n  note: Note | null;\n  week: number | null;\n  onExportError?: (error: string) => void;\n}) {\n  return (\n    <header className=\"lockin-notes-header lockin-notes-header-row\">\n      <div className=\"lockin-notes-header-left\">\n        <div className=\"lockin-notes-course-row\">\n          <span className=\"lockin-notes-label\">Course:</span>\n          <strong className=\"lockin-notes-course-value\">{courseCode || 'None'}</strong>\n        </div>\n        {weekLabel && (\n          <div className=\"lockin-notes-link-row\">\n            <span className=\"lockin-notes-label\">Linked to:</span>\n            <a\n              href={linkedTarget || '#'}\n              target=\"_blank\"\n              rel=\"noreferrer\"\n              className=\"lockin-notes-link-href\"\n            >\n              {weekLabel}\n            </a>\n          </div>\n        )}\n      </div>\n\n      <div className=\"lockin-notes-header-center\">\n        <div className=\"lockin-notes-toggle\">\n          <button\n            type=\"button\"\n            className={`lockin-notes-toggle-btn${view === 'current' ? ' is-active' : ''}`}\n            onClick={() => onViewChange('current')}\n          >\n            Current\n          </button>\n          <button\n            type=\"button\"\n            className={`lockin-notes-toggle-btn${view === 'all' ? ' is-active' : ''}`}\n            onClick={() => onViewChange('all')}\n          >\n            All notes\n          </button>\n        </div>\n      </div>\n\n      <div className=\"lockin-notes-header-right\">\n        {showActions && (\n          <div className=\"lockin-notes-header-actions\">\n            <ExportDropdown note={note} week={week} {...(onExportError ? { onExportError } : {})} />\n            <button\n              type=\"button\"\n              className={`lockin-note-action-btn lockin-note-star-btn${\n                isStarred ? ' is-starred' : ''\n              }`}\n              onClick={onToggleStar}\n              title={isStarred ? 'Unstar note' : 'Star note'}\n              aria-label={isStarred ? 'Unstar note' : 'Star note'}\n            >\n              <Star size={16} strokeWidth={2} fill={isStarred ? 'currentColor' : 'none'} />\n            </button>\n            <button\n              type=\"button\"\n              className=\"lockin-note-action-btn lockin-note-delete-btn\"\n              onClick={onDeleteNote}\n              disabled={isDeleting}\n              title=\"Delete note\"\n              aria-label=\"Delete note\"\n            >\n              {isDeleting ? (\n                <span className=\"lockin-inline-spinner\" aria-hidden=\"true\" />\n              ) : (\n                <Trash2 size={16} strokeWidth={2} />\n              )}\n            </button>\n          </div>\n        )}\n        <button type=\"button\" className=\"lockin-btn-primary\" onClick={onNewNote}>\n          + New note\n        </button>\n      </div>\n    </header>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\panel\\noteFilters.ts",
    "messages": [
      {
        "ruleId": "eqeqeq",
        "severity": 1,
        "message": "Expected '!==' and instead saw '!='.",
        "line": 21,
        "column": 22,
        "nodeType": "BinaryExpression",
        "messageId": "unexpected",
        "endLine": 21,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "replaceOperator",
            "data": { "expectedOperator": "!==", "actualOperator": "!=" },
            "fix": { "range": [474, 476], "text": "!==" },
            "desc": "Use '!==' instead of '!='."
          }
        ]
      },
      {
        "ruleId": "eqeqeq",
        "severity": 1,
        "message": "Expected '===' and instead saw '=='.",
        "line": 24,
        "column": 41,
        "nodeType": "BinaryExpression",
        "messageId": "unexpected",
        "endLine": 24,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "replaceOperator",
            "data": { "expectedOperator": "===", "actualOperator": "==" },
            "fix": { "range": [596, 598], "text": "===" },
            "desc": "Use '===' instead of '=='."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 30,
        "column": 21,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 30,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [726, 742], "text": "(item.previewText != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [726, 742], "text": "(item.previewText ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [726, 742], "text": "(Boolean(item.previewText))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 30,
        "column": 41,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 30,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [746, 769], "text": "((item.content?.plainText) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [746, 769], "text": "((item.content?.plainText) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [746, 769], "text": "(Boolean((item.content?.plainText)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 32,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 32,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [809, 820], "text": "(searchTerm.length === 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [809, 820], "text": "(searchTerm === \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [809, 820], "text": "(!Boolean(searchTerm))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Note } from '@core/domain/Note';\n\nexport function filterNotes({\n  notes,\n  courseCode,\n  filter,\n  search,\n}: {\n  notes: Note[];\n  courseCode: string | null;\n  filter: 'course' | 'all' | 'starred';\n  search: string;\n}): Note[] {\n  const searchTerm = search.trim().toLowerCase();\n  return notes.filter((item) => {\n    let matchesFilter = false;\n\n    if (filter === 'all') {\n      matchesFilter = true;\n    } else if (filter === 'course') {\n      if (courseCode != null) {\n        matchesFilter = item.courseCode === courseCode;\n      } else {\n        matchesFilter = item.courseCode == null;\n      }\n    } else if (filter === 'starred') {\n      matchesFilter = item.isStarred === true;\n    }\n\n    const preview = item.previewText || item.content?.plainText || '';\n    const matchesSearch =\n      !searchTerm ||\n      item.title.toLowerCase().includes(searchTerm) ||\n      preview.toLowerCase().includes(searchTerm);\n\n    return matchesFilter && matchesSearch;\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\panel\\useNotesPanelActions.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useNotesPanelActions' has too many lines (141). Maximum allowed is 50.",
        "line": 18,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 172,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 18,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 18,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 63,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 63,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1896, 1912], "text": "deleteConfirmId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1897, 1912], "text": "(deleteConfirmId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1896, 1912], "text": "!Boolean(deleteConfirmId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 80,
        "column": 34,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 80,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2400, 2411], "text": "(err.message.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2400, 2411], "text": "(err.message !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2400, 2411], "text": "(Boolean(err.message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 81,
        "column": 10,
        "nodeType": "ConditionalExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 81,
        "endColumn": 91,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [2425, 2506],
              "text": "(typeof errorRecord?.['message'] === 'string' ? errorRecord['message'] : undefined) != null"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": {
              "range": [2425, 2506],
              "text": "(typeof errorRecord?.['message'] === 'string' ? errorRecord['message'] : undefined) ?? \"\""
            },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [2425, 2506],
              "text": "Boolean((typeof errorRecord?.['message'] === 'string' ? errorRecord['message'] : undefined))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async arrow function has a complexity of 19. Maximum allowed is 15.",
        "line": 100,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 100,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 104,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 104,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3082, 3093], "text": "(updatedNote != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 108,
        "column": 13,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 108,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [3185, 3207], "text": "(updatedNote?.isStarred) ?? false" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [3185, 3207], "text": "(updatedNote?.isStarred) === true" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 118,
        "column": 36,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 118,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3639, 3650], "text": "(err.message.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3639, 3650], "text": "(err.message !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3639, 3650], "text": "(Boolean(err.message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 127,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 127,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4124, 4131], "text": "(message != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4124, 4131], "text": "(message ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4124, 4131], "text": "(Boolean(message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 127,
        "column": 48,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 127,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 139,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 139,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4477, 4492], "text": "editorActiveId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4478, 4492], "text": "(editorActiveId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4477, 4492], "text": "!Boolean(editorActiveId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 147,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 147,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4694, 4709], "text": "editorActiveId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4695, 4709], "text": "(editorActiveId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4694, 4709], "text": "!Boolean(editorActiveId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useState } from 'react';\nimport type { Dispatch, SetStateAction } from 'react';\nimport type { Note } from '@core/domain/Note';\nimport type { ToastType } from '@shared/ui/components';\n\nexport interface UseNotesPanelActionsOptions {\n  editorActiveId: string | null;\n  noteTitle: string;\n  onDeleteNote: (noteId: string) => Promise<void>;\n  onToggleStar: (noteId: string) => Promise<Note | undefined>;\n  onNoteSaved: (note: Note) => void;\n  onSelectNote: (noteId: string | null) => void;\n  resetToNew: () => void;\n  showToast: (message: string, type?: ToastType) => void;\n  setView: Dispatch<SetStateAction<'current' | 'all'>>;\n}\n\nexport function useNotesPanelActions({\n  editorActiveId,\n  noteTitle,\n  onDeleteNote,\n  onToggleStar,\n  onNoteSaved,\n  onSelectNote,\n  resetToNew,\n  showToast,\n  setView,\n}: UseNotesPanelActionsOptions) {\n  const [isDeleting, setIsDeleting] = useState<string | null>(null);\n  const [deleteError, setDeleteError] = useState<string | null>(null);\n  const [deleteConfirmId, setDeleteConfirmId] = useState<string | null>(null);\n  const [noteToDeleteTitle, setNoteToDeleteTitle] = useState<string>('');\n\n  const handleNewNote = useCallback(() => {\n    resetToNew();\n    onSelectNote(null);\n    setView('current');\n  }, [onSelectNote, resetToNew, setView]);\n\n  const handleSelectNote = useCallback(\n    (noteId: string | null) => {\n      onSelectNote(noteId);\n      setView('current');\n    },\n    [onSelectNote, setView],\n  );\n\n  const openDeleteConfirm = useCallback(\n    (noteId: string, noteTitleValue: string, event: React.MouseEvent) => {\n      event.stopPropagation();\n      setDeleteConfirmId(noteId);\n      setNoteToDeleteTitle(noteTitleValue);\n    },\n    [],\n  );\n\n  const closeDeleteConfirm = useCallback(() => {\n    setDeleteConfirmId(null);\n    setNoteToDeleteTitle('');\n  }, []);\n\n  const executeDelete = useCallback(async () => {\n    if (!deleteConfirmId) return;\n\n    try {\n      setIsDeleting(deleteConfirmId);\n      await onDeleteNote(deleteConfirmId);\n\n      if (editorActiveId === deleteConfirmId) {\n        resetToNew();\n        onSelectNote(null);\n      }\n\n      closeDeleteConfirm();\n      showToast('Note deleted', 'success');\n    } catch (err: unknown) {\n      const errorRecord =\n        typeof err === 'object' && err !== null ? (err as Record<string, unknown>) : null;\n      const errorMessage =\n        (err instanceof Error && err.message) ||\n        (typeof errorRecord?.['message'] === 'string' ? errorRecord['message'] : undefined) ||\n        'Failed to delete note';\n      setDeleteError(errorMessage);\n      showToast(errorMessage, 'error');\n      console.error('[Lock-in] Delete note failed:', err);\n    } finally {\n      setIsDeleting(null);\n    }\n  }, [\n    closeDeleteConfirm,\n    deleteConfirmId,\n    editorActiveId,\n    onDeleteNote,\n    onSelectNote,\n    resetToNew,\n    showToast,\n  ]);\n\n  const handleToggleStar = useCallback(\n    async (noteId: string, event: React.MouseEvent) => {\n      event.stopPropagation();\n      try {\n        const updatedNote = await onToggleStar(noteId);\n        if (updatedNote && editorActiveId === noteId) {\n          onNoteSaved(updatedNote);\n        }\n\n        if (updatedNote?.isStarred) {\n          showToast('Note starred', 'star');\n        } else {\n          showToast('Note unstarred', 'info');\n        }\n      } catch (err: unknown) {\n        const errorRecord =\n          typeof err === 'object' && err !== null ? (err as Record<string, unknown>) : null;\n        const code = typeof errorRecord?.['code'] === 'string' ? errorRecord['code'] : undefined;\n        const message =\n          (err instanceof Error && err.message) ||\n          (typeof errorRecord?.['message'] === 'string' ? errorRecord['message'] : undefined);\n        let errorMessage = 'Failed to update star status';\n        if (code === 'AUTH_REQUIRED') {\n          errorMessage = 'Please sign in to star notes';\n        } else if (code === 'NOT_FOUND') {\n          errorMessage = 'Note not found';\n        } else if (code === 'NETWORK_ERROR') {\n          errorMessage = 'Network error. Check your connection.';\n        } else if (message && message.length < 60) {\n          errorMessage = message;\n        }\n        showToast(errorMessage, 'error');\n        console.error('[Lock-in] Toggle star failed:', err);\n      }\n    },\n    [editorActiveId, onNoteSaved, onToggleStar, showToast],\n  );\n\n  const handleHeaderToggleStar = useCallback(\n    (event: React.MouseEvent) => {\n      if (!editorActiveId) return;\n      void handleToggleStar(editorActiveId, event);\n    },\n    [editorActiveId, handleToggleStar],\n  );\n\n  const handleHeaderDelete = useCallback(\n    (event: React.MouseEvent) => {\n      if (!editorActiveId) return;\n      openDeleteConfirm(editorActiveId, noteTitle, event);\n    },\n    [editorActiveId, noteTitle, openDeleteConfirm],\n  );\n\n  const clearDeleteError = useCallback(() => {\n    setDeleteError(null);\n  }, []);\n\n  return {\n    deleteConfirmId,\n    noteToDeleteTitle,\n    deleteError,\n    isDeleting,\n    openDeleteConfirm,\n    closeDeleteConfirm,\n    executeDelete,\n    handleToggleStar,\n    handleHeaderToggleStar,\n    handleHeaderDelete,\n    handleNewNote,\n    handleSelectNote,\n    clearDeleteError,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\notes\\utils\\relativeTime.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 1,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 1,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 2,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 2,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [70, 74], "text": "iso == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [71, 74], "text": "(iso ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [70, 74], "text": "!Boolean(iso)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60000.",
        "line": 6,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 6,
        "endColumn": 43
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 8,
        "column": 17,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 8,
        "endColumn": 19
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 9,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 9,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 24.",
        "line": 10,
        "column": 15,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 10,
        "endColumn": 17
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 24.",
        "line": 11,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 11,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "export function relativeLabel(iso: string | null | undefined) {\n  if (!iso) return 'just now';\n  const date = new Date(iso);\n  if (Number.isNaN(date.getTime())) return 'just now';\n  const delta = Date.now() - date.getTime();\n  const minutes = Math.round(delta / 60000);\n  if (minutes <= 1) return 'just now';\n  if (minutes < 60) return `${minutes}m ago`;\n  const hours = Math.round(minutes / 60);\n  if (hours < 24) return `${hours}h ago`;\n  const days = Math.round(hours / 24);\n  return `${days}d ago`;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\ChatSection.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 32,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 32,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 35,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 35,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 48,
        "column": 11,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 48,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [1224, 1224], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [1224, 1224], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'ChatSection' has too many lines (299). Maximum allowed is 50.",
        "line": 58,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 380,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 58,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 58,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 97,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 97,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2051, 2058], "text": "storage != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 118,
        "column": 12,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 118,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2651, 2678], "text": "(apiClient?.uploadChatAsset) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 135,
        "column": 33,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 135,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3247, 3256], "text": "(asset.url != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3247, 3256], "text": "(asset.url ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3247, 3256], "text": "(Boolean(asset.url))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 137,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 137,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3355, 3365], "text": "(asset.type.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3355, 3365], "text": "(asset.type !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3355, 3365], "text": "(Boolean(asset.type))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 139,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 139,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3430, 3444], "text": "(asset.fileName != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3430, 3444], "text": "(asset.fileName ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3430, 3444], "text": "(Boolean(asset.fileName))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 141,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 141,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3497, 3510], "text": "attachmentUrl != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3497, 3510], "text": "attachmentUrl ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3497, 3510], "text": "Boolean(attachmentUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (30). Maximum allowed is 20.",
        "line": 158,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 209,
        "endColumn": 6
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 173,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 173,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4581, 4588], "text": "chatId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4582, 4588], "text": "(chatId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4581, 4588], "text": "!Boolean(chatId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 238,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 238,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6461, 6476], "text": "(pendingPrefill == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6462, 6476], "text": "(pendingPrefill ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6461, 6476], "text": "(!Boolean(pendingPrefill))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 238,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 238,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [6480, 6502], "text": "(pendingPrefill.trim().length === 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [6480, 6502], "text": "(pendingPrefill.trim() === \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6480, 6502], "text": "(!Boolean(pendingPrefill.trim()))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 254,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 254,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected number value in conditional. An explicit zero/NaN check is required.",
        "line": 255,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNumber",
        "endLine": 255,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareArrayLengthZero",
            "fix": { "range": [6993, 7009], "text": "messages.length === 0" },
            "desc": "Change condition to check array's length (`value.length === 0`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 266,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 266,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [7334, 7351], "text": "(message.isPending ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareFalse",
            "fix": { "range": [7333, 7351], "text": "(message.isPending === false)" },
            "desc": "Change condition to check if false (`value === false`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 266,
        "column": 66,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 266,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [7356, 7371], "text": "(message.isError ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareFalse",
            "fix": { "range": [7355, 7371], "text": "(message.isError === false)" },
            "desc": "Change condition to check if false (`value === false`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 1,
        "message": "Promise-returning function provided to attribute where a void return was expected.",
        "line": 314,
        "column": 27,
        "nodeType": "JSXExpressionContainer",
        "messageId": "voidReturnAttribute",
        "endLine": 314,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 314,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 314,
        "endColumn": 33,
        "fix": { "range": [9220, 9220], "text": "async " }
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (351). Maximum allowed is 300.",
        "line": 328,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 381,
        "endColumn": 1
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 340,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 340,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [10213, 10226], "text": "(composerError != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [10213, 10226], "text": "(composerError ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [10213, 10226], "text": "(Boolean(composerError))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 23,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useCallback, useEffect, useLayoutEffect, useRef, useState } from 'react';\nimport type { ApiClient } from '@api/client';\nimport type { StudyMode } from '@core/domain/types';\nimport {\n  AttachmentButton,\n  AttachmentPreview,\n  ChatMessage as ChatMessageComponent,\n} from '../chat/components';\nimport {\n  useChat,\n  useChatAttachments,\n  useChatInput,\n  relativeTimeLabel,\n  type ChatAttachment,\n  type ChatMessage,\n} from '../chat';\nimport { useNoteSaveContext } from '../contexts/NoteSaveContext';\nimport type { StorageAdapter } from './types';\n\ninterface ChatSectionProps {\n  apiClient: ApiClient | null;\n  storage?: StorageAdapter;\n  mode: StudyMode;\n  pageUrl: string;\n  courseCode: string | null;\n  pendingPrefill?: string;\n  onClearPrefill?: () => void;\n  isOpen: boolean;\n  isActive: boolean;\n}\n\nfunction SaveNoteAction({ content }: { content: string }) {\n  const { saveNote } = useNoteSaveContext();\n\n  const handleSave = async () => {\n    await saveNote({\n      content,\n      noteType: 'manual',\n    });\n  };\n\n  return (\n    <div className=\"lockin-chat-save-note-action\">\n      <button\n        className=\"lockin-chat-save-note-btn\"\n        onClick={(event) => {\n          event.stopPropagation();\n          handleSave();\n        }}\n        type=\"button\"\n      >\n        Save note\n      </button>\n    </div>\n  );\n}\n\nexport function ChatSection({\n  apiClient,\n  storage,\n  mode,\n  pageUrl,\n  courseCode,\n  pendingPrefill,\n  onClearPrefill,\n  isOpen,\n  isActive,\n}: ChatSectionProps) {\n  const {\n    messages,\n    recentChats,\n    activeHistoryId,\n    isSending,\n    sendMessage,\n    startBlankChat,\n    selectChat,\n    isHistoryOpen,\n    setIsHistoryOpen,\n    ensureChatId,\n    hasMoreHistory,\n    isLoadingMoreHistory,\n    loadMoreHistory,\n    isLoadingHistory,\n  } = (() => {\n    const chatOptions: {\n      apiClient: ApiClient | null;\n      mode: StudyMode;\n      pageUrl: string;\n      courseCode: string | null;\n      storage?: StorageAdapter;\n    } = {\n      apiClient,\n      mode,\n      pageUrl,\n      courseCode,\n    };\n    if (storage) {\n      chatOptions.storage = storage;\n    }\n    return useChat(chatOptions);\n  })();\n\n  const {\n    attachments: pendingAttachments,\n    addFiles: addAttachmentFiles,\n    removeAttachment,\n    clearAttachments,\n    setAttachmentStatus,\n    isUploading: isAttachmentUploading,\n  } = useChatAttachments({ maxAttachments: 5 });\n\n  const [composerError, setComposerError] = useState<string | null>(null);\n  const prefillSourceRef = useRef(false);\n  const hasPendingAttachments = pendingAttachments.length > 0;\n\n  const uploadAttachments = useCallback(\n    async (chatId: string) => {\n      if (!apiClient?.uploadChatAsset) {\n        throw new Error('Attachment uploads are not available.');\n      }\n\n      const attachmentIds: string[] = [];\n      const messageAttachments: ChatAttachment[] = [];\n\n      for (const attachment of pendingAttachments) {\n        setAttachmentStatus(attachment.id, 'uploading');\n        try {\n          const asset = await apiClient.uploadChatAsset({\n            chatId,\n            file: attachment.file,\n          });\n          attachmentIds.push(asset.id);\n          setAttachmentStatus(attachment.id, 'uploaded', asset.id);\n\n          const attachmentUrl = asset.url || attachment.previewUrl;\n          const messageAttachment: ChatAttachment = {\n            kind: asset.type || 'other',\n            mime: asset.mimeType,\n            name: asset.fileName || attachment.file.name,\n          };\n          if (attachmentUrl) {\n            messageAttachment.url = attachmentUrl;\n          }\n          messageAttachments.push(messageAttachment);\n        } catch (error: unknown) {\n          const message = error instanceof Error ? error.message : 'Upload failed';\n          setAttachmentStatus(attachment.id, 'error', undefined, message);\n          throw error;\n        }\n      }\n\n      return { attachmentIds, messageAttachments };\n    },\n    [apiClient, pendingAttachments, setAttachmentStatus],\n  );\n\n  const handleSendMessage = useCallback(\n    async (value: string) => {\n      const trimmed = value.trim();\n      const hasText = trimmed.length > 0;\n      const hasAttachments = hasPendingAttachments;\n      if (!hasText && !hasAttachments) return false;\n      if (isSending || isAttachmentUploading) return false;\n\n      setComposerError(null);\n\n      let attachmentIds: string[] = [];\n      let messageAttachments: ChatAttachment[] = [];\n\n      if (hasAttachments) {\n        try {\n          const chatId = await ensureChatId(hasText ? trimmed : 'Attachment-based question');\n          if (!chatId) {\n            throw new Error('Unable to create a chat session for attachments.');\n          }\n\n          const uploadResult = await uploadAttachments(chatId);\n          attachmentIds = uploadResult.attachmentIds;\n          messageAttachments = uploadResult.messageAttachments;\n        } catch (error: unknown) {\n          const message = error instanceof Error ? error.message : 'Failed to upload attachments.';\n          setComposerError(message);\n          return false;\n        }\n      }\n\n      const displayMessage = hasText ? trimmed : 'Sent attachments';\n      const source = prefillSourceRef.current && hasText ? 'selection' : 'followup';\n      prefillSourceRef.current = false;\n\n      const sendOptions = {\n        source,\n        attachments: messageAttachments,\n        attachmentIds,\n      } as const;\n      const sendOverrides: {\n        selectionOverride?: string;\n        userMessageOverride?: string;\n      } = {};\n      if (!hasText) {\n        sendOverrides.selectionOverride = '';\n      } else {\n        sendOverrides.userMessageOverride = trimmed;\n      }\n      sendMessage(displayMessage, { ...sendOptions, ...sendOverrides });\n\n      clearAttachments();\n      return true;\n    },\n    [\n      hasPendingAttachments,\n      isSending,\n      isAttachmentUploading,\n      ensureChatId,\n      uploadAttachments,\n      sendMessage,\n      clearAttachments,\n    ],\n  );\n\n  const {\n    value: inputValue,\n    inputRef,\n    handleChange: handleInputChange,\n    handleKeyDown: handleInputKeyDown,\n    handleSend: handleInputSend,\n    syncHeight: syncTextareaHeight,\n    setValue,\n  } = useChatInput({\n    onSend: handleSendMessage,\n    isSending: isSending || isAttachmentUploading,\n    shouldFocus: isOpen && isActive,\n    canSend: hasPendingAttachments,\n  });\n  const canSend = Boolean(inputValue.trim()) || hasPendingAttachments;\n\n  useEffect(() => {\n    if (!pendingPrefill || !pendingPrefill.trim()) return;\n    prefillSourceRef.current = true;\n    setValue(pendingPrefill);\n    if (isOpen && isActive) {\n      requestAnimationFrame(() => {\n        inputRef.current?.focus();\n      });\n    }\n    onClearPrefill?.();\n  }, [pendingPrefill, setValue, onClearPrefill, isOpen, isActive, inputRef]);\n\n  useLayoutEffect(() => {\n    if (!isOpen || !isActive) return;\n    syncTextareaHeight();\n  }, [isOpen, isActive, inputValue, syncTextareaHeight]);\n\n  const renderChatMessages = () => {\n    if (!messages.length) {\n      return (\n        <div className=\"lockin-chat-empty\">Ask anything about this page to start a new chat.</div>\n      );\n    }\n\n    return messages.map((message: ChatMessage) => (\n      <ChatMessageComponent\n        key={message.id}\n        message={message}\n        action={\n          message.role === 'assistant' && !message.isPending && !message.isError ? (\n            <SaveNoteAction content={message.content} />\n          ) : null\n        }\n        isThinking={Boolean(message.isPending)}\n      />\n    ));\n  };\n\n  return (\n    <>\n      <div className=\"lockin-chat-toolbar\">\n        <div className=\"lockin-chat-toolbar-left\">\n          <button\n            className=\"lockin-history-toggle-btn\"\n            onClick={() => setIsHistoryOpen((prev) => !prev)}\n            aria-label=\"Toggle chat history\"\n            aria-pressed={isHistoryOpen}\n          >\n            <span className=\"lockin-history-toggle-icon\" aria-hidden=\"true\">\n              <span className=\"lockin-history-toggle-line\" />\n              <span className=\"lockin-history-toggle-line\" />\n              <span className=\"lockin-history-toggle-line\" />\n            </span>\n            <span className=\"lockin-sr-only\">Toggle chat history</span>\n          </button>\n        </div>\n        <div className=\"lockin-chat-toolbar-right\">\n          <button className=\"lockin-new-chat-btn\" onClick={startBlankChat}>\n            + New chat\n          </button>\n        </div>\n      </div>\n\n      <div className=\"lockin-chat-container\" data-history-state={isHistoryOpen ? 'open' : 'closed'}>\n        <aside className=\"lockin-chat-history-panel\" data-state={isHistoryOpen ? 'open' : 'closed'}>\n          <div className=\"lockin-history-list\">\n            {recentChats.length === 0 ? (\n              <div className=\"lockin-history-empty\">\n                {isLoadingHistory\n                  ? 'Loading chats...'\n                  : 'No chats yet. Start from a highlight or a question.'}\n              </div>\n            ) : (\n              recentChats.map((item) => (\n                <button\n                  key={item.id}\n                  className={`lockin-history-item ${activeHistoryId === item.id ? 'active' : ''}`}\n                  onClick={() => selectChat(item)}\n                >\n                  <div className=\"lockin-history-item-content\">\n                    <div className=\"lockin-history-title\">{item.title}</div>\n                    <div className=\"lockin-history-meta\">{relativeTimeLabel(item.updatedAt)}</div>\n                  </div>\n                </button>\n              ))\n            )}\n            {hasMoreHistory && (\n              <button\n                className=\"lockin-history-load-more\"\n                onClick={() => void loadMoreHistory()}\n                disabled={isLoadingMoreHistory}\n              >\n                {isLoadingMoreHistory ? 'Loading...' : 'Load more'}\n              </button>\n            )}\n          </div>\n        </aside>\n\n        <div className=\"lockin-chat-main\">\n          <div className=\"lockin-chat-content\">\n            <div className=\"lockin-chat-messages-wrapper\">\n              <div className=\"lockin-chat-messages\">\n                {renderChatMessages()}\n                {composerError && <div className=\"lockin-chat-error\">{composerError}</div>}\n              </div>\n            </div>\n\n            <div className=\"lockin-chat-bottom-section\">\n              <AttachmentPreview\n                attachments={pendingAttachments}\n                onRemove={removeAttachment}\n                disabled={isSending || isAttachmentUploading}\n              />\n              <div className=\"lockin-chat-input\">\n                <AttachmentButton\n                  onFilesSelected={addAttachmentFiles}\n                  disabled={isSending || isAttachmentUploading}\n                  currentFileCount={pendingAttachments.length}\n                  maxFiles={5}\n                />\n                <textarea\n                  className=\"lockin-chat-input-field\"\n                  placeholder=\"Ask a follow-up question...\"\n                  value={inputValue}\n                  ref={inputRef}\n                  onChange={handleInputChange}\n                  onKeyDown={handleInputKeyDown}\n                  rows={1}\n                />\n                <button\n                  className=\"lockin-send-btn\"\n                  disabled={!canSend || isSending || isAttachmentUploading}\n                  onClick={handleInputSend}\n                >\n                  Send\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\PrivacyNotice.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'PrivacyNotice' has too many lines (72). Maximum allowed is 50.",
        "line": 45,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 128,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 45,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 45,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 50,
        "column": 5,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 50,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 61,
        "column": 5,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 61,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [1761, 1761], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [1761, 1761], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 1,
        "message": "Promise-returning function provided to attribute where a void return was expected.",
        "line": 120,
        "column": 17,
        "nodeType": "JSXExpressionContainer",
        "messageId": "voidReturnAttribute",
        "endLine": 120,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 133,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 133,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * PrivacyNotice Component\n *\n * Displays a transparency notice about data collection and storage.\n * Shown on first use and always available in the footer.\n *\n * This satisfies Chrome Web Store requirements for clear data disclosure.\n */\n\nimport { useState, useEffect, useCallback } from 'react';\n\nconst PRIVACY_DISMISSED_KEY = 'lockin_privacy_notice_dismissed';\nconst PRIVACY_VERSION = '1'; // Increment to re-show notice after policy updates\n\ninterface PrivacyNoticeProps {\n  /** Storage adapter for persisting dismissal state */\n  storage?: {\n    get: (key: string) => Promise<string | null>;\n    set: (key: string, value: string) => Promise<void>;\n  };\n  /** Whether to show as a compact inline version */\n  compact?: boolean;\n}\n\n/**\n * Default storage adapter using localStorage\n */\nconst defaultStorage = {\n  get: async (key: string): Promise<string | null> => {\n    try {\n      return localStorage.getItem(key);\n    } catch {\n      return null;\n    }\n  },\n  set: async (key: string, value: string): Promise<void> => {\n    try {\n      localStorage.setItem(key, value);\n    } catch {\n      // Silently fail if localStorage is unavailable\n    }\n  },\n};\n\nexport function PrivacyNotice({ storage = defaultStorage, compact = false }: PrivacyNoticeProps) {\n  const [isDismissed, setIsDismissed] = useState(true); // Start hidden, show after check\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    async function checkDismissed() {\n      try {\n        const value = await storage.get(PRIVACY_DISMISSED_KEY);\n        // Show if not dismissed OR if version has changed\n        setIsDismissed(value === PRIVACY_VERSION);\n      } catch {\n        setIsDismissed(false);\n      } finally {\n        setIsLoading(false);\n      }\n    }\n    checkDismissed();\n  }, [storage]);\n\n  const handleDismiss = useCallback(async () => {\n    setIsDismissed(true);\n    try {\n      await storage.set(PRIVACY_DISMISSED_KEY, PRIVACY_VERSION);\n    } catch {\n      // Silently fail if storage is unavailable\n    }\n  }, [storage]);\n\n  // Don't render while loading to prevent flash\n  if (isLoading) return null;\n\n  // If dismissed, show only the compact footer version when requested\n  if (isDismissed && !compact) return null;\n\n  // Compact version for settings/footer\n  if (compact) {\n    return (\n      <div className=\"lockin-privacy-compact\">\n        <span className=\"lockin-privacy-icon\"></span>\n        <span className=\"lockin-privacy-text\">\n          Your data is stored securely.{' '}\n          <button\n            className=\"lockin-privacy-link\"\n            onClick={() => setIsDismissed(false)}\n            type=\"button\"\n          >\n            Learn more\n          </button>\n        </span>\n      </div>\n    );\n  }\n\n  // Full notice banner\n  return (\n    <div className=\"lockin-privacy-notice\" role=\"alert\" aria-live=\"polite\">\n      <div className=\"lockin-privacy-content\">\n        <div className=\"lockin-privacy-header\">\n          <span className=\"lockin-privacy-icon\"></span>\n          <strong>Privacy Notice</strong>\n        </div>\n        <p className=\"lockin-privacy-message\">\n          We store the source URL (without sensitive parameters like session tokens) and page title\n          to show where your summaries came from. Course codes and week numbers are extracted\n          locally and only used for organizing your notes.\n        </p>\n        <ul className=\"lockin-privacy-list\">\n          <li> URLs are sanitized to remove session keys and tokens</li>\n          <li> Your selections and notes are processed to provide AI assistance</li>\n          <li> Error reports (if enabled) contain no personal study content</li>\n          <li> No tracking across unrelated sites</li>\n        </ul>\n      </div>\n      <button\n        className=\"lockin-privacy-dismiss\"\n        onClick={handleDismiss}\n        type=\"button\"\n        aria-label=\"Dismiss privacy notice\"\n      >\n        Got it\n      </button>\n    </div>\n  );\n}\n\n/**\n * Compact privacy footer for settings sections\n */\nexport function PrivacyFooter() {\n  return (\n    <div className=\"lockin-privacy-footer\">\n      <span className=\"lockin-privacy-icon\"></span>\n      <span className=\"lockin-privacy-text\">\n        We store sanitized URLs and page titles to show where your content came from. Course codes\n        are extracted locally for organization.\n      </span>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\SidebarHeaderActions.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 7,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 7,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { StudyToolsDropdown } from '../tools';\n\ninterface SidebarHeaderActionsProps {\n  onOpenFeedback: () => void;\n}\n\nexport function SidebarHeaderActions({ onOpenFeedback }: SidebarHeaderActionsProps) {\n  return (\n    <>\n      <StudyToolsDropdown />\n      <button\n        className=\"lockin-feedback-trigger-btn\"\n        onClick={onOpenFeedback}\n        aria-label=\"Send feedback\"\n        title=\"Send feedback\"\n      >\n        <svg\n          width=\"16\"\n          height=\"16\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n        >\n          <path d=\"M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z\" />\n        </svg>\n      </button>\n    </>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\SidebarLayout.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 12,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 12,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { ReactNode, PointerEvent as ReactPointerEvent } from 'react';\n\ninterface SidebarLayoutProps {\n  isOpen: boolean;\n  onToggle: () => void;\n  onResizeStart: (event: ReactPointerEvent<HTMLDivElement>) => void;\n  headerLeft: ReactNode;\n  headerRight?: ReactNode;\n  children: ReactNode;\n}\n\nexport function SidebarLayout({\n  isOpen,\n  onToggle,\n  onResizeStart,\n  headerLeft,\n  headerRight,\n  children,\n}: SidebarLayoutProps) {\n  return (\n    <>\n      {!isOpen && (\n        <button id=\"lockin-toggle-pill\" onClick={onToggle} aria-label=\"Open Lock-in sidebar\">\n          Lock-in\n        </button>\n      )}\n\n      {isOpen && (\n        <div\n          id=\"lockin-sidebar\"\n          className=\"lockin-sidebar\"\n          data-state={isOpen ? 'expanded' : 'collapsed'}\n        >\n          <div\n            className=\"lockin-sidebar-resize-handle\"\n            onPointerDown={onResizeStart}\n            aria-hidden=\"true\"\n          />\n          <div className=\"lockin-top-bar\">\n            <div className=\"lockin-top-bar-left\">{headerLeft}</div>\n            <div className=\"lockin-top-bar-right\">{headerRight}</div>\n            <button className=\"lockin-close-btn\" onClick={onToggle} aria-label=\"Close sidebar\">\n              x\n            </button>\n          </div>\n          {children}\n        </div>\n      )}\n    </>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\SidebarTabs.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'SidebarTabs' has too many lines (53). Maximum allowed is 50.",
        "line": 12,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 64,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 12,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 12,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 36,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 36,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [999, 1011], "text": "(activeToolId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [999, 1011], "text": "(activeToolId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [999, 1011], "text": "(Boolean(activeToolId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { CHAT_TAB_ID, NOTES_TAB_ID, TOOL_TAB_ID } from './constants';\nimport type { SidebarTabId } from './types';\n\ninterface SidebarTabsProps {\n  activeTab: SidebarTabId;\n  onTabChange: (tabId: SidebarTabId) => void;\n  activeToolId?: string | null;\n  activeToolTitle?: string | null;\n  onCloseTool?: () => void;\n}\n\nexport function SidebarTabs({\n  activeTab,\n  onTabChange,\n  activeToolId,\n  activeToolTitle,\n  onCloseTool,\n}: SidebarTabsProps) {\n  return (\n    <div className=\"lockin-tabs-wrapper\" role=\"tablist\">\n      {[CHAT_TAB_ID, NOTES_TAB_ID].map((tabId) => {\n        const label = tabId === CHAT_TAB_ID ? 'Chat' : 'Notes';\n        const isActive = activeTab === tabId;\n        return (\n          <button\n            key={tabId}\n            className={`lockin-tab ${isActive ? 'lockin-tab-active' : ''}`}\n            onClick={() => onTabChange(tabId)}\n            role=\"tab\"\n            aria-selected={isActive}\n          >\n            {label}\n          </button>\n        );\n      })}\n      {activeToolId && (\n        <button\n          className={`lockin-tab lockin-tab-closable ${\n            activeTab === TOOL_TAB_ID ? 'lockin-tab-active' : ''\n          }`}\n          onClick={() => onTabChange(TOOL_TAB_ID)}\n          role=\"tab\"\n          aria-selected={activeTab === TOOL_TAB_ID}\n        >\n          <span>{activeToolTitle}</span>\n          <span\n            className=\"lockin-tab-close\"\n            onClick={(event) => {\n              event.stopPropagation();\n              onCloseTool?.();\n              if (activeTab === TOOL_TAB_ID) {\n                onTabChange(CHAT_TAB_ID);\n              }\n            }}\n            role=\"button\"\n            aria-label={`Close ${activeToolTitle}`}\n          >\n            A-\n          </span>\n        </button>\n      )}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\ToolSection.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 8,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 8,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 9,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 9,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [209, 222], "text": "activeToolId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [210, 222], "text": "(activeToolId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [209, 222], "text": "!Boolean(activeToolId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 11,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 11,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [285, 290], "text": "tool == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { getToolById } from '../tools';\n\ninterface ToolSectionProps {\n  activeToolId?: string | null;\n  onClose: () => void;\n}\n\nexport function ToolSection({ activeToolId, onClose }: ToolSectionProps) {\n  if (!activeToolId) return null;\n  const tool = getToolById(activeToolId);\n  if (!tool) return null;\n  const ToolComponent = tool.component;\n\n  return (\n    <div className=\"lockin-tool-panel\">\n      <ToolComponent onClose={onClose} />\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\useResize.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useResize' has too many lines (132). Maximum allowed is 50.",
        "line": 12,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 165,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 12,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 12,
        "endColumn": 26
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 360.",
        "line": 14,
        "column": 14,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 14,
        "endColumn": 17
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 1500.",
        "line": 15,
        "column": 14,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 15,
        "endColumn": 18
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0.75.",
        "line": 16,
        "column": 11,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 16,
        "endColumn": 15
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (55). Maximum allowed is 50.",
        "line": 50,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 117,
        "endColumn": 6
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 59,
        "column": 45,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 59,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 71,
        "column": 59,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 71,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 76,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 76,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 122,
        "column": 10,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 122,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4040, 4058], "text": "(storage?.getLocal) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 148,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 148,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 158,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 158,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5114, 5132], "text": "cleanupRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useEffect, useRef, type PointerEvent as ReactPointerEvent } from 'react';\nimport type { StorageAdapter } from './types';\n\ninterface UseResizeOptions {\n  storage?: StorageAdapter;\n  minWidth?: number;\n  maxWidth?: number;\n  maxVw?: number;\n  storageKey?: string;\n}\n\nexport function useResize({\n  storage,\n  minWidth = 360,\n  maxWidth = 1500,\n  maxVw = 0.75,\n  storageKey = 'lockin_sidebar_width',\n}: UseResizeOptions) {\n  const isResizingRef = useRef(false);\n  const resizeRafRef = useRef<number | null>(null);\n  const pendingWidthRef = useRef<number | null>(null);\n  const currentWidthRef = useRef<number | null>(null);\n  const cleanupRef = useRef<(() => void) | null>(null);\n\n  const getMaxSidebarWidth = useCallback(() => {\n    if (typeof window === 'undefined') return maxWidth;\n    return Math.min(maxWidth, Math.floor(window.innerWidth * maxVw));\n  }, [maxWidth, maxVw]);\n\n  const clampSidebarWidth = useCallback(\n    (width: number) => {\n      const computedMax = getMaxSidebarWidth();\n      const computedMin = Math.min(minWidth, computedMax);\n      return Math.min(computedMax, Math.max(computedMin, Math.round(width)));\n    },\n    [getMaxSidebarWidth, minWidth],\n  );\n\n  const applySidebarWidth = useCallback(\n    (width: number) => {\n      if (typeof document === 'undefined') return;\n      const clamped = clampSidebarWidth(width);\n      currentWidthRef.current = clamped;\n      document.documentElement.style.setProperty('--lockin-sidebar-width', `${clamped}px`);\n    },\n    [clampSidebarWidth],\n  );\n\n  const handleResizeStart = useCallback(\n    (event: ReactPointerEvent<HTMLDivElement>) => {\n      if (event.button !== 0) return;\n      if (typeof window === 'undefined') return;\n      event.preventDefault();\n      event.stopPropagation();\n\n      const handle = event.currentTarget;\n      const pointerId = event.pointerId;\n\n      const updateWidth = (clientX: number) => {\n        const nextWidth = window.innerWidth - clientX;\n        pendingWidthRef.current = nextWidth;\n        if (resizeRafRef.current !== null) return;\n        resizeRafRef.current = window.requestAnimationFrame(() => {\n          resizeRafRef.current = null;\n          if (pendingWidthRef.current === null) return;\n          applySidebarWidth(pendingWidthRef.current);\n          pendingWidthRef.current = null;\n        });\n      };\n\n      const handlePointerMove = (moveEvent: PointerEvent) => {\n        if (!isResizingRef.current) return;\n        updateWidth(moveEvent.clientX);\n      };\n\n      const stopResize = () => {\n        if (!isResizingRef.current) return;\n        isResizingRef.current = false;\n        cleanupRef.current = null;\n\n        if (handle.hasPointerCapture?.(pointerId)) {\n          handle.releasePointerCapture?.(pointerId);\n        }\n\n        document.documentElement.classList.remove('lockin-sidebar-resizing');\n        window.removeEventListener('pointermove', handlePointerMove);\n        window.removeEventListener('pointerup', stopResize);\n        window.removeEventListener('pointercancel', stopResize);\n\n        if (resizeRafRef.current !== null) {\n          window.cancelAnimationFrame(resizeRafRef.current);\n          resizeRafRef.current = null;\n        }\n\n        if (pendingWidthRef.current !== null) {\n          applySidebarWidth(pendingWidthRef.current);\n          pendingWidthRef.current = null;\n        }\n\n        if (currentWidthRef.current !== null) {\n          storage?.setLocal?.(storageKey, currentWidthRef.current).catch(() => {\n            /* ignore */\n          });\n        }\n      };\n\n      isResizingRef.current = true;\n      cleanupRef.current = stopResize;\n\n      handle.setPointerCapture?.(pointerId);\n      document.documentElement.classList.add('lockin-sidebar-resizing');\n      window.addEventListener('pointermove', handlePointerMove);\n      window.addEventListener('pointerup', stopResize);\n      window.addEventListener('pointercancel', stopResize);\n\n      updateWidth(event.clientX);\n    },\n    [applySidebarWidth, storage, storageKey],\n  );\n\n  useEffect(() => {\n    if (!storage?.getLocal) return;\n    let cancelled = false;\n    storage\n      .getLocal(storageKey)\n      .then((storedWidth) => {\n        if (cancelled) return;\n        const numeric =\n          typeof storedWidth === 'number'\n            ? storedWidth\n            : typeof storedWidth === 'string'\n              ? Number.parseFloat(storedWidth)\n              : null;\n        if (typeof numeric === 'number' && !Number.isNaN(numeric) && numeric > 0) {\n          applySidebarWidth(numeric);\n        }\n      })\n      .catch(() => {\n        /* ignore */\n      });\n    return () => {\n      cancelled = true;\n    };\n  }, [applySidebarWidth, storage, storageKey]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return undefined;\n    const handleResize = () => {\n      if (currentWidthRef.current === null) return;\n      applySidebarWidth(currentWidthRef.current);\n    };\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [applySidebarWidth]);\n\n  useEffect(() => {\n    return () => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n      }\n    };\n  }, []);\n\n  return { handleResizeStart };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\useSidebarState.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useSidebarState' has too many lines (136). Maximum allowed is 50.",
        "line": 23,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 180,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'useSidebarState' has too many statements (21). Maximum allowed is 20.",
        "line": 23,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 180,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 23,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 23,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 52,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 52,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 52,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 52,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 59,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 59,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1776, 1800], "text": "layoutTimeoutRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [1776, 1800], "text": "layoutTimeoutRef.current ?? 0" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1776, 1800], "text": "Boolean(layoutTimeoutRef.current)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 320.",
        "line": 64,
        "column": 8,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 64,
        "endColumn": 11
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 68,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 68,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2033, 2041], "text": "storage == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 69,
        "column": 5,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 74,
        "endColumn": 8,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [2055, 2055], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [2055, 2055], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 78,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 78,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2319, 2327], "text": "storage == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 86,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 86,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2538, 2550], "text": "(storedNoteId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2538, 2550], "text": "(storedNoteId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2538, 2550], "text": "(Boolean(storedNoteId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 97,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 97,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2788, 2796], "text": "(storage == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 104,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 104,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2998, 3006], "text": "storage == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 111,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 111,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3165, 3173], "text": "storage == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 118,
        "column": 10,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 118,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3316, 3334], "text": "(storage?.setLocal) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 128,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 128,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3568, 3592], "text": "layoutTimeoutRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [3568, 3592], "text": "layoutTimeoutRef.current ?? 0" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3568, 3592], "text": "Boolean(layoutTimeoutRef.current)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 135,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 135,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3729, 3747], "text": "activeTabExternal == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3730, 3747], "text": "(activeTabExternal ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3729, 3747], "text": "!Boolean(activeTabExternal)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 141,
        "column": 50,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 141,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 162,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 162,
        "endColumn": 47
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useEffect, useRef, useState } from 'react';\nimport type { StudyMode } from '@core/domain/types';\nimport type { SidebarTabId, StorageAdapter } from './types';\nimport {\n  CHAT_TAB_ID,\n  NOTES_TAB_ID,\n  TOOL_TAB_ID,\n  SIDEBAR_ACTIVE_TAB_KEY,\n  MODE_STORAGE_KEY,\n  SELECTED_NOTE_ID_KEY,\n  SIDEBAR_OPEN_KEY,\n} from './constants';\nimport { coerceTab, isValidUUID } from './utils';\n\ninterface UseSidebarStateOptions {\n  activeTabExternal?: string;\n  currentMode: StudyMode;\n  storage?: StorageAdapter;\n  isOpen: boolean;\n  onToggle: () => void;\n}\n\nexport function useSidebarState({\n  activeTabExternal,\n  currentMode,\n  storage,\n  isOpen,\n  onToggle,\n}: UseSidebarStateOptions) {\n  const [activeTab, setActiveTab] = useState<SidebarTabId>(coerceTab(activeTabExternal));\n  const [mode, setMode] = useState<StudyMode>(currentMode);\n  const [selectedNoteId, setSelectedNoteId] = useState<string | null>(null);\n  const [isNoteIdLoaded, setIsNoteIdLoaded] = useState(false);\n  const [isNoteEditing, setIsNoteEditing] = useState(false);\n  const lastForceOpenRef = useRef<number>(0);\n  const layoutTimeoutRef = useRef<number | null>(null);\n\n  const handleTabChange = useCallback((tabId: SidebarTabId) => {\n    const scrollX = window.scrollX;\n    const scrollY = window.scrollY;\n\n    setActiveTab(tabId);\n\n    requestAnimationFrame(() => {\n      window.scrollTo(scrollX, scrollY);\n    });\n  }, []);\n\n  const applySplitLayout = useCallback((open: boolean) => {\n    const body = document.body;\n    const html = document.documentElement;\n    if (!body || !html) return;\n    if (open) {\n      body.classList.add('lockin-sidebar-open');\n      html.classList.add('lockin-sidebar-transitioning');\n    } else {\n      body.classList.remove('lockin-sidebar-open');\n    }\n    if (layoutTimeoutRef.current) {\n      window.clearTimeout(layoutTimeoutRef.current);\n    }\n    layoutTimeoutRef.current = window.setTimeout(() => {\n      html.classList.remove('lockin-sidebar-transitioning');\n    }, 320);\n  }, []);\n\n  useEffect(() => {\n    if (!storage) return;\n    storage.get(SIDEBAR_ACTIVE_TAB_KEY).then((tab) => {\n      if (typeof tab !== 'string') return;\n      if (tab === CHAT_TAB_ID || tab === NOTES_TAB_ID || tab === TOOL_TAB_ID) {\n        setActiveTab(tab);\n      }\n    });\n  }, [storage]);\n\n  useEffect(() => {\n    if (!storage) {\n      setIsNoteIdLoaded(true);\n      return;\n    }\n    storage\n      .get(SELECTED_NOTE_ID_KEY)\n      .then((noteId) => {\n        const storedNoteId = typeof noteId === 'string' ? noteId : null;\n        if (storedNoteId && isValidUUID(storedNoteId)) {\n          setSelectedNoteId(storedNoteId);\n        }\n        setIsNoteIdLoaded(true);\n      })\n      .catch(() => {\n        setIsNoteIdLoaded(true);\n      });\n  }, [storage]);\n\n  useEffect(() => {\n    if (!storage || !isNoteIdLoaded) return;\n    storage.set(SELECTED_NOTE_ID_KEY, selectedNoteId).catch(() => {\n      /* ignore */\n    });\n  }, [selectedNoteId, storage, isNoteIdLoaded]);\n\n  useEffect(() => {\n    if (!storage) return;\n    storage.set(SIDEBAR_ACTIVE_TAB_KEY, activeTab).catch(() => {\n      /* ignore */\n    });\n  }, [activeTab, storage]);\n\n  useEffect(() => {\n    if (!storage) return;\n    storage.set(MODE_STORAGE_KEY, mode).catch(() => {\n      /* ignore */\n    });\n  }, [mode, storage]);\n\n  useEffect(() => {\n    if (!storage?.setLocal) return;\n    storage.setLocal(SIDEBAR_OPEN_KEY, isOpen).catch(() => {\n      /* ignore */\n    });\n  }, [isOpen, storage]);\n\n  useEffect(() => {\n    applySplitLayout(isOpen);\n    return () => {\n      applySplitLayout(false);\n      if (layoutTimeoutRef.current) {\n        window.clearTimeout(layoutTimeoutRef.current);\n      }\n    };\n  }, [applySplitLayout, isOpen]);\n\n  useEffect(() => {\n    if (!activeTabExternal) return;\n    const nextTab = coerceTab(activeTabExternal);\n    setActiveTab((current) => (current === nextTab ? current : nextTab));\n  }, [activeTabExternal]);\n\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === 'Escape' && isOpen) {\n        onToggle();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }\n\n    return undefined;\n  }, [isOpen, onToggle]);\n\n  useEffect(() => {\n    setMode(currentMode);\n  }, [currentMode]);\n\n  useEffect(() => {\n    if (isNoteEditing && !isOpen) {\n      const now = Date.now();\n      if (now - lastForceOpenRef.current > 400) {\n        lastForceOpenRef.current = now;\n        onToggle();\n      }\n    }\n  }, [isNoteEditing, isOpen, onToggle]);\n\n  return {\n    activeTab,\n    setActiveTab,\n    handleTabChange,\n    mode,\n    setMode,\n    selectedNoteId,\n    setSelectedNoteId,\n    isNoteEditing,\n    setIsNoteEditing,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\sidebar\\utils.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 5,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 5,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [195, 201], "text": "value == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [196, 201], "text": "(value ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [195, 201], "text": "!Boolean(value)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { CHAT_TAB_ID, NOTES_TAB_ID, TOOL_TAB_ID } from './constants';\nimport type { SidebarTabId } from './types';\n\nexport function isValidUUID(value: string | null | undefined): boolean {\n  if (!value) return false;\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);\n}\n\nexport function coerceTab(value?: string | null): SidebarTabId {\n  if (value === NOTES_TAB_ID || value === TOOL_TAB_ID || value === CHAT_TAB_ID) return value;\n  return CHAT_TAB_ID;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\tools\\StudyToolsDropdown.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'StudyToolsDropdown' has too many lines (56). Maximum allowed is 50.",
        "line": 16,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 76,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 16,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 16,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 23,
        "column": 24,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 23,
        "endColumn": 26
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * StudyToolsDropdown Component\n *\n * Dropdown menu for selecting study tools.\n * Displayed in the top bar, right-aligned.\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { TOOLS } from './registry';\nimport { useToolContext } from './ToolContext';\n\nfunction formatTypeTag(typeTag: string): string {\n  return typeTag.charAt(0).toUpperCase() + typeTag.slice(1);\n}\n\nexport function StudyToolsDropdown() {\n  const [isOpen, setIsOpen] = useState(false);\n  const { openTool } = useToolContext();\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    if (!isOpen) return;\n    const handler = () => setIsOpen(false);\n    document.addEventListener('click', handler);\n    return () => document.removeEventListener('click', handler);\n  }, [isOpen]);\n\n  const handleToggle = useCallback(() => {\n    setIsOpen((prev) => !prev);\n  }, []);\n\n  const handleToolSelect = useCallback(\n    (toolId: string, enabled: boolean) => {\n      if (enabled) {\n        openTool(toolId);\n        setIsOpen(false);\n      }\n    },\n    [openTool],\n  );\n\n  return (\n    <div className=\"lockin-study-tools-container\" onClick={(e) => e.stopPropagation()}>\n      <button\n        className=\"lockin-study-tools-btn\"\n        onClick={handleToggle}\n        aria-haspopup=\"listbox\"\n        aria-expanded={isOpen}\n      >\n        <span>Study Tools</span>\n        <span className=\"lockin-study-tools-chevron\" aria-hidden=\"true\">\n          \n        </span>\n      </button>\n      {isOpen && (\n        <div className=\"lockin-study-tools-menu\" role=\"listbox\">\n          {TOOLS.map((tool) => (\n            <button\n              key={tool.id}\n              className={`lockin-study-tools-item ${!tool.enabled ? 'lockin-study-tools-item-disabled' : ''}`}\n              onClick={() => handleToolSelect(tool.id, tool.enabled)}\n              disabled={!tool.enabled}\n              role=\"option\"\n              aria-disabled={!tool.enabled}\n            >\n              <span>\n                {tool.label} ({formatTypeTag(tool.typeTag)})\n              </span>\n              {!tool.enabled && <span className=\"lockin-coming-soon\">Coming soon</span>}\n            </button>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\tools\\ToolContext.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 41,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 41,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 47,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 47,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1639, 1643], "text": "(tool != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 78,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 78,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2475, 2483], "text": "context == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Study Tools - Tool Context\n *\n * Minimal context for active tool state.\n * Tool-specific state (e.g., selected video, transcript data) should live\n * inside the tool component, not here.\n */\n\nimport { createContext, useContext, useState, useCallback, useMemo, type ReactNode } from 'react';\nimport { getToolById } from './registry';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\ninterface ToolContextValue {\n  /** Currently active tool ID, or null if no tool is open */\n  activeToolId: string | null;\n  /** Display label for active tool (for tab display) */\n  activeToolTitle: string | null;\n  /** Open a tool by ID */\n  openTool: (toolId: string) => void;\n  /** Close the current tool */\n  closeTool: () => void;\n}\n\n// -----------------------------------------------------------------------------\n// Context\n// -----------------------------------------------------------------------------\n\nconst ToolContext = createContext<ToolContextValue | null>(null);\n\n// -----------------------------------------------------------------------------\n// Provider\n// -----------------------------------------------------------------------------\n\ninterface ToolProviderProps {\n  children: ReactNode;\n}\n\nexport function ToolProvider({ children }: ToolProviderProps) {\n  const [activeToolId, setActiveToolId] = useState<string | null>(null);\n  const [activeToolTitle, setActiveToolTitle] = useState<string | null>(null);\n\n  const openTool = useCallback((toolId: string) => {\n    const tool = getToolById(toolId);\n    if (tool && tool.enabled) {\n      setActiveToolId(toolId);\n      setActiveToolTitle(tool.label);\n    }\n  }, []);\n\n  const closeTool = useCallback(() => {\n    setActiveToolId(null);\n    setActiveToolTitle(null);\n  }, []);\n\n  // Memoize context value to avoid unnecessary rerenders\n  const value = useMemo<ToolContextValue>(\n    () => ({\n      activeToolId,\n      activeToolTitle,\n      openTool,\n      closeTool,\n    }),\n    [activeToolId, activeToolTitle, openTool, closeTool],\n  );\n\n  return <ToolContext.Provider value={value}>{children}</ToolContext.Provider>;\n}\n\n// -----------------------------------------------------------------------------\n// Hook\n// -----------------------------------------------------------------------------\n\nexport function useToolContext(): ToolContextValue {\n  const context = useContext(ToolContext);\n  if (!context) {\n    throw new Error('useToolContext must be used within a ToolProvider');\n  }\n  return context;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\tools\\TranscriptToolContent.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'TranscriptToolContent' has too many lines (91). Maximum allowed is 50.",
        "line": 15,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 116,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 15,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 15,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 30,
        "column": 49,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 30,
        "endColumn": 79,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [983, 1014], "text": "(transcriptState.lastTranscript == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 45,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 45,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1468, 1499], "text": "(transcriptState.lastTranscript == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 51,
        "column": 8,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 51,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1703, 1733], "text": "(transcriptState.lastTranscript != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 56,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 56,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": {
              "range": [1927, 1969],
              "text": "(transcriptState.lastTranscript.video.title.length > 0)"
            },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": {
              "range": [1927, 1969],
              "text": "(transcriptState.lastTranscript.video.title !== \"\")"
            },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [1927, 1969],
              "text": "(Boolean(transcriptState.lastTranscript.video.title))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 85,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 85,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3019, 3040], "text": "(transcriptState.error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3019, 3040], "text": "(transcriptState.error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3019, 3040], "text": "(Boolean(transcriptState.error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 86,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 86,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3098, 3127], "text": "(transcriptState.detectionHint != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3098, 3127], "text": "(transcriptState.detectionHint ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3098, 3127], "text": "(Boolean(transcriptState.detectionHint))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 89,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 89,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3225, 3253], "text": "(transcriptState.authRequired != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 102,
        "column": 27,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 102,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3716, 3747], "text": "(transcriptState.lastTranscript == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * TranscriptToolContent Component\n *\n * Wraps existing Transcript UI for use in the Study Tools framework.\n * Reuses useTranscripts hook and TranscriptVideoListPanel - no duplication of logic.\n *\n */\n\nimport { useEffect, useCallback } from 'react';\nimport { useTranscripts } from '../transcripts/useTranscripts';\nimport { TranscriptVideoListPanel } from '../transcripts/components';\nimport { TranscriptMessage } from '../transcripts/TranscriptMessage';\nimport { useNoteSaveContext } from '../contexts/NoteSaveContext';\n\nexport function TranscriptToolContent() {\n  const { saveNote } = useNoteSaveContext();\n  const {\n    state: transcriptState,\n    detectAndAutoExtract,\n    closeVideoList,\n    extractTranscript,\n    transcribeWithAI,\n    cancelAiTranscription,\n    clearError,\n  } = useTranscripts();\n\n  // Auto-detect videos when tool opens\n  useEffect(() => {\n    // Only detect if we don't already have videos or a transcript\n    if (transcriptState.videos.length === 0 && !transcriptState.lastTranscript) {\n      detectAndAutoExtract();\n    }\n    // Run once on mount - intentionally omitting dependencies\n  }, []);\n\n  const handlePanelClose = useCallback(() => {\n    closeVideoList();\n    clearError();\n  }, [closeVideoList, clearError]);\n\n  // Determine if we should show the video list\n  // Show list if: it's open, OR we have no transcript yet, OR we have videos but no extraction yet\n  const showVideoList =\n    transcriptState.isVideoListOpen ||\n    (!transcriptState.lastTranscript && transcriptState.videos.length > 0) ||\n    transcriptState.isDetecting;\n\n  return (\n    <div className=\"lockin-tool-content lockin-transcript-tool\">\n      {/* Show last extracted transcript */}\n      {transcriptState.lastTranscript && (\n        <>\n          <TranscriptMessage\n            transcript={transcriptState.lastTranscript.transcript}\n            video={transcriptState.lastTranscript.video}\n            videoTitle={transcriptState.lastTranscript.video.title || 'Video'}\n            saveNote={saveNote}\n          />\n          {/* Button to change video if multiple videos exist */}\n          {transcriptState.videos.length > 1 && !showVideoList && (\n            <div className=\"lockin-transcript-change-video\">\n              <button\n                className=\"lockin-transcript-change-video-btn\"\n                onClick={() => detectAndAutoExtract()}\n                type=\"button\"\n              >\n                Change video ({transcriptState.videos.length} available)\n              </button>\n            </div>\n          )}\n        </>\n      )}\n\n      {/* Show video list for selection */}\n      {showVideoList && (\n        <TranscriptVideoListPanel\n          videos={transcriptState.videos}\n          isLoading={transcriptState.isDetecting}\n          isExtracting={transcriptState.isExtracting}\n          extractingVideoId={transcriptState.extractingVideoId}\n          onSelectVideo={(video) => {\n            void extractTranscript(video);\n          }}\n          onClose={handlePanelClose}\n          {...(transcriptState.error ? { error: transcriptState.error } : {})}\n          {...(transcriptState.detectionHint\n            ? { detectionHint: transcriptState.detectionHint }\n            : {})}\n          {...(transcriptState.authRequired ? { authRequired: transcriptState.authRequired } : {})}\n          extractionResults={transcriptState.extractionsByVideoId}\n          aiTranscription={transcriptState.aiTranscription}\n          onTranscribeWithAI={(video) => {\n            void transcribeWithAI(video);\n          }}\n          onCancelAi={() => {\n            void cancelAiTranscription();\n          }}\n        />\n      )}\n\n      {/* Empty state when no videos detected */}\n      {!showVideoList && !transcriptState.lastTranscript && !transcriptState.isDetecting && (\n        <div className=\"lockin-transcript-empty\">\n          <p>No videos detected on this page.</p>\n          <button\n            className=\"lockin-transcript-retry-btn\"\n            onClick={() => detectAndAutoExtract()}\n            type=\"button\"\n          >\n            Scan again\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\tools\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\tools\\registry.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 14,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 14,
        "endColumn": 25
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Study Tools - Tool Registry\n *\n * Central registry of all available study tools.\n * To add a new tool:\n * 1. Create a ToolContent component implementing ToolContentProps\n * 2. Add an entry to the TOOLS array below\n */\n\nimport { TranscriptToolContent } from './TranscriptToolContent';\nimport type { ToolDefinition, ToolContentProps } from './types';\n\n// Placeholder component for disabled tools\nfunction PlaceholderTool(_props: ToolContentProps) {\n  return (\n    <div className=\"lockin-tool-placeholder\">\n      <p>This tool is coming soon!</p>\n    </div>\n  );\n}\n\n/**\n * Registry of all study tools.\n * Order determines display order in the dropdown.\n */\nexport const TOOLS: ToolDefinition[] = [\n  {\n    id: 'transcript',\n    label: 'Transcript',\n    typeTag: 'video',\n    enabled: true,\n    component: TranscriptToolContent,\n  },\n  {\n    id: 'quiz',\n    label: 'Quiz',\n    typeTag: 'video',\n    enabled: false, // Placeholder - coming soon\n    component: PlaceholderTool,\n  },\n];\n\n/**\n * Get a tool definition by ID.\n */\nexport function getToolById(id: string): ToolDefinition | undefined {\n  return TOOLS.find((tool) => tool.id === id);\n}\n\n/**\n * Get all enabled tools.\n */\nexport function getEnabledTools(): ToolDefinition[] {\n  return TOOLS.filter((tool) => tool.enabled);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\tools\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\TranscriptMessage.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'TranscriptMessage' has too many lines (79). Maximum allowed is 50.",
        "line": 25,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 109,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 25,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 25,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 75,
        "column": 23,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 75,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2773, 2794], "text": "(transcript.durationMs != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [2773, 2794], "text": "(transcript.durationMs ?? 0)" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2773, 2794], "text": "(Boolean(transcript.durationMs))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 1,
        "message": "Promise-returning function provided to attribute where a void return was expected.",
        "line": 100,
        "column": 19,
        "nodeType": "JSXExpressionContainer",
        "messageId": "voidReturnAttribute",
        "endLine": 100,
        "endColumn": 35
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * TranscriptMessage Component\n *\n * Displays a transcript in the chat with download options.\n */\n\nimport { useCallback } from 'react';\nimport type { DetectedVideo, TranscriptResult } from '@core/transcripts/types';\nimport type { SaveNoteOptions } from '../../hooks/useNoteSave';\nimport type { Note } from '@core/domain/Note';\nimport { useTranscriptCacheContext } from '../contexts/TranscriptCacheContext';\nimport { downloadFile, formatAsPlainText, formatAsVtt, formatTime } from './transcriptFormatting';\n\ninterface TranscriptMessageProps {\n  /** The transcript data */\n  transcript: TranscriptResult;\n  /** Video metadata for caching */\n  video: DetectedVideo;\n  /** Video title for display */\n  videoTitle: string;\n  /** Save note function from context */\n  saveNote: (options: SaveNoteOptions) => Promise<Note | null>;\n}\n\nexport function TranscriptMessage({\n  transcript,\n  video,\n  videoTitle,\n  saveNote,\n}: TranscriptMessageProps) {\n  const { cacheTranscript } = useTranscriptCacheContext();\n\n  const handleDownloadTxt = useCallback(() => {\n    const content = formatAsPlainText(transcript, videoTitle);\n    const safeTitle = videoTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase();\n    downloadFile(`transcript_${safeTitle}.txt`, content, 'text/plain');\n  }, [transcript, videoTitle]);\n\n  const handleDownloadVtt = useCallback(() => {\n    const content = formatAsVtt(transcript.segments);\n    const safeTitle = videoTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase();\n    downloadFile(`transcript_${safeTitle}.vtt`, content, 'text/vtt');\n  }, [transcript.segments, videoTitle]);\n\n  const handleSaveNote = useCallback(async () => {\n    cacheTranscript({ transcript, video }).catch((error) => {\n      console.error('Failed to cache transcript:', error);\n    });\n    const noteContent = `# Transcript: ${videoTitle}\\n\\n${transcript.plainText}`;\n    try {\n      await saveNote({\n        content: noteContent,\n        noteType: 'transcript',\n        onSuccess: (note) => {\n          console.log('Transcript saved as note:', note.id);\n        },\n        onError: (error) => {\n          console.error('Failed to save transcript:', error);\n        },\n      });\n    } catch (error) {\n      console.error('Failed to save note:', error);\n    }\n  }, [cacheTranscript, transcript, video, videoTitle, saveNote]);\n\n  return (\n    <div className=\"lockin-transcript-message\">\n      <div className=\"lockin-transcript-header\">\n        <div className=\"lockin-transcript-title-row\">\n          <span className=\"lockin-transcript-icon\"></span>\n          <span className=\"lockin-transcript-title\">Transcript: {videoTitle}</span>\n        </div>\n        <div className=\"lockin-transcript-meta\">\n          Transcript found | {transcript.segments.length} segments |{' '}\n          {formatTime(transcript.durationMs || 0)}\n        </div>\n      </div>\n\n      <div className=\"lockin-transcript-content\">{transcript.plainText}</div>\n\n      <div className=\"lockin-transcript-actions\">\n        <button\n          className=\"lockin-transcript-action-btn\"\n          onClick={handleDownloadTxt}\n          title=\"Download as plain text\"\n          type=\"button\"\n        >\n           Download .txt\n        </button>\n        <button\n          className=\"lockin-transcript-action-btn\"\n          onClick={handleDownloadVtt}\n          title=\"Download as VTT with timestamps\"\n          type=\"button\"\n        >\n           Download .vtt\n        </button>\n        <button\n          className=\"lockin-transcript-action-btn lockin-transcript-action-primary\"\n          onClick={handleSaveNote}\n          title=\"Save transcript as note\"\n          type=\"button\"\n        >\n           Save note\n        </button>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\components\\TranscriptVideoListPanel.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'TranscriptVideoListPanel' has too many lines (52). Maximum allowed is 50.",
        "line": 57,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 111,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 57,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 57,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 80,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 80,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2402, 2407], "text": "(error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2402, 2407], "text": "(error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2402, 2407], "text": "(Boolean(error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 81,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 81,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2438, 2451], "text": "(detectionHint != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2438, 2451], "text": "(detectionHint ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2438, 2451], "text": "(Boolean(detectionHint))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 82,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 82,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2490, 2502], "text": "(authRequired != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 93,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 93,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3122, 3128], "text": "(result != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 94,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 94,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [3202, 3212], "text": "(noCaptions ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [3202, 3212], "text": "(noCaptions === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 105,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 105,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3583, 3599], "text": "(extractionResult != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * TranscriptVideoListPanel Component\n *\n * Wraps the generic VideoListPanel with transcript-specific features:\n * - \"No transcript\" badges for videos without captions\n * - AI transcription actions and progress\n * - Extraction state management\n *\n * This is the component that LockInSidebar.tsx should import.\n */\n\nimport type { DetectedVideo } from '@core/transcripts/types';\nimport { VideoListPanel } from '../../videos';\nimport { TranscriptVideoStatus } from './TranscriptVideoStatus';\nimport type { AiTranscriptionUiState, VideoExtractionResult } from './types';\nimport { isAiTranscriptionBusy } from './types';\n\n// Re-export types for consumers\nexport type { AiTranscriptionUiState, VideoExtractionResult } from './types';\n\nexport interface TranscriptVideoListPanelProps {\n  /** List of detected videos */\n  videos: DetectedVideo[];\n  /** Whether video detection is in progress */\n  isLoading: boolean;\n  /** Callback when a video is selected for extraction */\n  onSelectVideo: (video: DetectedVideo) => void;\n  /** Callback to close the panel */\n  onClose: () => void;\n\n  // State props\n  /** Error message if detection failed */\n  error?: string;\n  /** Optional hint to show when no videos are detected */\n  detectionHint?: string;\n  /** Auth required info for sign-in prompt */\n  authRequired?: {\n    provider: string;\n    signInUrl: string;\n  };\n\n  // Transcript-specific props\n  /** Whether transcript extraction is in progress */\n  isExtracting: boolean;\n  /** ID of video currently being extracted */\n  extractingVideoId: string | null;\n  /** Per-video extraction results */\n  extractionResults: Record<string, VideoExtractionResult>;\n  /** AI transcription state */\n  aiTranscription: AiTranscriptionUiState;\n  /** Callback to start AI transcription */\n  onTranscribeWithAI: (video: DetectedVideo) => void;\n  /** Callback to cancel AI transcription */\n  onCancelAi: () => void;\n}\n\nexport function TranscriptVideoListPanel({\n  videos,\n  isLoading,\n  onSelectVideo,\n  onClose,\n  error,\n  detectionHint,\n  authRequired,\n  isExtracting,\n  extractingVideoId,\n  extractionResults,\n  aiTranscription,\n  onTranscribeWithAI,\n  onCancelAi,\n}: TranscriptVideoListPanelProps) {\n  const isAiBusy = isAiTranscriptionBusy(aiTranscription.status);\n\n  return (\n    <VideoListPanel\n      videos={videos}\n      isLoading={isLoading}\n      onSelectVideo={onSelectVideo}\n      onClose={onClose}\n      {...(error ? { error } : {})}\n      {...(detectionHint ? { detectionHint } : {})}\n      {...(authRequired ? { authRequired } : {})}\n      selectedVideoId={extractingVideoId}\n      isVideoDisabled={(video) => {\n        // Disable if another video is extracting or AI is busy on a different video\n        const isThisExtracting = isExtracting && extractingVideoId === video.id;\n        const isAnotherExtracting = isExtracting && extractingVideoId !== video.id;\n        return isAnotherExtracting || (isAiBusy && !isThisExtracting);\n      }}\n      renderItemBadge={({ video }) => {\n        // Show \"No transcript\" badge for videos without captions\n        const result = extractionResults[video.id];\n        const noCaptions = result && !result.success && result.errorCode === 'NO_CAPTIONS';\n        return noCaptions ? <span className=\"lockin-video-item-badge\">No transcript</span> : null;\n      }}\n      renderItemActions={({ video }) => {\n        const extractionResult = extractionResults[video.id];\n        const statusProps = {\n          video,\n          aiTranscription,\n          isExtracting,\n          isAiBusy,\n          onTranscribeWithAI,\n          onCancelAi,\n          ...(extractionResult ? { extractionResult } : {}),\n        };\n        return <TranscriptVideoStatus {...statusProps} />;\n      }}\n    />\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\components\\TranscriptVideoStatus.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'TranscriptVideoStatus' has too many lines (98). Maximum allowed is 50.",
        "line": 25,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 126,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 25,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 25,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'aiAvailable' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 34,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 34,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 40,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 40,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1185, 1201], "text": "(extractionResult != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 90,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 90,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2914, 2928], "text": "(aiErrorMessage != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2914, 2928], "text": "(aiErrorMessage ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2914, 2928], "text": "(Boolean(aiErrorMessage))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 123,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 123,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3969, 3984], "text": "(extractionError != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3969, 3984], "text": "(extractionError ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3969, 3984], "text": "(Boolean(extractionError))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * TranscriptVideoStatus Component\n *\n * Renders transcript-specific status and actions for a video:\n * - AI transcription progress (uploading, processing, transcribing)\n * - AI transcription errors and retry\n * - \"Transcribe with AI\" action button when captions unavailable\n * - Extraction errors\n */\n\nimport type { DetectedVideo } from '@core/transcripts/types';\nimport type { AiTranscriptionUiState, VideoExtractionResult } from './types';\nimport { resolveTranscriptVideoStatusState } from './TranscriptVideoStatusState';\n\ninterface TranscriptVideoStatusProps {\n  video: DetectedVideo;\n  extractionResult?: VideoExtractionResult;\n  aiTranscription: AiTranscriptionUiState;\n  isExtracting: boolean;\n  isAiBusy: boolean;\n  onTranscribeWithAI: (video: DetectedVideo) => void;\n  onCancelAi: () => void;\n}\n\nexport function TranscriptVideoStatus({\n  video,\n  extractionResult,\n  aiTranscription,\n  isExtracting,\n  isAiBusy,\n  onTranscribeWithAI,\n  onCancelAi,\n}: TranscriptVideoStatusProps) {\n  const { aiAvailable, extractionError, aiIsCanceled, ...uiState } =\n    resolveTranscriptVideoStatusState({\n      video,\n      aiTranscription,\n      isExtracting,\n      isAiBusy,\n      ...(extractionResult ? { extractionResult } : {}),\n    });\n  const {\n    showAiProgress,\n    showAiError,\n    showAiAction,\n    disableAiAction,\n    progressLabel,\n    progressMessage,\n    progressPercent,\n    aiActionSubtitle,\n    aiErrorMessage,\n  } = uiState;\n\n  return (\n    <>\n      {/* AI Progress */}\n      {showAiProgress && (\n        <div className=\"lockin-video-item-ai lockin-video-item-ai-active\" aria-live=\"polite\">\n          <div className=\"lockin-video-item-ai-main\">\n            <span className=\"lockin-inline-spinner\" />\n            <div className=\"lockin-video-item-ai-text\">\n              <div className=\"lockin-video-item-ai-title\">{progressLabel}</div>\n              <div className=\"lockin-video-item-ai-subtitle\">{progressMessage}</div>\n            </div>\n          </div>\n          {typeof progressPercent === 'number' && (\n            <div className=\"lockin-video-item-ai-progress\">\n              <div\n                className=\"lockin-video-item-ai-progress-bar\"\n                style={{\n                  width: `${Math.min(100, Math.max(0, progressPercent))}%`,\n                }}\n              />\n            </div>\n          )}\n          <button className=\"lockin-video-item-ai-btn\" onClick={onCancelAi} type=\"button\">\n            Cancel\n          </button>\n        </div>\n      )}\n\n      {/* AI Error / Canceled */}\n      {showAiError && (\n        <div className=\"lockin-video-item-ai lockin-video-item-ai-error\">\n          <div className=\"lockin-video-item-ai-text\">\n            <div className=\"lockin-video-item-ai-title\">\n              {aiIsCanceled ? 'Transcription canceled' : 'AI transcription failed'}\n            </div>\n            <div className=\"lockin-video-item-ai-subtitle\">\n              {aiErrorMessage || \"Try again when you're ready.\"}\n            </div>\n          </div>\n          <button\n            className=\"lockin-video-item-ai-btn\"\n            onClick={() => onTranscribeWithAI(video)}\n            type=\"button\"\n            disabled={disableAiAction}\n          >\n            Try again\n          </button>\n        </div>\n      )}\n\n      {/* AI Action (initial state) */}\n      {showAiAction && !showAiError && !showAiProgress && (\n        <div className=\"lockin-video-item-ai\">\n          <div className=\"lockin-video-item-ai-text\">\n            <div className=\"lockin-video-item-ai-title\">Transcribe with AI</div>\n            <div className=\"lockin-video-item-ai-subtitle\">{aiActionSubtitle}</div>\n          </div>\n          <button\n            className=\"lockin-video-item-ai-btn\"\n            onClick={() => onTranscribeWithAI(video)}\n            type=\"button\"\n            disabled={disableAiAction}\n          >\n            Transcribe with AI\n          </button>\n        </div>\n      )}\n\n      {/* Extraction Error (non-AI) */}\n      {extractionError && <div className=\"lockin-video-item-error\">{extractionError}</div>}\n    </>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\components\\TranscriptVideoStatusState.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 5,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 5,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 7,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 7,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [318, 339], "text": "(aiTranscription.video != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 9,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 9,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [477, 487], "text": "(aiForVideo != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 17,
        "column": 21,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 17,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [765, 782], "text": "((aiForVideo?.error) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [765, 782], "text": "((aiForVideo?.error) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [765, 782], "text": "(Boolean((aiForVideo?.error)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 21,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 21,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 23,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 23,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [897, 913], "text": "(extractionResult != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 24,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 24,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [1022, 1032], "text": "(noCaptions ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [1022, 1032], "text": "(noCaptions === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 26,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 26,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1111, 1127], "text": "(extractionResult != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 27,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 27,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1181, 1203], "text": "(extractionResult.error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1181, 1203], "text": "(extractionResult.error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1181, 1203], "text": "(Boolean(extractionResult.error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 32,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 32,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 61,
        "column": 5,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 61,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2107, 2134], "text": "((aiForVideo?.progressMessage) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2107, 2134], "text": "((aiForVideo?.progressMessage) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2107, 2134], "text": "(Boolean((aiForVideo?.progressMessage)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 81,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 81,
        "endColumn": 50
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { DetectedVideo } from '@core/transcripts/types';\nimport type { AiTranscriptionUiState, VideoExtractionResult } from './types';\nimport { isAiTranscriptionBusy, getAiStatusLabel } from './types';\n\nfunction getAiState(video: DetectedVideo, aiTranscription: AiTranscriptionUiState) {\n  const aiForVideo =\n    aiTranscription.video && aiTranscription.video.id === video.id ? aiTranscription : null;\n  const aiStatus = aiForVideo?.status ?? 'idle';\n  const aiIsActive = aiForVideo ? isAiTranscriptionBusy(aiStatus) : false;\n  return {\n    aiForVideo,\n    aiStatus,\n    aiIsActive,\n    aiIsFailed: aiForVideo?.status === 'failed',\n    aiIsCanceled: aiForVideo?.status === 'canceled',\n    aiIsCompleted: aiForVideo?.status === 'completed',\n    aiErrorMessage: aiForVideo?.error || null,\n  };\n}\n\nfunction getExtractionState(extractionResult?: VideoExtractionResult) {\n  const noCaptions =\n    extractionResult && !extractionResult.success && extractionResult.errorCode === 'NO_CAPTIONS';\n  const aiAvailable = Boolean(noCaptions && extractionResult?.aiTranscriptionAvailable);\n  const extractionError =\n    extractionResult && !extractionResult.success && !aiAvailable\n      ? extractionResult.error || 'Failed to extract transcript'\n      : null;\n  return { noCaptions, aiAvailable, extractionError };\n}\n\nfunction getAiUiState({\n  aiForVideo,\n  aiStatus,\n  aiIsActive,\n  aiIsFailed,\n  aiIsCanceled,\n  aiIsCompleted,\n  aiErrorMessage,\n  aiAvailable,\n  isExtracting,\n  isAiBusy,\n}: {\n  aiForVideo: AiTranscriptionUiState | null;\n  aiStatus: AiTranscriptionUiState['status'];\n  aiIsActive: boolean;\n  aiIsFailed: boolean;\n  aiIsCanceled: boolean;\n  aiIsCompleted: boolean;\n  aiErrorMessage: string | null;\n  aiAvailable: boolean;\n  isExtracting: boolean;\n  isAiBusy: boolean;\n}) {\n  const showAiProgress = aiIsActive;\n  const showAiError = aiAvailable && (aiIsFailed || aiIsCanceled);\n  const showAiAction = aiAvailable && !aiIsActive && !aiIsCompleted;\n  const disableAiAction = isExtracting || (isAiBusy && !aiIsActive);\n  const progressLabel = getAiStatusLabel(aiStatus);\n  const progressMessage =\n    aiForVideo?.progressMessage || 'Working on your transcript. This can take a few minutes.';\n  const progressPercent = aiForVideo?.progressPercent;\n  const aiActionSubtitle =\n    disableAiAction && isAiBusy && !aiIsActive\n      ? 'Another AI transcription is already running.'\n      : 'Generates captions when none are available.';\n\n  return {\n    showAiProgress,\n    showAiError,\n    showAiAction,\n    disableAiAction,\n    progressLabel,\n    progressMessage,\n    progressPercent,\n    aiActionSubtitle,\n    aiErrorMessage,\n  };\n}\n\nexport function resolveTranscriptVideoStatusState({\n  video,\n  extractionResult,\n  aiTranscription,\n  isExtracting,\n  isAiBusy,\n}: {\n  video: DetectedVideo;\n  extractionResult?: VideoExtractionResult;\n  aiTranscription: AiTranscriptionUiState;\n  isExtracting: boolean;\n  isAiBusy: boolean;\n}) {\n  const aiState = getAiState(video, aiTranscription);\n  const { aiAvailable, extractionError } = getExtractionState(extractionResult);\n  const uiState = getAiUiState({\n    aiForVideo: aiState.aiForVideo,\n    aiStatus: aiState.aiStatus,\n    aiIsActive: aiState.aiIsActive,\n    aiIsFailed: aiState.aiIsFailed,\n    aiIsCanceled: aiState.aiIsCanceled,\n    aiIsCompleted: aiState.aiIsCompleted,\n    aiErrorMessage: aiState.aiErrorMessage,\n    aiAvailable,\n    isExtracting,\n    isAiBusy,\n  });\n\n  return {\n    aiAvailable,\n    extractionError,\n    aiIsCanceled: aiState.aiIsCanceled,\n    ...uiState,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\components\\types.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/switch-exhaustiveness-check",
        "severity": 1,
        "message": "Switch is not exhaustive. Cases not matched: \"idle\"",
        "line": 57,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "switchIsNotExhaustive",
        "endLine": 57,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "addMissingCases",
            "fix": {
              "range": [2014, 2014],
              "text": "case \"idle\": { throw new Error('Not implemented yet: \"idle\" case') }\n    "
            },
            "desc": "Add branches for missing cases."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Transcript-specific types for video list UI\n *\n * These types extend the generic video types with transcript-specific\n * state for extraction and AI transcription.\n */\n\nimport type { DetectedVideo } from '@core/transcripts/types';\n\n// -----------------------------------------------------------------------------\n// AI Transcription UI Types\n// -----------------------------------------------------------------------------\n\nexport type AiTranscriptionStatus =\n  | 'idle'\n  | 'starting'\n  | 'uploading'\n  | 'processing'\n  | 'polling'\n  | 'completed'\n  | 'failed'\n  | 'canceled';\n\nexport interface AiTranscriptionUiState {\n  status: AiTranscriptionStatus;\n  video: DetectedVideo | null;\n  progressMessage?: string | null;\n  progressPercent?: number | null;\n  error?: string | null;\n}\n\n// -----------------------------------------------------------------------------\n// Extraction Result Types\n// -----------------------------------------------------------------------------\n\nexport interface VideoExtractionResult {\n  success: boolean;\n  error?: string;\n  errorCode?: string;\n  aiTranscriptionAvailable?: boolean;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nexport function isAiTranscriptionBusy(status: AiTranscriptionStatus): boolean {\n  return (\n    status === 'starting' ||\n    status === 'uploading' ||\n    status === 'processing' ||\n    status === 'polling'\n  );\n}\n\nexport function getAiStatusLabel(status: AiTranscriptionStatus): string {\n  switch (status) {\n    case 'starting':\n      return 'Preparing AI transcription';\n    case 'uploading':\n      return 'Uploading media';\n    case 'processing':\n      return 'Processing audio';\n    case 'polling':\n      return 'Transcribing';\n    case 'completed':\n      return 'Transcript ready';\n    case 'failed':\n      return 'AI transcription failed';\n    case 'canceled':\n      return 'Transcription canceled';\n    default:\n      return 'AI transcription';\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\extractHtml5TranscriptFromDom.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 15,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 15,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [330, 340], "text": "candidate == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [331, 340], "text": "(candidate ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [330, 340], "text": "!Boolean(candidate)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 25,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 25,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [557, 575], "text": "(videoEl.currentSrc.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [557, 575], "text": "(videoEl.currentSrc !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [557, 575], "text": "(Boolean(videoEl.currentSrc))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 26,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 26,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [583, 610], "text": "(videoEl.getAttribute('src') != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [583, 610], "text": "(videoEl.getAttribute('src') ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [583, 610], "text": "(Boolean(videoEl.getAttribute('src')))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 27,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 27,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [618, 629], "text": "(videoEl.src.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [618, 629], "text": "(videoEl.src !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [618, 629], "text": "(Boolean(videoEl.src))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 28,
        "column": 5,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 28,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": {
              "range": [637, 689],
              "text": "((videoEl.querySelector('source')?.getAttribute('src')) != null)"
            },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": {
              "range": [637, 689],
              "text": "((videoEl.querySelector('source')?.getAttribute('src')) ?? \"\")"
            },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": {
              "range": [637, 689],
              "text": "(Boolean((videoEl.querySelector('source')?.getAttribute('src'))))"
            },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 34,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 34,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [859, 870], "text": "video.domId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [859, 870], "text": "video.domId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [859, 870], "text": "Boolean(video.domId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 39,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 39,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [995, 1012], "text": "video.domSelector != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [995, 1012], "text": "video.domSelector ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [995, 1012], "text": "Boolean(video.domSelector)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 44,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 44,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1160, 1174], "text": "video.mediaUrl != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1160, 1174], "text": "video.mediaUrl ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1160, 1174], "text": "Boolean(video.mediaUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 48,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 48,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1383, 1395], "text": "(candidateUrl != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1383, 1395], "text": "(candidateUrl ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1383, 1395], "text": "(Boolean(candidateUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 74,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 74,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1970, 1975], "text": "text.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1970, 1975], "text": "text === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1970, 1975], "text": "!Boolean(text)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 87,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 87,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2255, 2267], "text": "lastSegment == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 110,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 110,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2862, 2866], "text": "(cues != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 117,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 117,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3031, 3035], "text": "(cues != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'extractHtml5TranscriptFromDom' has too many statements (22). Maximum allowed is 20.",
        "line": 121,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 164,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 125,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 125,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3266, 3274], "text": "videoEl == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 129,
        "column": 36,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 129,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 150,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 150,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3876, 3881], "text": "(cues == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 153,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 153,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3999, 4009], "text": "transcript != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 18,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * HTML5 transcript extraction from DOM textTracks.\n */\n\nimport type {\n  DetectedVideo,\n  TranscriptExtractionResult,\n  TranscriptResult,\n} from '@core/transcripts/types';\n\nconst CUE_WAIT_TIMEOUT_MS = 1500;\nconst CUE_POLL_INTERVAL_MS = 100;\n\nfunction resolveDomUrl(candidate: string | null | undefined): string | null {\n  if (!candidate) return null;\n  try {\n    return new URL(candidate, document.baseURI).toString();\n  } catch {\n    return null;\n  }\n}\n\nfunction getCandidateMediaUrl(videoEl: HTMLVideoElement): string | null {\n  const candidate =\n    videoEl.currentSrc ||\n    videoEl.getAttribute('src') ||\n    videoEl.src ||\n    videoEl.querySelector('source')?.getAttribute('src') ||\n    videoEl.querySelector('source')?.src;\n  return resolveDomUrl(candidate);\n}\n\nfunction findHtml5VideoElement(video: DetectedVideo): HTMLVideoElement | null {\n  if (video.domId) {\n    const byId = document.getElementById(video.domId);\n    if (byId instanceof HTMLVideoElement) return byId;\n  }\n\n  if (video.domSelector) {\n    const bySelector = document.querySelector(video.domSelector);\n    if (bySelector instanceof HTMLVideoElement) return bySelector;\n  }\n\n  if (video.mediaUrl) {\n    const candidates = Array.from(document.querySelectorAll('video')) as HTMLVideoElement[];\n    for (const candidate of candidates) {\n      const candidateUrl = getCandidateMediaUrl(candidate);\n      if (candidateUrl && candidateUrl === video.mediaUrl) {\n        return candidate;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction getCueText(cue: TextTrackCue): string {\n  if ('text' in cue) {\n    const text = (cue as VTTCue).text;\n    return typeof text === 'string' ? text : '';\n  }\n  return '';\n}\n\nfunction buildTranscriptFromCues(\n  cues: TextTrackCueList,\n  durationSeconds: number,\n): TranscriptResult | null {\n  const segments: TranscriptResult['segments'] = [];\n  const textParts: string[] = [];\n\n  for (const cue of Array.from(cues)) {\n    const text = getCueText(cue).trim();\n    if (!text) continue;\n\n    segments.push({\n      startMs: Math.round(cue.startTime * 1000),\n      endMs: Math.round(cue.endTime * 1000),\n      text,\n    });\n    textParts.push(text);\n  }\n\n  if (segments.length === 0) return null;\n\n  const lastSegment = segments[segments.length - 1];\n  if (!lastSegment) return null;\n  const fallbackDurationMs =\n    typeof lastSegment.endMs === 'number' ? lastSegment.endMs : lastSegment.startMs;\n  const durationMs =\n    Number.isFinite(durationSeconds) && durationSeconds > 0\n      ? Math.round(durationSeconds * 1000)\n      : fallbackDurationMs;\n\n  return {\n    plainText: textParts.join('\\n'),\n    segments,\n    durationMs,\n  };\n}\n\nasync function waitForTrackCues(\n  track: TextTrack,\n  timeoutMs: number,\n): Promise<TextTrackCueList | null> {\n  const deadline = Date.now() + timeoutMs;\n\n  while (Date.now() < deadline) {\n    const cues = track.cues;\n    if (cues && cues.length > 0) {\n      return cues;\n    }\n    await new Promise((resolve) => setTimeout(resolve, CUE_POLL_INTERVAL_MS));\n  }\n\n  const cues = track.cues;\n  if (cues && cues.length > 0) return cues;\n  return null;\n}\n\nexport async function extractHtml5TranscriptFromDom(\n  video: DetectedVideo,\n): Promise<TranscriptExtractionResult | null> {\n  const videoEl = findHtml5VideoElement(video);\n  if (!videoEl) {\n    return null;\n  }\n\n  const captionTracks = Array.from(videoEl.textTracks || []).filter(\n    (track) => track.kind === 'captions' || track.kind === 'subtitles',\n  );\n\n  if (captionTracks.length === 0) {\n    return null;\n  }\n\n  const deadline = Date.now() + CUE_WAIT_TIMEOUT_MS;\n\n  for (const track of captionTracks) {\n    const previousMode = track.mode;\n    if (track.mode === 'disabled') {\n      track.mode = 'hidden';\n    }\n\n    try {\n      const remainingMs = deadline - Date.now();\n      if (remainingMs <= 0) break;\n\n      const cues = await waitForTrackCues(track, remainingMs);\n      if (!cues || cues.length === 0) continue;\n\n      const transcript = buildTranscriptFromCues(cues, videoEl.duration);\n      if (transcript) {\n        return { success: true, transcript };\n      }\n    } finally {\n      if (previousMode === 'disabled') {\n        track.mode = previousMode;\n      }\n    }\n  }\n\n  return null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\aiTranscriptionHelpers.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'resolvePanoptoMediaUrl' has too many lines (52). Maximum allowed is 50.",
        "line": 11,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 66,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 15,
        "column": 39,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 15,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [485, 499], "text": "(video.mediaUrl != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [485, 499], "text": "(video.mediaUrl ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [485, 499], "text": "(Boolean(video.mediaUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 35,
        "column": 39,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 35,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [961, 987], "text": "(mediaUrlResponse.mediaUrl == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [962, 987], "text": "(mediaUrlResponse.mediaUrl ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [961, 987], "text": "(!Boolean(mediaUrlResponse.mediaUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 37,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 37,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1022, 1044], "text": "(mediaUrlResponse.error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1022, 1044], "text": "(mediaUrlResponse.error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1022, 1044], "text": "(Boolean(mediaUrlResponse.error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 72,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 72,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1915, 1929], "text": "video.mediaUrl != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1915, 1929], "text": "video.mediaUrl ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1915, 1929], "text": "Boolean(video.mediaUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 91,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 91,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2445, 2458], "text": "(durationLabel != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2445, 2458], "text": "(durationLabel ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2445, 2458], "text": "(Boolean(durationLabel))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Dispatch, SetStateAction } from 'react';\nimport type { DetectedVideo } from '@core/transcripts/types';\nimport {\n  sendToBackground,\n  formatDurationForConfirm,\n  LONG_DURATION_CONFIRM_MS,\n  type AiTranscriptionState,\n  type PanoptoMediaUrlResponse,\n} from './types';\n\nexport async function resolvePanoptoMediaUrl(\n  video: DetectedVideo,\n  setState: Dispatch<SetStateAction<AiTranscriptionState>>,\n): Promise<DetectedVideo | null> {\n  if (video.provider !== 'panopto' || video.mediaUrl) {\n    return video;\n  }\n\n  setState({\n    status: 'starting',\n    requestId: null,\n    jobId: null,\n    video,\n    progressMessage: 'Finding downloadable video URL... (checking if podcast download is enabled)',\n    progressPercent: null,\n    error: null,\n  });\n\n  try {\n    const mediaUrlResponse = await sendToBackground<PanoptoMediaUrlResponse>({\n      type: 'FETCH_PANOPTO_MEDIA_URL',\n      payload: { video },\n    });\n\n    if (!mediaUrlResponse.success || !mediaUrlResponse.mediaUrl) {\n      const errorMsg =\n        mediaUrlResponse.error ||\n        'Could not find video URL. The video may be restricted or require authentication.';\n      setState({\n        status: 'failed',\n        requestId: null,\n        jobId: null,\n        video,\n        progressMessage: null,\n        progressPercent: null,\n        error: errorMsg,\n      });\n      return null;\n    }\n\n    return { ...video, mediaUrl: mediaUrlResponse.mediaUrl };\n  } catch (error) {\n    const errorMsg =\n      error instanceof Error ? error.message : 'Failed to prepare video for AI transcription';\n    setState({\n      status: 'failed',\n      requestId: null,\n      jobId: null,\n      video,\n      progressMessage: null,\n      progressPercent: null,\n      error: errorMsg,\n    });\n    return null;\n  }\n}\n\nexport function ensureVideoHasMediaUrl(\n  video: DetectedVideo,\n  setState: Dispatch<SetStateAction<AiTranscriptionState>>,\n): boolean {\n  if (video.mediaUrl) return true;\n  setState({\n    status: 'failed',\n    requestId: null,\n    jobId: null,\n    video,\n    progressMessage: null,\n    progressPercent: null,\n    error: 'AI transcription is not available for this video.',\n  });\n  return false;\n}\n\nexport function buildConfirmMessage(video: DetectedVideo): string {\n  const durationLabel = formatDurationForConfirm(video.durationMs);\n  const isLong =\n    typeof video.durationMs === 'number' && video.durationMs >= LONG_DURATION_CONFIRM_MS;\n\n  return isLong\n    ? `This ${durationLabel ? `${durationLabel} ` : ''}video will be uploaded to Lock-in for AI transcription. This may take several minutes. Continue?`\n    : 'This video will be uploaded to Lock-in for AI transcription. Continue?';\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\aiTranscriptionStateHandlers.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 12,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 12,
        "endColumn": 25
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 13,
        "column": 53,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 13,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 38,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 38,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 55,
        "column": 8,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 55,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1693, 1713], "text": "response.transcript == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 59,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 59,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1787, 1801], "text": "(response.jobId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1787, 1801], "text": "(response.jobId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1787, 1801], "text": "(Boolean(response.jobId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 71,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 71,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 84,
        "column": 24,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 84,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2488, 2502], "text": "(response.error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2488, 2502], "text": "(response.error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2488, 2502], "text": "(Boolean(response.error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 91,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 91,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2761, 2775], "text": "(response.jobId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2761, 2775], "text": "(response.jobId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2761, 2775], "text": "(Boolean(response.jobId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 101,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 101,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 126,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 126,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 140,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 140,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Dispatch, MutableRefObject, SetStateAction } from 'react';\nimport type { DetectedVideo, TranscriptResult } from '@core/transcripts/types';\nimport {\n  mapStageToStatus,\n  INITIAL_AI_TRANSCRIPTION_STATE,\n  type AiTranscriptionResponse,\n  type AiTranscriptionState,\n  type TranscriptResponseData,\n} from './types';\nimport { buildConfirmMessage } from './aiTranscriptionHelpers';\n\nfunction createRequestId() {\n  return `ai-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n}\n\nexport function startAiTranscriptionRequest(\n  video: DetectedVideo,\n  setState: Dispatch<SetStateAction<AiTranscriptionState>>,\n  activeAiRequestIdRef: MutableRefObject<string | null>,\n): string | null {\n  const confirmMessage = buildConfirmMessage(video);\n  if (!window.confirm(confirmMessage)) return null;\n\n  const requestId = createRequestId();\n  activeAiRequestIdRef.current = requestId;\n  setState({\n    status: 'starting',\n    requestId,\n    jobId: null,\n    video,\n    progressMessage: 'No transcript available - transcribing with AI... This may take a minute.',\n    progressPercent: null,\n    error: null,\n  });\n  return requestId;\n}\n\nexport function handleAiTranscriptionSuccess({\n  resolvedVideo,\n  requestId,\n  response,\n  setState,\n  activeAiRequestIdRef,\n  onTranscriptReady,\n  onExtractionResult,\n}: {\n  resolvedVideo: DetectedVideo;\n  requestId: string;\n  response: AiTranscriptionResponse;\n  setState: Dispatch<SetStateAction<AiTranscriptionState>>;\n  activeAiRequestIdRef: MutableRefObject<string | null>;\n  onTranscriptReady?: (video: DetectedVideo, transcript: TranscriptResult) => void;\n  onExtractionResult?: (videoId: string, result: TranscriptResponseData) => void;\n}) {\n  if (!response.transcript) return;\n  setState({\n    status: 'completed',\n    requestId,\n    jobId: response.jobId || null,\n    video: resolvedVideo,\n    progressMessage: 'Transcript ready',\n    progressPercent: 100,\n    error: null,\n  });\n\n  onTranscriptReady?.(resolvedVideo, response.transcript);\n  onExtractionResult?.(resolvedVideo.id, { success: true, transcript: response.transcript });\n  activeAiRequestIdRef.current = null;\n}\n\nexport function handleAiTranscriptionFailure({\n  resolvedVideo,\n  requestId,\n  response,\n  setState,\n  activeAiRequestIdRef,\n}: {\n  resolvedVideo: DetectedVideo;\n  requestId: string;\n  response: AiTranscriptionResponse;\n  setState: Dispatch<SetStateAction<AiTranscriptionState>>;\n  activeAiRequestIdRef: MutableRefObject<string | null>;\n}) {\n  const errorMessage = response.error || 'AI transcription failed';\n  const fallbackStatus = response.status === 'canceled' ? 'canceled' : 'failed';\n  const nextStatus = mapStageToStatus(response.status, fallbackStatus);\n\n  setState((prev) => ({\n    status: nextStatus,\n    requestId,\n    jobId: response.jobId || prev.jobId,\n    video: resolvedVideo,\n    progressMessage: null,\n    progressPercent: null,\n    error: errorMessage,\n  }));\n\n  activeAiRequestIdRef.current = null;\n}\n\nexport function handleAiTranscriptionError({\n  resolvedVideo,\n  requestId,\n  message,\n  setState,\n  activeAiRequestIdRef,\n}: {\n  resolvedVideo: DetectedVideo;\n  requestId: string;\n  message: string;\n  setState: Dispatch<SetStateAction<AiTranscriptionState>>;\n  activeAiRequestIdRef: MutableRefObject<string | null>;\n}) {\n  setState((prev) => ({\n    status: 'failed',\n    requestId,\n    jobId: prev.jobId,\n    video: resolvedVideo,\n    progressMessage: null,\n    progressPercent: null,\n    error: message,\n  }));\n  activeAiRequestIdRef.current = null;\n}\n\nexport function cancelAiTranscriptionState(\n  setState: Dispatch<SetStateAction<AiTranscriptionState>>,\n  activeAiRequestIdRef: MutableRefObject<string | null>,\n) {\n  activeAiRequestIdRef.current = null;\n  setState((prev) => ({\n    ...prev,\n    status: 'canceled',\n    progressMessage: 'Transcription canceled',\n    progressPercent: null,\n    error: null,\n  }));\n}\n\nexport function resetAiTranscriptionState(\n  setState: Dispatch<SetStateAction<AiTranscriptionState>>,\n  activeAiRequestIdRef: MutableRefObject<string | null>,\n) {\n  activeAiRequestIdRef.current = null;\n  setState(INITIAL_AI_TRANSCRIPTION_STATE);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\types.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 91,
        "column": 43,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 91,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 97,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 97,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2591, 2615], "text": "chrome.runtime.lastError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'normalizeTranscriptResponse' has too many statements (24). Maximum allowed is 20.",
        "line": 113,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 148,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 115,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 115,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3188, 3192], "text": "data != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 117,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 117,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3278, 3293], "text": "data.transcript != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 120,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 120,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3358, 3368], "text": "data.error != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3358, 3368], "text": "data.error ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3358, 3368], "text": "Boolean(data.error)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 135,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 135,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3867, 3886], "text": "response.transcript != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 138,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 138,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3949, 3963], "text": "response.error != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3949, 3963], "text": "response.error ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3949, 3963], "text": "Boolean(response.error)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/switch-exhaustiveness-check",
        "severity": 1,
        "message": "Switch is not exhaustive. Cases not matched: undefined | null",
        "line": 172,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "switchIsNotExhaustive",
        "endLine": 172,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "addMissingCases",
            "fix": {
              "range": [5331, 5331],
              "text": "case undefined: { throw new Error('Not implemented yet: undefined case') }\n    case null: { throw new Error('Not implemented yet: null case') }\n    "
            },
            "desc": "Add branches for missing cases."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 207,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 207,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5789, 5796], "text": "message != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5789, 5796], "text": "message ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5789, 5796], "text": "Boolean(message)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/switch-exhaustiveness-check",
        "severity": 1,
        "message": "Switch is not exhaustive. Cases not matched: undefined | null",
        "line": 212,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "switchIsNotExhaustive",
        "endLine": 212,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "addMissingCases",
            "fix": {
              "range": [6378, 6378],
              "text": "case undefined: { throw new Error('Not implemented yet: undefined case') }\n      case null: { throw new Error('Not implemented yet: null case') }\n      "
            },
            "desc": "Add branches for missing cases."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 232,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 232,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 244,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 244,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6849, 6860], "text": "(durationMs == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [6850, 6860], "text": "(durationMs ?? 0)" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6849, 6860], "text": "(!Boolean(durationMs))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3600.",
        "line": 246,
        "column": 43,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 246,
        "endColumn": 47
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3600.",
        "line": 247,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 247,
        "endColumn": 50
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 247,
        "column": 54,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 247,
        "endColumn": 56
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 248,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 248,
        "endColumn": 36
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 20.",
        "line": 263,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 263,
        "endColumn": 43
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 263,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 263,
        "endColumn": 48
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Shared types for transcript hooks\n */\n\nimport type { DetectedVideo, TranscriptResult } from '@core/transcripts/types';\n\n// -----------------------------------------------------------------------------\n// AI Transcription Types\n// -----------------------------------------------------------------------------\n\nexport type AiTranscriptionStatus =\n  | 'idle'\n  | 'starting'\n  | 'uploading'\n  | 'processing'\n  | 'polling'\n  | 'completed'\n  | 'failed'\n  | 'canceled';\n\nexport interface AiTranscriptionState {\n  status: AiTranscriptionStatus;\n  requestId: string | null;\n  jobId: string | null;\n  video: DetectedVideo | null;\n  progressMessage: string | null;\n  progressPercent: number | null;\n  error: string | null;\n}\n\n// -----------------------------------------------------------------------------\n// Extraction Types\n// -----------------------------------------------------------------------------\n\nexport interface TranscriptResponseData {\n  success: boolean;\n  transcript?: TranscriptResult;\n  error?: string;\n  errorCode?: string;\n  aiTranscriptionAvailable?: boolean;\n}\n\n// -----------------------------------------------------------------------------\n// Background Response Types\n// -----------------------------------------------------------------------------\n\nexport interface BackgroundResponse {\n  success?: boolean;\n  ok?: boolean;\n  data?: TranscriptResponseData;\n  error?: string;\n  errorCode?: string;\n  transcript?: TranscriptResult;\n  aiTranscriptionAvailable?: boolean;\n  videos?: DetectedVideo[];\n}\n\nexport interface AiTranscriptionResponse {\n  success: boolean;\n  transcript?: TranscriptResult;\n  error?: string;\n  errorCode?: string;\n  jobId?: string;\n  status?: string;\n  requestId?: string;\n}\n\nexport interface AiTranscriptionProgressPayload {\n  requestId?: string;\n  jobId?: string | null;\n  stage?: string | null;\n  message?: string | null;\n  percent?: number | null;\n}\n\nexport interface PanoptoMediaUrlResponse {\n  success: boolean;\n  mediaUrl?: string;\n  error?: string;\n}\n\n// -----------------------------------------------------------------------------\n// Background Communication\n// -----------------------------------------------------------------------------\n\n/**\n * Send a message to the background script and await response\n */\nexport async function sendToBackground<T>(message: unknown): Promise<T> {\n  return new Promise((resolve, reject) => {\n    if (typeof chrome === 'undefined' || !chrome.runtime) {\n      reject(new Error('Chrome runtime not available'));\n      return;\n    }\n\n    chrome.runtime.sendMessage(message, (response: T) => {\n      if (chrome.runtime.lastError) {\n        reject(new Error(chrome.runtime.lastError.message));\n      } else {\n        resolve(response);\n      }\n    });\n  });\n}\n\n// -----------------------------------------------------------------------------\n// Response Normalization\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize the background script response for transcript extraction\n */\nexport function normalizeTranscriptResponse(response: BackgroundResponse): TranscriptResponseData {\n  const data = response.data as TranscriptResponseData | undefined;\n  if (data) {\n    const normalized: TranscriptResponseData = { success: data.success };\n    if (data.transcript) {\n      normalized.transcript = data.transcript;\n    }\n    if (data.error) {\n      normalized.error = data.error;\n    }\n    const errorCode = data.errorCode ?? response.errorCode;\n    if (errorCode !== undefined) {\n      normalized.errorCode = errorCode;\n    }\n    const aiAvailable = data.aiTranscriptionAvailable ?? response.aiTranscriptionAvailable;\n    if (aiAvailable !== undefined) {\n      normalized.aiTranscriptionAvailable = aiAvailable;\n    }\n    return normalized;\n  }\n\n  const normalized: TranscriptResponseData = { success: response.success ?? false };\n  if (response.transcript) {\n    normalized.transcript = response.transcript;\n  }\n  if (response.error) {\n    normalized.error = response.error;\n  }\n  if (response.errorCode !== undefined) {\n    normalized.errorCode = response.errorCode;\n  }\n  if (response.aiTranscriptionAvailable !== undefined) {\n    normalized.aiTranscriptionAvailable = response.aiTranscriptionAvailable;\n  }\n  return normalized;\n}\n\n/**\n * Normalize the background script response for video detection\n */\nexport function normalizeVideoDetectionResponse(response: BackgroundResponse): DetectedVideo[] {\n  if (Array.isArray(response.videos)) {\n    return response.videos;\n  }\n  const data = response.data as { videos?: DetectedVideo[] } | undefined;\n  if (Array.isArray(data?.videos)) {\n    return data.videos;\n  }\n  return [];\n}\n\n// -----------------------------------------------------------------------------\n// AI Transcription Helpers\n// -----------------------------------------------------------------------------\n\nexport function mapStageToStatus(\n  stage: string | null | undefined,\n  fallback: AiTranscriptionStatus,\n): AiTranscriptionStatus {\n  switch (stage) {\n    case 'starting':\n      return 'starting';\n    case 'uploading':\n      return 'uploading';\n    case 'processing':\n      return 'processing';\n    case 'polling':\n      return 'polling';\n    case 'completed':\n      return 'completed';\n    case 'failed':\n      return 'failed';\n    case 'canceled':\n      return 'canceled';\n    default:\n      return fallback;\n  }\n}\n\nexport function isAiTranscriptionBusy(status: AiTranscriptionStatus): boolean {\n  return (\n    status === 'starting' ||\n    status === 'uploading' ||\n    status === 'processing' ||\n    status === 'polling'\n  );\n}\n\nexport function formatAiProgressMessage(\n  stage: string | null | undefined,\n  message: string | null | undefined,\n  percent: number | null | undefined,\n  fallback: string | null,\n): string | null {\n  if (message) {\n    return typeof percent === 'number' ? `${message} (${Math.round(percent)}%)` : message;\n  }\n\n  const stageLabel = (() => {\n    switch (stage) {\n      case 'starting':\n        return 'Preparing AI transcription';\n      case 'uploading':\n        return 'Uploading media';\n      case 'processing':\n        return 'Processing audio';\n      case 'polling':\n        return 'Transcribing';\n      case 'completed':\n        return 'Transcript ready';\n      case 'failed':\n        return 'AI transcription failed';\n      case 'canceled':\n        return 'Transcription canceled';\n      default:\n        return null;\n    }\n  })();\n\n  if (!stageLabel) return fallback;\n  if (typeof percent === 'number') {\n    return `${stageLabel} (${Math.round(percent)}%)`;\n  }\n  return stageLabel;\n}\n\n// -----------------------------------------------------------------------------\n// Duration Formatting\n// -----------------------------------------------------------------------------\n\nexport function formatDurationForConfirm(durationMs?: number): string | null {\n  if (!durationMs || durationMs <= 0) return null;\n  const totalSeconds = Math.round(durationMs / 1000);\n  const hours = Math.floor(totalSeconds / 3600);\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\n  const seconds = totalSeconds % 60;\n\n  if (hours > 0) {\n    return `${hours}h ${minutes}m`;\n  }\n  if (minutes > 0) {\n    return `${minutes}m ${seconds}s`;\n  }\n  return `${seconds}s`;\n}\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\nexport const LONG_DURATION_CONFIRM_MS = 20 * 60 * 1000;\n\nexport const INITIAL_AI_TRANSCRIPTION_STATE: AiTranscriptionState = {\n  status: 'idle',\n  requestId: null,\n  jobId: null,\n  video: null,\n  progressMessage: null,\n  progressPercent: null,\n  error: null,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\useAiTranscription.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 55,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 55,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2125, 2142], "text": "(onTranscriptReady != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 56,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 56,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2182, 2200], "text": "(onExtractionResult != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useAiTranscription Hook\n *\n * Manages AI transcription state, progress polling, and cancellation.\n * Handles communication with background script for AI-powered transcription.\n */\n\nimport { useState, useRef } from 'react';\nimport type { DetectedVideo, TranscriptResult } from '@core/transcripts/types';\nimport {\n  INITIAL_AI_TRANSCRIPTION_STATE,\n  type AiTranscriptionState,\n  type TranscriptResponseData,\n} from './types';\nimport { useAiTranscriptionActions } from './useAiTranscriptionActions';\nimport { useAiTranscriptionProgressListener } from './useAiTranscriptionProgressListener';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\nexport interface UseAiTranscriptionResult {\n  state: AiTranscriptionState;\n  /** Check if AI transcription is currently busy */\n  isBusy: boolean;\n  /** Start AI transcription for a video */\n  transcribeWithAI: (\n    video: DetectedVideo,\n    options?: { languageHint?: string; maxMinutes?: number },\n  ) => Promise<TranscriptResult | null>;\n  /** Cancel ongoing AI transcription */\n  cancelAiTranscription: () => Promise<void>;\n  /** Reset AI transcription state */\n  resetAiTranscription: () => void;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function useAiTranscription(\n  /** Callback when transcription completes successfully */\n  onTranscriptReady?: (video: DetectedVideo, transcript: TranscriptResult) => void,\n  /** Callback to update extraction state */\n  onExtractionResult?: (videoId: string, result: TranscriptResponseData) => void,\n): UseAiTranscriptionResult {\n  const [state, setState] = useState<AiTranscriptionState>(INITIAL_AI_TRANSCRIPTION_STATE);\n  const activeAiRequestIdRef = useRef<string | null>(null);\n\n  useAiTranscriptionProgressListener(activeAiRequestIdRef, setState);\n  const actions = useAiTranscriptionActions({\n    state,\n    setState,\n    activeAiRequestIdRef,\n    ...(onTranscriptReady ? { onTranscriptReady } : {}),\n    ...(onExtractionResult ? { onExtractionResult } : {}),\n  });\n\n  return {\n    state,\n    ...actions,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\useAiTranscriptionActions.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useAiTranscriptionActions' has too many lines (128). Maximum allowed is 50.",
        "line": 28,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 155,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 28,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 28,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 39,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 39,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1419, 1433], "text": "resolvedVideo == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 58,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 58,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2048, 2065], "text": "(onTranscriptReady != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 59,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 59,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2109, 2127], "text": "(onExtractionResult != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 83,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 83,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2909, 2923], "text": "resolvedVideo == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 85,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 85,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3001, 3011], "text": "requestId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3002, 3011], "text": "(requestId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3001, 3011], "text": "!Boolean(requestId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 94,
        "column": 33,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 94,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3352, 3371], "text": "(response.transcript != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 128,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 128,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4288, 4298], "text": "(requestId == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4289, 4298], "text": "(requestId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4288, 4298], "text": "(!Boolean(requestId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 128,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 128,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4302, 4308], "text": "(jobId == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4303, 4308], "text": "(jobId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4302, 4308], "text": "(!Boolean(jobId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Dispatch, MutableRefObject, SetStateAction } from 'react';\nimport { useCallback } from 'react';\nimport type { DetectedVideo, TranscriptResult } from '@core/transcripts/types';\nimport {\n  sendToBackground,\n  isAiTranscriptionBusy,\n  type AiTranscriptionState,\n  type AiTranscriptionResponse,\n  type TranscriptResponseData,\n} from './types';\nimport { ensureVideoHasMediaUrl, resolvePanoptoMediaUrl } from './aiTranscriptionHelpers';\nimport {\n  cancelAiTranscriptionState,\n  handleAiTranscriptionError,\n  handleAiTranscriptionFailure,\n  handleAiTranscriptionSuccess,\n  resetAiTranscriptionState,\n  startAiTranscriptionRequest,\n} from './aiTranscriptionStateHandlers';\n\ninterface UseAiTranscriptionActionsArgs {\n  state: AiTranscriptionState;\n  setState: Dispatch<SetStateAction<AiTranscriptionState>>;\n  activeAiRequestIdRef: MutableRefObject<string | null>;\n  onTranscriptReady?: (video: DetectedVideo, transcript: TranscriptResult) => void;\n  onExtractionResult?: (videoId: string, result: TranscriptResponseData) => void;\n}\nexport function useAiTranscriptionActions({\n  state,\n  setState,\n  activeAiRequestIdRef,\n  onTranscriptReady,\n  onExtractionResult,\n}: UseAiTranscriptionActionsArgs) {\n  const isBusy = isAiTranscriptionBusy(state.status);\n  const resolveVideo = useCallback(\n    async (video: DetectedVideo) => {\n      const resolvedVideo = await resolvePanoptoMediaUrl(video, setState);\n      if (!resolvedVideo) return null;\n      return ensureVideoHasMediaUrl(resolvedVideo, setState) ? resolvedVideo : null;\n    },\n    [setState],\n  );\n  const startRequest = useCallback(\n    (video: DetectedVideo) => {\n      return startAiTranscriptionRequest(video, setState, activeAiRequestIdRef);\n    },\n    [activeAiRequestIdRef, setState],\n  );\n  const handleSuccess = useCallback(\n    (resolvedVideo: DetectedVideo, requestId: string, response: AiTranscriptionResponse) => {\n      handleAiTranscriptionSuccess({\n        resolvedVideo,\n        requestId,\n        response,\n        setState,\n        activeAiRequestIdRef,\n        ...(onTranscriptReady ? { onTranscriptReady } : {}),\n        ...(onExtractionResult ? { onExtractionResult } : {}),\n      });\n    },\n    [activeAiRequestIdRef, onExtractionResult, onTranscriptReady, setState],\n  );\n  const handleFailure = useCallback(\n    (resolvedVideo: DetectedVideo, requestId: string, response: AiTranscriptionResponse) => {\n      handleAiTranscriptionFailure({\n        resolvedVideo,\n        requestId,\n        response,\n        setState,\n        activeAiRequestIdRef,\n      });\n    },\n    [activeAiRequestIdRef, setState],\n  );\n  const transcribeWithAI = useCallback(\n    async (\n      video: DetectedVideo,\n      options?: { languageHint?: string; maxMinutes?: number },\n    ): Promise<TranscriptResult | null> => {\n      if (isAiTranscriptionBusy(state.status)) return null;\n      const resolvedVideo = await resolveVideo(video);\n      if (!resolvedVideo) return null;\n      const requestId = startRequest(resolvedVideo);\n      if (!requestId) return null;\n      try {\n        const response = await sendToBackground<AiTranscriptionResponse>({\n          type: 'TRANSCRIBE_MEDIA_AI',\n          payload: { video: resolvedVideo, options, requestId },\n        });\n        if (activeAiRequestIdRef.current !== requestId) {\n          return null;\n        }\n        if (response.success && response.transcript) {\n          handleSuccess(resolvedVideo, requestId, response);\n          return response.transcript;\n        }\n        handleFailure(resolvedVideo, requestId, response);\n        return null;\n      } catch (error) {\n        if (activeAiRequestIdRef.current !== requestId) {\n          return null;\n        }\n        const message = error instanceof Error ? error.message : 'AI transcription failed';\n        handleAiTranscriptionError({\n          resolvedVideo,\n          requestId,\n          message,\n          setState,\n          activeAiRequestIdRef,\n        });\n        return null;\n      }\n    },\n    [\n      activeAiRequestIdRef,\n      handleFailure,\n      handleSuccess,\n      resolveVideo,\n      startRequest,\n      state.status,\n      setState,\n    ],\n  );\n  const cancelAiTranscription = useCallback(async (): Promise<void> => {\n    const requestId = state.requestId;\n    const jobId = state.jobId;\n    if (!requestId && !jobId) {\n      return;\n    }\n    cancelAiTranscriptionState(setState, activeAiRequestIdRef);\n    try {\n      await sendToBackground<AiTranscriptionResponse>({\n        type: 'TRANSCRIBE_MEDIA_AI',\n        payload: { action: 'cancel', requestId, jobId },\n      });\n    } catch (error) {\n      setState((prev) => ({\n        ...prev,\n        status: 'failed',\n        error: error instanceof Error ? error.message : 'Failed to cancel transcription',\n        progressPercent: null,\n      }));\n    }\n  }, [activeAiRequestIdRef, setState, state.jobId, state.requestId]);\n  const resetAiTranscription = useCallback(() => {\n    resetAiTranscriptionState(setState, activeAiRequestIdRef);\n  }, [activeAiRequestIdRef, setState]);\n  return {\n    isBusy,\n    transcribeWithAI,\n    cancelAiTranscription,\n    resetAiTranscription,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\useAiTranscriptionProgressListener.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 6,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 6,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 11,
        "column": 43,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorObject",
        "endLine": 11,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 18,
        "column": 7,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 18,
        "endColumn": 9
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 19,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 19,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 20,
        "column": 23,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 20,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [802, 817], "text": "(message.payload != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 21,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 21,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [835, 853], "text": "(payload.requestId == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [836, 853], "text": "(payload.requestId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [835, 853], "text": "(!Boolean(payload.requestId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Dispatch, MutableRefObject, SetStateAction } from 'react';\nimport { useEffect } from 'react';\nimport type { AiTranscriptionProgressPayload, AiTranscriptionState } from './types';\nimport { mapStageToStatus, formatAiProgressMessage } from './types';\n\nexport function useAiTranscriptionProgressListener(\n  activeRequestIdRef: MutableRefObject<string | null>,\n  setState: Dispatch<SetStateAction<AiTranscriptionState>>,\n) {\n  useEffect(() => {\n    if (typeof chrome === 'undefined' || !chrome.runtime?.onMessage) {\n      return;\n    }\n\n    const listener = (\n      message: { type?: string; payload?: AiTranscriptionProgressPayload },\n      _sender: chrome.runtime.MessageSender,\n    ) => {\n      if (!message || message.type !== 'TRANSCRIBE_MEDIA_AI_PROGRESS') return;\n      const payload = message.payload || {};\n      if (!payload.requestId || payload.requestId !== activeRequestIdRef.current) {\n        return;\n      }\n\n      setState((prev) => {\n        if (prev.requestId !== payload.requestId) return prev;\n        const nextStatus = mapStageToStatus(payload.stage, prev.status);\n        const progressMessage = formatAiProgressMessage(\n          payload.stage,\n          payload.message,\n          payload.percent,\n          prev.progressMessage,\n        );\n        return {\n          ...prev,\n          status: nextStatus,\n          progressMessage,\n          progressPercent:\n            typeof payload.percent === 'number' ? payload.percent : prev.progressPercent,\n        };\n      });\n    };\n\n    chrome.runtime.onMessage.addListener(listener);\n    return () => {\n      chrome.runtime.onMessage.removeListener(listener);\n    };\n  }, [activeRequestIdRef, setState]);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\useTranscriptCache.ts",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 5.",
        "line": 32,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 32,
        "endColumn": 22
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 36.",
        "line": 35,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 35,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 39,
        "column": 41,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 39,
        "endColumn": 54
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 46,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 46,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 51,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 51,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1466, 1475], "text": "mediaUrl.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1466, 1475], "text": "mediaUrl === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1466, 1475], "text": "!Boolean(mediaUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 57,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 57,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1645, 1653], "text": "segment.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1645, 1653], "text": "segment === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1645, 1653], "text": "!Boolean(segment)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 32.",
        "line": 58,
        "column": 28,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 58,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 78,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 78,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2206, 2213], "text": "(metaUrl.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2206, 2213], "text": "(metaUrl !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2206, 2213], "text": "(Boolean(metaUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 82,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 82,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2271, 2285], "text": "(video.mediaUrl != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2271, 2285], "text": "(video.mediaUrl ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2271, 2285], "text": "(Boolean(video.mediaUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 86,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 86,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2357, 2371], "text": "(video.embedUrl.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2357, 2371], "text": "(video.embedUrl !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2357, 2371], "text": "(Boolean(video.embedUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 108,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 108,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 124,
        "column": 8,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 124,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3182, 3209], "text": "(apiClient?.cacheTranscript) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 128,
        "column": 8,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorObject",
        "endLine": 128,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 128,
        "column": 30,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorObject",
        "endLine": 128,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 135,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 135,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 136,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 136,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3535, 3555], "text": "(input.video.provider.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3535, 3555], "text": "(input.video.provider !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3535, 3555], "text": "(Boolean(input.video.provider))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 137,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 137,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3588, 3602], "text": "(input.video.id.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3588, 3602], "text": "(input.video.id !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3588, 3602], "text": "(Boolean(input.video.id))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 149,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 149,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4048, 4065], "text": "(input.fingerprint != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4048, 4065], "text": "(input.fingerprint ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4048, 4065], "text": "(Boolean(input.fingerprint))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useTranscriptCache' has too many lines (80). Maximum allowed is 50.",
        "line": 167,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 256,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 167,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 167,
        "endColumn": 35
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async arrow function has too many lines (66). Maximum allowed is 50.",
        "line": 173,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 246,
        "endColumn": 6
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (31). Maximum allowed is 20.",
        "line": 173,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 246,
        "endColumn": 6
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 178,
        "column": 12,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 178,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4813, 4837], "text": "(client?.cacheTranscript) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 207,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 207,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [5549, 5557], "text": "mediaUrl.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [5549, 5557], "text": "mediaUrl !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5549, 5557], "text": "Boolean(mediaUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 210,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 210,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [5619, 5637], "text": "mediaUrlNormalized.length > 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [5619, 5637], "text": "mediaUrlNormalized !== \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5619, 5637], "text": "Boolean(mediaUrlNormalized)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 213,
        "column": 13,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 213,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5719, 5735], "text": "(input.meta?.etag) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5719, 5735], "text": "(input.meta?.etag) ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5719, 5735], "text": "Boolean((input.meta?.etag))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 216,
        "column": 13,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 216,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5800, 5824], "text": "(input.meta?.lastModified) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5800, 5824], "text": "(input.meta?.lastModified) ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5800, 5824], "text": "Boolean((input.meta?.lastModified))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 27,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useRef, useState } from 'react';\nimport type { ApiClient, TranscriptCacheMeta } from '@api/client';\nimport type { DetectedVideo, TranscriptResult } from '@core/transcripts/types';\n\nexport interface TranscriptCacheInput {\n  transcript: TranscriptResult;\n  video: DetectedVideo;\n  fingerprint?: string;\n  meta?: TranscriptCacheMeta;\n}\n\nexport interface TranscriptCacheState {\n  status: 'idle' | 'caching' | 'cached' | 'error';\n  error: string | null;\n  lastFingerprint: string | null;\n}\n\nconst INITIAL_STATE: TranscriptCacheState = {\n  status: 'idle',\n  error: null,\n  lastFingerprint: null,\n};\n\nfunction coerceNumber(value: unknown): number | null {\n  const num = Number(value);\n  return Number.isFinite(num) ? num : null;\n}\n\nfunction hashStringFallback(value: string): string {\n  let hash = 0;\n  for (let i = 0; i < value.length; i += 1) {\n    hash = (hash << 5) - hash + value.charCodeAt(i);\n    hash |= 0;\n  }\n  return Math.abs(hash).toString(36);\n}\n\nasync function hashStringSha256(value: string): Promise<string> {\n  if (typeof crypto === 'undefined' || !crypto.subtle || typeof TextEncoder === 'undefined') {\n    return hashStringFallback(value);\n  }\n\n  const data = new TextEncoder().encode(value);\n  const digest = await crypto.subtle.digest('SHA-256', data);\n  return Array.from(new Uint8Array(digest))\n    .map((byte) => byte.toString(16).padStart(2, '0'))\n    .join('');\n}\n\nfunction sanitizeMediaUrl(mediaUrl: string): string {\n  if (!mediaUrl) return '';\n  try {\n    const url = new URL(mediaUrl);\n    url.hash = '';\n    url.search = '';\n    const segments = url.pathname.split('/').map((segment) => {\n      if (!segment) return segment;\n      if (segment.length > 32) return '[redacted]';\n      return segment;\n    });\n    url.pathname = segments.join('/');\n    return url.toString();\n  } catch {\n    return '';\n  }\n}\n\nfunction normalizeMediaUrlForCache(mediaUrl: string): string {\n  return sanitizeMediaUrl(mediaUrl);\n}\n\nfunction isBlobUrl(value: string): boolean {\n  return value.startsWith('blob:');\n}\n\nfunction resolveMediaUrl(video: DetectedVideo, meta?: TranscriptCacheMeta): string {\n  const metaUrl = typeof meta?.mediaUrl === 'string' ? meta.mediaUrl : '';\n  if (metaUrl && !isBlobUrl(metaUrl)) {\n    return metaUrl;\n  }\n\n  if (video.mediaUrl && !isBlobUrl(video.mediaUrl)) {\n    return video.mediaUrl;\n  }\n\n  if (video.embedUrl && !isBlobUrl(video.embedUrl)) {\n    return video.embedUrl;\n  }\n\n  return '';\n}\n\nasync function buildFingerprint({\n  provider,\n  videoId,\n  mediaUrlNormalized,\n  durationMs,\n}: {\n  provider: string;\n  videoId: string;\n  mediaUrlNormalized: string;\n  durationMs: number | null;\n}): Promise<string> {\n  const source = [provider, videoId, mediaUrlNormalized, durationMs ?? ''].join('|');\n  return hashStringSha256(source);\n}\n\nfunction setCacheError(\n  setState: React.Dispatch<React.SetStateAction<TranscriptCacheState>>,\n  message: string,\n) {\n  setState((prev) => ({\n    ...prev,\n    status: 'error',\n    error: message,\n  }));\n}\n\nfunction ensureCacheReady(\n  apiClient: ApiClient | null,\n  input: TranscriptCacheInput,\n  setState: React.Dispatch<React.SetStateAction<TranscriptCacheState>>,\n): boolean {\n  if (!apiClient?.cacheTranscript) {\n    setCacheError(setState, 'Transcript caching is unavailable.');\n    return false;\n  }\n  if (!input?.transcript || !input?.video) {\n    setCacheError(setState, 'Transcript context is missing.');\n    return false;\n  }\n  return true;\n}\n\nasync function resolveCachePayload(input: TranscriptCacheInput) {\n  const provider = input.video.provider || 'unknown';\n  const videoId = input.video.id || '';\n  const mediaUrl = resolveMediaUrl(input.video, input.meta);\n  const mediaUrlNormalized =\n    typeof input.meta?.mediaUrlNormalized === 'string'\n      ? normalizeMediaUrlForCache(input.meta.mediaUrlNormalized)\n      : normalizeMediaUrlForCache(mediaUrl);\n  const durationMs =\n    coerceNumber(input.meta?.durationMs) ??\n    coerceNumber(input.transcript.durationMs) ??\n    coerceNumber(input.video.durationMs);\n\n  const fingerprint =\n    input.fingerprint ||\n    (await buildFingerprint({\n      provider,\n      videoId,\n      mediaUrlNormalized,\n      durationMs,\n    }));\n\n  return {\n    provider,\n    videoId,\n    mediaUrl,\n    mediaUrlNormalized,\n    durationMs,\n    fingerprint,\n  };\n}\n\nexport function useTranscriptCache(apiClient: ApiClient | null) {\n  const [state, setState] = useState<TranscriptCacheState>(INITIAL_STATE);\n  const cachedFingerprintsRef = useRef<Set<string>>(new Set());\n  const inFlightRef = useRef<Set<string>>(new Set());\n\n  const cacheTranscript = useCallback(\n    async (input: TranscriptCacheInput): Promise<{ fingerprint: string } | null> => {\n      const client = apiClient;\n      if (!ensureCacheReady(client, input, setState)) {\n        return null;\n      }\n      if (!client?.cacheTranscript) {\n        return null;\n      }\n\n      const { provider, mediaUrl, mediaUrlNormalized, durationMs, fingerprint } =\n        await resolveCachePayload(input);\n\n      if (cachedFingerprintsRef.current.has(fingerprint)) {\n        setState((prev) => ({\n          ...prev,\n          status: 'cached',\n          lastFingerprint: fingerprint,\n        }));\n        return { fingerprint };\n      }\n\n      if (inFlightRef.current.has(fingerprint)) {\n        return { fingerprint };\n      }\n\n      inFlightRef.current.add(fingerprint);\n      setState((prev) => ({\n        ...prev,\n        status: 'caching',\n        error: null,\n      }));\n\n      try {\n        const meta: TranscriptCacheMeta = { durationMs };\n        if (mediaUrl) {\n          meta.mediaUrl = mediaUrl;\n        }\n        if (mediaUrlNormalized) {\n          meta.mediaUrlNormalized = mediaUrlNormalized;\n        }\n        if (input.meta?.etag) {\n          meta.etag = input.meta.etag;\n        }\n        if (input.meta?.lastModified) {\n          meta.lastModified = input.meta.lastModified;\n        }\n\n        await client.cacheTranscript({\n          fingerprint,\n          provider,\n          transcript: input.transcript,\n          meta,\n        });\n\n        cachedFingerprintsRef.current.add(fingerprint);\n        setState({\n          status: 'cached',\n          error: null,\n          lastFingerprint: fingerprint,\n        });\n\n        return { fingerprint };\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'Failed to cache transcript.';\n        setState((prev) => ({\n          ...prev,\n          status: 'error',\n          error: message,\n        }));\n        return null;\n      } finally {\n        inFlightRef.current.delete(fingerprint);\n      }\n    },\n    [apiClient],\n  );\n\n  return {\n    cacheTranscript,\n    status: state.status,\n    error: state.error,\n    lastFingerprint: state.lastFingerprint,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\useTranscriptControls.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useTranscriptControls' has too many lines (111). Maximum allowed is 50.",
        "line": 26,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 152,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 26,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 26,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 47,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 47,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1508, 1518], "text": "(transcript != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 55,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 55,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1839, 1851], "text": "(result.error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1839, 1851], "text": "(result.error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1839, 1851], "text": "(Boolean(result.error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 85,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 85,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2704, 2715], "text": "(singleVideo != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 92,
        "column": 33,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 92,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2890, 2901], "text": "(err.message.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2890, 2901], "text": "(err.message !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2890, 2901], "text": "(Boolean(err.message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 115,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 115,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3486, 3496], "text": "transcript != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Dispatch, SetStateAction } from 'react';\nimport { useCallback } from 'react';\nimport type { DetectedVideo, TranscriptResult } from '@core/transcripts/types';\nimport type { UseVideoDetectionResult } from './useVideoDetection';\nimport type { UseTranscriptExtractionResult } from './useTranscriptExtraction';\nimport type { UseAiTranscriptionResult } from './useAiTranscription';\nimport { isAiTranscriptionBusy } from './types';\n\ninterface UseTranscriptControlsArgs {\n  detection: UseVideoDetectionResult;\n  extraction: UseTranscriptExtractionResult;\n  aiTranscription: UseAiTranscriptionResult;\n  setIsVideoListOpen: Dispatch<SetStateAction<boolean>>;\n  setError: Dispatch<SetStateAction<string | null>>;\n  setAuthRequired: Dispatch<\n    SetStateAction<\n      | {\n          provider: string;\n          signInUrl: string;\n        }\n      | undefined\n    >\n  >;\n}\n\nexport function useTranscriptControls({\n  detection,\n  extraction,\n  aiTranscription,\n  setIsVideoListOpen,\n  setError,\n  setAuthRequired,\n}: UseTranscriptControlsArgs) {\n  const closeVideoList = useCallback(() => {\n    setIsVideoListOpen(false);\n  }, [setIsVideoListOpen]);\n\n  const autoExtractSingleVideo = useCallback(\n    async (video: DetectedVideo) => {\n      setIsVideoListOpen(false);\n      extraction.setExtracting(true, video.id);\n      extraction.clearExtractionForVideo(video.id);\n\n      try {\n        const { transcript, result } = await extraction.extractTranscriptWithDomFallback(video);\n\n        if (result.success && transcript) {\n          extraction.setExtracting(false);\n          extraction.setLastTranscript(video, transcript);\n          extraction.setExtractionResult(video.id, result);\n        } else {\n          extraction.setExtracting(false);\n          extraction.setExtractionResult(video.id, {\n            ...result,\n            error: result.error || 'Failed to extract transcript',\n          });\n          setIsVideoListOpen(true);\n        }\n      } catch (extractError) {\n        const errorMessage =\n          extractError instanceof Error ? extractError.message : 'Failed to extract transcript';\n        extraction.setExtracting(false);\n        extraction.setExtractionResult(video.id, {\n          success: false,\n          error: errorMessage,\n        });\n        setIsVideoListOpen(true);\n      }\n    },\n    [extraction, setIsVideoListOpen],\n  );\n\n  const detectAndAutoExtract = useCallback(async () => {\n    setIsVideoListOpen(true);\n    detection.setDetecting(true);\n    setError(null);\n    setAuthRequired(undefined);\n\n    extraction.resetExtraction();\n\n    try {\n      const { videos } = await detection.detectVideos();\n      const [singleVideo] = videos;\n\n      if (videos.length === 1 && singleVideo) {\n        await autoExtractSingleVideo(singleVideo);\n      }\n\n      detection.setDetecting(false);\n    } catch (err) {\n      const message =\n        err instanceof Error && err.message\n          ? err.message\n          : 'Video detection failed. Please refresh and try again.';\n      setError(message);\n      detection.setDetecting(false);\n    }\n  }, [\n    autoExtractSingleVideo,\n    detection,\n    extraction,\n    setAuthRequired,\n    setError,\n    setIsVideoListOpen,\n  ]);\n\n  const extractTranscript = useCallback(\n    async (video: DetectedVideo): Promise<TranscriptResult | null> => {\n      if (extraction.state.isExtracting || aiTranscription.isBusy) {\n        return null;\n      }\n\n      const transcript = await extraction.extractTranscript(video);\n\n      if (transcript) {\n        setIsVideoListOpen(false);\n      }\n\n      return transcript;\n    },\n    [aiTranscription.isBusy, extraction, setIsVideoListOpen],\n  );\n\n  const transcribeWithAI = useCallback(\n    async (\n      video: DetectedVideo,\n      options?: { languageHint?: string; maxMinutes?: number },\n    ): Promise<TranscriptResult | null> => {\n      if (isAiTranscriptionBusy(aiTranscription.state.status)) {\n        return null;\n      }\n\n      return aiTranscription.transcribeWithAI(video, options);\n    },\n    [aiTranscription],\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n    setAuthRequired(undefined);\n    detection.setError(null);\n  }, [detection, setAuthRequired, setError]);\n\n  return {\n    closeVideoList,\n    detectAndAutoExtract,\n    extractTranscript,\n    transcribeWithAI,\n    cancelAiTranscription: aiTranscription.cancelAiTranscription,\n    clearError,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\useTranscriptExtraction.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useTranscriptExtraction' has too many lines (158). Maximum allowed is 50.",
        "line": 71,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 255,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 99,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 99,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3609, 3619], "text": "domResult == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 110,
        "column": 14,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 110,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3940, 3961], "text": "domResult.transcript == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 128,
        "column": 28,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 128,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4505, 4522], "text": "(result.transcript != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async arrow function has too many lines (59). Maximum allowed is 50.",
        "line": 137,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 201,
        "endColumn": 6
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 156,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 156,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5251, 5261], "text": "(transcript != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 179,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 179,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5887, 5899], "text": "(result.error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5887, 5899], "text": "(result.error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5887, 5899], "text": "(Boolean(result.error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useTranscriptExtraction Hook\n *\n * Manages transcript extraction state and logic.\n * Handles both background script extraction and DOM-based extraction for HTML5 videos.\n */\n\nimport { useState, useCallback } from 'react';\nimport type { DetectedVideo, TranscriptResult } from '@core/transcripts/types';\nimport { extractHtml5TranscriptFromDom } from '../extractHtml5TranscriptFromDom';\nimport {\n  sendToBackground,\n  normalizeTranscriptResponse,\n  type TranscriptResponseData,\n  type BackgroundResponse,\n} from './types';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\nexport interface TranscriptExtractionState {\n  /** Whether transcript extraction is in progress */\n  isExtracting: boolean;\n  /** ID of video currently being extracted */\n  extractingVideoId: string | null;\n  /** Per-video transcript extraction results */\n  extractionsByVideoId: Record<string, TranscriptResponseData>;\n  /** Last extracted transcript */\n  lastTranscript: {\n    video: DetectedVideo;\n    transcript: TranscriptResult;\n  } | null;\n}\n\nexport interface UseTranscriptExtractionResult {\n  state: TranscriptExtractionState;\n  /** Extract transcript for a video */\n  extractTranscript: (video: DetectedVideo) => Promise<TranscriptResult | null>;\n  /** Extract transcript with DOM fallback for HTML5 videos */\n  extractTranscriptWithDomFallback: (\n    video: DetectedVideo,\n  ) => Promise<{ transcript: TranscriptResult | null; result: TranscriptResponseData }>;\n  /** Reset extraction state */\n  resetExtraction: () => void;\n  /** Set extracting state */\n  setExtracting: (isExtracting: boolean, videoId?: string | null) => void;\n  /** Update extraction result for a video */\n  setExtractionResult: (videoId: string, result: TranscriptResponseData) => void;\n  /** Set last transcript */\n  setLastTranscript: (video: DetectedVideo, transcript: TranscriptResult) => void;\n  /** Clear extraction for a video */\n  clearExtractionForVideo: (videoId: string) => void;\n}\n\n// -----------------------------------------------------------------------------\n// Initial State\n// -----------------------------------------------------------------------------\n\nconst INITIAL_STATE: TranscriptExtractionState = {\n  isExtracting: false,\n  extractingVideoId: null,\n  extractionsByVideoId: {},\n  lastTranscript: null,\n};\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function useTranscriptExtraction(): UseTranscriptExtractionResult {\n  const [state, setState] = useState<TranscriptExtractionState>(INITIAL_STATE);\n\n  /**\n   * Fetch transcript from background script\n   */\n  const fetchBackgroundTranscript = useCallback(\n    async (video: DetectedVideo): Promise<TranscriptResponseData> => {\n      const response = await sendToBackground<BackgroundResponse>({\n        type: 'EXTRACT_TRANSCRIPT',\n        payload: { video },\n      });\n\n      return normalizeTranscriptResponse(response);\n    },\n    [],\n  );\n\n  /**\n   * Extract transcript with DOM fallback for HTML5 videos\n   */\n  const extractTranscriptWithDomFallback = useCallback(\n    async (\n      video: DetectedVideo,\n    ): Promise<{ transcript: TranscriptResult | null; result: TranscriptResponseData }> => {\n      if (video.provider === 'html5') {\n        const domResult = await extractHtml5TranscriptFromDom(video);\n        // Handle null result (no video element found or no captions available)\n        if (!domResult) {\n          return {\n            transcript: null,\n            result: {\n              success: false,\n              error: 'No captions available for this video',\n              errorCode: 'NO_CAPTIONS',\n              aiTranscriptionAvailable: Boolean(video.mediaUrl),\n            },\n          };\n        }\n        if (!domResult.transcript) {\n          return {\n            transcript: null,\n            result: {\n              success: false,\n              error: 'Transcript payload missing',\n              errorCode: 'INVALID_RESPONSE',\n              aiTranscriptionAvailable: Boolean(video.mediaUrl),\n            },\n          };\n        }\n        return {\n          transcript: domResult.transcript,\n          result: { success: true, transcript: domResult.transcript },\n        };\n      }\n\n      const result = await fetchBackgroundTranscript(video);\n      return { transcript: result.transcript || null, result };\n    },\n    [fetchBackgroundTranscript],\n  );\n\n  /**\n   * Extract transcript for a video\n   */\n  const extractTranscript = useCallback(\n    async (video: DetectedVideo): Promise<TranscriptResult | null> => {\n      if (state.isExtracting) {\n        return null;\n      }\n\n      setState((prev) => {\n        const nextExtractions = { ...prev.extractionsByVideoId };\n        delete nextExtractions[video.id];\n        return {\n          ...prev,\n          isExtracting: true,\n          extractingVideoId: video.id,\n          extractionsByVideoId: nextExtractions,\n        };\n      });\n\n      try {\n        const { transcript, result } = await extractTranscriptWithDomFallback(video);\n\n        if (result.success && transcript) {\n          setState((prev) => ({\n            ...prev,\n            isExtracting: false,\n            extractingVideoId: null,\n            lastTranscript: { video, transcript },\n            extractionsByVideoId: {\n              ...prev.extractionsByVideoId,\n              [video.id]: result,\n            },\n          }));\n\n          return transcript;\n        }\n\n        setState((prev) => ({\n          ...prev,\n          isExtracting: false,\n          extractingVideoId: null,\n          extractionsByVideoId: {\n            ...prev.extractionsByVideoId,\n            [video.id]: {\n              ...result,\n              error: result.error || 'Failed to extract transcript',\n            },\n          },\n        }));\n\n        return null;\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        setState((prev) => ({\n          ...prev,\n          isExtracting: false,\n          extractingVideoId: null,\n          extractionsByVideoId: {\n            ...prev.extractionsByVideoId,\n            [video.id]: {\n              success: false,\n              error: errorMessage,\n            },\n          },\n        }));\n        return null;\n      }\n    },\n    [extractTranscriptWithDomFallback, state.isExtracting],\n  );\n\n  const resetExtraction = useCallback(() => {\n    setState(INITIAL_STATE);\n  }, []);\n\n  const setExtracting = useCallback((isExtracting: boolean, videoId?: string | null) => {\n    setState((prev) => ({\n      ...prev,\n      isExtracting,\n      extractingVideoId: videoId ?? null,\n    }));\n  }, []);\n\n  const setExtractionResult = useCallback((videoId: string, result: TranscriptResponseData) => {\n    setState((prev) => ({\n      ...prev,\n      extractionsByVideoId: {\n        ...prev.extractionsByVideoId,\n        [videoId]: result,\n      },\n    }));\n  }, []);\n\n  const setLastTranscript = useCallback((video: DetectedVideo, transcript: TranscriptResult) => {\n    setState((prev) => ({\n      ...prev,\n      lastTranscript: { video, transcript },\n    }));\n  }, []);\n\n  const clearExtractionForVideo = useCallback((videoId: string) => {\n    setState((prev) => {\n      const nextExtractions = { ...prev.extractionsByVideoId };\n      delete nextExtractions[videoId];\n      return {\n        ...prev,\n        extractionsByVideoId: nextExtractions,\n      };\n    });\n  }, []);\n\n  return {\n    state,\n    extractTranscript,\n    extractTranscriptWithDomFallback,\n    resetExtraction,\n    setExtracting,\n    setExtractionResult,\n    setLastTranscript,\n    clearExtractionForVideo,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\hooks\\useVideoDetection.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 68,
        "column": 8,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 68,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2486, 2505], "text": "(video.echoLessonId == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2487, 2505], "text": "(video.echoLessonId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2486, 2505], "text": "(!Boolean(video.echoLessonId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 68,
        "column": 31,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 68,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2509, 2527], "text": "(video.echoMediaId == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2510, 2527], "text": "(video.echoMediaId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2509, 2527], "text": "(!Boolean(video.echoMediaId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 112,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 112,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 127,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 127,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 145,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 145,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 150,
        "column": 59,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "conditionErrorOther",
        "endLine": 153,
        "endColumn": 4,
        "suggestions": [
          {
            "messageId": "explicitBooleanReturnType",
            "fix": { "range": [5118, 5118], "text": ": boolean" },
            "desc": "Add an explicit `boolean` return type annotation."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 152,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 152,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [5176, 5193], "text": "(video.currentSrc.length === 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [5176, 5193], "text": "(video.currentSrc === \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5176, 5193], "text": "(!Boolean(video.currentSrc))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 152,
        "column": 34,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 152,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [5197, 5207], "text": "(video.src.length === 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [5197, 5207], "text": "(video.src === \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5197, 5207], "text": "(!Boolean(video.src))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 157,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 157,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 166,
        "column": 59,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "conditionErrorOther",
        "endLine": 169,
        "endColumn": 4,
        "suggestions": [
          {
            "messageId": "explicitBooleanReturnType",
            "fix": { "range": [5680, 5680], "text": ": boolean" },
            "desc": "Add an explicit `boolean` return type annotation."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 168,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 168,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [5738, 5755], "text": "(video.currentSrc.length === 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [5738, 5755], "text": "(video.currentSrc === \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5738, 5755], "text": "(!Boolean(video.currentSrc))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 168,
        "column": 34,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 168,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [5759, 5769], "text": "(video.src.length === 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [5759, 5769], "text": "(video.src === \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5759, 5769], "text": "(!Boolean(video.src))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'tryAsyncDetection' has too many lines (65). Maximum allowed is 50.",
        "line": 190,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 262,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async function 'tryAsyncDetection' has too many statements (21). Maximum allowed is 20.",
        "line": 190,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 262,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 204,
        "column": 5,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 204,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": {
              "range": [7015, 7071],
              "text": "((provider?.requiresAsyncDetection?.(contextForBackground)) ?? false)"
            },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": {
              "range": [7015, 7071],
              "text": "((provider?.requiresAsyncDetection?.(contextForBackground)) === true)"
            },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useVideoDetection' has too many lines (59). Maximum allowed is 50.",
        "line": 268,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 341,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 287,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 287,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9657, 9668], "text": "asyncResult != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 17,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useVideoDetection Hook\n *\n * Manages video detection state and logic.\n * Handles retry logic for delayed video players (video.js, MediaElement.js).\n * Delegates to provider's requiresAsyncDetection() for async detection needs.\n */\n\nimport { useState, useCallback } from 'react';\nimport type { DetectedVideo } from '@core/transcripts/types';\nimport { detectVideosSync, collectIframeInfo } from '@core/transcripts/videoDetection';\nimport { getProviderForUrl } from '@core/transcripts/providerRegistry';\nimport {\n  sendToBackground,\n  normalizeVideoDetectionResponse,\n  type BackgroundResponse,\n} from './types';\n\n// -----------------------------------------------------------------------------\n// Echo360 Detection Helpers\n// Note: These are needed because the provider registry may not be populated\n// in the content script context. The background script handles actual extraction.\n// -----------------------------------------------------------------------------\n\nconst ECHO360_SECTION_REGEX =\n  /\\/section\\/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i;\nconst ECHO360_EMPTY_HINT = 'Echo360 tip: open a lesson page or the syllabus list to load videos.';\n\nfunction hasEcho360Hint(value: string | null | undefined): boolean {\n  return typeof value === 'string' && value.toLowerCase().includes('echo360');\n}\n\nfunction isEcho360SectionPage(pageUrl: string): boolean {\n  if (!hasEcho360Hint(pageUrl)) return false;\n\n  const isSectionPath = ECHO360_SECTION_REGEX.test(pageUrl);\n  if (!isSectionPath) return false;\n\n  // It's a section page if we're not on a specific lesson page\n  const isLessonPage = /\\/lessons?\\/[^/]+/i.test(pageUrl);\n  return !isLessonPage;\n}\n\nfunction hasEcho360Context(context: { pageUrl: string; iframes: Array<{ src: string }> }): boolean {\n  if (hasEcho360Hint(context.pageUrl)) return true;\n  return context.iframes.some((iframe) => hasEcho360Hint(iframe.src));\n}\n\nfunction shouldFetchEcho360Async(\n  context: { pageUrl: string; iframes: Array<{ src: string }> },\n  videos: DetectedVideo[],\n  echo360Context = hasEcho360Context(context),\n): boolean {\n  if (!echo360Context) return false;\n\n  // Always fetch async on section pages to get all videos from syllabus\n  if (isEcho360SectionPage(context.pageUrl)) {\n    return true;\n  }\n\n  if (videos.length === 0) return true;\n\n  const echoVideos = videos.filter((video) => video.provider === 'echo360');\n  if (echoVideos.length === 0) return false;\n\n  return echoVideos.some(\n    (video) =>\n      !video.echoLessonId || !video.echoMediaId || ECHO360_SECTION_REGEX.test(video.embedUrl),\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\nexport interface VideoDetectionState {\n  /** Detected videos on the page */\n  videos: DetectedVideo[];\n  /** Whether video detection is in progress */\n  isDetecting: boolean;\n  /** Error message for detection failures */\n  error: string | null;\n  /** Optional hint for empty detection results (provider-specific) */\n  detectionHint: string | null;\n}\n\nexport interface UseVideoDetectionResult {\n  state: VideoDetectionState;\n  /** Detect videos on the current page */\n  detectVideos: () => Promise<{ videos: DetectedVideo[]; provider: string | null }>;\n  /** Reset detection state */\n  resetDetection: () => void;\n  /** Set error message */\n  setError: (error: string | null) => void;\n  /** Set detecting state */\n  setDetecting: (isDetecting: boolean) => void;\n  /** Update videos list */\n  setVideos: (videos: DetectedVideo[]) => void;\n}\n\n// -----------------------------------------------------------------------------\n// Initial State\n// -----------------------------------------------------------------------------\n\nconst INITIAL_STATE: VideoDetectionState = {\n  videos: [],\n  isDetecting: false,\n  error: null,\n  detectionHint: null,\n};\n\nfunction buildDetectionContext(currentUrl: string) {\n  const iframes = collectIframeInfo(document);\n  const context = {\n    pageUrl: currentUrl,\n    iframes,\n    document,\n  };\n  console.log('[Lock-in UI] Detection context built', {\n    pageUrl: context.pageUrl,\n    iframeCount: context.iframes.length,\n    iframeSrcs: context.iframes.map((iframe) => iframe.src).filter(Boolean),\n  });\n  return context;\n}\n\nfunction runDetectionAttempt(currentUrl: string) {\n  const context = buildDetectionContext(currentUrl);\n  const result = detectVideosSync(context);\n  console.log('[Lock-in UI] Sync detection result', {\n    videoCount: result.videos.length,\n    provider: result.provider,\n    requiresApiCall: result.requiresApiCall,\n    videos: result.videos.map((v) => ({\n      id: v.id,\n      provider: v.provider,\n      title: v.title,\n      lessonId: v.echoLessonId,\n      mediaId: v.echoMediaId,\n    })),\n  });\n  return { result, context };\n}\n\nfunction shouldRetryDetection(result: ReturnType<typeof detectVideosSync>) {\n  if (result.videos.length > 0 || result.requiresApiCall) {\n    return false;\n  }\n  const videoElements = document.querySelectorAll('video');\n  const hasUnreadyVideos = Array.from(videoElements).some((v) => {\n    const video = v as HTMLVideoElement;\n    return !video.currentSrc && !video.src && video.querySelector('source');\n  });\n  return hasUnreadyVideos || videoElements.length > 0;\n}\n\nasync function runDetectionWithRetries(currentUrl: string) {\n  let { result, context } = runDetectionAttempt(currentUrl);\n  if (!shouldRetryDetection(result)) {\n    return { result, context };\n  }\n\n  const MAX_RETRIES = 3;\n  const RETRY_DELAY_MS = 500;\n  const videoElements = document.querySelectorAll('video');\n  const hasUnreadyVideos = Array.from(videoElements).some((v) => {\n    const video = v as HTMLVideoElement;\n    return !video.currentSrc && !video.src && video.querySelector('source');\n  });\n  console.log('[Lock-in UI] Retrying detection for delayed video players', {\n    videoElementCount: videoElements.length,\n    hasUnreadyVideos,\n  });\n\n  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {\n    await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY_MS));\n    ({ result, context } = runDetectionAttempt(currentUrl));\n    if (result.videos.length > 0) {\n      console.log('[Lock-in UI] Videos detected on retry', {\n        attempt,\n        videoCount: result.videos.length,\n      });\n      break;\n    }\n  }\n\n  return { result, context };\n}\n\nasync function tryAsyncDetection(\n  result: ReturnType<typeof detectVideosSync>,\n  contextForBackground: { pageUrl: string; iframes: Array<{ src: string; title?: string }> },\n): Promise<{ videos: DetectedVideo[]; provider: string | null } | null> {\n  const echo360Context = hasEcho360Context(contextForBackground);\n  const shouldFetchAsync = shouldFetchEcho360Async(\n    contextForBackground,\n    result.videos,\n    echo360Context,\n  );\n  const provider = getProviderForUrl(contextForBackground.pageUrl);\n  const providerName = result.provider ?? (echo360Context ? 'echo360' : null);\n  const requiresAsync =\n    shouldFetchAsync ||\n    provider?.requiresAsyncDetection?.(contextForBackground) ||\n    result.requiresApiCall;\n\n  console.log('[Lock-in UI] Checking if async detection needed', {\n    requiresAsync,\n    shouldFetchAsync,\n    echo360Context,\n    currentVideoCount: result.videos.length,\n    provider: providerName,\n  });\n\n  if (!requiresAsync) {\n    return null;\n  }\n\n  try {\n    console.log('[Lock-in UI] Sending async detection request', {\n      context: contextForBackground,\n    });\n\n    const messageType = echo360Context ? 'DETECT_ECHO360_VIDEOS' : 'DETECT_VIDEOS_ASYNC';\n    const response = await sendToBackground<BackgroundResponse>({\n      type: messageType,\n      payload: { context: contextForBackground },\n    });\n\n    console.log('[Lock-in UI] Async detection response received', {\n      success: response.success,\n      videoCount: response.videos?.length,\n    });\n\n    const asyncVideos = normalizeVideoDetectionResponse(response);\n    console.log('[Lock-in UI] Async videos normalized', {\n      videoCount: asyncVideos.length,\n      videos: asyncVideos.map((v) => ({\n        id: v.id,\n        provider: v.provider,\n        title: v.title,\n        lessonId: v.echoLessonId,\n        mediaId: v.echoMediaId,\n      })),\n    });\n\n    if (asyncVideos.length > 0) {\n      console.log('[Lock-in UI] Returning async videos', {\n        count: asyncVideos.length,\n      });\n      return { videos: asyncVideos, provider: providerName };\n    }\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Async detection failed';\n    console.error('[Lock-in UI] Async detection failed:', {\n      message,\n      error: error instanceof Error ? error.stack : String(error),\n    });\n  }\n\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function useVideoDetection(): UseVideoDetectionResult {\n  const [state, setState] = useState<VideoDetectionState>(INITIAL_STATE);\n\n  /**\n   * Core detection logic with retry for delayed video players (video.js, MediaElement.js).\n   */\n  const detectVideos = useCallback(async (): Promise<{\n    videos: DetectedVideo[];\n    provider: string | null;\n  }> => {\n    const currentUrl = window.location.href;\n    console.log('[Lock-in UI] Starting video detection', { currentUrl });\n    const { result, context } = await runDetectionWithRetries(currentUrl);\n\n    const contextForBackground = {\n      pageUrl: context.pageUrl,\n      iframes: context.iframes,\n    };\n    const asyncResult = await tryAsyncDetection(result, contextForBackground);\n    if (asyncResult) {\n      setState((prev) => ({\n        ...prev,\n        videos: asyncResult.videos,\n        detectionHint: null,\n      }));\n      return asyncResult;\n    }\n\n    // Get hint when no videos found on Echo360 pages\n    const detectionHint =\n      result.videos.length === 0 && hasEcho360Context(contextForBackground)\n        ? ECHO360_EMPTY_HINT\n        : null;\n    const providerName =\n      result.provider ?? (hasEcho360Context(contextForBackground) ? 'echo360' : null);\n\n    console.log('[Lock-in UI] Returning sync detection videos', {\n      count: result.videos.length,\n    });\n\n    setState((prev) => ({\n      ...prev,\n      videos: result.videos,\n      detectionHint,\n    }));\n\n    return { videos: result.videos, provider: providerName };\n  }, []);\n\n  const resetDetection = useCallback(() => {\n    setState(INITIAL_STATE);\n  }, []);\n\n  const setError = useCallback((error: string | null) => {\n    setState((prev) => ({ ...prev, error }));\n  }, []);\n\n  const setDetecting = useCallback((isDetecting: boolean) => {\n    setState((prev) => ({ ...prev, isDetecting }));\n  }, []);\n\n  const setVideos = useCallback((videos: DetectedVideo[]) => {\n    setState((prev) => ({ ...prev, videos }));\n  }, []);\n\n  return {\n    state,\n    detectVideos,\n    resetDetection,\n    setError,\n    setDetecting,\n    setVideos,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\transcriptFormatting.ts",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 8,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 8,
        "endColumn": 47
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 9,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 9,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 19,
        "column": 38,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 19,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [640, 661], "text": "(transcript.durationMs != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [640, 661], "text": "(transcript.durationMs ?? 0)" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [640, 661], "text": "(Boolean(transcript.durationMs))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 34,
        "column": 40,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 34,
        "endColumn": 42
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3600.",
        "line": 36,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 36,
        "endColumn": 51
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3600.",
        "line": 37,
        "column": 50,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 37,
        "endColumn": 54
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 37,
        "column": 58,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 37,
        "endColumn": 60
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 60.",
        "line": 38,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 38,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 3.",
        "line": 40,
        "column": 147,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 40,
        "endColumn": 148
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 56,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 56,
        "endColumn": 29
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { TranscriptResult, TranscriptSegment } from '@core/transcripts/types';\n\n/**\n * Format milliseconds as MM:SS\n */\nexport function formatTime(ms: number): string {\n  const totalSeconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(totalSeconds / 60);\n  const seconds = totalSeconds % 60;\n  return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;\n}\n\n/**\n * Format transcript for plain text download\n */\nexport function formatAsPlainText(transcript: TranscriptResult, title: string): string {\n  const lines: string[] = [];\n  lines.push(`Transcript: ${title}`);\n  lines.push(`Duration: ${formatTime(transcript.durationMs || 0)}`);\n  lines.push('');\n  lines.push('---');\n  lines.push('');\n  lines.push(transcript.plainText);\n  return lines.join('\\n');\n}\n\n/**\n * Format transcript as VTT\n */\nexport function formatAsVtt(segments: TranscriptSegment[]): string {\n  const lines: string[] = ['WEBVTT', ''];\n\n  segments.forEach((segment, index) => {\n    const formatVttTime = (ms: number) => {\n      const totalSeconds = Math.floor(ms / 1000);\n      const hours = Math.floor(totalSeconds / 3600);\n      const minutes = Math.floor((totalSeconds % 3600) / 60);\n      const seconds = totalSeconds % 60;\n      const millis = ms % 1000;\n      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(millis).padStart(3, '0')}`;\n    };\n\n    lines.push(String(index + 1));\n    const endMs = typeof segment.endMs === 'number' ? segment.endMs : segment.startMs;\n    lines.push(`${formatVttTime(segment.startMs)} --> ${formatVttTime(endMs)}`);\n    lines.push(segment.text);\n    lines.push('');\n  });\n\n  return lines.join('\\n');\n}\n\n/**\n * Download a file with given content\n */\nexport function downloadFile(filename: string, content: string, mimeType: string) {\n  const blob = new Blob([content], { type: mimeType });\n  const url = URL.createObjectURL(blob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\transcripts\\useTranscripts.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 124,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 124,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4103, 4108], "text": "(error != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4103, 4108], "text": "(error ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4103, 4108], "text": "(Boolean(error))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 130,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 130,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4385, 4397], "text": "(authRequired != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useTranscripts Hook\n *\n * Manages transcript extraction state and communication with background script.\n * Detects videos from multiple providers (Panopto, HTML5, Echo360).\n *\n * This is a composition hook that combines:\n * - useVideoDetection: Video detection logic\n * - useTranscriptExtraction: Transcript extraction logic\n * - useAiTranscription: AI transcription with progress polling\n */\n\nimport { useState, useCallback } from 'react';\nimport type { DetectedVideo, TranscriptResult } from '@core/transcripts/types';\nimport {\n  useVideoDetection,\n  useTranscriptExtraction,\n  useAiTranscription,\n  type AiTranscriptionState,\n  type TranscriptResponseData,\n} from './hooks';\nimport { useTranscriptControls } from './hooks/useTranscriptControls';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\ninterface TranscriptState {\n  /** Whether the video list panel is open */\n  isVideoListOpen: boolean;\n  /** Detected videos on the page */\n  videos: DetectedVideo[];\n  /** Whether video detection is in progress */\n  isDetecting: boolean;\n  /** Whether transcript extraction is in progress */\n  isExtracting: boolean;\n  /** ID of video currently being extracted */\n  extractingVideoId: string | null;\n  /** Error message for detection failures */\n  error: string | null;\n  /** Optional hint for empty detection results */\n  detectionHint: string | null;\n  /** Per-video transcript extraction results */\n  extractionsByVideoId: Record<string, TranscriptResponseData>;\n  /** Last extracted transcript */\n  lastTranscript: {\n    video: DetectedVideo;\n    transcript: TranscriptResult;\n  } | null;\n  /** AI transcription state */\n  aiTranscription: AiTranscriptionState;\n  /** Auth required info for displaying sign-in prompt */\n  authRequired?: {\n    provider: string;\n    signInUrl: string;\n  };\n}\n\ninterface UseTranscriptsResult {\n  state: TranscriptState;\n  closeVideoList: () => void;\n  /** Detect videos and auto-extract if only one is found */\n  detectAndAutoExtract: () => void;\n  extractTranscript: (video: DetectedVideo) => Promise<TranscriptResult | null>;\n  transcribeWithAI: (\n    video: DetectedVideo,\n    options?: { languageHint?: string; maxMinutes?: number },\n  ) => Promise<TranscriptResult | null>;\n  cancelAiTranscription: () => Promise<void>;\n  clearError: () => void;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function useTranscripts(): UseTranscriptsResult {\n  // Compose the focused hooks\n  const detection = useVideoDetection();\n  const extraction = useTranscriptExtraction();\n\n  // Callbacks for AI transcription to update extraction state\n  const handleTranscriptReady = useCallback(\n    (video: DetectedVideo, transcript: TranscriptResult) => {\n      extraction.setLastTranscript(video, transcript);\n      extraction.setExtracting(false);\n      setIsVideoListOpen(false);\n    },\n    [extraction],\n  );\n\n  const handleExtractionResult = useCallback(\n    (videoId: string, result: TranscriptResponseData) => {\n      extraction.setExtractionResult(videoId, result);\n    },\n    [extraction],\n  );\n\n  const aiTranscription = useAiTranscription(handleTranscriptReady, handleExtractionResult);\n\n  // UI state\n  const [isVideoListOpen, setIsVideoListOpen] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [authRequired, setAuthRequired] = useState<\n    { provider: string; signInUrl: string } | undefined\n  >(undefined);\n\n  const controls = useTranscriptControls({\n    detection,\n    extraction,\n    aiTranscription,\n    setIsVideoListOpen,\n    setError,\n    setAuthRequired,\n  });\n\n  // Compose the state\n  const stateBase: TranscriptState = {\n    isVideoListOpen,\n    videos: detection.state.videos,\n    isDetecting: detection.state.isDetecting,\n    isExtracting: extraction.state.isExtracting,\n    extractingVideoId: extraction.state.extractingVideoId,\n    error: error || detection.state.error,\n    detectionHint: detection.state.detectionHint,\n    extractionsByVideoId: extraction.state.extractionsByVideoId,\n    lastTranscript: extraction.state.lastTranscript,\n    aiTranscription: aiTranscription.state,\n  };\n  const state: TranscriptState = authRequired ? { ...stateBase, authRequired } : stateBase;\n\n  return {\n    state,\n    ...controls,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\videos\\ProviderBadge.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 23,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 23,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * ProviderBadge Component\n *\n * Displays a colored badge indicating the video provider.\n * Extracted from transcript-specific code for reuse.\n */\n\ninterface ProviderBadgeProps {\n  /** Provider identifier (panopto, echo360, html5, youtube, unknown) */\n  provider: string;\n}\n\ntype ProviderKey = 'panopto' | 'echo360' | 'html5' | 'youtube' | 'unknown';\n\nconst BADGE_COLORS: Record<ProviderKey, { bg: string; text: string }> = {\n  panopto: { bg: '#1e3a5f', text: '#ffffff' },\n  echo360: { bg: '#b45309', text: '#ffffff' },\n  html5: { bg: '#2f6f44', text: '#ffffff' },\n  youtube: { bg: '#cc0000', text: '#ffffff' },\n  unknown: { bg: '#6b7280', text: '#ffffff' },\n};\n\nexport function ProviderBadge({ provider }: ProviderBadgeProps) {\n  const key = Object.prototype.hasOwnProperty.call(BADGE_COLORS, provider)\n    ? (provider as ProviderKey)\n    : 'unknown';\n  const colors = BADGE_COLORS[key];\n  const label = provider.charAt(0).toUpperCase() + provider.slice(1);\n\n  return (\n    <span\n      className=\"lockin-video-provider-badge\"\n      style={{ backgroundColor: colors.bg, color: colors.text }}\n    >\n      {label}\n    </span>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\videos\\VideoListItem.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 36,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 36,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 70,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 70,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2299, 2311], "text": "(renderStatus != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * VideoListItem Component\n *\n * Generic selectable video list item with render props for customization.\n * Feature-specific code (Transcript, Key Takeaways, etc.) can inject:\n * - Custom badges after the title (renderBadge)\n * - Custom actions below the item (renderActions)\n * - Custom status indicators in the action area (renderStatus)\n */\n\nimport type { DetectedVideo } from '@core/transcripts/types';\nimport { ProviderBadge } from './ProviderBadge';\nimport type {\n  VideoItemBadgeRenderer,\n  VideoItemActionRenderer,\n  VideoItemStatusRenderer,\n} from './types';\n\nexport interface VideoListItemProps {\n  /** The video to display */\n  video: DetectedVideo;\n  /** Callback when the video is selected */\n  onSelect: () => void;\n  /** Whether this item is disabled for interaction */\n  isDisabled?: boolean;\n  /** Whether this item is currently selected/active */\n  isSelected?: boolean;\n  /** Optional custom badge to render after the title */\n  renderBadge?: VideoItemBadgeRenderer;\n  /** Optional custom actions to render below the item */\n  renderActions?: VideoItemActionRenderer;\n  /** Optional custom status indicator in the action area (defaults to spinner when selected) */\n  renderStatus?: VideoItemStatusRenderer;\n}\n\nexport function VideoListItem({\n  video,\n  onSelect,\n  isDisabled = false,\n  isSelected = false,\n  renderBadge,\n  renderActions,\n  renderStatus,\n}: VideoListItemProps) {\n  const renderProps = { video, isSelected, isDisabled };\n\n  // Default status: spinner when selected, arrow otherwise\n  const defaultStatus = isSelected ? (\n    <span className=\"lockin-inline-spinner\" />\n  ) : (\n    <span className=\"lockin-video-extract-icon\"></span>\n  );\n\n  return (\n    <div className={`lockin-video-item ${isSelected ? 'is-extracting' : ''}`} role=\"listitem\">\n      <button\n        className=\"lockin-video-item-main\"\n        onClick={onSelect}\n        disabled={isDisabled}\n        type=\"button\"\n      >\n        <div className=\"lockin-video-item-content\">\n          <div className=\"lockin-video-item-header\">\n            <ProviderBadge provider={video.provider} />\n            <span className=\"lockin-video-item-title\">{video.title}</span>\n            {renderBadge?.(renderProps)}\n          </div>\n        </div>\n        <div className=\"lockin-video-item-action\">\n          {renderStatus ? renderStatus(renderProps) : defaultStatus}\n        </div>\n      </button>\n\n      {renderActions?.(renderProps)}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\videos\\VideoListPanel.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 76,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 76,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 79,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 79,
        "endColumn": 29
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'VideoListPanel' has too many lines (77). Maximum allowed is 50.",
        "line": 100,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 181,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 100,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 100,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 139,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 139,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4376, 4388], "text": "(authRequired != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 149,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 149,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4826, 4839], "text": "(detectionHint != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4826, 4839], "text": "(detectionHint ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4826, 4839], "text": "(Boolean(detectionHint))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 163,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 163,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5401, 5416], "text": "(renderItemBadge != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 164,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 164,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5479, 5496], "text": "(renderItemActions != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 165,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 165,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5563, 5579], "text": "(renderItemStatus != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * VideoListPanel Component\n *\n * Generic panel for displaying and selecting videos.\n * Handles loading, empty, error, and auth-required states.\n *\n * Feature-specific code (Transcript, Key Takeaways, etc.) can:\n * - Customize title, empty message, supported providers text\n * - Inject custom badges/actions via render props\n * - Control selection state and disabled logic\n */\n\nimport type { DetectedVideo } from '@core/transcripts/types';\nimport { VideoListItem } from './VideoListItem';\nimport type {\n  VideoItemBadgeRenderer,\n  VideoItemActionRenderer,\n  VideoItemStatusRenderer,\n} from './types';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\nexport interface VideoListPanelProps {\n  /** List of detected videos */\n  videos: DetectedVideo[];\n  /** Whether video detection is in progress */\n  isLoading: boolean;\n  /** Callback when a video is selected */\n  onSelectVideo: (video: DetectedVideo) => void;\n  /** Callback to close the panel */\n  onClose: () => void;\n\n  // State props\n  /** Error message if detection failed */\n  error?: string;\n  /** Optional hint to show when no videos are detected */\n  detectionHint?: string;\n  /** Auth required info for sign-in prompt */\n  authRequired?: {\n    provider: string;\n    signInUrl: string;\n  };\n\n  // Selection state\n  /** ID of the currently selected video */\n  selectedVideoId?: string | null;\n  /** Function to determine if a video should be disabled */\n  isVideoDisabled?: (video: DetectedVideo) => boolean;\n\n  // Customization\n  /** Panel title (default: \"Select a video\") */\n  title?: string;\n  /** Message shown when no videos detected */\n  emptyMessage?: string;\n  /** Supported providers hint text */\n  supportedProviders?: string;\n\n  // Render props for item customization\n  /** Custom badge renderer for each video item */\n  renderItemBadge?: VideoItemBadgeRenderer;\n  /** Custom actions renderer for each video item */\n  renderItemActions?: VideoItemActionRenderer;\n  /** Custom status renderer for each video item */\n  renderItemStatus?: VideoItemStatusRenderer;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Components\n// -----------------------------------------------------------------------------\n\n/**\n * Auth required prompt for providers needing sign-in\n */\nfunction AuthRequiredPrompt({ provider, signInUrl }: { provider: string; signInUrl: string }) {\n  const providerName = provider.charAt(0).toUpperCase() + provider.slice(1);\n\n  const handleSignIn = () => {\n    window.open(signInUrl, '_blank', 'noopener,noreferrer');\n  };\n\n  return (\n    <div className=\"lockin-video-auth-required\">\n      <p className=\"lockin-video-auth-message\">\n        Please sign in to {providerName} to view recordings.\n      </p>\n      <button className=\"lockin-video-auth-button\" onClick={handleSignIn} type=\"button\">\n        Open {providerName} Sign In\n      </button>\n      <p className=\"lockin-video-auth-hint\">After signing in, close this panel and try again.</p>\n    </div>\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Main Component\n// -----------------------------------------------------------------------------\n\nexport function VideoListPanel({\n  videos,\n  isLoading,\n  onSelectVideo,\n  onClose,\n  error,\n  detectionHint,\n  authRequired,\n  selectedVideoId,\n  isVideoDisabled,\n  title = 'Select a video',\n  emptyMessage = 'No videos detected on this page.',\n  supportedProviders = 'Supported: Panopto, Echo360, HTML5 videos',\n  renderItemBadge,\n  renderItemActions,\n  renderItemStatus,\n}: VideoListPanelProps) {\n  const showError = Boolean(error) && videos.length === 0;\n\n  return (\n    <div className=\"lockin-video-list-panel\">\n      <div className=\"lockin-video-list-header\">\n        <h3 className=\"lockin-video-list-title\">{title}</h3>\n        <button\n          className=\"lockin-video-list-close\"\n          onClick={onClose}\n          aria-label=\"Close\"\n          type=\"button\"\n        >\n          \n        </button>\n      </div>\n\n      <div className=\"lockin-video-list-body\">\n        {isLoading ? (\n          <div className=\"lockin-video-list-loading\">\n            <span className=\"lockin-inline-spinner\" />\n            <span>Detecting videos...</span>\n          </div>\n        ) : authRequired ? (\n          <AuthRequiredPrompt provider={authRequired.provider} signInUrl={authRequired.signInUrl} />\n        ) : showError ? (\n          <div className=\"lockin-video-list-error\">\n            <p>{error}</p>\n          </div>\n        ) : videos.length === 0 ? (\n          <div className=\"lockin-video-list-empty\">\n            <p>{emptyMessage}</p>\n            <p className=\"lockin-video-list-hint\">{supportedProviders}</p>\n            {detectionHint && <p className=\"lockin-video-list-hint\">{detectionHint}</p>}\n          </div>\n        ) : (\n          <div className=\"lockin-video-list\" role=\"list\">\n            {videos.map((video) => {\n              const isSelected = selectedVideoId === video.id;\n              const isDisabled = isVideoDisabled?.(video) ?? false;\n\n              const itemProps = {\n                key: `${video.provider}-${video.id}`,\n                video,\n                onSelect: () => onSelectVideo(video),\n                isSelected,\n                isDisabled,\n                ...(renderItemBadge ? { renderBadge: renderItemBadge } : {}),\n                ...(renderItemActions ? { renderActions: renderItemActions } : {}),\n                ...(renderItemStatus ? { renderStatus: renderItemStatus } : {}),\n              };\n\n              return <VideoListItem {...itemProps} />;\n            })}\n          </div>\n        )}\n      </div>\n\n      <div className=\"lockin-video-list-footer\">\n        <p className=\"lockin-video-list-info\">\n          {videos.length} video{videos.length !== 1 ? 's' : ''} found\n        </p>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\videos\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\extension\\videos\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\__tests__\\useNotesList.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 52,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 52,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 62,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 62,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 68,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 68,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 79,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 79,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [2296, 2310], "text": "(note.isStarred ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": { "range": [2296, 2310], "text": "(note.isStarred === true)" },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (65). Maximum allowed is 50.",
        "line": 97,
        "column": 26,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 173,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/promise-function-async",
        "severity": 1,
        "message": "Functions that return promises must be async.",
        "line": 137,
        "column": 54,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAsync",
        "endLine": 137,
        "endColumn": 56,
        "fix": { "range": [4038, 4038], "text": "async " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';\nimport { act } from 'react';\nimport { createRoot, type Root } from 'react-dom/client';\nimport type { Note } from '@core/domain/Note';\nimport type { NotesService } from '@core/services/notesService';\nimport { useNotesList } from '../useNotesList';\n\nconst actEnvironment = globalThis as typeof globalThis & {\n  IS_REACT_ACT_ENVIRONMENT?: boolean;\n};\nactEnvironment.IS_REACT_ACT_ENVIRONMENT = true;\n\nfunction createNote(overrides: Partial<Note> = {}): Note {\n  return {\n    id: 'note-1',\n    title: 'Sample note',\n    content: {\n      version: 'lexical_v1',\n      editorState: null,\n      legacyHtml: null,\n      plainText: 'Sample note',\n    },\n    sourceUrl: null,\n    sourceSelection: null,\n    courseCode: null,\n    noteType: 'manual',\n    tags: [],\n    createdAt: '2025-01-01T00:00:00.000Z',\n    updatedAt: '2025-01-01T00:00:00.000Z',\n    isStarred: false,\n    previewText: 'Sample note',\n    ...overrides,\n  };\n}\n\nfunction createNotesServiceStub(overrides: Partial<NotesService> = {}): NotesService {\n  return {\n    listNotes: vi.fn().mockResolvedValue([]),\n    getNote: vi.fn(),\n    createNote: vi.fn(),\n    updateNote: vi.fn(),\n    deleteNote: vi.fn(),\n    toggleStar: vi.fn(),\n    setStar: vi.fn(),\n    listAssets: vi.fn(),\n    uploadAsset: vi.fn(),\n    deleteAsset: vi.fn(),\n    ...overrides,\n  } as NotesService;\n}\n\nfunction createDeferred<T>() {\n  let resolve!: (value: T | PromiseLike<T>) => void;\n  let reject!: (reason?: unknown) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n}\n\nasync function flushPromises(cycles = 1) {\n  for (let i = 0; i < cycles; i += 1) {\n    await new Promise((resolve) => setTimeout(resolve, 0));\n  }\n}\n\nfunction NotesListHarness({ notesService }: { notesService: NotesService }) {\n  const { notes, error, toggleStar } = useNotesList({ notesService, limit: 50 });\n\n  return (\n    <div>\n      <div data-testid=\"notes-error\">{error ?? ''}</div>\n      <ul>\n        {notes.map((note) => (\n          <li key={note.id ?? ''} data-testid=\"note-item\">\n            <span data-testid={`note-title-${note.id}`}>{note.title}</span>\n            <span data-testid={`note-star-${note.id}`}>\n              {note.isStarred ? 'starred' : 'unstarred'}\n            </span>\n            <button\n              data-testid={`note-toggle-${note.id}`}\n              type=\"button\"\n              onClick={() => {\n                void toggleStar(note.id as string).catch(() => undefined);\n              }}\n            >\n              toggle\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\ndescribe('useNotesList', () => {\n  let container: HTMLDivElement;\n  let root: Root;\n\n  beforeEach(() => {\n    container = document.createElement('div');\n    document.body.appendChild(container);\n    root = createRoot(container);\n  });\n\n  afterEach(() => {\n    act(() => {\n      root.unmount();\n    });\n    container.remove();\n    document.body.innerHTML = '';\n    vi.restoreAllMocks();\n  });\n\n  it('loads notes from the service on mount', async () => {\n    const note = createNote({ id: 'note-101', title: 'Week 3 summary' });\n    const listNotes = vi.fn().mockResolvedValue([note]);\n    const notesService = createNotesServiceStub({ listNotes });\n\n    await act(async () => {\n      root.render(<NotesListHarness notesService={notesService} />);\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    expect(listNotes).toHaveBeenCalledWith({ limit: 50 });\n    const title = document.querySelector('[data-testid=\"note-title-note-101\"]');\n    expect(title?.textContent).toBe('Week 3 summary');\n  });\n\n  it('rolls back star state when the toggle request fails', async () => {\n    const note = createNote({ id: 'note-202', title: 'Lecture notes', isStarred: false });\n    const listNotes = vi.fn().mockResolvedValue([note]);\n    const deferred = createDeferred<Note>();\n    const toggleStar = vi.fn().mockImplementation(() => deferred.promise);\n    const notesService = createNotesServiceStub({ listNotes, toggleStar });\n\n    await act(async () => {\n      root.render(<NotesListHarness notesService={notesService} />);\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const toggleButton = document.querySelector(\n      '[data-testid=\"note-toggle-note-202\"]',\n    ) as HTMLButtonElement | null;\n    expect(toggleButton).not.toBeNull();\n\n    await act(async () => {\n      toggleButton?.click();\n    });\n    await act(async () => {\n      await flushPromises(2);\n    });\n\n    const optimisticStar = document.querySelector('[data-testid=\"note-star-note-202\"]');\n    expect(optimisticStar?.textContent).toBe('starred');\n\n    await act(async () => {\n      deferred.reject(new Error('Network error'));\n      await flushPromises(2);\n    });\n\n    expect(toggleStar).toHaveBeenCalledWith('note-202');\n    const star = document.querySelector('[data-testid=\"note-star-note-202\"]');\n    expect(star?.textContent).toBe('unstarred');\n    const error = document.querySelector('[data-testid=\"notes-error\"]');\n    expect(error?.textContent).toContain('Network error');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\noteEditor\\constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\noteEditor\\noteUtils.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 7,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 7,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [233, 257], "text": "(globalCrypto?.randomUUID) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 11,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 11,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 12,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 12,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [346, 375], "text": "(globalCrypto?.getRandomValues) != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 256.",
        "line": 16,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 16,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0x0f.",
        "line": 20,
        "column": 33,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 20,
        "endColumn": 37
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0x40.",
        "line": 20,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 20,
        "endColumn": 45
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0x3f.",
        "line": 21,
        "column": 33,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 21,
        "endColumn": 37
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 0x80.",
        "line": 21,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 21,
        "endColumn": 45
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 22,
        "column": 57,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 22,
        "endColumn": 59
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 23,
        "column": 26,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 23,
        "endColumn": 27
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 4.",
        "line": 23,
        "column": 51,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 23,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 23,
        "column": 54,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 23,
        "endColumn": 55
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 6.",
        "line": 24,
        "column": 12,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 24,
        "endColumn": 13
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 8.",
        "line": 24,
        "column": 15,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 24,
        "endColumn": 16
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 8.",
        "line": 25,
        "column": 28,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 25,
        "endColumn": 29
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 25,
        "column": 31,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 25,
        "endColumn": 33
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 10.",
        "line": 25,
        "column": 57,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 25,
        "endColumn": 59
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 16.",
        "line": 25,
        "column": 61,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 25,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 52,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 52,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1462, 1477], "text": "opts.courseCode != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1462, 1477], "text": "opts.courseCode ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1462, 1477], "text": "Boolean(opts.courseCode)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Note, NoteContent } from '@core/domain/Note';\n\nexport function createClientNoteId(): string {\n  const globalCrypto =\n    typeof globalThis !== 'undefined' ? (globalThis.crypto as Crypto | undefined) : undefined;\n\n  if (globalCrypto?.randomUUID) {\n    return globalCrypto.randomUUID();\n  }\n\n  const bytes = new Uint8Array(16);\n  if (globalCrypto?.getRandomValues) {\n    globalCrypto.getRandomValues(bytes);\n  } else {\n    for (let i = 0; i < bytes.length; i += 1) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n\n  bytes[6] = ((bytes[6] ?? 0) & 0x0f) | 0x40;\n  bytes[8] = ((bytes[8] ?? 0) & 0x3f) | 0x80;\n  const hex = Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0'));\n  return `${hex.slice(0, 4).join('')}-${hex.slice(4, 6).join('')}-${hex\n    .slice(6, 8)\n    .join('')}-${hex.slice(8, 10).join('')}-${hex.slice(10, 16).join('')}`;\n}\n\nexport function createDraftNote(opts: {\n  courseCode?: string | null;\n  sourceUrl?: string | null;\n  sourceSelection?: string | null;\n}): Note {\n  const note: Note = {\n    id: null,\n    title: '',\n    content: {\n      version: 'lexical_v1',\n      editorState: null,\n      legacyHtml: null,\n      plainText: '',\n    },\n    sourceUrl: opts.sourceUrl ?? null,\n    sourceSelection: opts.sourceSelection ?? null,\n    courseCode: opts.courseCode ?? null,\n    noteType: 'manual',\n    tags: [],\n    createdAt: null,\n    updatedAt: null,\n    isStarred: false,\n    previewText: '',\n  };\n  if (opts.courseCode) {\n    note.linkedLabel = opts.courseCode;\n  }\n  return note;\n}\n\nexport function createContentFingerprint(title: string, content: NoteContent): string {\n  return JSON.stringify({\n    title: title.trim(),\n    content: content.editorState,\n    version: content.version,\n    legacy: content.legacyHtml,\n    plainText: content.plainText,\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\noteEditor\\offlineQueue.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 21,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 21,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [564, 575], "text": "(save.noteId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [564, 575], "text": "(save.noteId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [564, 575], "text": "(Boolean(save.noteId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 35,
        "column": 21,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 35,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [990, 1007], "text": "(item.clientNoteId.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [990, 1007], "text": "(item.clientNoteId !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [990, 1007], "text": "(Boolean(item.clientNoteId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 35,
        "column": 42,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 35,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1011, 1022], "text": "(item.noteId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1011, 1022], "text": "(item.noteId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1011, 1022], "text": "(Boolean(item.noteId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 41,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 41,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1244, 1253], "text": "(existing == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 52,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 52,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1572, 1579], "text": "stored == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1573, 1579], "text": "(stored ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1572, 1579], "text": "!Boolean(stored)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 53,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 53,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 1,
        "message": "Unsafe argument of type `any[]` assigned to a parameter of type `PendingSave[]`.",
        "line": 54,
        "column": 34,
        "nodeType": "ConditionalExpression",
        "messageId": "unsafeArgument",
        "endLine": 54,
        "endColumn": 69
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: -50.",
        "line": 77,
        "column": 34,
        "nodeType": "UnaryExpression",
        "messageId": "noMagic",
        "endLine": 77,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { NoteContent, NoteType } from '@core/domain/Note';\nimport { OFFLINE_QUEUE_KEY } from './constants';\nimport { createClientNoteId } from './noteUtils';\n\nexport interface PendingSave {\n  noteId: string | null;\n  clientNoteId: string;\n  title: string;\n  content: NoteContent;\n  courseCode: string | null;\n  sourceUrl: string | null;\n  sourceSelection: string | null;\n  noteType: NoteType;\n  tags: string[];\n  expectedUpdatedAt: string | null;\n  timestamp: number;\n  retryCount: number;\n}\n\nexport function getQueueKey(save: PendingSave): string {\n  return save.noteId || save.clientNoteId;\n}\n\nfunction normalizeOfflineQueue(queue: PendingSave[]): PendingSave[] {\n  const latestByKey = new Map<string, PendingSave>();\n\n  queue.forEach((item) => {\n    const noteType =\n      typeof item.noteType === 'string' && item.noteType.length > 0\n        ? (item.noteType as NoteType)\n        : 'manual';\n    const normalized: PendingSave = {\n      ...item,\n      noteType,\n      clientNoteId: item.clientNoteId || item.noteId || createClientNoteId(),\n      expectedUpdatedAt: item.expectedUpdatedAt ?? null,\n      retryCount: item.retryCount ?? 0,\n    };\n    const key = getQueueKey(normalized);\n    const existing = latestByKey.get(key);\n    if (!existing || normalized.timestamp >= existing.timestamp) {\n      latestByKey.set(key, normalized);\n    }\n  });\n\n  return Array.from(latestByKey.values()).sort((a, b) => a.timestamp - b.timestamp);\n}\n\nexport function loadOfflineQueue(): PendingSave[] {\n  try {\n    const stored = localStorage.getItem(OFFLINE_QUEUE_KEY);\n    if (!stored) return [];\n    const parsed = JSON.parse(stored);\n    return normalizeOfflineQueue(Array.isArray(parsed) ? parsed : []);\n  } catch {\n    return [];\n  }\n}\n\nexport function saveOfflineQueue(queue: PendingSave[]): void {\n  try {\n    const normalized = normalizeOfflineQueue(queue);\n    localStorage.setItem(OFFLINE_QUEUE_KEY, JSON.stringify(normalized));\n  } catch {\n    console.error('[NoteEditor] Failed to save offline queue');\n  }\n}\n\nexport function addToOfflineQueue(save: PendingSave): void {\n  const queue = loadOfflineQueue();\n  // Remove any existing entry for the same note (we only need the latest)\n  const key = getQueueKey(save);\n  const filtered = queue.filter((s) => getQueueKey(s) !== key);\n  // Keep only the most recent for this note\n  filtered.push(save);\n  // Limit queue size to prevent storage bloat\n  const trimmed = filtered.slice(-50);\n  saveOfflineQueue(trimmed);\n}\n\nexport function removeFromOfflineQueue(queueKey: string): void {\n  const queue = loadOfflineQueue();\n  const filtered = queue.filter((s) => getQueueKey(s) !== queueKey);\n  saveOfflineQueue(filtered);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\noteEditor\\persistenceUtils.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 30,
        "column": 30,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 30,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [977, 988], "text": "(err.message.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [977, 988], "text": "(err.message !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [977, 988], "text": "(Boolean(err.message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 32,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 32,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1078, 1085], "text": "message != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1078, 1085], "text": "message ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1078, 1085], "text": "Boolean(message)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 38,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 38,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 39,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 39,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1212, 1223], "text": "ref.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [1212, 1223], "text": "ref.current ?? 0" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1212, 1223], "text": "Boolean(ref.current)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 45,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 45,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 71,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 71,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [1967, 1977], "text": "(note.title.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [1967, 1977], "text": "(note.title !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1967, 1977], "text": "(Boolean(note.title))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 113,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 113,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3134, 3144], "text": "(note.title.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3134, 3144], "text": "(note.title !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3134, 3144], "text": "(Boolean(note.title))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 143,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 143,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3914, 3921], "text": "note.id != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3914, 3921], "text": "note.id ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3914, 3921], "text": "Boolean(note.id)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 170,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 170,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4562, 4576], "text": "((latestNote?.id) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4562, 4576], "text": "((latestNote?.id) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4562, 4576], "text": "(Boolean((latestNote?.id)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 170,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 170,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4580, 4588], "text": "(saved.id != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4580, 4588], "text": "(saved.id ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4580, 4588], "text": "(Boolean(saved.id))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 173,
        "column": 8,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 173,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4681, 4696], "text": "((latestNote?.id) == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4682, 4696], "text": "((latestNote?.id) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4681, 4696], "text": "(!Boolean((latestNote?.id)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 176,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 176,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4825, 4835], "text": "(latestNote != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 179,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 179,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4923, 4940], "text": "(latestFingerprint != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4923, 4940], "text": "(latestFingerprint ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4923, 4940], "text": "(Boolean(latestFingerprint))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 429.",
        "line": 189,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 189,
        "endColumn": 24
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 190,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 190,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 194,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 194,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 218,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 218,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6059, 6071], "text": "(meta.message != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6059, 6071], "text": "(meta.message ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6059, 6071], "text": "(Boolean(meta.message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 222,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 222,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 241,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 241,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6658, 6666], "text": "saved.id != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6658, 6666], "text": "saved.id ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6658, 6666], "text": "Boolean(saved.id)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 286,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 286,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7999, 8009], "text": "(latestNote != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 289,
        "column": 24,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 289,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8113, 8128], "text": "((latestNote?.id) == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [8114, 8128], "text": "((latestNote?.id) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [8113, 8128], "text": "(!Boolean((latestNote?.id)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 290,
        "column": 22,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 290,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8207, 8221], "text": "((latestNote?.id) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [8207, 8221], "text": "((latestNote?.id) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [8207, 8221], "text": "(Boolean((latestNote?.id)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 292,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 292,
        "endColumn": 44
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 23,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Dispatch, MutableRefObject, SetStateAction } from 'react';\nimport type { Note, NoteStatus } from '@core/domain/Note';\nimport type { CreateNoteInput, NotesService, UpdateNoteInput } from '@core/services/notesService';\nimport { MAX_SAVE_RETRIES, SAVED_RESET_DELAY_MS } from './constants';\nimport {\n  addToOfflineQueue,\n  getQueueKey,\n  loadOfflineQueue,\n  saveOfflineQueue,\n  type PendingSave,\n} from './offlineQueue';\nimport { createContentFingerprint } from './noteUtils';\n\nexport type ErrorMeta = {\n  code?: string;\n  status?: number;\n  message?: string;\n};\n\nexport function getErrorMeta(err: unknown): ErrorMeta {\n  const record = typeof err === 'object' && err !== null ? (err as Record<string, unknown>) : null;\n  const meta: ErrorMeta = {};\n  if (typeof record?.['code'] === 'string') {\n    meta.code = record['code'];\n  }\n  if (typeof record?.['status'] === 'number') {\n    meta.status = record['status'];\n  }\n  const message =\n    (err instanceof Error && err.message) ||\n    (typeof record?.['message'] === 'string' ? record['message'] : undefined);\n  if (message) {\n    meta.message = message;\n  }\n  return meta;\n}\n\nexport function clearTimer(ref: MutableRefObject<number | null>) {\n  if (ref.current) {\n    window.clearTimeout(ref.current);\n    ref.current = null;\n  }\n}\n\nexport function scheduleSavedReset(\n  setStatus: Dispatch<SetStateAction<NoteStatus>>,\n  savedResetRef: MutableRefObject<number | null>,\n) {\n  clearTimer(savedResetRef);\n  savedResetRef.current = window.setTimeout(() => setStatus('idle'), SAVED_RESET_DELAY_MS);\n}\n\nexport function buildPendingSave({\n  note,\n  clientNoteId,\n  defaultCourseCode,\n  defaultSourceUrl,\n  sourceSelection,\n  expectedUpdatedAt,\n}: {\n  note: Note;\n  clientNoteId: string;\n  defaultCourseCode?: string | null;\n  defaultSourceUrl?: string | null;\n  sourceSelection?: string | null;\n  expectedUpdatedAt: string | null;\n}): PendingSave {\n  return {\n    noteId: note.id,\n    clientNoteId,\n    title: note.title || 'Untitled note',\n    content: note.content,\n    courseCode: note.courseCode ?? defaultCourseCode ?? null,\n    sourceUrl: note.sourceUrl ?? defaultSourceUrl ?? null,\n    sourceSelection: note.sourceSelection ?? sourceSelection ?? null,\n    noteType: note.noteType,\n    tags: note.tags,\n    expectedUpdatedAt,\n    timestamp: Date.now(),\n    retryCount: 0,\n  };\n}\n\nexport function buildUpdatePayload(\n  note: Note,\n  defaults: {\n    defaultCourseCode?: string | null;\n    defaultSourceUrl?: string | null;\n    sourceSelection?: string | null;\n  },\n): UpdateNoteInput {\n  return {\n    title: note.title,\n    content: note.content,\n    courseCode: note.courseCode ?? defaults.defaultCourseCode ?? null,\n    sourceUrl: note.sourceUrl ?? defaults.defaultSourceUrl ?? null,\n    sourceSelection: note.sourceSelection ?? defaults.sourceSelection ?? null,\n    noteType: note.noteType,\n    tags: note.tags,\n  };\n}\n\nexport function buildCreatePayload(\n  note: Note,\n  clientNoteId: string,\n  defaults: {\n    defaultCourseCode?: string | null;\n    defaultSourceUrl?: string | null;\n    sourceSelection?: string | null;\n  },\n): CreateNoteInput {\n  return {\n    title: note.title || 'Untitled note',\n    content: note.content,\n    courseCode: note.courseCode ?? defaults.defaultCourseCode ?? null,\n    sourceUrl: note.sourceUrl ?? defaults.defaultSourceUrl ?? null,\n    sourceSelection: note.sourceSelection ?? defaults.sourceSelection ?? null,\n    noteType: note.noteType,\n    tags: note.tags,\n    clientNoteId,\n  };\n}\n\nexport async function saveNoteToService({\n  notesService,\n  note,\n  clientNoteId,\n  expectedUpdatedAt,\n  controller,\n  defaults,\n}: {\n  notesService: NotesService;\n  note: Note;\n  clientNoteId: string;\n  expectedUpdatedAt: string | null;\n  controller: AbortController;\n  defaults: {\n    defaultCourseCode?: string | null;\n    defaultSourceUrl?: string | null;\n    sourceSelection?: string | null;\n  };\n}): Promise<Note> {\n  if (note.id) {\n    const payload = buildUpdatePayload(note, defaults);\n    return notesService.updateNote(note.id, payload, {\n      signal: controller.signal,\n      expectedUpdatedAt,\n    });\n  }\n\n  const payload = buildCreatePayload(note, clientNoteId, defaults);\n  return notesService.createNote(payload, {\n    signal: controller.signal,\n  });\n}\n\nexport function evaluateSaveResult({\n  saved,\n  latestNote,\n  fingerprint,\n  clientNoteIdRef,\n  clientNoteId,\n}: {\n  saved: Note;\n  latestNote: Note | null;\n  fingerprint: string;\n  clientNoteIdRef: MutableRefObject<string>;\n  clientNoteId: string;\n}): { ignore: boolean; markEditing: boolean } {\n  if (latestNote?.id && saved.id && latestNote.id !== saved.id) {\n    return { ignore: true, markEditing: false };\n  }\n  if (!latestNote?.id && clientNoteIdRef.current !== clientNoteId) {\n    return { ignore: true, markEditing: false };\n  }\n  const latestFingerprint = latestNote\n    ? createContentFingerprint(latestNote.title, latestNote.content)\n    : null;\n  if (latestFingerprint && latestFingerprint !== fingerprint) {\n    return { ignore: true, markEditing: true };\n  }\n  return { ignore: false, markEditing: false };\n}\n\nexport function isRetryableError(meta: ErrorMeta): boolean {\n  return (\n    meta.code === 'NETWORK_ERROR' ||\n    meta.code === 'RATE_LIMIT' ||\n    meta.status === 429 ||\n    (meta.status ?? 0) >= 500\n  );\n}\n\nexport function handlePersistFailure({\n  meta,\n  pendingSave,\n  setPendingSaveCount,\n  setError,\n  setStatus,\n}: {\n  meta: ErrorMeta;\n  pendingSave: PendingSave;\n  setPendingSaveCount: Dispatch<SetStateAction<number>>;\n  setError: Dispatch<SetStateAction<string | null>>;\n  setStatus: Dispatch<SetStateAction<NoteStatus>>;\n}) {\n  const networkError = meta.code === 'NETWORK_ERROR' || !navigator.onLine;\n  const retryable = networkError || isRetryableError(meta);\n\n  if (retryable && pendingSave.retryCount < MAX_SAVE_RETRIES) {\n    addToOfflineQueue(pendingSave);\n    setPendingSaveCount(loadOfflineQueue().length);\n    setError(networkError ? 'Saved offline - will sync when connected' : 'Save queued for retry');\n    setStatus('error');\n    return;\n  }\n\n  setError(meta.message || 'Failed to save note');\n  setStatus('error');\n}\n\nexport function applySavedNote({\n  saved,\n  setNote,\n  setActiveNoteId,\n  clientNoteIdRef,\n  lastSavedFingerprintRef,\n  setStatus,\n  savedResetRef,\n}: {\n  saved: Note;\n  setNote: Dispatch<SetStateAction<Note | null>>;\n  setActiveNoteId: (noteId: string | null) => void;\n  clientNoteIdRef: MutableRefObject<string>;\n  lastSavedFingerprintRef: MutableRefObject<string | null>;\n  setStatus: Dispatch<SetStateAction<NoteStatus>>;\n  savedResetRef: MutableRefObject<number | null>;\n}) {\n  setNote(saved);\n  setActiveNoteId(saved.id);\n  if (saved.id) {\n    clientNoteIdRef.current = saved.id;\n  }\n  lastSavedFingerprintRef.current = createContentFingerprint(saved.title, saved.content);\n  setStatus('saved');\n  scheduleSavedReset(setStatus, savedResetRef);\n}\n\nexport function buildPendingUpdatePayload(pendingSave: PendingSave): UpdateNoteInput {\n  return {\n    title: pendingSave.title,\n    content: pendingSave.content,\n    courseCode: pendingSave.courseCode,\n    sourceUrl: pendingSave.sourceUrl,\n    sourceSelection: pendingSave.sourceSelection,\n    noteType: pendingSave.noteType,\n    tags: pendingSave.tags,\n  };\n}\n\nexport function buildPendingCreatePayload(pendingSave: PendingSave): CreateNoteInput {\n  return {\n    title: pendingSave.title,\n    content: pendingSave.content,\n    courseCode: pendingSave.courseCode,\n    sourceUrl: pendingSave.sourceUrl,\n    sourceSelection: pendingSave.sourceSelection,\n    noteType: pendingSave.noteType,\n    tags: pendingSave.tags,\n    clientNoteId: pendingSave.clientNoteId,\n  };\n}\n\nexport function shouldApplySyncedSave({\n  saved,\n  pendingSave,\n  latestNote,\n  clientNoteIdRef,\n}: {\n  saved: Note;\n  pendingSave: PendingSave;\n  latestNote: Note | null;\n  clientNoteIdRef: MutableRefObject<string>;\n}): boolean {\n  const pendingFingerprint = createContentFingerprint(pendingSave.title, pendingSave.content);\n  const latestFingerprint = latestNote\n    ? createContentFingerprint(latestNote.title, latestNote.content)\n    : null;\n  const isSameDraft = !latestNote?.id && clientNoteIdRef.current === pendingSave.clientNoteId;\n  const isSameNote = latestNote?.id && latestNote.id === saved.id;\n\n  return Boolean((isSameDraft || isSameNote) && latestFingerprint === pendingFingerprint);\n}\n\nexport function updateQueueAfterSyncFailure(queueKey: string, meta: ErrorMeta): PendingSave[] {\n  const isStale = meta.code === 'CONFLICT' || meta.code === 'NOT_FOUND';\n  const retryable = isRetryableError(meta);\n  const updated = loadOfflineQueue().map((save) =>\n    getQueueKey(save) === queueKey ? { ...save, retryCount: (save.retryCount ?? 0) + 1 } : save,\n  );\n  let filtered = updated.filter((save) => save.retryCount < MAX_SAVE_RETRIES);\n  if (!retryable || isStale) {\n    filtered = filtered.filter((save) => getQueueKey(save) !== queueKey);\n  }\n  saveOfflineQueue(filtered);\n  return filtered;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\noteEditor\\useNoteEditorPersistence.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useNoteEditorPersistence' has too many lines (314). Maximum allowed is 50.",
        "line": 46,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 388,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 66,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 66,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2207, 2226], "text": "debounceRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [2207, 2226], "text": "debounceRef.current ?? 0" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2207, 2226], "text": "Boolean(debounceRef.current)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 69,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 69,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2298, 2319], "text": "savedResetRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [2298, 2319], "text": "savedResetRef.current ?? 0" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2298, 2319], "text": "Boolean(savedResetRef.current)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 72,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 72,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2393, 2419], "text": "abortControllerRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async arrow function has too many lines (94). Maximum allowed is 50.",
        "line": 80,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 184,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (46). Maximum allowed is 20.",
        "line": 80,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 184,
        "endColumn": 4
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async arrow function has a complexity of 20. Maximum allowed is 15.",
        "line": 80,
        "column": 40,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 80,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 83,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 83,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2681, 2694], "text": "(notesService == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 83,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 83,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2698, 2710], "text": "(currentNote == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 99,
        "column": 26,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 99,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3150, 3164], "text": "(currentNote.id != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3150, 3164], "text": "(currentNote.id ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3150, 3164], "text": "(Boolean(currentNote.id))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 99,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 99,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [3168, 3191], "text": "(clientNoteIdRef.current.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [3168, 3191], "text": "(clientNoteIdRef.current !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3168, 3191], "text": "(Boolean(clientNoteIdRef.current))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 100,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 100,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3225, 3240], "text": "currentNote.id == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3226, 3240], "text": "(currentNote.id ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3225, 3240], "text": "!Boolean(currentNote.id)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 104,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 104,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3378, 3392], "text": "(currentNote.id != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3378, 3392], "text": "(currentNote.id ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3378, 3392], "text": "(Boolean(currentNote.id))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 198,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 198,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5665, 5684], "text": "debounceRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [5665, 5684], "text": "debounceRef.current ?? 0" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5665, 5684], "text": "Boolean(debounceRef.current)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 263,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 263,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7743, 7762], "text": "debounceRef.current != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [7743, 7762], "text": "debounceRef.current ?? 0" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7743, 7762], "text": "Boolean(debounceRef.current)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async arrow function has too many lines (53). Maximum allowed is 50.",
        "line": 302,
        "column": 40,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 360,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (26). Maximum allowed is 20.",
        "line": 302,
        "column": 40,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 360,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 303,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 303,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8865, 8878], "text": "notesService == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 314,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 314,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9187, 9205], "text": "pendingSave.noteId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [9187, 9205], "text": "pendingSave.noteId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [9187, 9205], "text": "Boolean(pendingSave.noteId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines",
        "severity": 1,
        "message": "File has too many lines (356). Maximum allowed is 300.",
        "line": 328,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 389,
        "endColumn": 1
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 328,
        "column": 56,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 328,
        "endColumn": 74,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [9863, 9881], "text": "(pendingSave.noteId != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [9863, 9881], "text": "(pendingSave.noteId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [9863, 9881], "text": "(Boolean(pendingSave.noteId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 328,
        "column": 78,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 328,
        "endColumn": 102,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [9885, 9909], "text": "(pendingSave.clientNoteId.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [9885, 9909], "text": "(pendingSave.clientNoteId !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [9885, 9909], "text": "(Boolean(pendingSave.clientNoteId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 331,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 331,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 371,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 371,
        "endColumn": 31
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 24,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useEffect, useRef, useState } from 'react';\nimport type { Dispatch, MutableRefObject, SetStateAction } from 'react';\nimport type { Note, NoteContent, NoteStatus } from '@core/domain/Note';\nimport type { NotesService } from '@core/services/notesService';\nimport { SAVE_DEBOUNCE_MS } from './constants';\nimport { getQueueKey, loadOfflineQueue, removeFromOfflineQueue } from './offlineQueue';\nimport { createClientNoteId, createContentFingerprint, createDraftNote } from './noteUtils';\nimport {\n  applySavedNote,\n  buildPendingCreatePayload,\n  buildPendingSave,\n  buildPendingUpdatePayload,\n  clearTimer,\n  evaluateSaveResult,\n  getErrorMeta,\n  handlePersistFailure,\n  saveNoteToService,\n  scheduleSavedReset,\n  shouldApplySyncedSave,\n  updateQueueAfterSyncFailure,\n} from './persistenceUtils';\n\nexport interface NoteEditorPersistenceOptions {\n  notesService: NotesService | null | undefined;\n  defaultCourseCode?: string | null;\n  defaultSourceUrl?: string | null;\n  sourceSelection?: string | null;\n  noteRef: MutableRefObject<Note | null>;\n  clientNoteIdRef: MutableRefObject<string>;\n  lastSavedFingerprintRef: MutableRefObject<string | null>;\n  setNote: Dispatch<SetStateAction<Note | null>>;\n  setStatus: Dispatch<SetStateAction<NoteStatus>>;\n  setError: Dispatch<SetStateAction<string | null>>;\n  setActiveNoteId: (noteId: string | null) => void;\n}\n\nexport interface NoteEditorPersistenceResult {\n  pendingSaveCount: number;\n  handleContentChange: (content: NoteContent) => void;\n  handleTitleChange: (title: string) => void;\n  saveNow: () => Promise<void>;\n  resetToNew: () => void;\n  syncOfflineQueue: () => Promise<void>;\n}\n\nexport function useNoteEditorPersistence({\n  notesService,\n  defaultCourseCode,\n  defaultSourceUrl,\n  sourceSelection,\n  noteRef,\n  clientNoteIdRef,\n  lastSavedFingerprintRef,\n  setNote,\n  setStatus,\n  setError,\n  setActiveNoteId,\n}: NoteEditorPersistenceOptions): NoteEditorPersistenceResult {\n  const saveSequenceRef = useRef(0);\n  const debounceRef = useRef<number | null>(null);\n  const savedResetRef = useRef<number | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  useEffect(() => {\n    return () => {\n      if (debounceRef.current) {\n        window.clearTimeout(debounceRef.current);\n      }\n      if (savedResetRef.current) {\n        window.clearTimeout(savedResetRef.current);\n      }\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  const [pendingSaveCount, setPendingSaveCount] = useState(() => loadOfflineQueue().length);\n\n  const persist = useCallback(async () => {\n    const currentNote = noteRef.current;\n\n    if (!notesService || !currentNote) {\n      setError('Notes service unavailable');\n      setStatus('error');\n      return;\n    }\n\n    clearTimer(debounceRef);\n    abortControllerRef.current?.abort();\n\n    const fingerprint = createContentFingerprint(currentNote.title, currentNote.content);\n    if (fingerprint === lastSavedFingerprintRef.current) {\n      setStatus('saved');\n      scheduleSavedReset(setStatus, savedResetRef);\n      return;\n    }\n\n    const clientNoteId = currentNote.id || clientNoteIdRef.current || createClientNoteId();\n    if (!currentNote.id) {\n      clientNoteIdRef.current = clientNoteId;\n    }\n    const expectedUpdatedAt = currentNote.updatedAt ?? null;\n    const queueKey = currentNote.id || clientNoteId;\n    const saveSequence = ++saveSequenceRef.current;\n\n    const controller = new AbortController();\n    abortControllerRef.current = controller;\n    setStatus('saving');\n    setError(null);\n\n    const defaults: {\n      defaultCourseCode?: string | null;\n      defaultSourceUrl?: string | null;\n      sourceSelection?: string | null;\n    } = {};\n    if (defaultCourseCode !== undefined) {\n      defaults.defaultCourseCode = defaultCourseCode;\n    }\n    if (defaultSourceUrl !== undefined) {\n      defaults.defaultSourceUrl = defaultSourceUrl;\n    }\n    if (sourceSelection !== undefined) {\n      defaults.sourceSelection = sourceSelection;\n    }\n    const pendingSave = buildPendingSave({\n      note: currentNote,\n      clientNoteId,\n      expectedUpdatedAt,\n      ...defaults,\n    });\n\n    try {\n      const saved = await saveNoteToService({\n        notesService,\n        note: currentNote,\n        clientNoteId,\n        expectedUpdatedAt,\n        controller,\n        defaults,\n      });\n\n      if (controller.signal.aborted) return;\n      if (saveSequence !== saveSequenceRef.current) return;\n\n      const latestNote = noteRef.current;\n      const evaluation = evaluateSaveResult({\n        saved,\n        latestNote,\n        fingerprint,\n        clientNoteIdRef,\n        clientNoteId,\n      });\n      if (evaluation.ignore) {\n        if (evaluation.markEditing) {\n          setStatus('editing');\n        }\n        return;\n      }\n\n      removeFromOfflineQueue(queueKey);\n      setPendingSaveCount(loadOfflineQueue().length);\n\n      applySavedNote({\n        saved,\n        setNote,\n        setActiveNoteId,\n        clientNoteIdRef,\n        lastSavedFingerprintRef,\n        setStatus,\n        savedResetRef,\n      });\n    } catch (err: unknown) {\n      const meta = getErrorMeta(err);\n      if (controller.signal.aborted || meta.code === 'ABORTED') return;\n      handlePersistFailure({\n        meta,\n        pendingSave,\n        setPendingSaveCount,\n        setError,\n        setStatus,\n      });\n    }\n  }, [\n    defaultCourseCode,\n    defaultSourceUrl,\n    lastSavedFingerprintRef,\n    notesService,\n    noteRef,\n    setActiveNoteId,\n    setError,\n    setNote,\n    setStatus,\n    sourceSelection,\n  ]);\n\n  const scheduleSave = useCallback(() => {\n    if (debounceRef.current) {\n      window.clearTimeout(debounceRef.current);\n    }\n    debounceRef.current = window.setTimeout(() => {\n      void persist();\n    }, SAVE_DEBOUNCE_MS);\n  }, [persist]);\n\n  const handleContentChange = useCallback(\n    (content: NoteContent) => {\n      setNote((prev: Note | null) => {\n        const draftDefaults: {\n          courseCode?: string | null;\n          sourceUrl?: string | null;\n          sourceSelection?: string | null;\n        } = {};\n        if (defaultCourseCode !== undefined) {\n          draftDefaults.courseCode = defaultCourseCode;\n        }\n        if (defaultSourceUrl !== undefined) {\n          draftDefaults.sourceUrl = defaultSourceUrl;\n        }\n        if (sourceSelection !== undefined) {\n          draftDefaults.sourceSelection = sourceSelection;\n        }\n        const base = prev ?? createDraftNote(draftDefaults);\n        return { ...base, content };\n      });\n      setStatus('editing');\n      scheduleSave();\n    },\n    [defaultCourseCode, defaultSourceUrl, scheduleSave, setNote, setStatus, sourceSelection],\n  );\n\n  const handleTitleChange = useCallback(\n    (title: string) => {\n      setNote((prev: Note | null) => {\n        const draftDefaults: {\n          courseCode?: string | null;\n          sourceUrl?: string | null;\n          sourceSelection?: string | null;\n        } = {};\n        if (defaultCourseCode !== undefined) {\n          draftDefaults.courseCode = defaultCourseCode;\n        }\n        if (defaultSourceUrl !== undefined) {\n          draftDefaults.sourceUrl = defaultSourceUrl;\n        }\n        if (sourceSelection !== undefined) {\n          draftDefaults.sourceSelection = sourceSelection;\n        }\n        const base = prev ?? createDraftNote(draftDefaults);\n        return { ...base, title };\n      });\n      setStatus('editing');\n      scheduleSave();\n    },\n    [defaultCourseCode, defaultSourceUrl, scheduleSave, setNote, setStatus, sourceSelection],\n  );\n\n  const saveNow = useCallback(async () => {\n    await persist();\n  }, [persist]);\n\n  const resetToNew = useCallback(() => {\n    if (debounceRef.current) {\n      window.clearTimeout(debounceRef.current);\n      debounceRef.current = null;\n    }\n    abortControllerRef.current?.abort();\n    saveSequenceRef.current += 1;\n    setActiveNoteId(null);\n    clientNoteIdRef.current = createClientNoteId();\n    const draftDefaults: {\n      courseCode?: string | null;\n      sourceUrl?: string | null;\n      sourceSelection?: string | null;\n    } = {};\n    if (defaultCourseCode !== undefined) {\n      draftDefaults.courseCode = defaultCourseCode;\n    }\n    if (defaultSourceUrl !== undefined) {\n      draftDefaults.sourceUrl = defaultSourceUrl;\n    }\n    if (sourceSelection !== undefined) {\n      draftDefaults.sourceSelection = sourceSelection;\n    }\n    const draft = createDraftNote(draftDefaults);\n    setNote(draft);\n    lastSavedFingerprintRef.current = null;\n    setStatus('idle');\n    setError(null);\n  }, [\n    clientNoteIdRef,\n    defaultCourseCode,\n    defaultSourceUrl,\n    lastSavedFingerprintRef,\n    setActiveNoteId,\n    setError,\n    setNote,\n    setStatus,\n    sourceSelection,\n  ]);\n\n  const syncOfflineQueue = useCallback(async () => {\n    if (!notesService) return;\n\n    const queue = loadOfflineQueue();\n    if (queue.length === 0) return;\n\n    console.log(`[NoteEditor] Syncing ${queue.length} offline saves`);\n\n    for (const pendingSave of queue) {\n      const queueKey = getQueueKey(pendingSave);\n      try {\n        let saved: Note | null = null;\n        if (pendingSave.noteId) {\n          const payload = buildPendingUpdatePayload(pendingSave);\n          const updateOptions: { expectedUpdatedAt?: string | null } = {};\n          if (pendingSave.expectedUpdatedAt !== undefined) {\n            updateOptions.expectedUpdatedAt = pendingSave.expectedUpdatedAt;\n          }\n          saved = await notesService.updateNote(pendingSave.noteId, payload, updateOptions);\n        } else {\n          const payload = buildPendingCreatePayload(pendingSave);\n          saved = await notesService.createNote(payload);\n        }\n\n        removeFromOfflineQueue(queueKey);\n        console.log(\n          `[NoteEditor] Synced offline save for note ${pendingSave.noteId || pendingSave.clientNoteId || 'new'}`,\n        );\n\n        if (saved) {\n          const latestNote = noteRef.current;\n          if (\n            shouldApplySyncedSave({\n              saved,\n              pendingSave,\n              latestNote,\n              clientNoteIdRef,\n            })\n          ) {\n            applySavedNote({\n              saved,\n              setNote,\n              setActiveNoteId,\n              clientNoteIdRef,\n              lastSavedFingerprintRef,\n              setStatus,\n              savedResetRef,\n            });\n          }\n        }\n      } catch (err: unknown) {\n        console.error(`[NoteEditor] Failed to sync offline save:`, err);\n        const meta = getErrorMeta(err);\n        updateQueueAfterSyncFailure(queueKey, meta);\n      }\n    }\n\n    setPendingSaveCount(loadOfflineQueue().length);\n  }, [\n    clientNoteIdRef,\n    lastSavedFingerprintRef,\n    notesService,\n    noteRef,\n    setActiveNoteId,\n    setNote,\n    setStatus,\n  ]);\n\n  useEffect(() => {\n    const handleOnline = () => {\n      console.log('[NoteEditor] Back online - syncing offline queue');\n      void syncOfflineQueue();\n    };\n\n    window.addEventListener('online', handleOnline);\n    return () => window.removeEventListener('online', handleOnline);\n  }, [syncOfflineQueue]);\n\n  return {\n    pendingSaveCount,\n    handleContentChange,\n    handleTitleChange,\n    saveNow,\n    resetToNew,\n    syncOfflineQueue,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\noteEditor\\useNoteEditorState.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 8,
        "column": 31,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 8,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [441, 452], "text": "(err.message.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [441, 452], "text": "(err.message !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [441, 452], "text": "(Boolean(err.message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useNoteEditorState' has too many lines (135). Maximum allowed is 50.",
        "line": 43,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 195,
        "endColumn": 2
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function 'useNoteEditorState' has too many statements (22). Maximum allowed is 20.",
        "line": 43,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 195,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (72). Maximum allowed is 50.",
        "line": 96,
        "column": 13,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 178,
        "endColumn": 4
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (37). Maximum allowed is 20.",
        "line": 96,
        "column": 13,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 178,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 101,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 101,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3615, 3623], "text": "targetId != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3615, 3623], "text": "targetId ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3615, 3623], "text": "Boolean(targetId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 113,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 113,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3917, 3926], "text": "targetId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3918, 3926], "text": "(targetId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3917, 3926], "text": "!Boolean(targetId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 116,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 116,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4021, 4033], "text": "(currentNote == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 142,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 142,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5044, 5052], "text": "service == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 154,
        "column": 5,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 173,
        "endColumn": 10,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [5261, 5261], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [5261, 5261], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useRef, useState } from 'react';\nimport type { Dispatch, MutableRefObject, SetStateAction } from 'react';\nimport type { Note, NoteStatus } from '@core/domain/Note';\nimport type { NotesService } from '@core/services/notesService';\nimport { createClientNoteId, createContentFingerprint, createDraftNote } from './noteUtils';\n\nfunction getErrorMessage(err: unknown, fallback: string): string {\n  if (err instanceof Error && err.message) return err.message;\n  if (typeof err === 'object' && err !== null) {\n    const record = err as Record<string, unknown>;\n    if (typeof record['message'] === 'string') return record['message'];\n  }\n  return fallback;\n}\n\nexport interface NoteEditorStateOptions {\n  noteId?: string | null;\n  notesService: NotesService | null | undefined;\n  defaultCourseCode?: string | null;\n  defaultSourceUrl?: string | null;\n  sourceSelection?: string | null;\n}\n\nexport interface NoteEditorState {\n  note: Note | null;\n  status: NoteStatus;\n  error: string | null;\n  isLoading: boolean;\n  activeNoteId: string | null;\n  setActiveNoteId: (noteId: string | null) => void;\n}\n\nexport interface NoteEditorStateInternal extends NoteEditorState {\n  setNote: Dispatch<SetStateAction<Note | null>>;\n  setStatus: Dispatch<SetStateAction<NoteStatus>>;\n  setError: Dispatch<SetStateAction<string | null>>;\n  setIsLoading: Dispatch<SetStateAction<boolean>>;\n  noteRef: MutableRefObject<Note | null>;\n  clientNoteIdRef: MutableRefObject<string>;\n  lastSavedFingerprintRef: MutableRefObject<string | null>;\n}\n\nexport function useNoteEditorState({\n  noteId,\n  notesService,\n  defaultCourseCode,\n  defaultSourceUrl,\n  sourceSelection,\n}: NoteEditorStateOptions): NoteEditorStateInternal {\n  const [activeNoteId, setActiveNoteId] = useState<string | null>(noteId ?? null);\n  const [note, setNote] = useState<Note | null>(\n    (() => {\n      const draftDefaults: {\n        courseCode?: string | null;\n        sourceUrl?: string | null;\n        sourceSelection?: string | null;\n      } = {};\n      if (defaultCourseCode !== undefined) {\n        draftDefaults.courseCode = defaultCourseCode;\n      }\n      if (defaultSourceUrl !== undefined) {\n        draftDefaults.sourceUrl = defaultSourceUrl;\n      }\n      if (sourceSelection !== undefined) {\n        draftDefaults.sourceSelection = sourceSelection;\n      }\n      return createDraftNote(draftDefaults);\n    })(),\n  );\n  const [status, setStatus] = useState<NoteStatus>('idle');\n  const [error, setError] = useState<string | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const noteRef = useRef(note);\n  noteRef.current = note;\n  const clientNoteIdRef = useRef<string>(noteId ?? createClientNoteId());\n  const lastSavedFingerprintRef = useRef<string | null>(null);\n  const loadingNoteIdRef = useRef<string | null>(null);\n  const lastLoadedNoteIdRef = useRef<string | null>(null);\n\n  useEffect(() => {\n    setActiveNoteId(noteId ?? null);\n  }, [noteId]);\n\n  // Load note when activeNoteId changes\n  // Uses refs for dependencies to avoid re-running on every render\n  const notesServiceRef = useRef(notesService);\n  notesServiceRef.current = notesService;\n  const defaultCourseCodeRef = useRef(defaultCourseCode);\n  defaultCourseCodeRef.current = defaultCourseCode;\n  const defaultSourceUrlRef = useRef(defaultSourceUrl);\n  defaultSourceUrlRef.current = defaultSourceUrl;\n  const sourceSelectionRef = useRef(sourceSelection);\n  sourceSelectionRef.current = sourceSelection;\n\n  useEffect(() => {\n    const targetId = activeNoteId;\n    const service = notesServiceRef.current;\n    const currentNote = noteRef.current;\n\n    if (targetId) {\n      clientNoteIdRef.current = targetId;\n    }\n\n    // Skip if we're already loading this note or it's already loaded\n    if (targetId === loadingNoteIdRef.current) {\n      return;\n    }\n    if (targetId === lastLoadedNoteIdRef.current && targetId !== null) {\n      return;\n    }\n\n    if (!targetId) {\n      loadingNoteIdRef.current = null;\n      lastLoadedNoteIdRef.current = null;\n      if (!currentNote || currentNote.id !== null) {\n        clientNoteIdRef.current = createClientNoteId();\n        const draftDefaults: {\n          courseCode?: string | null;\n          sourceUrl?: string | null;\n          sourceSelection?: string | null;\n        } = {};\n        if (defaultCourseCodeRef.current !== undefined) {\n          draftDefaults.courseCode = defaultCourseCodeRef.current;\n        }\n        if (defaultSourceUrlRef.current !== undefined) {\n          draftDefaults.sourceUrl = defaultSourceUrlRef.current;\n        }\n        if (sourceSelectionRef.current !== undefined) {\n          draftDefaults.sourceSelection = sourceSelectionRef.current;\n        }\n        const draft = createDraftNote(draftDefaults);\n        setNote(draft);\n        // Set fingerprint for the initial draft to prevent unnecessary save on first change\n        lastSavedFingerprintRef.current = createContentFingerprint(draft.title, draft.content);\n      }\n      setStatus('idle');\n      setIsLoading(false);\n      return;\n    }\n\n    if (!service) {\n      loadingNoteIdRef.current = null;\n      setIsLoading(false);\n      return;\n    }\n\n    loadingNoteIdRef.current = targetId;\n    setIsLoading(true);\n    setError(null);\n\n    let cancelled = false;\n\n    (async () => {\n      try {\n        const loaded = await service.getNote(targetId);\n        if (cancelled) return;\n\n        setNote(loaded);\n        lastSavedFingerprintRef.current = createContentFingerprint(loaded.title, loaded.content);\n        lastLoadedNoteIdRef.current = targetId;\n        setStatus('idle');\n      } catch (err: unknown) {\n        if (cancelled) return;\n        setError(getErrorMessage(err, 'Failed to load note'));\n        setStatus('error');\n      } finally {\n        if (!cancelled) {\n          loadingNoteIdRef.current = null;\n          setIsLoading(false);\n        }\n      }\n    })();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [activeNoteId, notesService]);\n\n  return {\n    note,\n    status,\n    error,\n    isLoading,\n    activeNoteId,\n    setActiveNoteId,\n    setNote,\n    setStatus,\n    setError,\n    setIsLoading,\n    noteRef,\n    clientNoteIdRef,\n    lastSavedFingerprintRef,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\useNoteAssets.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 6,
        "column": 31,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 6,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [286, 297], "text": "(err.message.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [286, 297], "text": "(err.message !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [286, 297], "text": "(Boolean(err.message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useNoteAssets' has too many lines (90). Maximum allowed is 50.",
        "line": 34,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 141,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 47,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 47,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1774, 1781], "text": "(noteId == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1775, 1781], "text": "(noteId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1774, 1781], "text": "(!Boolean(noteId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 47,
        "column": 21,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 47,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1785, 1810], "text": "((notesService?.listAssets) == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 88,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 88,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3077, 3084], "text": "noteId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3078, 3084], "text": "(noteId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3077, 3084], "text": "!Boolean(noteId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 92,
        "column": 12,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 92,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3189, 3215], "text": "(notesService?.uploadAsset) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 115,
        "column": 12,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 115,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3815, 3841], "text": "(notesService?.deleteAsset) == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useRef, useState } from 'react';\nimport type { NoteAsset } from '../../core/domain/Note.ts';\nimport type { NotesService } from '../../core/services/notesService.ts';\n\nfunction getErrorMessage(err: unknown, fallback: string): string {\n  if (err instanceof Error && err.message) return err.message;\n  if (typeof err === 'object' && err !== null) {\n    const record = err as Record<string, unknown>;\n    if (typeof record['message'] === 'string') return record['message'];\n  }\n  return fallback;\n}\n\nexport interface UseNoteAssetsResult {\n  noteAssets: NoteAsset[];\n  isLoading: boolean;\n  isUploading: boolean;\n  error: string | null;\n  uploadAsset: (file: File) => Promise<NoteAsset | null>;\n  deleteAsset: (assetId: string) => Promise<boolean>;\n  reloadAssets: () => Promise<void>;\n}\n\n/**\n * Hook for managing note assets (attachments).\n *\n * IMPORTANT: This hook does NOT auto-fetch assets on mount or when noteId changes.\n * Assets are only loaded when explicitly requested via `reloadAssets()`.\n * This prevents excessive API calls during autosave cycles.\n *\n * The hook includes request deduplication - if a request is already in progress\n * for the same noteId, subsequent calls will be ignored.\n */\nexport function useNoteAssets(\n  noteId: string | null | undefined,\n  notesService: NotesService | null | undefined,\n): UseNoteAssetsResult {\n  const [noteAssets, setNoteAssets] = useState<NoteAsset[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isUploading, setIsUploading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Track in-flight request to prevent duplicate requests\n  const loadingNoteIdRef = useRef<string | null>(null);\n\n  const loadAssets = useCallback(async () => {\n    if (!noteId || !notesService?.listAssets) {\n      setNoteAssets([]);\n      setIsLoading(false);\n      return;\n    }\n\n    // Prevent duplicate requests for the same noteId\n    if (loadingNoteIdRef.current === noteId) {\n      return;\n    }\n\n    loadingNoteIdRef.current = noteId;\n    setIsLoading(true);\n    setError(null);\n    setNoteAssets([]);\n\n    try {\n      const assets = await notesService.listAssets(noteId);\n      // Only update state if this is still the current request\n      if (loadingNoteIdRef.current === noteId) {\n        setNoteAssets(Array.isArray(assets) ? assets : []);\n      }\n    } catch (err: unknown) {\n      // Only update error if this is still the current request\n      if (loadingNoteIdRef.current === noteId) {\n        setError(getErrorMessage(err, 'Failed to load attachments'));\n      }\n    } finally {\n      // Only clear loading if this is still the current request\n      if (loadingNoteIdRef.current === noteId) {\n        setIsLoading(false);\n        loadingNoteIdRef.current = null;\n      }\n    }\n  }, [noteId, notesService]);\n\n  // Do not auto-fetch on mount; we only need assets when explicitly requested.\n  // This avoids piling up GET requests during autosave cycles.\n\n  const uploadAsset = useCallback(\n    async (file: File): Promise<NoteAsset | null> => {\n      if (!noteId) {\n        setError('Save the note before adding attachments.');\n        return null;\n      }\n      if (!notesService?.uploadAsset) {\n        setError('Upload is not available.');\n        return null;\n      }\n\n      setIsUploading(true);\n      setError(null);\n      try {\n        const asset = await notesService.uploadAsset(noteId, file);\n        setNoteAssets((prev) => [...prev, asset]);\n        return asset;\n      } catch (err: unknown) {\n        setError(getErrorMessage(err, 'Failed to upload attachment'));\n        return null;\n      } finally {\n        setIsUploading(false);\n      }\n    },\n    [noteId, notesService],\n  );\n\n  const deleteAsset = useCallback(\n    async (assetId: string): Promise<boolean> => {\n      if (!notesService?.deleteAsset) {\n        setError('Delete is not available.');\n        return false;\n      }\n\n      try {\n        await notesService.deleteAsset(assetId);\n        setNoteAssets((prev) => prev.filter((asset) => asset.id !== assetId));\n        return true;\n      } catch (err: unknown) {\n        setError(getErrorMessage(err, 'Failed to delete attachment'));\n        return false;\n      }\n    },\n    [notesService],\n  );\n\n  return {\n    noteAssets,\n    isLoading,\n    isUploading,\n    error,\n    uploadAsset,\n    deleteAsset,\n    reloadAssets: loadAssets,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\useNoteEditor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\useNoteSave.ts",
    "messages": [
      {
        "ruleId": "no-restricted-imports",
        "severity": 1,
        "message": "'../extension/notes/content' import is restricted from being used by a pattern. UI cannot import backend/extension/integrations code.",
        "line": 4,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "messageId": "patternWithCustomMessage",
        "endLine": 4,
        "endColumn": 77
      },
      {
        "ruleId": "no-restricted-imports",
        "severity": 1,
        "message": "'../extension/sidebar/types' import is restricted from being used by a pattern. UI cannot import backend/extension/integrations code.",
        "line": 5,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "messageId": "patternWithCustomMessage",
        "endLine": 5,
        "endColumn": 64
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useNoteSave' has too many lines (57). Maximum allowed is 50.",
        "line": 49,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 125,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 49,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 49,
        "endColumn": 28
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (24). Maximum allowed is 20.",
        "line": 58,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 120,
        "endColumn": 6
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Async arrow function has a complexity of 19. Maximum allowed is 15.",
        "line": 58,
        "column": 60,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 58,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 60,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 60,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1824, 1837], "text": "notesService == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 75,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 75,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2343, 2353], "text": "noteTitle == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2344, 2353], "text": "(noteTitle ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2343, 2353], "text": "!Boolean(noteTitle)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 77,
        "column": 69,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 77,
        "endColumn": 94,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2455, 2480], "text": "(options.content.plainText != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2455, 2480], "text": "(options.content.plainText ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2455, 2480], "text": "(Boolean(options.content.plainText))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 79,
        "column": 23,
        "nodeType": "CallExpression",
        "messageId": "conditionErrorString",
        "endLine": 79,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2580, 2602], "text": "(firstLine.slice(0, 50).length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2580, 2602], "text": "(firstLine.slice(0, 50) !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2580, 2602], "text": "(Boolean(firstLine.slice(0, 50)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 79,
        "column": 42,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 79,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 101,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 101,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3306, 3323], "text": "options.onSuccess != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 111,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableObject",
        "endLine": 111,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3636, 3651], "text": "options.onError != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback } from 'react';\nimport type { Note, NoteContent, NoteType } from '@core/domain/Note';\nimport type { NotesService } from '@core/services/notesService';\nimport { createNoteContentFromPlainText } from '../extension/notes/content';\nimport type { SidebarTabId } from '../extension/sidebar/types';\n\n/**\n * Options for saving a note\n */\nexport interface SaveNoteOptions {\n  /** Note content - plain text string or structured NoteContent */\n  content: string | NoteContent;\n  /** Optional title - defaults to first line or \"Untitled note\" */\n  title?: string;\n  /** Note type - defaults to 'manual' */\n  noteType?: NoteType;\n  /** Optional source selection text */\n  sourceSelection?: string | null;\n  /** Optional source URL - defaults to pageUrl */\n  sourceUrl?: string | null;\n  /** Optional course code - defaults to current course */\n  courseCode?: string | null;\n  /** Optional tags */\n  tags?: string[];\n  /** Success callback */\n  onSuccess?: (note: Note) => void;\n  /** Error callback */\n  onError?: (error: Error) => void;\n}\n\n/**\n * Dependencies required for note saving\n */\nexport interface UseNoteSaveOptions {\n  notesService: NotesService | null;\n  pageUrl: string | null;\n  courseCode: string | null;\n  upsertNote: (note: Note) => void;\n  setSelectedNoteId: (id: string | null) => void;\n  setActiveTab: (tab: SidebarTabId) => void;\n}\n\n/**\n * Custom hook for note saving logic\n *\n * Encapsulates all note saving functionality in a reusable hook.\n * Used internally by NoteSaveContext.\n */\nexport function useNoteSave({\n  notesService,\n  pageUrl,\n  courseCode,\n  upsertNote,\n  setSelectedNoteId,\n  setActiveTab,\n}: UseNoteSaveOptions) {\n  const saveNote = useCallback(\n    async (options: SaveNoteOptions): Promise<Note | null> => {\n      // Early return if notes service is not available\n      if (!notesService) {\n        console.warn('NotesService not available, switching to Notes tab');\n        setActiveTab('notes');\n        return null;\n      }\n\n      try {\n        // Convert content to NoteContent if it's a string\n        const noteContent: NoteContent =\n          typeof options.content === 'string'\n            ? createNoteContentFromPlainText(options.content.trim())\n            : options.content;\n\n        // Generate title from content if not provided\n        let noteTitle = options.title;\n        if (!noteTitle) {\n          const contentText =\n            typeof options.content === 'string' ? options.content : options.content.plainText || '';\n          const firstLine = contentText.split('\\n')[0]?.trim() ?? '';\n          noteTitle = firstLine.slice(0, 50) || 'Untitled note';\n        }\n\n        // Create the note\n        const createdNote = await notesService.createNote({\n          title: noteTitle,\n          content: noteContent,\n          sourceUrl: options.sourceUrl ?? pageUrl,\n          sourceSelection: options.sourceSelection ?? null,\n          courseCode: options.courseCode ?? courseCode ?? null,\n          noteType: options.noteType ?? 'manual',\n          tags: options.tags ?? [],\n        });\n\n        // Update note list and select the new note\n        upsertNote(createdNote);\n        setSelectedNoteId(createdNote.id);\n\n        // Navigate to Notes tab\n        setActiveTab('notes');\n\n        // Call success callback if provided\n        if (options.onSuccess) {\n          options.onSuccess(createdNote);\n        }\n\n        return createdNote;\n      } catch (error: unknown) {\n        const err = error instanceof Error ? error : new Error('Failed to save note');\n        console.error('Failed to save note:', err);\n\n        // Call error callback if provided\n        if (options.onError) {\n          options.onError(err);\n        }\n\n        // Still navigate to Notes tab on error\n        setActiveTab('notes');\n\n        return null;\n      }\n    },\n    [notesService, pageUrl, courseCode, upsertNote, setSelectedNoteId, setActiveTab],\n  );\n\n  return { saveNote };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\ui\\hooks\\useNotesList.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 17,
        "column": 30,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorString",
        "endLine": 17,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [657, 668], "text": "(err.message.length > 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [657, 668], "text": "(err.message !== \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [657, 668], "text": "(Boolean(err.message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 19,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 19,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [758, 765], "text": "message != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [758, 765], "text": "message ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [758, 765], "text": "Boolean(message)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useNotesList' has too many lines (133). Maximum allowed is 50.",
        "line": 33,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 214,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 33,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 33,
        "endColumn": 29
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 50.",
        "line": 34,
        "column": 33,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 34,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 44,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 44,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1530, 1543], "text": "notesService == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 68,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 68,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2292, 2304], "text": "(meta.message != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2292, 2304], "text": "(meta.message ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2292, 2304], "text": "(Boolean(meta.message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 89,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 89,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2920, 2933], "text": "(notesService == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 89,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 89,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [2937, 2944], "text": "(noteId.length === 0)" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [2937, 2944], "text": "(noteId === \"\")" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2937, 2944], "text": "(!Boolean(noteId))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 108,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 108,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3535, 3546], "text": "deletedNote != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 121,
        "column": 18,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 121,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4001, 4013], "text": "(meta.message != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4001, 4013], "text": "(meta.message ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4001, 4013], "text": "(Boolean(meta.message))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Async arrow function has too many statements (25). Maximum allowed is 20.",
        "line": 134,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 188,
        "endColumn": 6
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 135,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 135,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4401, 4414], "text": "notesService == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected string value in conditional. An explicit empty string check is required.",
        "line": 141,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorString",
        "endLine": 141,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "conditionFixCompareStringLength",
            "fix": { "range": [4574, 4581], "text": "noteId.length === 0" },
            "desc": "Change condition to check string's length (`value.length !== 0`)"
          },
          {
            "messageId": "conditionFixCompareEmptyString",
            "fix": { "range": [4574, 4581], "text": "noteId === \"\"" },
            "desc": "Change condition to check for empty string (`value !== \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4574, 4581], "text": "!Boolean(noteId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 155,
        "column": 40,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 155,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": { "range": [5038, 5049], "text": "(n.isStarred ?? false)" },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareFalse",
            "fix": { "range": [5037, 5049], "text": "n.isStarred === false" },
            "desc": "Change condition to check if false (`value === false`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable object value in conditional. An explicit null check is required.",
        "line": 169,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableObject",
        "endLine": 169,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5498, 5510], "text": "originalNote != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 181,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 181,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [6068, 6080], "text": "meta.message != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [6068, 6080], "text": "meta.message ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [6068, 6080], "text": "Boolean(meta.message)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 201,
        "column": 5,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 201,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [6505, 6505], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [6505, 6505], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 18,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useEffect, useRef, useState } from 'react';\nimport type { Note } from '../../core/domain/Note.ts';\nimport type { NotesService } from '../../core/services/notesService.ts';\n\ninterface UseNotesListOptions {\n  notesService: NotesService | null | undefined;\n  limit?: number;\n}\n\nfunction getErrorMeta(err: unknown): { code?: string; message?: string } {\n  const record = typeof err === 'object' && err !== null ? (err as Record<string, unknown>) : null;\n  const meta: { code?: string; message?: string } = {};\n  if (typeof record?.['code'] === 'string') {\n    meta.code = record['code'];\n  }\n  const message =\n    (err instanceof Error && err.message) ||\n    (typeof record?.['message'] === 'string' ? record['message'] : undefined);\n  if (message) {\n    meta.message = message;\n  }\n  return meta;\n}\n\n/**\n * Hook for managing the notes list.\n *\n * Includes request deduplication to prevent multiple concurrent requests\n * and skips requests if parameters haven't meaningfully changed.\n *\n * Provides optimistic updates for delete and star operations.\n */\nexport function useNotesList(options: UseNotesListOptions) {\n  const { notesService, limit = 50 } = options;\n  const [notes, setNotes] = useState<Note[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Track request state to prevent duplicates\n  const isRefreshingRef = useRef(false);\n  const lastParamsRef = useRef<string>('');\n\n  const refresh = useCallback(async () => {\n    if (!notesService) return;\n\n    // Create a fingerprint of current params (only limit matters now)\n    const paramsFingerprint = JSON.stringify({ limit });\n\n    // Skip if already refreshing with same params\n    if (isRefreshingRef.current && lastParamsRef.current === paramsFingerprint) {\n      return;\n    }\n\n    isRefreshingRef.current = true;\n    lastParamsRef.current = paramsFingerprint;\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      // Fetch ALL notes for the user (no courseCode/sourceUrl filters)\n      // Client-side filtering will handle course/starred filters\n      const list = await notesService.listNotes({\n        limit,\n      });\n      setNotes(list);\n    } catch (err: unknown) {\n      const meta = getErrorMeta(err);\n      setError(meta.message || 'Failed to load notes');\n    } finally {\n      setIsLoading(false);\n      isRefreshingRef.current = false;\n    }\n  }, [limit, notesService]);\n\n  const upsertNote = useCallback((note: Note) => {\n    setNotes((prev) => {\n      const filtered = prev.filter((item) => item.id !== note.id);\n      return [note, ...filtered];\n    });\n  }, []);\n\n  /**\n   * Delete a note with optimistic update.\n   * Removes the note from the list immediately, then calls the backend.\n   * If the backend call fails, the note is restored.\n   */\n  const deleteNote = useCallback(\n    async (noteId: string): Promise<void> => {\n      if (!notesService || !noteId) return;\n\n      // Store the note for potential rollback\n      let deletedNote: Note | undefined;\n      let deletedIndex: number = -1;\n\n      // Optimistic update: remove from list immediately\n      setNotes((prev) => {\n        deletedIndex = prev.findIndex((n) => n.id === noteId);\n        if (deletedIndex >= 0) {\n          deletedNote = prev[deletedIndex];\n        }\n        return prev.filter((n) => n.id !== noteId);\n      });\n\n      try {\n        await notesService.deleteNote(noteId);\n      } catch (err: unknown) {\n        // Rollback: restore the note if delete failed\n        if (deletedNote) {\n          setNotes((prev) => {\n            // Insert back at original position if possible\n            const newList = [...prev];\n            if (deletedIndex >= 0 && deletedIndex <= newList.length) {\n              newList.splice(deletedIndex, 0, deletedNote!);\n            } else {\n              newList.unshift(deletedNote!);\n            }\n            return newList;\n          });\n        }\n        const meta = getErrorMeta(err);\n        setError(meta.message || 'Failed to delete note');\n        throw err;\n      }\n    },\n    [notesService],\n  );\n\n  /**\n   * Toggle the starred status of a note with optimistic update.\n   * Updates the UI immediately, then syncs with the backend.\n   * If the backend call fails, the change is reverted.\n   */\n  const toggleStar = useCallback(\n    async (noteId: string): Promise<Note | undefined> => {\n      if (!notesService) {\n        const error = new Error('Notes service not available. Please try again.');\n        setError(error.message);\n        throw error;\n      }\n\n      if (!noteId) {\n        const error = new Error('Cannot star note: Note ID is missing');\n        setError(error.message);\n        throw error;\n      }\n\n      // Store the original state for potential rollback\n      let originalNote: Note | undefined;\n\n      // Optimistic update: toggle starred immediately\n      setNotes((prev) => {\n        return prev.map((n) => {\n          if (n.id === noteId) {\n            originalNote = n;\n            return { ...n, isStarred: !n.isStarred };\n          }\n          return n;\n        });\n      });\n\n      try {\n        const updated = await notesService.toggleStar(noteId);\n        // Update with the server response to ensure consistency\n        setNotes((prev) => prev.map((n) => (n.id === noteId ? updated : n)));\n        return updated;\n      } catch (err: unknown) {\n        const meta = getErrorMeta(err);\n        // Rollback: restore the original state if toggle failed\n        if (originalNote) {\n          setNotes((prev) => prev.map((n) => (n.id === noteId ? originalNote! : n)));\n        }\n\n        // Provide more specific error messages based on error type\n        let errorMessage = 'Failed to toggle star';\n        if (meta.code === 'AUTH_REQUIRED') {\n          errorMessage = 'Please sign in to star notes';\n        } else if (meta.code === 'NOT_FOUND') {\n          errorMessage = 'Note not found';\n        } else if (meta.code === 'NETWORK_ERROR') {\n          errorMessage = 'Network error. Please check your connection.';\n        } else if (meta.message) {\n          errorMessage = meta.message;\n        }\n\n        setError(errorMessage);\n        throw err;\n      }\n    },\n    [notesService],\n  );\n\n  /**\n   * Remove a note from the list without calling the backend.\n   * Useful when deletion is triggered elsewhere.\n   */\n  const removeFromList = useCallback((noteId: string) => {\n    setNotes((prev) => prev.filter((n) => n.id !== noteId));\n  }, []);\n\n  useEffect(() => {\n    refresh();\n  }, [refresh]);\n\n  return {\n    notes,\n    isLoading,\n    error,\n    refresh,\n    upsertNote,\n    deleteNote,\n    toggleStar,\n    removeFromList,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\vite.config.contentLibs.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\vite.config.extensionConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\vite.config.initApi.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\vite.config.messageSchemas.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\vite.config.sentry.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 29,
        "column": 30,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 29,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [917, 938], "text": "(env.SENTRY_AUTH_TOKEN != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [917, 938], "text": "(env.SENTRY_AUTH_TOKEN ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [917, 938], "text": "(Boolean(env.SENTRY_AUTH_TOKEN))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 29,
        "column": 55,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 29,
        "endColumn": 69,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [942, 956], "text": "(env.SENTRY_ORG != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [942, 956], "text": "(env.SENTRY_ORG ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [942, 956], "text": "(Boolean(env.SENTRY_ORG))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 35,
        "column": 57,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 35,
        "endColumn": 76,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1194, 1213], "text": "(env.VITE_SENTRY_DSN != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1194, 1213], "text": "(env.VITE_SENTRY_DSN ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1194, 1213], "text": "(Boolean(env.VITE_SENTRY_DSN))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 43,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 43,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 49,
        "column": 39,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 49,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1702, 1733], "text": "(process.env.npm_package_version != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1702, 1733], "text": "(process.env.npm_package_version ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1702, 1733], "text": "(Boolean(process.env.npm_package_version))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Vite config for building the Sentry module as an IIFE bundle.\n *\n * This bundle is loaded by:\n * - background.js (via importScripts)\n * - popup.html (via script tag)\n * - content scripts (via manifest.json)\n *\n * The DSN is injected at build time via VITE_SENTRY_DSN environment variable.\n * Source maps are uploaded to Sentry when SENTRY_AUTH_TOKEN is configured.\n */\n\nimport { defineConfig, loadEnv } from 'vite';\nimport { sentryVitePlugin } from '@sentry/vite-plugin';\nimport { resolve } from 'path';\nimport {\n  createAliases,\n  createDefines,\n  createIifeBuildConfig,\n  ensureAsciiSafeOutput,\n} from './build/viteShared';\n\nexport default defineConfig(({ mode }) => {\n  // Load environment variables from .env file\n  const env = loadEnv(mode, process.cwd(), '');\n\n  // Only upload source maps in production builds when Sentry auth is configured\n  const shouldUploadSourceMaps =\n    mode === 'production' && env.SENTRY_AUTH_TOKEN && env.SENTRY_ORG && env.SENTRY_PROJECT;\n\n  return {\n    define: {\n      ...createDefines(mode),\n      // Inject Sentry DSN at build time (required for service worker where import.meta doesn't work)\n      'import.meta.env.VITE_SENTRY_DSN': JSON.stringify(env.VITE_SENTRY_DSN || ''),\n    },\n    plugins: [\n      ensureAsciiSafeOutput(\n        resolve(process.cwd(), 'extension/dist/libs/sentry.js'),\n        'Processed Sentry bundle for ASCII compatibility',\n      ),\n      // Upload source maps to Sentry for readable stack traces\n      shouldUploadSourceMaps &&\n        sentryVitePlugin({\n          org: env.SENTRY_ORG,\n          project: env.SENTRY_PROJECT,\n          authToken: env.SENTRY_AUTH_TOKEN,\n          release: {\n            name: `lockin-extension@${process.env.npm_package_version || '1.0.0'}`,\n          },\n          sourcemaps: {\n            filesToDeleteAfterUpload: ['extension/dist/libs/sentry.js.map'],\n          },\n          telemetry: false,\n        }),\n    ].filter(Boolean),\n    build: {\n      ...createIifeBuildConfig({\n        outDir: 'extension/dist/libs',\n        entry: 'extension/src/sentry.ts',\n        name: 'LockInSentry',\n        fileName: 'sentry.js',\n        sourcemap: true,\n      }),\n      // Don't empty the output dir - other libs are there too\n      emptyOutDir: false,\n    },\n    resolve: {\n      alias: createAliases({ includeCore: false }),\n    },\n  };\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\vite.config.transcriptProviders.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\vite.config.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (53). Maximum allowed is 50.",
        "line": 13,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 75,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 24,
        "column": 30,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 24,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [868, 889], "text": "(env.SENTRY_AUTH_TOKEN != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [868, 889], "text": "(env.SENTRY_AUTH_TOKEN ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [868, 889], "text": "(Boolean(env.SENTRY_AUTH_TOKEN))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 24,
        "column": 55,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 24,
        "endColumn": 69,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [893, 907], "text": "(env.SENTRY_ORG != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [893, 907], "text": "(env.SENTRY_ORG ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [893, 907], "text": "(Boolean(env.SENTRY_ORG))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 50,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorOther",
        "endLine": 50,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 56,
        "column": 39,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 56,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1919, 1950], "text": "(process.env.npm_package_version != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1919, 1950], "text": "(process.env.npm_package_version ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1919, 1950], "text": "(Boolean(process.env.npm_package_version))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { defineConfig, loadEnv } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport { sentryVitePlugin } from '@sentry/vite-plugin';\nimport { resolve } from 'path';\nimport {\n  createAliases,\n  createDefines,\n  createIifeBuildConfig,\n  createOptionalDependencyAliases,\n  ensureAsciiSafeOutput,\n} from './build/viteShared';\n\nexport default defineConfig(({ mode }) => {\n  // Align NODE_ENV with Vite mode so React's JSX transform and runtime match.\n  // This must happen before the react plugin processes files.\n  const resolvedNodeEnv = mode === 'development' ? 'development' : 'production';\n  process.env.NODE_ENV = resolvedNodeEnv;\n\n  // Load environment variables\n  const env = loadEnv(mode, process.cwd(), '');\n\n  // Only upload source maps in production builds when Sentry auth is configured\n  const shouldUploadSourceMaps =\n    mode === 'production' && env.SENTRY_AUTH_TOKEN && env.SENTRY_ORG && env.SENTRY_PROJECT;\n\n  const baseAliases = createAliases({ includeApi: true, includeSharedUi: true });\n  const optionalAliases = createOptionalDependencyAliases();\n  const aliasEntries = [\n    ...optionalAliases,\n    ...Object.entries(baseAliases).map(([find, replacement]) => ({ find, replacement })),\n  ];\n\n  return {\n    define: createDefines(mode),\n    esbuild: {\n      jsxDev: mode === 'development',\n    },\n    css: {\n      postcss: './postcss.config.js',\n    },\n    plugins: [\n      react({\n        jsxRuntime: 'automatic',\n      }),\n      ensureAsciiSafeOutput(\n        resolve(process.cwd(), 'extension/dist/ui/index.js'),\n        'Processed output file for ASCII compatibility',\n      ),\n      // Upload source maps to Sentry for readable stack traces in production\n      shouldUploadSourceMaps &&\n        sentryVitePlugin({\n          org: env.SENTRY_ORG,\n          project: env.SENTRY_PROJECT,\n          authToken: env.SENTRY_AUTH_TOKEN,\n          release: {\n            name: `lockin-extension@${process.env.npm_package_version || '1.0.0'}`,\n          },\n          sourcemaps: {\n            // Upload source maps but delete them after (don't ship to users)\n            filesToDeleteAfterUpload: ['extension/dist/**/*.map'],\n          },\n          telemetry: false, // Disable Sentry's own telemetry\n        }),\n    ].filter(Boolean),\n    build: createIifeBuildConfig({\n      outDir: 'extension/dist/ui',\n      entry: 'ui/extension/index.tsx',\n      name: 'LockInUI',\n      fileName: 'index.js',\n    }),\n    resolve: {\n      alias: aliasEntries,\n    },\n  };\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\vite.config.webvttParser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\matth\\Lock-in\\vitest.config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
