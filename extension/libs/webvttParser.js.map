{"version":3,"file":"webvttParser.js","sources":["../../core/transcripts/webvttParser.ts"],"sourcesContent":["/**\r\n * WebVTT Parser\r\n * \r\n * Parses WebVTT format captions into structured segments.\r\n * Handles HTML entity decoding and common VTT variations.\r\n */\r\n\r\nimport type { TranscriptResult, TranscriptSegment } from './types';\r\n\r\n/**\r\n * Common HTML entities that appear in VTT captions\r\n */\r\nconst HTML_ENTITIES: Record<string, string> = {\r\n  '&#39;': \"'\",\r\n  '&#x27;': \"'\",\r\n  '&apos;': \"'\",\r\n  '&#34;': '\"',\r\n  '&#x22;': '\"',\r\n  '&quot;': '\"',\r\n  '&amp;': '&',\r\n  '&#38;': '&',\r\n  '&lt;': '<',\r\n  '&#60;': '<',\r\n  '&gt;': '>',\r\n  '&#62;': '>',\r\n  '&nbsp;': ' ',\r\n  '&#160;': ' ',\r\n  '&#8217;': '\\u2019', // Right single quote\r\n  '&#8216;': '\\u2018', // Left single quote\r\n  '&#8220;': '\\u201C', // Left double quote\r\n  '&#8221;': '\\u201D', // Right double quote\r\n  '&#8211;': '\\u2013', // En dash\r\n  '&#8212;': '\\u2014', // Em dash\r\n  '&#8230;': '\\u2026', // Ellipsis\r\n};\r\n\r\n/**\r\n * Decode HTML entities in text\r\n */\r\nexport function decodeHtmlEntities(text: string): string {\r\n  let result = text;\r\n  \r\n  // Replace named and numeric entities\r\n  for (const [entity, char] of Object.entries(HTML_ENTITIES)) {\r\n    result = result.split(entity).join(char);\r\n  }\r\n  \r\n  // Handle arbitrary numeric entities (&#NNN; or &#xHHH;)\r\n  result = result.replace(/&#(\\d+);/g, (_, code) => {\r\n    return String.fromCharCode(parseInt(code, 10));\r\n  });\r\n  \r\n  result = result.replace(/&#x([0-9a-fA-F]+);/g, (_, code) => {\r\n    return String.fromCharCode(parseInt(code, 16));\r\n  });\r\n  \r\n  return result;\r\n}\r\n\r\n/**\r\n * Parse a VTT timestamp into milliseconds\r\n * Formats: HH:MM:SS.mmm or MM:SS.mmm\r\n */\r\nexport function parseVttTimestamp(timestamp: string): number {\r\n  const parts = timestamp.trim().split(':');\r\n  \r\n  if (parts.length < 2 || parts.length > 3) {\r\n    return 0;\r\n  }\r\n  \r\n  let hours = 0;\r\n  let minutes: number;\r\n  let seconds: number;\r\n  \r\n  if (parts.length === 3) {\r\n    hours = parseInt(parts[0], 10) || 0;\r\n    minutes = parseInt(parts[1], 10) || 0;\r\n    seconds = parseFloat(parts[2]) || 0;\r\n  } else {\r\n    minutes = parseInt(parts[0], 10) || 0;\r\n    seconds = parseFloat(parts[1]) || 0;\r\n  }\r\n  \r\n  return Math.round((hours * 3600 + minutes * 60 + seconds) * 1000);\r\n}\r\n\r\n/**\r\n * Strip VTT formatting tags like <v>, <c>, <b>, etc.\r\n */\r\nfunction stripVttTags(text: string): string {\r\n  // Remove voice tags: <v Name>text</v>\r\n  let result = text.replace(/<v[^>]*>/gi, '').replace(/<\\/v>/gi, '');\r\n  \r\n  // Remove class tags: <c.classname>text</c>\r\n  result = result.replace(/<c[^>]*>/gi, '').replace(/<\\/c>/gi, '');\r\n  \r\n  // Remove other inline tags: <b>, <i>, <u>, <ruby>, <rt>, <lang>\r\n  result = result.replace(/<\\/?(?:b|i|u|ruby|rt|lang)[^>]*>/gi, '');\r\n  \r\n  return result.trim();\r\n}\r\n\r\n/**\r\n * Parse WebVTT content into structured segments\r\n * \r\n * @param vttContent - Raw VTT file content\r\n * @returns Parsed transcript with segments and plain text\r\n */\r\nexport function parseWebVtt(vttContent: string): TranscriptResult {\r\n  const lines = vttContent.split(/\\r?\\n/);\r\n  const segments: TranscriptSegment[] = [];\r\n  \r\n  let i = 0;\r\n  \r\n  // Skip WEBVTT header and any metadata\r\n  while (i < lines.length) {\r\n    const line = lines[i].trim();\r\n    if (line === '' || line.startsWith('WEBVTT') || line.startsWith('NOTE') || line.startsWith('STYLE')) {\r\n      i++;\r\n      // Skip multi-line NOTE/STYLE blocks\r\n      if (line.startsWith('NOTE') || line.startsWith('STYLE')) {\r\n        while (i < lines.length && lines[i].trim() !== '') {\r\n          i++;\r\n        }\r\n      }\r\n      continue;\r\n    }\r\n    break;\r\n  }\r\n  \r\n  // Parse cues\r\n  while (i < lines.length) {\r\n    const line = lines[i].trim();\r\n    \r\n    // Skip empty lines and cue identifiers (numeric or text before timestamp)\r\n    if (line === '') {\r\n      i++;\r\n      continue;\r\n    }\r\n    \r\n    // Check if this line is a timestamp line (contains -->)\r\n    const timestampMatch = line.match(/^(\\d{1,2}:\\d{2}(?::\\d{2})?(?:\\.\\d{1,3})?)\\s*-->\\s*(\\d{1,2}:\\d{2}(?::\\d{2})?(?:\\.\\d{1,3})?)/);\r\n    \r\n    if (!timestampMatch) {\r\n      // This might be a cue identifier, skip it\r\n      i++;\r\n      continue;\r\n    }\r\n    \r\n    const startMs = parseVttTimestamp(timestampMatch[1]);\r\n    const endMs = parseVttTimestamp(timestampMatch[2]);\r\n    \r\n    i++;\r\n    \r\n    // Collect cue text (may span multiple lines until empty line)\r\n    const textLines: string[] = [];\r\n    while (i < lines.length && lines[i].trim() !== '') {\r\n      textLines.push(lines[i]);\r\n      i++;\r\n    }\r\n    \r\n    if (textLines.length > 0) {\r\n      let text = textLines.join(' ');\r\n      text = stripVttTags(text);\r\n      text = decodeHtmlEntities(text);\r\n      text = text.replace(/\\s+/g, ' ').trim();\r\n      \r\n      if (text) {\r\n        segments.push({ startMs, endMs, text });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Build plain text version\r\n  const plainText = segments.map(s => s.text).join(' ');\r\n  \r\n  // Calculate duration from last segment\r\n  const durationMs = segments.length > 0 ? segments[segments.length - 1].endMs : 0;\r\n  \r\n  return {\r\n    plainText,\r\n    segments,\r\n    durationMs,\r\n  };\r\n}\r\n\r\n/**\r\n * Format segments back to VTT format\r\n */\r\nexport function formatAsVtt(segments: TranscriptSegment[]): string {\r\n  const lines: string[] = ['WEBVTT', ''];\r\n  \r\n  segments.forEach((segment, index) => {\r\n    lines.push(String(index + 1));\r\n    lines.push(`${formatVttTimestamp(segment.startMs)} --> ${formatVttTimestamp(segment.endMs)}`);\r\n    lines.push(segment.text);\r\n    lines.push('');\r\n  });\r\n  \r\n  return lines.join('\\n');\r\n}\r\n\r\n/**\r\n * Format milliseconds as VTT timestamp (HH:MM:SS.mmm)\r\n */\r\nfunction formatVttTimestamp(ms: number): string {\r\n  const totalSeconds = Math.floor(ms / 1000);\r\n  const hours = Math.floor(totalSeconds / 3600);\r\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\r\n  const seconds = totalSeconds % 60;\r\n  const millis = ms % 1000;\r\n  \r\n  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(millis).padStart(3, '0')}`;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}