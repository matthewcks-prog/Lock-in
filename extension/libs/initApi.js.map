{
  "version": 3,
  "sources": ["initApi.ts", "../../api/auth.ts", "../../api/client.ts", "chromeStorage.ts"],
  "sourcesContent": ["/**\r\n * Initialize API and Auth Clients for Extension\r\n * \r\n * This file wires together the Chrome-specific storage with the Chrome-agnostic\r\n * API and auth clients. It's the bridge between extension code and shared code.\r\n */\r\n\r\nimport { createAuthClient } from \"../../api/auth\";\r\nimport { createApiClient } from \"../../api/client\";\r\nimport { chromeStorage } from \"./chromeStorage\";\r\n\r\n/**\n * Get config from window (set by config.js)\n */\nexport function getConfig() {\n  const config = (typeof window !== \"undefined\" && (window as any).LOCKIN_CONFIG) || {};\n  return {\n    backendUrl: config.BACKEND_URL || \"http://localhost:3000\",\n    supabaseUrl: config.SUPABASE_URL || \"\",\n    supabaseAnonKey: config.SUPABASE_ANON_KEY || \"\",\n    sessionStorageKey: config.SESSION_STORAGE_KEY || \"lockinSupabaseSession\",\r\n    tokenExpiryBufferMs: Number(config.TOKEN_EXPIRY_BUFFER_MS) || 60000,\r\n  };\r\n}\r\n\r\n/**\r\n * Initialize auth client\r\n */\r\nexport function initAuthClient() {\r\n  const config = getConfig();\r\n  return createAuthClient(\r\n    {\r\n      supabaseUrl: config.supabaseUrl,\r\n      supabaseAnonKey: config.supabaseAnonKey,\r\n      sessionStorageKey: config.sessionStorageKey,\r\n      tokenExpiryBufferMs: config.tokenExpiryBufferMs,\r\n    },\r\n    chromeStorage\r\n  );\r\n}\r\n\r\n/**\r\n * Initialize API client\r\n */\r\nexport function initApiClient(authClient: ReturnType<typeof initAuthClient>) {\r\n  const config = getConfig();\r\n  return createApiClient({\r\n    backendUrl: config.backendUrl,\r\n    authClient,\r\n  });\r\n}\r\n\r\n/**\r\n * Initialize both clients and expose globally for backward compatibility\r\n */\r\nlet cachedClients: { authClient: ReturnType<typeof initAuthClient>; apiClient: ReturnType<typeof initApiClient> } | null =\r\n  null;\r\n\r\nexport function initClients() {\r\n  if (cachedClients) {\r\n    return cachedClients;\r\n  }\r\n\r\n  const authClient = initAuthClient();\r\n  const apiClient = initApiClient(authClient);\r\n\r\n  cachedClients = { authClient, apiClient };\r\n\r\n  // Expose globally for backward compatibility with existing code\r\n  if (typeof window !== \"undefined\") {\r\n    (window as any).LockInAuth = authClient;\r\n    (window as any).LockInAPI = apiClient;\r\n  }\r\n\r\n  return cachedClients;\n}\n\n// Auto-initialize when running in the extension/page context\nif (typeof window !== \"undefined\") {\n  initClients();\n  (window as any).LockInInit = {\n    getConfig,\n    initAuthClient,\n    initApiClient,\n    initClients,\n  };\n}\n", "/**\r\n * Supabase Auth Client\r\n * \r\n * Chrome-agnostic authentication client for Supabase.\r\n * Uses storage interface abstraction - no Chrome dependencies.\r\n */\r\n\r\nimport type { StorageInterface } from \"../core/storage/storageInterface\";\r\nimport type { AuthSession, AuthUser } from \"../core/domain/types\";\r\n\r\nexport interface AuthConfig {\r\n  supabaseUrl: string;\r\n  supabaseAnonKey: string;\r\n  sessionStorageKey?: string;\r\n  tokenExpiryBufferMs?: number;\r\n}\r\n\r\nexport interface AuthClient {\r\n  signUpWithEmail(email: string, password: string): Promise<AuthSession>;\r\n  signInWithEmail(email: string, password: string): Promise<AuthSession>;\r\n  signOut(): Promise<void>;\r\n  getSession(): Promise<AuthSession | null>;\r\n  getCurrentUser(): Promise<AuthUser | null>;\r\n  getValidAccessToken(): Promise<string | null>;\r\n  getAccessToken(): Promise<string | null>;\r\n  onSessionChanged(callback: (session: AuthSession | null) => void): () => void;\r\n}\r\n\r\n/**\r\n * Create auth error with code\r\n */\r\nfunction createAuthError(message: string, code: string = \"AUTH_ERROR\", details?: any): Error {\r\n  const error = new Error(message || \"Authentication failed\");\r\n  (error as any).code = code;\r\n  if (details) {\r\n    (error as any).details = details;\r\n  }\r\n  return error;\r\n}\r\n\r\n/**\r\n * Parse error response from Supabase\r\n */\r\nasync function parseErrorResponse(response: Response, fallbackMessage: string): Promise<{ message: string; code: string; details?: any }> {\r\n  let payload: any = null;\r\n  try {\r\n    payload = await response.json();\r\n  } catch (_) {\r\n    try {\r\n      const text = await response.text();\r\n      if (text) {\r\n        payload = { message: text };\r\n      }\r\n    } catch (_) {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  const message =\r\n    payload?.error_description ||\r\n    payload?.error ||\r\n    payload?.message ||\r\n    fallbackMessage;\r\n  const normalized = (message || \"\").toLowerCase();\r\n\r\n  let code = \"AUTH_ERROR\";\r\n  if (normalized.includes(\"already registered\")) {\r\n    code = \"USER_ALREADY_REGISTERED\";\r\n  } else if (normalized.includes(\"invalid login\")) {\r\n    code = \"INVALID_LOGIN\";\r\n  } else if (normalized.includes(\"email not confirmed\")) {\r\n    code = \"EMAIL_NOT_CONFIRMED\";\r\n  } else if (normalized.includes(\"invalid email\")) {\r\n    code = \"INVALID_EMAIL\";\r\n  }\r\n\r\n  return { message, code, details: payload };\r\n}\r\n\r\n/**\r\n * Normalize Supabase session data\r\n */\r\nfunction normalizeSession(data: any, fallbackUser: AuthUser | null = null): AuthSession {\r\n  if (!data?.access_token || !data?.refresh_token) {\r\n    throw new Error(\"Supabase session payload missing tokens\");\r\n  }\r\n\r\n  const expiresIn = Number(data.expires_in) || 3600;\r\n  const expiresAt = Date.now() + expiresIn * 1000;\r\n\r\n  return {\r\n    accessToken: data.access_token,\r\n    refreshToken: data.refresh_token,\r\n    expiresAt,\r\n    tokenType: data.token_type || \"bearer\",\r\n    user: data.user || fallbackUser || null,\r\n  };\r\n}\r\n\r\n/**\r\n * Create Supabase auth client\r\n */\r\nexport function createAuthClient(config: AuthConfig, storage: StorageInterface): AuthClient {\r\n  const {\r\n    supabaseUrl,\r\n    supabaseAnonKey,\r\n    sessionStorageKey = \"lockinSupabaseSession\",\r\n    tokenExpiryBufferMs = 60000,\r\n  } = config;\r\n\r\n  const listeners = new Set<(session: AuthSession | null) => void>();\r\n\r\n  function assertConfig(): void {\r\n    if (!supabaseUrl || !supabaseAnonKey) {\r\n      throw new Error(\"Supabase URL or anon key is not configured\");\r\n    }\r\n  }\r\n\r\n  async function readStorage(): Promise<AuthSession | null> {\r\n    try {\r\n      const data = await storage.get(sessionStorageKey);\r\n      return data[sessionStorageKey] || null;\r\n    } catch (error) {\r\n      console.error(\"Lock-in auth storage read error:\", error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async function writeStorage(session: AuthSession): Promise<void> {\r\n    try {\r\n      await storage.set({ [sessionStorageKey]: session });\r\n    } catch (error) {\r\n      console.error(\"Lock-in auth storage write error:\", error);\r\n    }\r\n  }\r\n\r\n  async function clearStorage(): Promise<void> {\r\n    try {\r\n      await storage.remove(sessionStorageKey);\r\n    } catch (error) {\r\n      console.error(\"Lock-in auth storage clear error:\", error);\r\n    }\r\n  }\r\n\r\n  function notify(session: AuthSession | null): void {\r\n    listeners.forEach((cb) => {\r\n      try {\r\n        cb(session);\r\n      } catch (error) {\r\n        console.error(\"Lock-in auth listener error:\", error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async function signInWithEmail(email: string, password: string): Promise<AuthSession> {\r\n    assertConfig();\r\n\r\n    const response = await fetch(`${supabaseUrl}/auth/v1/token?grant_type=password`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        apikey: supabaseAnonKey,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ email, password }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const parsed = await parseErrorResponse(response, \"Failed to sign in\");\r\n      throw createAuthError(parsed.message, parsed.code, parsed.details);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const session = normalizeSession(data);\r\n    await writeStorage(session);\r\n    notify(session);\r\n    return session;\r\n  }\r\n\r\n  async function signUpWithEmail(email: string, password: string): Promise<AuthSession> {\r\n    assertConfig();\r\n\r\n    const response = await fetch(`${supabaseUrl}/auth/v1/signup`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        apikey: supabaseAnonKey,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ email, password }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const parsed = await parseErrorResponse(response, \"Failed to create account\");\r\n      throw createAuthError(parsed.message, parsed.code, parsed.details);\r\n    }\r\n\r\n    const data = await response.json();\r\n\r\n    if (!data?.access_token || !data?.refresh_token) {\r\n      throw createAuthError(\r\n        \"Check your email to confirm your account, then sign in.\",\r\n        \"EMAIL_CONFIRMATION_REQUIRED\",\r\n        data\r\n      );\r\n    }\r\n\r\n    const session = normalizeSession(data);\r\n    await writeStorage(session);\r\n    notify(session);\r\n    return session;\r\n  }\r\n\r\n  async function refreshSession(refreshToken: string, existingUser: AuthUser | null = null): Promise<AuthSession> {\r\n    assertConfig();\r\n\r\n    if (!refreshToken) {\r\n      throw new Error(\"Missing refresh token\");\r\n    }\r\n\r\n    const response = await fetch(`${supabaseUrl}/auth/v1/token?grant_type=refresh_token`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        apikey: supabaseAnonKey,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ refresh_token: refreshToken }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      await clearStorage();\r\n      let errorMessage = \"Failed to refresh session\";\r\n      try {\r\n        const errorBody = await response.json();\r\n        errorMessage = errorBody?.error_description || errorBody?.message || errorMessage;\r\n      } catch (_) {\r\n        // ignore parse errors\r\n      }\r\n      throw new Error(errorMessage);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const session = normalizeSession(\r\n      { ...data, refresh_token: data.refresh_token || refreshToken },\r\n      existingUser\r\n    );\r\n    await writeStorage(session);\r\n    notify(session);\r\n    return session;\r\n  }\r\n\r\n  async function getSession(): Promise<AuthSession | null> {\r\n    return readStorage();\r\n  }\r\n\r\n  async function getValidAccessToken(): Promise<string | null> {\r\n    const session = await readStorage();\r\n    if (!session) {\r\n      return null;\r\n    }\r\n\r\n    const expiresAt = Number(session.expiresAt) || 0;\r\n    const buffer = tokenExpiryBufferMs;\r\n    if (expiresAt - buffer > Date.now()) {\r\n      return session.accessToken;\r\n    }\r\n\r\n    try {\r\n      const refreshed = await refreshSession(session.refreshToken, session.user);\r\n      return refreshed.accessToken;\r\n    } catch (error) {\r\n      console.error(\"Lock-in token refresh failed:\", (error as Error).message);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async function getCurrentUser(): Promise<AuthUser | null> {\r\n    const session = await getSession();\r\n    return session?.user || null;\r\n  }\r\n\r\n  async function signOut(): Promise<void> {\r\n    await clearStorage();\r\n    notify(null);\r\n  }\r\n\r\n  function onSessionChanged(callback: (session: AuthSession | null) => void): () => void {\r\n    if (typeof callback !== \"function\") {\r\n      return () => {};\r\n    }\r\n    listeners.add(callback);\r\n    return () => listeners.delete(callback);\r\n  }\r\n\r\n  // Listen to storage changes\r\n  storage.onChanged((changes, areaName) => {\r\n    if (areaName === \"sync\" && changes[sessionStorageKey]) {\r\n      notify(changes[sessionStorageKey].newValue || null);\r\n    }\r\n  });\r\n\r\n  return {\r\n    signUpWithEmail,\r\n    signInWithEmail,\r\n    signOut,\r\n    getSession,\r\n    getCurrentUser,\r\n    getValidAccessToken,\r\n    getAccessToken: getValidAccessToken,\r\n    onSessionChanged,\r\n  };\r\n}\r\n", "/**\r\n * API Client for Lock-in\r\n * \r\n * Chrome-agnostic API client for backend communication.\r\n * Uses auth client interface - no direct Chrome dependencies.\r\n */\r\n\r\nimport type { StudyResponse, ApiResponse, ChatMessage } from \"../core/domain/types\";\r\nimport type { AuthClient } from \"./auth\";\r\n\r\nexport interface ApiClientConfig {\r\n  backendUrl: string;\r\n  authClient: AuthClient;\r\n}\r\n\r\nexport interface ProcessTextParams {\r\n  selection: string;\r\n  mode: \"explain\" | \"simplify\" | \"translate\" | \"general\";\r\n  targetLanguage?: string;\r\n  difficultyLevel?: \"highschool\" | \"university\";\r\n  chatHistory?: ChatMessage[];\r\n  newUserMessage?: string;\r\n  chatId?: string;\r\n  pageContext?: string;\r\n  pageUrl?: string;\r\n  courseCode?: string;\r\n  language?: string;\r\n}\r\n\r\nexport interface ListNotesParams {\r\n  sourceUrl?: string;\r\n  courseCode?: string;\r\n  limit?: number;\r\n}\r\n\r\nexport interface SearchNotesParams {\r\n  query: string;\r\n  courseCode?: string;\r\n  k?: number;\r\n}\r\n\r\nexport interface ChatWithNotesParams {\r\n  query: string;\r\n  courseCode?: string;\r\n  k?: number;\r\n}\r\n\r\nexport interface UploadNoteAssetParams {\r\n  noteId: string;\r\n  file: File | Blob;\r\n}\r\n\r\nexport interface ListNoteAssetsParams {\r\n  noteId: string;\r\n}\r\n\r\nexport interface DeleteNoteAssetParams {\r\n  assetId: string;\r\n}\r\n\r\n/**\r\n * Create API error from response\r\n */\r\nasync function createApiError(response: Response, originalError: Error | null = null): Promise<Error> {\r\n  let errorMessage = \"API request failed\";\r\n  let errorCode = \"API_ERROR\";\r\n\r\n  try {\r\n    const errorBody = await response.json();\r\n    errorMessage =\r\n      errorBody?.error?.message ||\r\n      errorBody?.message ||\r\n      (typeof errorBody?.error === \"string\" ? errorBody.error : null) ||\r\n      errorMessage;\r\n\r\n    // Map status codes to error codes\r\n    if (response.status === 401 || response.status === 403) {\r\n      errorCode = \"AUTH_REQUIRED\";\r\n    } else if (response.status === 429) {\r\n      errorCode = \"RATE_LIMIT\";\r\n    } else if (response.status === 400) {\r\n      errorCode = \"BAD_REQUEST\";\r\n    } else if (response.status >= 500) {\r\n      errorCode = \"SERVER_ERROR\";\r\n    }\r\n  } catch (_) {\r\n    // If JSON parsing fails, try text\r\n    try {\r\n      const text = await response.text();\r\n      if (text) {\r\n        errorMessage = text;\r\n      }\r\n    } catch (_) {\r\n      // Ignore\r\n    }\r\n  }\r\n\r\n  const error = new Error(errorMessage);\r\n  (error as any).code = errorCode;\r\n  (error as any).status = response.status;\r\n  if (originalError) {\r\n    (error as any).cause = originalError;\r\n  }\r\n  return error;\r\n}\r\n\r\n/**\r\n * Create API client\r\n */\nexport function createApiClient(config: ApiClientConfig) {\n  const { backendUrl, authClient } = config;\n  const clientConfig = { backendUrl };\n\r\n  /**\r\n   * Make an authenticated API request\r\n   */\r\n  async function apiRequest<T = any>(\r\n    endpoint: string,\r\n    options: RequestInit & { signal?: AbortSignal } = {}\r\n  ): Promise<T> {\r\n    const url = endpoint.startsWith(\"http\") ? endpoint : `${backendUrl}${endpoint}`;\r\n\r\n    // Check if request was aborted before starting\r\n    if (options.signal?.aborted) {\r\n      const error = new Error(\"Request was aborted\");\r\n      (error as any).code = \"ABORTED\";\r\n      throw error;\r\n    }\r\n\r\n    // Get access token\r\n    const accessToken = await authClient.getValidAccessToken();\r\n    if (!accessToken) {\r\n      const error = new Error(\"Please sign in via the Lock-in popup before using the assistant.\");\r\n      (error as any).code = \"AUTH_REQUIRED\";\r\n      throw error;\r\n    }\r\n\r\n    // Check again after async operation\r\n    if (options.signal?.aborted) {\r\n      const error = new Error(\"Request was aborted\");\r\n      (error as any).code = \"ABORTED\";\r\n      throw error;\r\n    }\r\n\r\n    // Prepare headers\r\n    const isFormData = typeof FormData !== \"undefined\" && options.body instanceof FormData;\r\n    const headers: HeadersInit = {\r\n      Authorization: `Bearer ${accessToken}`,\r\n      ...(isFormData ? {} : { \"Content-Type\": \"application/json\" }),\r\n      ...(options.headers || {}),\r\n    };\r\n\r\n    // Prepare request (include signal for cancellation)\r\n    const requestOptions: RequestInit = {\r\n      ...options,\r\n      headers,\r\n      signal: options.signal,\r\n    };\r\n\r\n    // Make request\r\n    let response: Response;\r\n    try {\r\n      response = await fetch(url, requestOptions);\r\n    } catch (networkError: any) {\r\n      // Check if error is due to abort\r\n      if (networkError.name === \"AbortError\" || options.signal?.aborted) {\r\n        const error = new Error(\"Request was aborted\");\r\n        (error as any).code = \"ABORTED\";\r\n        throw error;\r\n      }\r\n      const error = new Error(\"Unable to reach Lock-in. Please check your connection.\");\r\n      (error as any).code = \"NETWORK_ERROR\";\r\n      (error as any).cause = networkError;\r\n      throw error;\r\n    }\r\n\r\n    // Handle auth errors\r\n    if (response.status === 401 || response.status === 403) {\r\n      // Try to sign out if auth fails\r\n      await authClient.signOut().catch(() => {\r\n        // Ignore sign-out errors\r\n      });\r\n    }\r\n\r\n    // Handle HTTP errors\r\n    if (!response.ok) {\r\n      throw await createApiError(response);\r\n    }\r\n\r\n    // Parse and return response\r\n    try {\r\n      const data = await response.json();\r\n      // Check for success: false in response body (even if HTTP status is 200)\r\n      if (data && data.success === false) {\r\n        const error = new Error(data.error?.message || \"Request failed\");\r\n        (error as any).code = data.error?.code || \"API_ERROR\";\r\n        throw error;\r\n      }\r\n      return data;\r\n    } catch (parseError) {\r\n      // If it's already an Error we threw, re-throw it\r\n      if (parseError instanceof Error && (parseError as any).code) {\r\n        throw parseError;\r\n      }\r\n      const error = new Error(\"Failed to parse API response\");\r\n      (error as any).code = \"PARSE_ERROR\";\r\n      (error as any).cause = parseError;\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process text with Lock-in AI\r\n   */\r\n  async function processText(params: ProcessTextParams): Promise<ApiResponse<StudyResponse>> {\r\n    const {\r\n      selection,\r\n      mode,\r\n      targetLanguage = \"en\",\r\n      difficultyLevel = \"highschool\",\r\n      chatHistory = [],\r\n      newUserMessage,\r\n      chatId,\r\n      pageContext,\r\n      pageUrl,\r\n      courseCode,\r\n      language = \"en\",\r\n    } = params;\r\n\r\n    // Normalize chat history\r\n    const normalizedHistory = (Array.isArray(chatHistory) ? chatHistory : [])\r\n      .filter(\r\n        (message) =>\r\n          message &&\r\n          typeof message.role === \"string\" &&\r\n          typeof message.content === \"string\"\r\n      )\r\n      .map((message) => ({\r\n        role: message.role,\r\n        content: message.content,\r\n      }));\r\n\r\n    const body: any = {\r\n      selection: selection || \"\",\r\n      mode,\r\n      targetLanguage,\r\n      difficultyLevel,\r\n      chatHistory: normalizedHistory,\r\n    };\r\n\r\n    if (newUserMessage) body.newUserMessage = newUserMessage;\r\n    if (chatId) body.chatId = chatId;\r\n    if (pageContext) body.pageContext = pageContext;\r\n    if (pageUrl) body.pageUrl = pageUrl;\r\n    if (courseCode) body.courseCode = courseCode;\r\n    if (language) body.language = language;\r\n\r\n    return apiRequest<ApiResponse<StudyResponse>>(\"/api/lockin\", {\r\n      method: \"POST\",\r\n      body: JSON.stringify(body),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get recent chats\r\n   */\r\n  async function getRecentChats(params: { limit?: number } = {}): Promise<any[]> {\r\n    const { limit = 10 } = params;\r\n    const queryParams = new URLSearchParams();\r\n    if (limit) {\r\n      queryParams.set(\"limit\", String(limit));\r\n    }\r\n\r\n    const endpoint = `/api/chats${queryParams.toString() ? `?${queryParams.toString()}` : \"\"}`;\r\n    return apiRequest<any[]>(endpoint, {\r\n      method: \"GET\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get messages for a chat\r\n   */\r\n  async function getChatMessages(chatId: string): Promise<any[]> {\r\n    if (!chatId) {\r\n      throw new Error(\"Chat ID is required\");\r\n    }\r\n\r\n    return apiRequest<any[]>(`/api/chats/${chatId}/messages`, {\r\n      method: \"GET\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete a chat\r\n   */\r\n  async function deleteChat(chatId: string): Promise<void> {\r\n    if (!chatId) {\r\n      throw new Error(\"Chat ID is required\");\r\n    }\r\n\r\n    return apiRequest<void>(`/api/chats/${chatId}`, {\r\n      method: \"DELETE\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create a new note\r\n   */\r\n  async function createNote(\r\n    note: {\r\n      title: string;\r\n      content: string;\r\n      sourceSelection?: string;\r\n      sourceUrl?: string;\r\n      courseCode?: string | null;\r\n      noteType?: string;\r\n      tags?: string[];\r\n    },\r\n    options?: { signal?: AbortSignal }\r\n  ): Promise<any> {\r\n    return apiRequest<any>(\"/api/notes\", {\r\n      method: \"POST\",\r\n      body: JSON.stringify(note),\r\n      signal: options?.signal,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update an existing note\r\n   */\r\n  async function updateNote(\r\n    noteId: string,\r\n    note: {\r\n      title?: string;\r\n      content?: string;\r\n      sourceSelection?: string;\r\n      sourceUrl?: string;\r\n      courseCode?: string | null;\r\n      noteType?: string;\r\n      tags?: string[];\r\n    },\r\n    options?: { signal?: AbortSignal }\r\n  ): Promise<any> {\r\n    if (!noteId) {\r\n      throw new Error(\"noteId is required to update a note\");\r\n    }\r\n    return apiRequest<any>(\r\n      `/api/notes/${noteId}`,\r\n      {\r\n        method: \"PUT\",\r\n        body: JSON.stringify(note),\r\n        signal: options?.signal,\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Delete a note\r\n   */\r\n  async function deleteNote(noteId: string): Promise<void> {\r\n    if (!noteId) {\r\n      throw new Error(\"noteId is required to delete a note\");\r\n    }\r\n    return apiRequest<void>(`/api/notes/${noteId}`, {\r\n      method: \"DELETE\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * List notes with optional filters\r\n   */\r\n  async function listNotes(params: ListNotesParams = {}): Promise<any[]> {\r\n    const { sourceUrl, courseCode, limit = 50 } = params;\r\n    const queryParams = new URLSearchParams();\r\n    if (sourceUrl) queryParams.set(\"sourceUrl\", sourceUrl);\r\n    if (courseCode) queryParams.set(\"courseCode\", courseCode);\r\n    if (limit) queryParams.set(\"limit\", String(limit));\r\n\r\n    const endpoint = `/api/notes${queryParams.toString() ? `?${queryParams.toString()}` : \"\"}`;\r\n    return apiRequest<any[]>(endpoint, {\r\n      method: \"GET\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Search notes by semantic similarity\r\n   */\r\n  async function searchNotes(params: SearchNotesParams): Promise<any[]> {\r\n    const { query, courseCode, k = 10 } = params;\r\n    const queryParams = new URLSearchParams({ q: query, k: String(k) });\r\n    if (courseCode) queryParams.set(\"courseCode\", courseCode);\r\n\r\n    return apiRequest<any[]>(`/api/notes/search?${queryParams.toString()}`, {\r\n      method: \"GET\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Chat with notes using semantic search\r\n   */\r\n  async function chatWithNotes(params: ChatWithNotesParams): Promise<{ answer: string; usedNotes: any[] }> {\r\n    return apiRequest<{ answer: string; usedNotes: any[] }>(\"/api/notes/chat\", {\r\n      method: \"POST\",\r\n      body: JSON.stringify({ query: params.query, courseCode: params.courseCode, k: params.k }),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Upload an asset for a note\r\n   */\r\n  async function uploadNoteAsset(params: UploadNoteAssetParams): Promise<any> {\r\n    const { noteId, file } = params;\r\n    if (!noteId) {\r\n      throw new Error(\"noteId is required to upload an asset\");\r\n    }\r\n    if (!file) {\r\n      throw new Error(\"file is required to upload an asset\");\r\n    }\r\n\r\n    const formData = new FormData();\r\n    formData.append(\"file\", file);\r\n\r\n    return apiRequest<any>(`/api/notes/${noteId}/assets`, {\r\n      method: \"POST\",\r\n      body: formData,\r\n      // Let the browser set Content-Type with boundary\r\n    });\r\n  }\r\n\r\n  /**\r\n   * List assets for a note\r\n   */\r\n  async function listNoteAssets(params: ListNoteAssetsParams): Promise<any[]> {\r\n    const { noteId } = params;\r\n    if (!noteId) {\r\n      throw new Error(\"noteId is required to list assets\");\r\n    }\r\n\r\n    return apiRequest<any[]>(`/api/notes/${noteId}/assets`, {\r\n      method: \"GET\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete a note asset\r\n   */\r\n  async function deleteNoteAsset(params: DeleteNoteAssetParams): Promise<void> {\n    const { assetId } = params;\n    if (!assetId) {\n      throw new Error(\"assetId is required to delete an asset\");\n    }\n\r\n    return apiRequest<void>(`/api/note-assets/${assetId}`, {\r\n      method: \"DELETE\",\n    });\n  }\n\n  /**\n   * Get backend URL used by this client\n   */\n  function getBackendUrl(): string {\n    return clientConfig.backendUrl;\n  }\n\n  return {\n    apiRequest,\n    getBackendUrl,\n    processText,\n    getRecentChats,\n    getChatMessages,\n    deleteChat,\n    createNote,\n    updateNote,\r\n    deleteNote,\r\n    listNotes,\r\n    searchNotes,\r\n    chatWithNotes,\r\n    uploadNoteAsset,\r\n    listNoteAssets,\r\n    deleteNoteAsset,\r\n  };\r\n}\r\n\r\n/**\r\n * Type for the API client returned by createApiClient\r\n */\r\nexport type ApiClient = ReturnType<typeof createApiClient>;\r\n", "/**\r\n * Chrome Storage Implementation\r\n * \r\n * Implements StorageInterface using chrome.storage APIs.\r\n * This is the extension-specific implementation.\r\n */\r\n\r\nimport type { StorageInterface, LocalStorageInterface } from \"../../core/storage/storageInterface\";\r\n\r\n/**\r\n * Chrome storage implementation for sync storage\r\n */\r\nexport class ChromeStorage implements StorageInterface {\r\n  async get<T = any>(key: string | string[]): Promise<Record<string, T>> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.sync.get(key, (data) => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve(data as Record<string, T>);\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async set(data: Record<string, any>): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.sync.set(data, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve();\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async remove(keys: string | string[]): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.sync.remove(keys, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve();\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  onChanged(\r\n    callback: (changes: Record<string, { oldValue?: any; newValue?: any }>, areaName: string) => void\r\n  ): () => void {\r\n    const listener = (changes: chrome.storage.StorageChange, areaName: chrome.storage.StorageArea) => {\r\n      const normalizedChanges: Record<string, { oldValue?: any; newValue?: any }> = {};\r\n      for (const [key, change] of Object.entries(changes)) {\r\n        normalizedChanges[key] = {\r\n          oldValue: change.oldValue,\r\n          newValue: change.newValue,\r\n        };\r\n      }\r\n      callback(normalizedChanges, areaName as unknown as string);\r\n    };\r\n\r\n    chrome.storage.onChanged.addListener(listener as any);\r\n\r\n    return () => {\r\n      chrome.storage.onChanged.removeListener(listener as any);\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Chrome local storage implementation\r\n */\r\nexport class ChromeLocalStorage implements LocalStorageInterface {\r\n  async get<T = any>(key: string | string[]): Promise<Record<string, T>> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.local.get(key, (data) => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve(data as Record<string, T>);\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async set(data: Record<string, any>): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.local.set(data, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve();\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async remove(keys: string | string[]): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.local.remove(keys, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve();\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// Export singleton instances\r\nexport const chromeStorage = new ChromeStorage();\r\nexport const chromeLocalStorage = new ChromeLocalStorage();\r\n"],
  "mappings": "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",
  "names": ["_", "_", "error"]
}
