{"version":3,"file":"initApi.js","sources":["../../api/auth.ts","../../api/client.ts","chromeStorage.ts","initApi.ts"],"sourcesContent":["/**\r\n * Supabase Auth Client\r\n * \r\n * Chrome-agnostic authentication client for Supabase.\r\n * Uses storage interface abstraction - no Chrome dependencies.\r\n */\r\n\r\nimport type { StorageInterface } from \"../core/storage/storageInterface\";\r\nimport type { AuthSession, AuthUser } from \"../core/domain/types\";\r\n\r\nexport interface AuthConfig {\r\n  supabaseUrl: string;\r\n  supabaseAnonKey: string;\r\n  sessionStorageKey?: string;\r\n  tokenExpiryBufferMs?: number;\r\n}\r\n\r\nexport interface AuthClient {\r\n  signUpWithEmail(email: string, password: string): Promise<AuthSession>;\r\n  signInWithEmail(email: string, password: string): Promise<AuthSession>;\r\n  signOut(): Promise<void>;\r\n  getSession(): Promise<AuthSession | null>;\r\n  getCurrentUser(): Promise<AuthUser | null>;\r\n  getValidAccessToken(): Promise<string | null>;\r\n  getAccessToken(): Promise<string | null>;\r\n  onSessionChanged(callback: (session: AuthSession | null) => void): () => void;\r\n}\r\n\r\n/**\r\n * Create auth error with code\r\n */\r\nfunction createAuthError(message: string, code: string = \"AUTH_ERROR\", details?: any): Error {\r\n  const error = new Error(message || \"Authentication failed\");\r\n  (error as any).code = code;\r\n  if (details) {\r\n    (error as any).details = details;\r\n  }\r\n  return error;\r\n}\r\n\r\n/**\r\n * Parse error response from Supabase\r\n */\r\nasync function parseErrorResponse(response: Response, fallbackMessage: string): Promise<{ message: string; code: string; details?: any }> {\r\n  let payload: any = null;\r\n  try {\r\n    payload = await response.json();\r\n  } catch (_) {\r\n    try {\r\n      const text = await response.text();\r\n      if (text) {\r\n        payload = { message: text };\r\n      }\r\n    } catch (_) {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  const message =\r\n    payload?.error_description ||\r\n    payload?.error ||\r\n    payload?.message ||\r\n    fallbackMessage;\r\n  const normalized = (message || \"\").toLowerCase();\r\n\r\n  let code = \"AUTH_ERROR\";\r\n  if (normalized.includes(\"already registered\")) {\r\n    code = \"USER_ALREADY_REGISTERED\";\r\n  } else if (normalized.includes(\"invalid login\")) {\r\n    code = \"INVALID_LOGIN\";\r\n  } else if (normalized.includes(\"email not confirmed\")) {\r\n    code = \"EMAIL_NOT_CONFIRMED\";\r\n  } else if (normalized.includes(\"invalid email\")) {\r\n    code = \"INVALID_EMAIL\";\r\n  }\r\n\r\n  return { message, code, details: payload };\r\n}\r\n\r\n/**\r\n * Normalize Supabase session data\r\n */\r\nfunction normalizeSession(data: any, fallbackUser: AuthUser | null = null): AuthSession {\r\n  if (!data?.access_token || !data?.refresh_token) {\r\n    throw new Error(\"Supabase session payload missing tokens\");\r\n  }\r\n\r\n  const expiresIn = Number(data.expires_in) || 3600;\r\n  const expiresAt = Date.now() + expiresIn * 1000;\r\n\r\n  return {\r\n    accessToken: data.access_token,\r\n    refreshToken: data.refresh_token,\r\n    expiresAt,\r\n    tokenType: data.token_type || \"bearer\",\r\n    user: data.user || fallbackUser || null,\r\n  };\r\n}\r\n\r\n/**\r\n * Create Supabase auth client\r\n */\r\nexport function createAuthClient(config: AuthConfig, storage: StorageInterface): AuthClient {\r\n  const {\r\n    supabaseUrl,\r\n    supabaseAnonKey,\r\n    sessionStorageKey = \"lockinSupabaseSession\",\r\n    tokenExpiryBufferMs = 60000,\r\n  } = config;\r\n\r\n  const listeners = new Set<(session: AuthSession | null) => void>();\r\n\r\n  function assertConfig(): void {\r\n    if (!supabaseUrl || !supabaseAnonKey) {\r\n      throw new Error(\"Supabase URL or anon key is not configured\");\r\n    }\r\n  }\r\n\r\n  async function readStorage(): Promise<AuthSession | null> {\r\n    try {\r\n      const data = await storage.get(sessionStorageKey);\r\n      return data[sessionStorageKey] || null;\r\n    } catch (error) {\r\n      console.error(\"Lock-in auth storage read error:\", error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async function writeStorage(session: AuthSession): Promise<void> {\r\n    try {\r\n      await storage.set({ [sessionStorageKey]: session });\r\n    } catch (error) {\r\n      console.error(\"Lock-in auth storage write error:\", error);\r\n    }\r\n  }\r\n\r\n  async function clearStorage(): Promise<void> {\r\n    try {\r\n      await storage.remove(sessionStorageKey);\r\n    } catch (error) {\r\n      console.error(\"Lock-in auth storage clear error:\", error);\r\n    }\r\n  }\r\n\r\n  function notify(session: AuthSession | null): void {\r\n    listeners.forEach((cb) => {\r\n      try {\r\n        cb(session);\r\n      } catch (error) {\r\n        console.error(\"Lock-in auth listener error:\", error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async function signInWithEmail(email: string, password: string): Promise<AuthSession> {\r\n    assertConfig();\r\n\r\n    const response = await fetch(`${supabaseUrl}/auth/v1/token?grant_type=password`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        apikey: supabaseAnonKey,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ email, password }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const parsed = await parseErrorResponse(response, \"Failed to sign in\");\r\n      throw createAuthError(parsed.message, parsed.code, parsed.details);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const session = normalizeSession(data);\r\n    await writeStorage(session);\r\n    notify(session);\r\n    return session;\r\n  }\r\n\r\n  async function signUpWithEmail(email: string, password: string): Promise<AuthSession> {\r\n    assertConfig();\r\n\r\n    const response = await fetch(`${supabaseUrl}/auth/v1/signup`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        apikey: supabaseAnonKey,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ email, password }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const parsed = await parseErrorResponse(response, \"Failed to create account\");\r\n      throw createAuthError(parsed.message, parsed.code, parsed.details);\r\n    }\r\n\r\n    const data = await response.json();\r\n\r\n    if (!data?.access_token || !data?.refresh_token) {\r\n      throw createAuthError(\r\n        \"Check your email to confirm your account, then sign in.\",\r\n        \"EMAIL_CONFIRMATION_REQUIRED\",\r\n        data\r\n      );\r\n    }\r\n\r\n    const session = normalizeSession(data);\r\n    await writeStorage(session);\r\n    notify(session);\r\n    return session;\r\n  }\r\n\r\n  async function refreshSession(refreshToken: string, existingUser: AuthUser | null = null): Promise<AuthSession> {\r\n    assertConfig();\r\n\r\n    if (!refreshToken) {\r\n      throw new Error(\"Missing refresh token\");\r\n    }\r\n\r\n    const response = await fetch(`${supabaseUrl}/auth/v1/token?grant_type=refresh_token`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        apikey: supabaseAnonKey,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ refresh_token: refreshToken }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      await clearStorage();\r\n      let errorMessage = \"Failed to refresh session\";\r\n      try {\r\n        const errorBody = await response.json();\r\n        errorMessage = errorBody?.error_description || errorBody?.message || errorMessage;\r\n      } catch (_) {\r\n        // ignore parse errors\r\n      }\r\n      throw new Error(errorMessage);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const session = normalizeSession(\r\n      { ...data, refresh_token: data.refresh_token || refreshToken },\r\n      existingUser\r\n    );\r\n    await writeStorage(session);\r\n    notify(session);\r\n    return session;\r\n  }\r\n\r\n  async function getSession(): Promise<AuthSession | null> {\r\n    return readStorage();\r\n  }\r\n\r\n  async function getValidAccessToken(): Promise<string | null> {\r\n    const session = await readStorage();\r\n    if (!session) {\r\n      return null;\r\n    }\r\n\r\n    const expiresAt = Number(session.expiresAt) || 0;\r\n    const buffer = tokenExpiryBufferMs;\r\n    if (expiresAt - buffer > Date.now()) {\r\n      return session.accessToken;\r\n    }\r\n\r\n    try {\r\n      const refreshed = await refreshSession(session.refreshToken, session.user);\r\n      return refreshed.accessToken;\r\n    } catch (error) {\r\n      console.error(\"Lock-in token refresh failed:\", (error as Error).message);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async function getCurrentUser(): Promise<AuthUser | null> {\r\n    const session = await getSession();\r\n    return session?.user || null;\r\n  }\r\n\r\n  async function signOut(): Promise<void> {\r\n    await clearStorage();\r\n    notify(null);\r\n  }\r\n\r\n  function onSessionChanged(callback: (session: AuthSession | null) => void): () => void {\r\n    if (typeof callback !== \"function\") {\r\n      return () => {};\r\n    }\r\n    listeners.add(callback);\r\n    return () => listeners.delete(callback);\r\n  }\r\n\r\n  // Listen to storage changes\r\n  storage.onChanged((changes, areaName) => {\r\n    if (areaName === \"sync\" && changes[sessionStorageKey]) {\r\n      notify(changes[sessionStorageKey].newValue || null);\r\n    }\r\n  });\r\n\r\n  return {\r\n    signUpWithEmail,\r\n    signInWithEmail,\r\n    signOut,\r\n    getSession,\r\n    getCurrentUser,\r\n    getValidAccessToken,\r\n    getAccessToken: getValidAccessToken,\r\n    onSessionChanged,\r\n  };\r\n}\r\n","/**\r\n * API Client for Lock-in\r\n * \r\n * Chrome-agnostic API client for backend communication.\r\n * Uses auth client interface - no direct Chrome dependencies.\r\n * \r\n * Scalability features:\r\n * - Exponential backoff retry for transient failures\r\n * - Request deduplication via AbortController\r\n * - Optimistic locking support via updatedAt\r\n */\r\n\r\nimport type { StudyResponse, ApiResponse, ChatMessage, NoteAsset } from \"../core/domain/types\";\r\nimport type { AuthClient } from \"./auth\";\r\n\r\nexport interface ApiClientConfig {\r\n  backendUrl: string;\r\n  authClient: AuthClient;\r\n}\r\n\r\n/**\r\n * Retry configuration for transient failures\r\n * Industry best practice: exponential backoff with jitter\r\n */\r\ninterface RetryConfig {\r\n  maxRetries: number;\r\n  baseDelayMs: number;\r\n  maxDelayMs: number;\r\n  retryableStatuses: number[];\r\n}\r\n\r\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\r\n  maxRetries: 3,\r\n  baseDelayMs: 500,\r\n  maxDelayMs: 5000,\r\n  // 429 = rate limit, 502/503/504 = server overload/temporary issues\r\n  retryableStatuses: [429, 502, 503, 504],\r\n};\r\n\r\n/**\r\n * Calculate delay with exponential backoff and jitter\r\n * Jitter prevents thundering herd problem with thousands of users\r\n */\r\nfunction calculateRetryDelay(attempt: number, config: RetryConfig): number {\r\n  const exponentialDelay = config.baseDelayMs * Math.pow(2, attempt);\r\n  const cappedDelay = Math.min(exponentialDelay, config.maxDelayMs);\r\n  // Add 0-30% jitter to prevent synchronized retries\r\n  const jitter = cappedDelay * (Math.random() * 0.3);\r\n  return Math.floor(cappedDelay + jitter);\r\n}\r\n\r\n/**\r\n * Sleep utility for retry delays\r\n */\r\nfunction sleep(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nexport interface ProcessTextParams {\r\n  selection: string;\r\n  mode: \"explain\" | \"simplify\" | \"translate\" | \"general\";\r\n  targetLanguage?: string;\r\n  difficultyLevel?: \"highschool\" | \"university\";\r\n  chatHistory?: ChatMessage[];\r\n  newUserMessage?: string;\r\n  chatId?: string;\r\n  pageContext?: string;\r\n  pageUrl?: string;\r\n  courseCode?: string;\r\n  language?: string;\r\n}\r\n\r\nexport interface ListNotesParams {\r\n  sourceUrl?: string;\r\n  courseCode?: string;\r\n  limit?: number;\r\n}\r\n\r\nexport interface SearchNotesParams {\r\n  query: string;\r\n  courseCode?: string;\r\n  k?: number;\r\n}\r\n\r\nexport interface ChatWithNotesParams {\r\n  query: string;\r\n  courseCode?: string;\r\n  k?: number;\r\n}\r\n\r\nexport interface UploadNoteAssetParams {\r\n  noteId: string;\r\n  file: File | Blob;\r\n}\r\n\r\nexport interface ListNoteAssetsParams {\r\n  noteId: string;\r\n}\r\n\r\nexport interface DeleteNoteAssetParams {\r\n  assetId: string;\r\n}\r\n\r\n/**\r\n * Options for API requests\r\n */\r\nexport interface ApiRequestOptions extends RequestInit {\r\n  signal?: AbortSignal;\r\n  /** Set to false to disable retries for this request */\r\n  retry?: boolean;\r\n  /** Custom retry config */\r\n  retryConfig?: Partial<RetryConfig>;\r\n  /** updatedAt for optimistic locking (conflict detection) */\r\n  ifUnmodifiedSince?: string;\r\n}\r\n\r\n/**\r\n * Conflict error thrown when optimistic locking fails\r\n */\r\nexport class ConflictError extends Error {\r\n  code = \"CONFLICT\";\r\n  status = 409;\r\n  serverVersion?: string;\r\n  \r\n  constructor(message: string, serverVersion?: string) {\r\n    super(message);\r\n    this.name = \"ConflictError\";\r\n    this.serverVersion = serverVersion;\r\n  }\r\n}\r\n\r\n/**\r\n * Create API error from response\r\n */\r\nasync function createApiError(response: Response, originalError: Error | null = null): Promise<Error> {\r\n  let errorMessage = \"API request failed\";\r\n  let errorCode = \"API_ERROR\";\r\n\r\n  try {\r\n    const errorBody = await response.json();\r\n    errorMessage =\r\n      errorBody?.error?.message ||\r\n      errorBody?.message ||\r\n      (typeof errorBody?.error === \"string\" ? errorBody.error : null) ||\r\n      errorMessage;\r\n\r\n    // Map status codes to error codes\r\n    if (response.status === 401 || response.status === 403) {\r\n      errorCode = \"AUTH_REQUIRED\";\r\n    } else if (response.status === 429) {\r\n      errorCode = \"RATE_LIMIT\";\r\n    } else if (response.status === 400) {\r\n      errorCode = \"BAD_REQUEST\";\r\n    } else if (response.status >= 500) {\r\n      errorCode = \"SERVER_ERROR\";\r\n    }\r\n  } catch (_) {\r\n    // If JSON parsing fails, try text\r\n    try {\r\n      const text = await response.text();\r\n      if (text) {\r\n        errorMessage = text;\r\n      }\r\n    } catch (_) {\r\n      // Ignore\r\n    }\r\n  }\r\n\r\n  const error = new Error(errorMessage);\r\n  (error as any).code = errorCode;\r\n  (error as any).status = response.status;\r\n  if (originalError) {\r\n    (error as any).cause = originalError;\r\n  }\r\n  return error;\r\n}\r\n\r\n/**\r\n * Create API client\r\n */\r\nexport function createApiClient(config: ApiClientConfig) {\r\n  const { backendUrl, authClient } = config;\r\n  const clientConfig = { backendUrl };\r\n\r\n  /**\r\n   * Make an authenticated API request with automatic retry for transient failures.\r\n   * \r\n   * Scalability features:\r\n   * - Exponential backoff with jitter for retries (prevents thundering herd)\r\n   * - Automatic retry for 429, 502, 503, 504 status codes\r\n   * - Support for optimistic locking via If-Unmodified-Since header\r\n   * - AbortController support for request cancellation\r\n   */\r\n  async function apiRequest<T = any>(\r\n    endpoint: string,\r\n    options: ApiRequestOptions = {}\r\n  ): Promise<T> {\r\n    const {\r\n      retry = true,\r\n      retryConfig: customRetryConfig,\r\n      ifUnmodifiedSince,\r\n      ...fetchOptions\r\n    } = options;\r\n    \r\n    const retryConfig = { ...DEFAULT_RETRY_CONFIG, ...customRetryConfig };\r\n    const url = endpoint.startsWith(\"http\") ? endpoint : `${backendUrl}${endpoint}`;\r\n\r\n    // Check if request was aborted before starting\r\n    if (fetchOptions.signal?.aborted) {\r\n      const error = new Error(\"Request was aborted\");\r\n      (error as any).code = \"ABORTED\";\r\n      throw error;\r\n    }\r\n\r\n    // Get access token\r\n    const accessToken = await authClient.getValidAccessToken();\r\n    if (!accessToken) {\r\n      const error = new Error(\"Please sign in via the Lock-in popup before using the assistant.\");\r\n      (error as any).code = \"AUTH_REQUIRED\";\r\n      throw error;\r\n    }\r\n\r\n    // Check again after async operation\r\n    if (fetchOptions.signal?.aborted) {\r\n      const error = new Error(\"Request was aborted\");\r\n      (error as any).code = \"ABORTED\";\r\n      throw error;\r\n    }\r\n\r\n    // Prepare headers\r\n    const isFormData = typeof FormData !== \"undefined\" && fetchOptions.body instanceof FormData;\r\n    const headers: HeadersInit = {\r\n      Authorization: `Bearer ${accessToken}`,\r\n      ...(isFormData ? {} : { \"Content-Type\": \"application/json\" }),\r\n      ...(ifUnmodifiedSince ? { \"If-Unmodified-Since\": ifUnmodifiedSince } : {}),\r\n      ...(fetchOptions.headers || {}),\r\n    };\r\n\r\n    // Prepare request (include signal for cancellation)\r\n    const requestOptions: RequestInit = {\r\n      ...fetchOptions,\r\n      headers,\r\n      signal: fetchOptions.signal,\r\n    };\r\n\r\n    // Retry loop with exponential backoff\r\n    let lastError: Error | null = null;\r\n    for (let attempt = 0; attempt <= (retry ? retryConfig.maxRetries : 0); attempt++) {\r\n      // Check abort before each attempt\r\n      if (fetchOptions.signal?.aborted) {\r\n        const error = new Error(\"Request was aborted\");\r\n        (error as any).code = \"ABORTED\";\r\n        throw error;\r\n      }\r\n\r\n      // Wait before retry (skip for first attempt)\r\n      if (attempt > 0) {\r\n        const delay = calculateRetryDelay(attempt - 1, retryConfig);\r\n        console.log(`[API] Retry attempt ${attempt}/${retryConfig.maxRetries} after ${delay}ms`);\r\n        await sleep(delay);\r\n        \r\n        // Check abort after sleep\r\n        if (fetchOptions.signal?.aborted) {\r\n          const error = new Error(\"Request was aborted\");\r\n          (error as any).code = \"ABORTED\";\r\n          throw error;\r\n        }\r\n      }\r\n\r\n      // Make request\r\n      let response: Response;\r\n      try {\r\n        response = await fetch(url, requestOptions);\r\n      } catch (networkError: any) {\r\n        // Check if error is due to abort\r\n        if (networkError.name === \"AbortError\" || fetchOptions.signal?.aborted) {\r\n          const error = new Error(\"Request was aborted\");\r\n          (error as any).code = \"ABORTED\";\r\n          throw error;\r\n        }\r\n        \r\n        // Network errors are retryable\r\n        lastError = new Error(\"Unable to reach Lock-in. Please check your connection.\");\r\n        (lastError as any).code = \"NETWORK_ERROR\";\r\n        (lastError as any).cause = networkError;\r\n        \r\n        if (retry && attempt < retryConfig.maxRetries) {\r\n          continue; // Retry on network error\r\n        }\r\n        throw lastError;\r\n      }\r\n\r\n      // Handle 409 Conflict for optimistic locking\r\n      if (response.status === 409) {\r\n        let serverVersion: string | undefined;\r\n        try {\r\n          const body = await response.json();\r\n          serverVersion = body?.updatedAt || body?.updated_at;\r\n        } catch {}\r\n        throw new ConflictError(\r\n          \"Note was modified by another session. Please refresh and try again.\",\r\n          serverVersion\r\n        );\r\n      }\r\n\r\n      // Check if response status is retryable\r\n      if (retry && retryConfig.retryableStatuses.includes(response.status) && attempt < retryConfig.maxRetries) {\r\n        lastError = await createApiError(response);\r\n        continue; // Retry on retryable status\r\n      }\r\n\r\n      // Handle auth errors\r\n      if (response.status === 401 || response.status === 403) {\r\n        // Try to sign out if auth fails\r\n        await authClient.signOut().catch(() => {\r\n          // Ignore sign-out errors\r\n        });\r\n      }\r\n\r\n      // Handle HTTP errors\r\n      if (!response.ok) {\r\n        throw await createApiError(response);\r\n      }\r\n\r\n      // Handle 204 No Content (common for DELETE requests)\r\n      if (response.status === 204) {\r\n        return undefined as T;\r\n      }\r\n\r\n      // Parse and return response\r\n      try {\r\n        // Check if there's actually content to parse\r\n        const contentLength = response.headers.get(\"content-length\");\r\n        const contentType = response.headers.get(\"content-type\");\r\n        \r\n        // If no content or not JSON, return undefined\r\n        if (contentLength === \"0\" || !contentType?.includes(\"application/json\")) {\r\n          return undefined as T;\r\n        }\r\n        \r\n        const data = await response.json();\r\n        // Check for success: false in response body (even if HTTP status is 200)\r\n        if (data && data.success === false) {\r\n          const error = new Error(data.error?.message || \"Request failed\");\r\n          (error as any).code = data.error?.code || \"API_ERROR\";\r\n          throw error;\r\n        }\r\n        return data;\r\n      } catch (parseError) {\r\n        // If it's already an Error we threw, re-throw it\r\n        if (parseError instanceof Error && (parseError as any).code) {\r\n          throw parseError;\r\n        }\r\n        const error = new Error(\"Failed to parse API response\");\r\n        (error as any).code = \"PARSE_ERROR\";\r\n        (error as any).cause = parseError;\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    // If we've exhausted all retries\r\n    throw lastError || new Error(\"Request failed after retries\");\r\n  }\r\n\r\n  /**\r\n   * Process text with Lock-in AI\r\n   */\r\n  async function processText(params: ProcessTextParams): Promise<ApiResponse<StudyResponse>> {\r\n    const {\r\n      selection,\r\n      mode,\r\n      targetLanguage = \"en\",\r\n      difficultyLevel = \"highschool\",\r\n      chatHistory = [],\r\n      newUserMessage,\r\n      chatId,\r\n      pageContext,\r\n      pageUrl,\r\n      courseCode,\r\n      language = \"en\",\r\n    } = params;\r\n\r\n    // Normalize chat history\r\n    const normalizedHistory = (Array.isArray(chatHistory) ? chatHistory : [])\r\n      .filter(\r\n        (message) =>\r\n          message &&\r\n          typeof message.role === \"string\" &&\r\n          typeof message.content === \"string\"\r\n      )\r\n      .map((message) => ({\r\n        role: message.role,\r\n        content: message.content,\r\n      }));\r\n\r\n    const body: any = {\r\n      selection: selection || \"\",\r\n      mode,\r\n      targetLanguage,\r\n      difficultyLevel,\r\n      chatHistory: normalizedHistory,\r\n    };\r\n\r\n    if (newUserMessage) body.newUserMessage = newUserMessage;\r\n    if (chatId) body.chatId = chatId;\r\n    if (pageContext) body.pageContext = pageContext;\r\n    if (pageUrl) body.pageUrl = pageUrl;\r\n    if (courseCode) body.courseCode = courseCode;\r\n    if (language) body.language = language;\r\n\r\n    return apiRequest<ApiResponse<StudyResponse>>(\"/api/lockin\", {\r\n      method: \"POST\",\r\n      body: JSON.stringify(body),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get recent chats\r\n   */\r\n  async function getRecentChats(params: { limit?: number } = {}): Promise<any[]> {\r\n    const { limit = 10 } = params;\r\n    const queryParams = new URLSearchParams();\r\n    if (limit) {\r\n      queryParams.set(\"limit\", String(limit));\r\n    }\r\n\r\n    const endpoint = `/api/chats${queryParams.toString() ? `?${queryParams.toString()}` : \"\"}`;\r\n    return apiRequest<any[]>(endpoint, {\r\n      method: \"GET\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get messages for a chat\r\n   */\r\n  async function getChatMessages(chatId: string): Promise<any[]> {\r\n    if (!chatId) {\r\n      throw new Error(\"Chat ID is required\");\r\n    }\r\n\r\n    return apiRequest<any[]>(`/api/chats/${chatId}/messages`, {\r\n      method: \"GET\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete a chat\r\n   */\r\n  async function deleteChat(chatId: string): Promise<void> {\r\n    if (!chatId) {\r\n      throw new Error(\"Chat ID is required\");\r\n    }\r\n\r\n    return apiRequest<void>(`/api/chats/${chatId}`, {\r\n      method: \"DELETE\",\r\n    });\r\n  }\r\n\r\n  type NotePayload = {\r\n    title?: string;\r\n    content?: string;\r\n    content_text?: string | null;\r\n    content_json?: unknown;\r\n    contentJson?: unknown;\r\n    editor_version?: string;\r\n    sourceSelection?: string | null;\r\n    source_selection?: string | null;\r\n    sourceUrl?: string | null;\r\n    source_url?: string | null;\r\n    courseCode?: string | null;\r\n    course_code?: string | null;\r\n    noteType?: string | null;\r\n    note_type?: string | null;\r\n    tags?: string[];\r\n  };\r\n\r\n  /**\r\n   * Create a new note\r\n   */\r\n  async function createNote(\r\n    note: NotePayload & { title: string },\r\n    options?: { signal?: AbortSignal }\r\n  ): Promise<any> {\r\n    return apiRequest<any>(\"/api/notes\", {\r\n      method: \"POST\",\r\n      body: JSON.stringify(note),\r\n      signal: options?.signal,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update an existing note\r\n   */\r\n  async function updateNote(\r\n    noteId: string,\r\n    note: NotePayload,\r\n    options?: { signal?: AbortSignal }\r\n  ): Promise<any> {\r\n    if (!noteId) {\r\n      throw new Error(\"noteId is required to update a note\");\r\n    }\r\n    return apiRequest<any>(\r\n      `/api/notes/${noteId}`,\r\n      {\r\n        method: \"PUT\",\r\n        body: JSON.stringify(note),\r\n        signal: options?.signal,\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Delete a note\r\n   */\r\n  async function deleteNote(noteId: string): Promise<void> {\r\n    if (!noteId) {\r\n      throw new Error(\"noteId is required to delete a note\");\r\n    }\r\n    return apiRequest<void>(`/api/notes/${noteId}`, {\r\n      method: \"DELETE\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Toggle the starred status of a note\r\n   */\r\n  async function toggleNoteStar(noteId: string): Promise<any> {\r\n    if (!noteId) {\r\n      throw new Error(\"noteId is required to toggle star\");\r\n    }\r\n    return apiRequest<any>(`/api/notes/${noteId}/star`, {\r\n      method: \"PATCH\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set the starred status of a note\r\n   */\r\n  async function setNoteStar(noteId: string, isStarred: boolean): Promise<any> {\r\n    if (!noteId) {\r\n      throw new Error(\"noteId is required to set star\");\r\n    }\r\n    return apiRequest<any>(`/api/notes/${noteId}/star`, {\r\n      method: \"PUT\",\r\n      body: JSON.stringify({ isStarred }),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * List notes with optional filters\r\n   */\r\n  async function listNotes(params: ListNotesParams = {}): Promise<any[]> {\r\n    const { sourceUrl, courseCode, limit = 50 } = params;\r\n    const queryParams = new URLSearchParams();\r\n    if (sourceUrl) queryParams.set(\"sourceUrl\", sourceUrl);\r\n    if (courseCode) queryParams.set(\"courseCode\", courseCode);\r\n    if (limit) queryParams.set(\"limit\", String(limit));\r\n\r\n    const endpoint = `/api/notes${queryParams.toString() ? `?${queryParams.toString()}` : \"\"}`;\r\n    return apiRequest<any[]>(endpoint, {\r\n      method: \"GET\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Search notes by semantic similarity\r\n   */\r\n  async function searchNotes(params: SearchNotesParams): Promise<any[]> {\r\n    const { query, courseCode, k = 10 } = params;\r\n    const queryParams = new URLSearchParams({ q: query, k: String(k) });\r\n    if (courseCode) queryParams.set(\"courseCode\", courseCode);\r\n\r\n    return apiRequest<any[]>(`/api/notes/search?${queryParams.toString()}`, {\r\n      method: \"GET\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Chat with notes using semantic search\r\n   */\r\n  async function chatWithNotes(params: ChatWithNotesParams): Promise<{ answer: string; usedNotes: any[] }> {\r\n    return apiRequest<{ answer: string; usedNotes: any[] }>(\"/api/notes/chat\", {\r\n      method: \"POST\",\r\n      body: JSON.stringify({ query: params.query, courseCode: params.courseCode, k: params.k }),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Map backend note asset response (snake_case) to frontend NoteAsset (camelCase)\r\n   */\r\n  function mapNoteAsset(raw: any): NoteAsset {\r\n    return {\r\n      id: raw.id,\r\n      noteId: raw.note_id,\r\n      userId: raw.user_id,\r\n      type: raw.type,\r\n      mimeType: raw.mime_type,\r\n      storagePath: raw.storage_path,\r\n      createdAt: raw.created_at,\r\n      url: raw.url,\r\n      fileName: raw.file_name || raw.filename || raw.name || null,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Upload an asset for a note\r\n   */\r\n  async function uploadNoteAsset(params: UploadNoteAssetParams): Promise<NoteAsset> {\r\n    const { noteId, file } = params;\r\n    if (!noteId) {\r\n      throw new Error(\"noteId is required to upload an asset\");\r\n    }\r\n    if (!file) {\r\n      throw new Error(\"file is required to upload an asset\");\r\n    }\r\n\r\n    const formData = new FormData();\r\n    formData.append(\"file\", file);\r\n\r\n    const raw = await apiRequest<any>(`/api/notes/${noteId}/assets`, {\r\n      method: \"POST\",\r\n      body: formData,\r\n      // Let the browser set Content-Type with boundary\r\n    });\r\n\r\n    return mapNoteAsset(raw);\r\n  }\r\n\r\n  /**\r\n   * List assets for a note\r\n   */\r\n  async function listNoteAssets(params: ListNoteAssetsParams): Promise<NoteAsset[]> {\r\n    const { noteId } = params;\r\n    if (!noteId) {\r\n      throw new Error(\"noteId is required to list assets\");\r\n    }\r\n\r\n    const raw = await apiRequest<any[]>(`/api/notes/${noteId}/assets`, {\r\n      method: \"GET\",\r\n    });\r\n\r\n    return raw.map(mapNoteAsset);\r\n  }\r\n\r\n  /**\r\n   * Delete a note asset\r\n   */\r\n  async function deleteNoteAsset(params: DeleteNoteAssetParams): Promise<void> {\r\n    const { assetId } = params;\r\n    if (!assetId) {\r\n      throw new Error(\"assetId is required to delete an asset\");\r\n    }\r\n\r\n    return apiRequest<void>(`/api/note-assets/${assetId}`, {\r\n      method: \"DELETE\",\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get backend URL used by this client\r\n   */\r\n  function getBackendUrl(): string {\r\n    return clientConfig.backendUrl;\r\n  }\r\n\r\n  return {\r\n    apiRequest,\r\n    getBackendUrl,\r\n    processText,\r\n    getRecentChats,\r\n    getChatMessages,\r\n    deleteChat,\r\n    createNote,\r\n    updateNote,\r\n    deleteNote,\r\n    toggleNoteStar,\r\n    setNoteStar,\r\n    listNotes,\r\n    searchNotes,\r\n    chatWithNotes,\r\n    uploadNoteAsset,\r\n    listNoteAssets,\r\n    deleteNoteAsset,\r\n  };\r\n}\r\n\r\n/**\r\n * Type for the API client returned by createApiClient\r\n */\r\nexport type ApiClient = ReturnType<typeof createApiClient>;\r\n","/**\r\n * Chrome Storage Implementation\r\n * \r\n * Implements StorageInterface using chrome.storage APIs.\r\n * This is the extension-specific implementation.\r\n */\r\n\r\nimport type { StorageInterface, LocalStorageInterface } from \"../../core/storage/storageInterface\";\r\n\r\n/**\r\n * Chrome storage implementation for sync storage\r\n */\r\nexport class ChromeStorage implements StorageInterface {\r\n  async get<T = any>(key: string | string[]): Promise<Record<string, T>> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.sync.get(key, (data) => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve(data as Record<string, T>);\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async set(data: Record<string, any>): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.sync.set(data, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve();\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async remove(keys: string | string[]): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.sync.remove(keys, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve();\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  onChanged(\r\n    callback: (changes: Record<string, { oldValue?: any; newValue?: any }>, areaName: string) => void\r\n  ): () => void {\r\n    const listener = (changes: chrome.storage.StorageChange, areaName: chrome.storage.StorageArea) => {\r\n      const normalizedChanges: Record<string, { oldValue?: any; newValue?: any }> = {};\r\n      for (const [key, change] of Object.entries(changes)) {\r\n        normalizedChanges[key] = {\r\n          oldValue: change.oldValue,\r\n          newValue: change.newValue,\r\n        };\r\n      }\r\n      callback(normalizedChanges, areaName as unknown as string);\r\n    };\r\n\r\n    chrome.storage.onChanged.addListener(listener as any);\r\n\r\n    return () => {\r\n      chrome.storage.onChanged.removeListener(listener as any);\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Chrome local storage implementation\r\n */\r\nexport class ChromeLocalStorage implements LocalStorageInterface {\r\n  async get<T = any>(key: string | string[]): Promise<Record<string, T>> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.local.get(key, (data) => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve(data as Record<string, T>);\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async set(data: Record<string, any>): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.local.set(data, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve();\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async remove(keys: string | string[]): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.local.remove(keys, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n            return;\r\n          }\r\n          resolve();\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// Export singleton instances\r\nexport const chromeStorage = new ChromeStorage();\r\nexport const chromeLocalStorage = new ChromeLocalStorage();\r\n","/**\r\n * Initialize API and Auth Clients for Extension\r\n * \r\n * This file wires together the Chrome-specific storage with the Chrome-agnostic\r\n * API and auth clients. It's the bridge between extension code and shared code.\r\n */\r\n\r\nimport { createAuthClient } from \"../../api/auth\";\r\nimport { createApiClient } from \"../../api/client\";\r\nimport { chromeStorage } from \"./chromeStorage\";\r\n\r\n/**\r\n * Get config from window (set by config.js)\r\n */\r\nexport function getConfig() {\r\n  const config = (typeof window !== \"undefined\" && (window as any).LOCKIN_CONFIG) || {};\r\n  return {\r\n    backendUrl: config.BACKEND_URL || \"http://localhost:3000\",\r\n    supabaseUrl: config.SUPABASE_URL || \"\",\r\n    supabaseAnonKey: config.SUPABASE_ANON_KEY || \"\",\r\n    sessionStorageKey: config.SESSION_STORAGE_KEY || \"lockinSupabaseSession\",\r\n    tokenExpiryBufferMs: Number(config.TOKEN_EXPIRY_BUFFER_MS) || 60000,\r\n  };\r\n}\r\n\r\n/**\r\n * Initialize auth client\r\n */\r\nexport function initAuthClient() {\r\n  const config = getConfig();\r\n  return createAuthClient(\r\n    {\r\n      supabaseUrl: config.supabaseUrl,\r\n      supabaseAnonKey: config.supabaseAnonKey,\r\n      sessionStorageKey: config.sessionStorageKey,\r\n      tokenExpiryBufferMs: config.tokenExpiryBufferMs,\r\n    },\r\n    chromeStorage\r\n  );\r\n}\r\n\r\n/**\r\n * Initialize API client\r\n */\r\nexport function initApiClient(authClient: ReturnType<typeof initAuthClient>) {\r\n  const config = getConfig();\r\n  return createApiClient({\r\n    backendUrl: config.backendUrl,\r\n    authClient,\r\n  });\r\n}\r\n\r\n/**\r\n * Initialize both clients and expose globally for backward compatibility\r\n */\r\nlet cachedClients: { authClient: ReturnType<typeof initAuthClient>; apiClient: ReturnType<typeof initApiClient> } | null =\r\n  null;\r\n\r\nexport function initClients() {\r\n  if (cachedClients) {\r\n    return cachedClients;\r\n  }\r\n\r\n  const authClient = initAuthClient();\r\n  const apiClient = initApiClient(authClient);\r\n\r\n  cachedClients = { authClient, apiClient };\r\n\r\n  // Expose globally for backward compatibility with existing code\r\n  if (typeof window !== \"undefined\") {\r\n    (window as any).LockInAuth = authClient;\r\n    (window as any).LockInAPI = apiClient;\r\n  }\r\n\r\n  return cachedClients;\r\n}\r\n\r\n// Auto-initialize when running in the extension/page context\r\nif (typeof window !== \"undefined\") {\r\n  initClients();\r\n  (window as any).LockInInit = {\r\n    getConfig,\r\n    initAuthClient,\r\n    initApiClient,\r\n    initClients,\r\n  };\r\n}\r\n"],"names":["_"],"mappings":"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"}