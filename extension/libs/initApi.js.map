{"version":3,"file":"initApi.js","sources":["../../api/auth.ts","../../api/fetcher.ts","../../api/resources/lockinClient.ts","../../api/resources/chatsClient.ts","../../api/resources/notesClient.ts","../../api/resources/assetsClient.ts","../../api/client.ts","../src/chromeStorage.ts","../src/initApi.ts"],"sourcesContent":["/**\r\n * Supabase Auth Client\r\n * \r\n * Chrome-agnostic authentication client for Supabase.\r\n * Uses storage interface abstraction - no Chrome dependencies.\r\n */\r\n\r\nimport type { StorageInterface } from \"../core/storage/storageInterface\";\r\nimport type { AuthSession, AuthUser } from \"../core/domain/types\";\r\n\r\nexport interface AuthConfig {\r\n  supabaseUrl: string;\r\n  supabaseAnonKey: string;\r\n  sessionStorageKey?: string;\r\n  tokenExpiryBufferMs?: number;\r\n}\r\n\r\nexport interface AuthClient {\r\n  signUpWithEmail(email: string, password: string): Promise<AuthSession>;\r\n  signInWithEmail(email: string, password: string): Promise<AuthSession>;\r\n  signOut(): Promise<void>;\r\n  getSession(): Promise<AuthSession | null>;\r\n  getCurrentUser(): Promise<AuthUser | null>;\r\n  getValidAccessToken(): Promise<string | null>;\r\n  getAccessToken(): Promise<string | null>;\r\n  onSessionChanged(callback: (session: AuthSession | null) => void): () => void;\r\n}\r\n\r\n/**\r\n * Create auth error with code\r\n */\r\nfunction createAuthError(message: string, code: string = \"AUTH_ERROR\", details?: any): Error {\r\n  const error = new Error(message || \"Authentication failed\");\r\n  (error as any).code = code;\r\n  if (details) {\r\n    (error as any).details = details;\r\n  }\r\n  return error;\r\n}\r\n\r\n/**\r\n * Parse error response from Supabase\r\n */\r\nasync function parseErrorResponse(response: Response, fallbackMessage: string): Promise<{ message: string; code: string; details?: any }> {\r\n  let payload: any = null;\r\n  try {\r\n    payload = await response.json();\r\n  } catch (_) {\r\n    try {\r\n      const text = await response.text();\r\n      if (text) {\r\n        payload = { message: text };\r\n      }\r\n    } catch (_) {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  const message =\r\n    payload?.error_description ||\r\n    payload?.error ||\r\n    payload?.message ||\r\n    fallbackMessage;\r\n  const normalized = (message || \"\").toLowerCase();\r\n\r\n  let code = \"AUTH_ERROR\";\r\n  if (normalized.includes(\"already registered\")) {\r\n    code = \"USER_ALREADY_REGISTERED\";\r\n  } else if (normalized.includes(\"invalid login\")) {\r\n    code = \"INVALID_LOGIN\";\r\n  } else if (normalized.includes(\"email not confirmed\")) {\r\n    code = \"EMAIL_NOT_CONFIRMED\";\r\n  } else if (normalized.includes(\"invalid email\")) {\r\n    code = \"INVALID_EMAIL\";\r\n  }\r\n\r\n  return { message, code, details: payload };\r\n}\r\n\r\n/**\r\n * Normalize Supabase session data\r\n */\r\nfunction normalizeSession(data: any, fallbackUser: AuthUser | null = null): AuthSession {\r\n  if (!data?.access_token || !data?.refresh_token) {\r\n    throw new Error(\"Supabase session payload missing tokens\");\r\n  }\r\n\r\n  const expiresIn = Number(data.expires_in) || 3600;\r\n  const expiresAt = Date.now() + expiresIn * 1000;\r\n\r\n  return {\r\n    accessToken: data.access_token,\r\n    refreshToken: data.refresh_token,\r\n    expiresAt,\r\n    tokenType: data.token_type || \"bearer\",\r\n    user: data.user || fallbackUser || null,\r\n  };\r\n}\r\n\r\n/**\r\n * Create Supabase auth client\r\n */\r\nexport function createAuthClient(config: AuthConfig, storage: StorageInterface): AuthClient {\r\n  const {\r\n    supabaseUrl,\r\n    supabaseAnonKey,\r\n    sessionStorageKey = \"lockinSupabaseSession\",\r\n    tokenExpiryBufferMs = 60000,\r\n  } = config;\r\n\r\n  const listeners = new Set<(session: AuthSession | null) => void>();\r\n\r\n  function assertConfig(): void {\r\n    if (!supabaseUrl || !supabaseAnonKey) {\r\n      throw new Error(\"Supabase URL or anon key is not configured\");\r\n    }\r\n  }\r\n\r\n  async function readStorage(): Promise<AuthSession | null> {\r\n    try {\r\n      const data = await storage.get(sessionStorageKey);\r\n      return data[sessionStorageKey] || null;\r\n    } catch (error) {\r\n      console.error(\"Lock-in auth storage read error:\", error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async function writeStorage(session: AuthSession): Promise<void> {\r\n    try {\r\n      await storage.set({ [sessionStorageKey]: session });\r\n    } catch (error) {\r\n      console.error(\"Lock-in auth storage write error:\", error);\r\n    }\r\n  }\r\n\r\n  async function clearStorage(): Promise<void> {\r\n    try {\r\n      await storage.remove(sessionStorageKey);\r\n    } catch (error) {\r\n      console.error(\"Lock-in auth storage clear error:\", error);\r\n    }\r\n  }\r\n\r\n  function notify(session: AuthSession | null): void {\r\n    listeners.forEach((cb) => {\r\n      try {\r\n        cb(session);\r\n      } catch (error) {\r\n        console.error(\"Lock-in auth listener error:\", error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async function signInWithEmail(email: string, password: string): Promise<AuthSession> {\r\n    assertConfig();\r\n\r\n    const response = await fetch(`${supabaseUrl}/auth/v1/token?grant_type=password`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        apikey: supabaseAnonKey,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ email, password }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const parsed = await parseErrorResponse(response, \"Failed to sign in\");\r\n      throw createAuthError(parsed.message, parsed.code, parsed.details);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const session = normalizeSession(data);\r\n    await writeStorage(session);\r\n    notify(session);\r\n    return session;\r\n  }\r\n\r\n  async function signUpWithEmail(email: string, password: string): Promise<AuthSession> {\r\n    assertConfig();\r\n\r\n    const response = await fetch(`${supabaseUrl}/auth/v1/signup`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        apikey: supabaseAnonKey,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ email, password }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const parsed = await parseErrorResponse(response, \"Failed to create account\");\r\n      throw createAuthError(parsed.message, parsed.code, parsed.details);\r\n    }\r\n\r\n    const data = await response.json();\r\n\r\n    if (!data?.access_token || !data?.refresh_token) {\r\n      throw createAuthError(\r\n        \"Check your email to confirm your account, then sign in.\",\r\n        \"EMAIL_CONFIRMATION_REQUIRED\",\r\n        data\r\n      );\r\n    }\r\n\r\n    const session = normalizeSession(data);\r\n    await writeStorage(session);\r\n    notify(session);\r\n    return session;\r\n  }\r\n\r\n  async function refreshSession(refreshToken: string, existingUser: AuthUser | null = null): Promise<AuthSession> {\r\n    assertConfig();\r\n\r\n    if (!refreshToken) {\r\n      throw new Error(\"Missing refresh token\");\r\n    }\r\n\r\n    const response = await fetch(`${supabaseUrl}/auth/v1/token?grant_type=refresh_token`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        apikey: supabaseAnonKey,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ refresh_token: refreshToken }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      await clearStorage();\r\n      let errorMessage = \"Failed to refresh session\";\r\n      try {\r\n        const errorBody = await response.json();\r\n        errorMessage = errorBody?.error_description || errorBody?.message || errorMessage;\r\n      } catch (_) {\r\n        // ignore parse errors\r\n      }\r\n      throw new Error(errorMessage);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const session = normalizeSession(\r\n      { ...data, refresh_token: data.refresh_token || refreshToken },\r\n      existingUser\r\n    );\r\n    await writeStorage(session);\r\n    notify(session);\r\n    return session;\r\n  }\r\n\r\n  async function getSession(): Promise<AuthSession | null> {\r\n    return readStorage();\r\n  }\r\n\r\n  async function getValidAccessToken(): Promise<string | null> {\r\n    const session = await readStorage();\r\n    if (!session) {\r\n      return null;\r\n    }\r\n\r\n    const expiresAt = Number(session.expiresAt) || 0;\r\n    const buffer = tokenExpiryBufferMs;\r\n    if (expiresAt - buffer > Date.now()) {\r\n      return session.accessToken;\r\n    }\r\n\r\n    try {\r\n      const refreshed = await refreshSession(session.refreshToken, session.user);\r\n      return refreshed.accessToken;\r\n    } catch (error) {\r\n      console.error(\"Lock-in token refresh failed:\", (error as Error).message);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async function getCurrentUser(): Promise<AuthUser | null> {\r\n    const session = await getSession();\r\n    return session?.user || null;\r\n  }\r\n\r\n  async function signOut(): Promise<void> {\r\n    await clearStorage();\r\n    notify(null);\r\n  }\r\n\r\n  function onSessionChanged(callback: (session: AuthSession | null) => void): () => void {\r\n    if (typeof callback !== \"function\") {\r\n      return () => {};\r\n    }\r\n    listeners.add(callback);\r\n    return () => listeners.delete(callback);\r\n  }\r\n\r\n  // Listen to storage changes\r\n  storage.onChanged((changes, areaName) => {\r\n    if (areaName === \"sync\" && changes[sessionStorageKey]) {\r\n      notify(changes[sessionStorageKey].newValue || null);\r\n    }\r\n  });\r\n\r\n  return {\r\n    signUpWithEmail,\r\n    signInWithEmail,\r\n    signOut,\r\n    getSession,\r\n    getCurrentUser,\r\n    getValidAccessToken,\r\n    getAccessToken: getValidAccessToken,\r\n    onSessionChanged,\r\n  };\r\n}\r\n","import type { AuthClient } from \"./auth\";\n\ninterface RetryConfig {\n  maxRetries: number;\n  baseDelayMs: number;\n  maxDelayMs: number;\n  retryableStatuses: number[];\n}\n\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  baseDelayMs: 500,\n  maxDelayMs: 5000,\n  retryableStatuses: [429, 502, 503, 504],\n};\n\nfunction calculateRetryDelay(attempt: number, config: RetryConfig): number {\n  const exponentialDelay = config.baseDelayMs * Math.pow(2, attempt);\n  const cappedDelay = Math.min(exponentialDelay, config.maxDelayMs);\n  const jitter = cappedDelay * (Math.random() * 0.3);\n  return Math.floor(cappedDelay + jitter);\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport interface ApiRequestOptions extends RequestInit {\n  signal?: AbortSignal;\n  retry?: boolean;\n  retryConfig?: Partial<RetryConfig>;\n  ifUnmodifiedSince?: string;\n}\n\nexport class ConflictError extends Error {\n  code = \"CONFLICT\";\n  status = 409;\n  serverVersion?: string;\n\n  constructor(message: string, serverVersion?: string) {\n    super(message);\n    this.name = \"ConflictError\";\n    this.serverVersion = serverVersion;\n  }\n}\n\nasync function createApiError(response: Response, originalError: Error | null = null): Promise<Error> {\n  let errorMessage = \"API request failed\";\n  let errorCode = \"API_ERROR\";\n\n  try {\n    const errorBody = await response.json();\n    errorMessage =\n      errorBody?.error?.message ||\n      errorBody?.message ||\n      (typeof errorBody?.error === \"string\" ? errorBody.error : null) ||\n      errorMessage;\n\n    if (response.status === 401 || response.status === 403) {\n      errorCode = \"AUTH_REQUIRED\";\n    } else if (response.status === 429) {\n      errorCode = \"RATE_LIMIT\";\n    } else if (response.status === 400) {\n      errorCode = \"BAD_REQUEST\";\n    } else if (response.status >= 500) {\n      errorCode = \"SERVER_ERROR\";\n    }\n  } catch (_) {\n    try {\n      const text = await response.text();\n      if (text) {\n        errorMessage = text;\n      }\n    } catch (_) {\n      // Ignore parse errors\n    }\n  }\n\n  const error = new Error(errorMessage);\n  (error as any).code = errorCode;\n  (error as any).status = response.status;\n  if (originalError) {\n    (error as any).cause = originalError;\n  }\n  return error;\n}\n\nexport type ApiRequest = <T = any>(endpoint: string, options?: ApiRequestOptions) => Promise<T>;\n\nexport interface FetcherConfig {\n  backendUrl: string;\n  authClient: AuthClient;\n}\n\nexport function createFetcher(config: FetcherConfig) {\n  const { backendUrl, authClient } = config;\n  const clientConfig = { backendUrl };\n\n  async function apiRequest<T = any>(endpoint: string, options: ApiRequestOptions = {}): Promise<T> {\n    const { retry = true, retryConfig: customRetryConfig, ifUnmodifiedSince, ...fetchOptions } = options;\n\n    const retryConfig = { ...DEFAULT_RETRY_CONFIG, ...customRetryConfig };\n    const url = endpoint.startsWith(\"http\") ? endpoint : `${backendUrl}${endpoint}`;\n\n    if (fetchOptions.signal?.aborted) {\n      const error = new Error(\"Request was aborted\");\n      (error as any).code = \"ABORTED\";\n      throw error;\n    }\n\n    const accessToken = await authClient.getValidAccessToken();\n    if (!accessToken) {\n      const error = new Error(\"Please sign in via the Lock-in popup before using the assistant.\");\n      (error as any).code = \"AUTH_REQUIRED\";\n      throw error;\n    }\n\n    if (fetchOptions.signal?.aborted) {\n      const error = new Error(\"Request was aborted\");\n      (error as any).code = \"ABORTED\";\n      throw error;\n    }\n\n    const isFormData = typeof FormData !== \"undefined\" && fetchOptions.body instanceof FormData;\n    const headers: HeadersInit = {\n      Authorization: `Bearer ${accessToken}`,\n      ...(isFormData ? {} : { \"Content-Type\": \"application/json\" }),\n      ...(ifUnmodifiedSince ? { \"If-Unmodified-Since\": ifUnmodifiedSince } : {}),\n      ...(fetchOptions.headers || {}),\n    };\n\n    const requestOptions: RequestInit = {\n      ...fetchOptions,\n      headers,\n      signal: fetchOptions.signal,\n    };\n\n    let lastError: Error | null = null;\n    for (let attempt = 0; attempt <= (retry ? retryConfig.maxRetries : 0); attempt++) {\n      if (fetchOptions.signal?.aborted) {\n        const error = new Error(\"Request was aborted\");\n        (error as any).code = \"ABORTED\";\n        throw error;\n      }\n\n      if (attempt > 0) {\n        const delay = calculateRetryDelay(attempt - 1, retryConfig);\n        // eslint-disable-next-line no-console\n        console.log(`[API] Retry attempt ${attempt}/${retryConfig.maxRetries} after ${delay}ms`);\n        await sleep(delay);\n\n        if (fetchOptions.signal?.aborted) {\n          const error = new Error(\"Request was aborted\");\n          (error as any).code = \"ABORTED\";\n          throw error;\n        }\n      }\n\n      let response: Response;\n      try {\n        response = await fetch(url, requestOptions);\n      } catch (networkError: any) {\n        if (networkError.name === \"AbortError\" || fetchOptions.signal?.aborted) {\n          const error = new Error(\"Request was aborted\");\n          (error as any).code = \"ABORTED\";\n          throw error;\n        }\n\n        lastError = new Error(\"Unable to reach Lock-in. Please check your connection.\");\n        (lastError as any).code = \"NETWORK_ERROR\";\n        (lastError as any).cause = networkError;\n\n        if (retry && attempt < retryConfig.maxRetries) {\n          continue;\n        }\n        throw lastError;\n      }\n\n      if (response.status === 409) {\n        let serverVersion: string | undefined;\n        try {\n          const body = await response.json();\n          serverVersion = body?.updatedAt || body?.updated_at;\n        } catch {}\n        throw new ConflictError(\n          \"Note was modified by another session. Please refresh and try again.\",\n          serverVersion,\n        );\n      }\n\n      if (retry && retryConfig.retryableStatuses.includes(response.status) && attempt < retryConfig.maxRetries) {\n        lastError = await createApiError(response);\n        continue;\n      }\n\n      if (response.status === 401 || response.status === 403) {\n        await authClient.signOut().catch(() => {});\n      }\n\n      if (!response.ok) {\n        throw await createApiError(response);\n      }\n\n      if (response.status === 204) {\n        return undefined as T;\n      }\n\n      try {\n        const contentLength = response.headers.get(\"content-length\");\n        const contentType = response.headers.get(\"content-type\");\n\n        if (contentLength === \"0\" || !contentType?.includes(\"application/json\")) {\n          return undefined as T;\n        }\n\n        const data = await response.json();\n        if (data && data.success === false) {\n          const error = new Error(data.error?.message || \"Request failed\");\n          (error as any).code = data.error?.code || \"API_ERROR\";\n          throw error;\n        }\n        return data;\n      } catch (parseError: any) {\n        if (parseError instanceof Error && (parseError as any).code) {\n          throw parseError;\n        }\n        const error = new Error(\"Failed to parse API response\");\n        (error as any).code = \"PARSE_ERROR\";\n        (error as any).cause = parseError;\n        throw error;\n      }\n    }\n\n    throw lastError || new Error(\"Request failed after retries\");\n  }\n\n  function getBackendUrl(): string {\n    return clientConfig.backendUrl;\n  }\n\n  return {\n    apiRequest,\n    getBackendUrl,\n  };\n}\n","import type { ChatMessage, StudyResponse, ApiResponse } from \"../../core/domain/types\";\r\nimport type { ApiRequest } from \"../fetcher\";\r\n\r\nexport interface ProcessTextParams {\r\n  selection: string;\r\n  mode: \"explain\" | \"general\";\r\n  difficultyLevel?: \"highschool\" | \"university\";\r\n  chatHistory?: ChatMessage[];\r\n  newUserMessage?: string;\r\n  chatId?: string;\r\n  pageContext?: string;\r\n  pageUrl?: string;\r\n  courseCode?: string;\r\n  language?: string;\r\n}\r\n\r\nexport function createLockinClient(apiRequest: ApiRequest) {\r\n  async function processText(params: ProcessTextParams): Promise<ApiResponse<StudyResponse>> {\r\n    const {\r\n      selection,\r\n      mode,\r\n      difficultyLevel = \"highschool\",\r\n      chatHistory = [],\r\n      newUserMessage,\r\n      chatId,\r\n      pageContext,\r\n      pageUrl,\r\n      courseCode,\r\n      language = \"en\",\r\n    } = params;\r\n\r\n    const normalizedHistory = (Array.isArray(chatHistory) ? chatHistory : [])\r\n      .filter(\r\n        (message) =>\r\n          message &&\r\n          typeof message.role === \"string\" &&\r\n          typeof message.content === \"string\",\r\n      )\r\n      .map((message) => ({\r\n        role: message.role,\r\n        content: message.content,\r\n      }));\r\n\r\n    const body: any = {\r\n      selection: selection || \"\",\r\n      mode,\r\n      difficultyLevel,\r\n      chatHistory: normalizedHistory,\r\n    };\r\n\r\n    if (newUserMessage) body.newUserMessage = newUserMessage;\r\n    if (chatId) body.chatId = chatId;\r\n    if (pageContext) body.pageContext = pageContext;\r\n    if (pageUrl) body.pageUrl = pageUrl;\r\n    if (courseCode) body.courseCode = courseCode;\r\n    if (language) body.language = language;\r\n\r\n    return apiRequest<ApiResponse<StudyResponse>>(\"/api/lockin\", {\r\n      method: \"POST\",\r\n      body: JSON.stringify(body),\r\n    });\r\n  }\r\n\r\n  return {\r\n    processText,\r\n  };\r\n}\r\n","import type { ApiRequest } from \"../fetcher\";\n\nexport function createChatsClient(apiRequest: ApiRequest) {\n  async function getRecentChats(params: { limit?: number } = {}): Promise<any[]> {\n    const { limit = 10 } = params;\n    const queryParams = new URLSearchParams();\n    if (limit) {\n      queryParams.set(\"limit\", String(limit));\n    }\n\n    const endpoint = `/api/chats${queryParams.toString() ? `?${queryParams.toString()}` : \"\"}`;\n    return apiRequest<any[]>(endpoint, {\n      method: \"GET\",\n    });\n  }\n\n  async function getChatMessages(chatId: string): Promise<any[]> {\n    if (!chatId) {\n      throw new Error(\"Chat ID is required\");\n    }\n\n    return apiRequest<any[]>(`/api/chats/${chatId}/messages`, {\n      method: \"GET\",\n    });\n  }\n\n  async function deleteChat(chatId: string): Promise<void> {\n    if (!chatId) {\n      throw new Error(\"Chat ID is required\");\n    }\n\n    return apiRequest<void>(`/api/chats/${chatId}`, {\n      method: \"DELETE\",\n    });\n  }\n\n  return {\n    getRecentChats,\n    getChatMessages,\n    deleteChat,\n  };\n}\n","import type { ApiRequest, ApiRequestOptions } from \"../fetcher\";\n\nexport interface ListNotesParams {\n  sourceUrl?: string;\n  courseCode?: string;\n  limit?: number;\n}\n\nexport interface SearchNotesParams {\n  query: string;\n  courseCode?: string;\n  k?: number;\n}\n\nexport interface ChatWithNotesParams {\n  query: string;\n  courseCode?: string;\n  k?: number;\n}\n\ntype NotePayload = {\n  title?: string;\n  content?: string;\n  content_text?: string | null;\n  content_json?: unknown;\n  contentJson?: unknown;\n  editor_version?: string;\n  clientNoteId?: string;\n  sourceSelection?: string | null;\n  source_selection?: string | null;\n  sourceUrl?: string | null;\n  source_url?: string | null;\n  courseCode?: string | null;\n  course_code?: string | null;\n  noteType?: string | null;\n  note_type?: string | null;\n  tags?: string[];\n};\n\nexport function createNotesClient(apiRequest: ApiRequest) {\n  async function createNote(\n    note: NotePayload & { title: string },\n    options?: ApiRequestOptions,\n  ): Promise<any> {\n    return apiRequest<any>(\"/api/notes\", {\n      method: \"POST\",\n      body: JSON.stringify(note),\n      ...options,\n    });\n  }\n\n  async function updateNote(\n    noteId: string,\n    note: NotePayload,\n    options?: ApiRequestOptions,\n  ): Promise<any> {\n    if (!noteId) {\n      throw new Error(\"noteId is required to update a note\");\n    }\n    return apiRequest<any>(`/api/notes/${noteId}`, {\n      method: \"PUT\",\n      body: JSON.stringify(note),\n      ...options,\n    });\n  }\n\n  async function deleteNote(noteId: string): Promise<void> {\n    if (!noteId) {\n      throw new Error(\"noteId is required to delete a note\");\n    }\n    return apiRequest<void>(`/api/notes/${noteId}`, {\n      method: \"DELETE\",\n    });\n  }\n\n  async function toggleNoteStar(noteId: string): Promise<any> {\n    if (!noteId) {\n      throw new Error(\"noteId is required to toggle star\");\n    }\n    return apiRequest<any>(`/api/notes/${noteId}/star`, {\n      method: \"PATCH\",\n    });\n  }\n\n  async function setNoteStar(noteId: string, isStarred: boolean): Promise<any> {\n    if (!noteId) {\n      throw new Error(\"noteId is required to set star\");\n    }\n    return apiRequest<any>(`/api/notes/${noteId}/star`, {\n      method: \"PUT\",\n      body: JSON.stringify({ isStarred }),\n    });\n  }\n\n  async function listNotes(params: ListNotesParams = {}): Promise<any[]> {\n    const { sourceUrl, courseCode, limit = 50 } = params;\n    const queryParams = new URLSearchParams();\n    if (sourceUrl) queryParams.set(\"sourceUrl\", sourceUrl);\n    if (courseCode) queryParams.set(\"courseCode\", courseCode);\n    if (limit) queryParams.set(\"limit\", String(limit));\n\n    const endpoint = `/api/notes${queryParams.toString() ? `?${queryParams.toString()}` : \"\"}`;\n    return apiRequest<any[]>(endpoint, {\n      method: \"GET\",\n    });\n  }\n\n  async function searchNotes(params: SearchNotesParams): Promise<any[]> {\n    const { query, courseCode, k = 10 } = params;\n    const queryParams = new URLSearchParams({ q: query, k: String(k) });\n    if (courseCode) queryParams.set(\"courseCode\", courseCode);\n\n    return apiRequest<any[]>(`/api/notes/search?${queryParams.toString()}`, {\n      method: \"GET\",\n    });\n  }\n\n  async function chatWithNotes(params: ChatWithNotesParams): Promise<{ answer: string; usedNotes: any[] }> {\n    return apiRequest<{ answer: string; usedNotes: any[] }>(\"/api/notes/chat\", {\n      method: \"POST\",\n      body: JSON.stringify({ query: params.query, courseCode: params.courseCode, k: params.k }),\n    });\n  }\n\n  return {\n    createNote,\n    updateNote,\n    deleteNote,\n    toggleNoteStar,\n    setNoteStar,\n    listNotes,\n    searchNotes,\n    chatWithNotes,\n  };\n}\n","import type { NoteAsset } from \"../../core/domain/types\";\nimport type { ApiRequest } from \"../fetcher\";\n\nexport interface UploadNoteAssetParams {\n  noteId: string;\n  file: File | Blob;\n}\n\nexport interface ListNoteAssetsParams {\n  noteId: string;\n}\n\nexport interface DeleteNoteAssetParams {\n  assetId: string;\n}\n\nfunction mapNoteAsset(raw: any): NoteAsset {\n  return {\n    id: raw.id,\n    noteId: raw.note_id,\n    userId: raw.user_id,\n    type: raw.type,\n    mimeType: raw.mime_type,\n    storagePath: raw.storage_path,\n    createdAt: raw.created_at,\n    url: raw.url,\n    fileName: raw.file_name || raw.filename || raw.name || null,\n  };\n}\n\nexport function createAssetsClient(apiRequest: ApiRequest) {\n  async function uploadNoteAsset(params: UploadNoteAssetParams): Promise<NoteAsset> {\n    const { noteId, file } = params;\n    if (!noteId) {\n      throw new Error(\"noteId is required to upload an asset\");\n    }\n    if (!file) {\n      throw new Error(\"file is required to upload an asset\");\n    }\n\n    const formData = new FormData();\n    formData.append(\"file\", file);\n\n    const raw = await apiRequest<any>(`/api/notes/${noteId}/assets`, {\n      method: \"POST\",\n      body: formData,\n    });\n\n    return mapNoteAsset(raw);\n  }\n\n  async function listNoteAssets(params: ListNoteAssetsParams): Promise<NoteAsset[]> {\n    const { noteId } = params;\n    if (!noteId) {\n      throw new Error(\"noteId is required to list assets\");\n    }\n\n    const raw = await apiRequest<any[]>(`/api/notes/${noteId}/assets`, {\n      method: \"GET\",\n    });\n\n    return raw.map(mapNoteAsset);\n  }\n\n  async function deleteNoteAsset(params: DeleteNoteAssetParams): Promise<void> {\n    const { assetId } = params;\n    if (!assetId) {\n      throw new Error(\"assetId is required to delete an asset\");\n    }\n\n    return apiRequest<void>(`/api/note-assets/${assetId}`, {\n      method: \"DELETE\",\n    });\n  }\n\n  return {\n    uploadNoteAsset,\n    listNoteAssets,\n    deleteNoteAsset,\n  };\n}\n","/**\r\n * API Client for Lock-in\r\n *\r\n * Chrome-agnostic API client for backend communication.\r\n * Uses auth client interface - no direct Chrome dependencies.\r\n *\r\n * Scalability features:\r\n * - Exponential backoff retry for transient failures\r\n * - Request deduplication via AbortController\r\n * - Optimistic locking support via updatedAt\r\n */\r\n\r\nimport type { AuthClient } from \"./auth\";\r\nimport {\r\n  createFetcher,\r\n  type ApiRequestOptions,\r\n} from \"./fetcher\";\r\nimport {\r\n  createLockinClient,\r\n  type ProcessTextParams,\r\n} from \"./resources/lockinClient\";\r\nimport { createChatsClient } from \"./resources/chatsClient\";\r\nimport {\r\n  createNotesClient,\r\n  type ListNotesParams,\r\n  type SearchNotesParams,\r\n  type ChatWithNotesParams,\r\n} from \"./resources/notesClient\";\r\nimport {\r\n  createAssetsClient,\r\n  type UploadNoteAssetParams,\r\n  type ListNoteAssetsParams,\r\n  type DeleteNoteAssetParams,\r\n} from \"./resources/assetsClient\";\r\n\r\nexport interface ApiClientConfig {\r\n  backendUrl: string;\r\n  authClient: AuthClient;\r\n}\r\n\r\nexport function createApiClient(config: ApiClientConfig) {\r\n  const fetcher = createFetcher(config);\r\n  const { apiRequest, getBackendUrl } = fetcher;\r\n\r\n  const { processText } = createLockinClient(apiRequest);\r\n  const { getRecentChats, getChatMessages, deleteChat } = createChatsClient(apiRequest);\r\n  const {\r\n    createNote,\r\n    updateNote,\r\n    deleteNote,\r\n    toggleNoteStar,\r\n    setNoteStar,\r\n    listNotes,\r\n    searchNotes,\r\n    chatWithNotes,\r\n  } = createNotesClient(apiRequest);\r\n  const {\r\n    uploadNoteAsset,\r\n    listNoteAssets,\r\n    deleteNoteAsset,\r\n  } = createAssetsClient(apiRequest);\r\n\r\n  return {\r\n    apiRequest,\r\n    getBackendUrl,\r\n    processText,\r\n    getRecentChats,\r\n    getChatMessages,\r\n    deleteChat,\r\n    createNote,\r\n    updateNote,\r\n    deleteNote,\r\n    toggleNoteStar,\r\n    setNoteStar,\r\n    listNotes,\r\n    searchNotes,\r\n    chatWithNotes,\r\n    uploadNoteAsset,\r\n    listNoteAssets,\r\n    deleteNoteAsset,\r\n  };\r\n}\r\n\r\nexport type ApiClient = ReturnType<typeof createApiClient>;\r\n\r\nexport { ConflictError } from \"./fetcher\";\r\nexport type {\r\n  ApiRequestOptions,\r\n  ProcessTextParams,\r\n  ListNotesParams,\r\n  SearchNotesParams,\r\n  ChatWithNotesParams,\r\n  UploadNoteAssetParams,\r\n  ListNoteAssetsParams,\r\n  DeleteNoteAssetParams,\r\n};\r\n","/**\r\n * Chrome Storage Adapter\r\n * \r\n * Implements StorageInterface using Chrome's storage.sync API.\r\n * This is the bridge between the Chrome-agnostic core code and Chrome-specific storage.\r\n */\r\n\r\nimport type { StorageInterface } from \"../../core/storage/storageInterface\";\r\n\r\n/**\r\n * Chrome storage implementation of StorageInterface\r\n * Uses chrome.storage.sync for cross-device persistence\r\n */\r\nexport const chromeStorage: StorageInterface = {\r\n  async get<T = any>(key: string | string[]): Promise<Record<string, T>> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.sync.get(key, (result) => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n          } else {\r\n            resolve(result as Record<string, T>);\r\n          }\r\n        });\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n  },\r\n\r\n  async set(data: Record<string, any>): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.sync.set(data, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n          } else {\r\n            resolve();\r\n          }\r\n        });\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n  },\r\n\r\n  async remove(keys: string | string[]): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.sync.remove(keys, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n          } else {\r\n            resolve();\r\n          }\r\n        });\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n  },\r\n\r\n  onChanged(\r\n    callback: (changes: Record<string, { oldValue?: any; newValue?: any }>, areaName: string) => void\r\n  ): () => void {\r\n    const listener = (\r\n      changes: { [key: string]: chrome.storage.StorageChange },\r\n      areaName: string\r\n    ) => {\r\n      // Convert Chrome's StorageChange format to our interface format\r\n      const normalizedChanges: Record<string, { oldValue?: any; newValue?: any }> = {};\r\n      for (const key in changes) {\r\n        normalizedChanges[key] = {\r\n          oldValue: changes[key].oldValue,\r\n          newValue: changes[key].newValue,\r\n        };\r\n      }\r\n      callback(normalizedChanges, areaName);\r\n    };\r\n\r\n    chrome.storage.onChanged.addListener(listener);\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      chrome.storage.onChanged.removeListener(listener);\r\n    };\r\n  },\r\n};\r\n\r\n/**\r\n * Chrome local storage implementation\r\n * Uses chrome.storage.local for larger, device-specific data\r\n */\r\nexport const chromeLocalStorage: StorageInterface = {\r\n  async get<T = any>(key: string | string[]): Promise<Record<string, T>> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.local.get(key, (result) => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n          } else {\r\n            resolve(result as Record<string, T>);\r\n          }\r\n        });\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n  },\r\n\r\n  async set(data: Record<string, any>): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.local.set(data, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n          } else {\r\n            resolve();\r\n          }\r\n        });\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n  },\r\n\r\n  async remove(keys: string | string[]): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        chrome.storage.local.remove(keys, () => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(new Error(chrome.runtime.lastError.message));\r\n          } else {\r\n            resolve();\r\n          }\r\n        });\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n  },\r\n\r\n  onChanged(\r\n    callback: (changes: Record<string, { oldValue?: any; newValue?: any }>, areaName: string) => void\r\n  ): () => void {\r\n    const listener = (\r\n      changes: { [key: string]: chrome.storage.StorageChange },\r\n      areaName: string\r\n    ) => {\r\n      // Only fire for local storage changes\r\n      if (areaName !== \"local\") return;\r\n\r\n      const normalizedChanges: Record<string, { oldValue?: any; newValue?: any }> = {};\r\n      for (const key in changes) {\r\n        normalizedChanges[key] = {\r\n          oldValue: changes[key].oldValue,\r\n          newValue: changes[key].newValue,\r\n        };\r\n      }\r\n      callback(normalizedChanges, areaName);\r\n    };\r\n\r\n    chrome.storage.onChanged.addListener(listener);\r\n\r\n    return () => {\r\n      chrome.storage.onChanged.removeListener(listener);\r\n    };\r\n  },\r\n};\r\n","/**\r\n * Initialize API and Auth Clients for Extension\r\n * \r\n * This file wires together the Chrome-specific storage with the Chrome-agnostic\r\n * API and auth clients. It is the bridge between extension code and shared code.\r\n * \r\n * This is bundled by vite.config.initApi.ts into extension/libs/initApi.js (IIFE format)\r\n * and exposes window.LockInAuth and window.LockInAPI for use by content scripts.\r\n */\r\n\r\nimport { createAuthClient, type AuthClient } from \"../../api/auth\";\r\nimport { createApiClient, type ApiClient } from \"../../api/client\";\r\nimport { chromeStorage } from \"./chromeStorage\";\r\n\r\n/**\r\n * Extension configuration from window.LOCKIN_CONFIG (set by config.js)\r\n */\r\nexport interface LockInConfig {\r\n  backendUrl: string;\r\n  supabaseUrl: string;\r\n  supabaseAnonKey: string;\r\n  sessionStorageKey: string;\r\n  tokenExpiryBufferMs: number;\r\n}\r\n\r\n/**\r\n * Get config from window (set by config.js)\r\n */\r\nexport function getConfig(): LockInConfig {\r\n  const config = (typeof window !== \"undefined\" && (window as any).LOCKIN_CONFIG) || {};\r\n  return {\r\n    backendUrl: config.BACKEND_URL || \"http://localhost:3000\",\r\n    supabaseUrl: config.SUPABASE_URL || \"\",\r\n    supabaseAnonKey: config.SUPABASE_ANON_KEY || \"\",\r\n    sessionStorageKey: config.SESSION_STORAGE_KEY || \"lockinSupabaseSession\",\r\n    tokenExpiryBufferMs: Number(config.TOKEN_EXPIRY_BUFFER_MS) || 60000,\r\n  };\r\n}\r\n\r\n/**\r\n * Initialize auth client with Chrome storage\r\n */\r\nexport function initAuthClient(): AuthClient {\r\n  const config = getConfig();\r\n  return createAuthClient(\r\n    {\r\n      supabaseUrl: config.supabaseUrl,\r\n      supabaseAnonKey: config.supabaseAnonKey,\r\n      sessionStorageKey: config.sessionStorageKey,\r\n      tokenExpiryBufferMs: config.tokenExpiryBufferMs,\r\n    },\r\n    chromeStorage\r\n  );\r\n}\r\n\r\n/**\r\n * Initialize API client with auth client\r\n */\r\nexport function initApiClient(authClient: AuthClient): ApiClient {\r\n  const config = getConfig();\r\n  return createApiClient({\r\n    backendUrl: config.backendUrl,\r\n    authClient,\r\n  });\r\n}\r\n\r\n/**\r\n * Cached clients for singleton pattern\r\n */\r\nlet cachedClients: { authClient: AuthClient; apiClient: ApiClient } | null = null;\r\n\r\n/**\r\n * Initialize both clients and expose globally for backward compatibility\r\n */\r\nexport function initClients(): { authClient: AuthClient; apiClient: ApiClient } {\r\n  if (cachedClients) {\r\n    return cachedClients;\r\n  }\r\n\r\n  const authClient = initAuthClient();\r\n  const apiClient = initApiClient(authClient);\r\n\r\n  cachedClients = { authClient, apiClient };\r\n\r\n  // Expose globally for legacy code and content scripts\r\n  if (typeof window !== \"undefined\") {\r\n    (window as any).LockInAuth = authClient;\r\n    (window as any).LockInAPI = apiClient;\r\n    \r\n    // Also expose as authClient/apiClient for backward compatibility\r\n    (window as any).authClient = authClient;\r\n    (window as any).apiClient = apiClient;\r\n  }\r\n\r\n  return cachedClients;\r\n}\r\n\r\n/**\r\n * Get cached clients (or initialize if not cached)\r\n */\r\nexport function getClients(): { authClient: AuthClient; apiClient: ApiClient } {\r\n  return cachedClients || initClients();\r\n}\r\n\r\n// Auto-initialize when loaded in browser context\r\nif (typeof window !== \"undefined\") {\r\n  initClients();\r\n}\r\n\r\n// Re-export types for convenience\r\nexport type { AuthClient } from \"../../api/auth\";\r\nexport type { ApiClient } from \"../../api/client\";\r\n"],"names":["_","_a"],"mappings":"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"}